// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace proto {
namespace common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class object_state_info;
class mobile_info;
class chat_param;
class server_info;
class account_role_data;
class channel_general;
class task_type_count;
class task_type_data;
class fight_study_data;
class role_fight_data;
class role_server_data;
class last_static_map;
class role_data;
class country_common;
class object_common_info;
class personal_info;
class interior_info;
class role_cross_data;
class mirror_fight_data;
class attr_single;
class attr_data;
class hero_state;
class hero_state_data;
class fight_attr;
class hero_equip;
class hero_skill_single;
class hero_skill_data;
class base_attr;
class skill_single;
class skill_data;
class item_data;
class item_single;
class talent_single;
class talent_data;
class formation_pair;
class formation_single;
class formation_data;
class fate_pair;
class hero_single;
class hero_data;
class fight_special_hero_single;
class fight_special_hero_data;
class luckydraw_award;
class role_change_data;
class task_state;
class task_data;
class family_member;
class family_data;
class family_list_info;
class family_build_data;
class family_apply_member;
class family_gift_data;
class family_gift_data_list;
class family_prayer_data;
class family_prayer_list;
class family_prayer_record_data;
class family_prayer_record_list;
class family_invite_result;
class family_shop_item;
class family_shop_data;
class family_shop_personal_item;
class family_shop_personal_data;
class family_impeach_data;
class family_war_data;
class family_against_data;
class family_object_pos;
class family_against_list;
class family_war_history_data;
class family_war_hero_data;
class country_base_data;
class country_officer_data;
class country_info_data;
class country_family_data;
class country_family_list;
class server_channel_single;
class fh_channel_role_list;
class server_channel_data;
class chat_syn_user_info;
class chat_common_data;
class chat_common_role_info;
class user_troop_member;
class troop_data;
class troop_type;
class user_troop_member_hero_list;
class city_base_info;
class role_trade_info;
class role_trade_item_single;
class role_trade_item;
class city_trade_shop_item_info;
class city_trade_shop_info;
class city_trade_event_info;
class trade_supplement_info;
class grid_single;
class grid_data;
class fight_dark_param;
class fight_light_param;
class cross_arena_ex;
class cross_arena_param;
class fight_param;
class fight_common;
class obj_single;
class obj_data;
class fight_camp;
class fight_state;
class fight_data;
class fight_recovery_obj_single;
class fight_recovery_obj_data;
class fight_buff_single_data;
class fight_buff_data;
class fight_hero_skill_single_data;
class combat_all_action_data;
class fight_video_data;
class fight_hero_skill_data;
class fight_hero_attr_single_data;
class fight_hero_attr_data;
class fight_recovery_hero_single_data;
class fight_recovery_hero_data;
class fight_recovery_data;
class fight_process;
class fight_result;
class rank_role_base;
class rank_family_base;
class rank_score_tower;
class rank_score_achievement;
class rank_data_extra;
class rank_single_data;
class mount_data_single;
class mount_data;
class field_boss_rank;
class filed_boss_one_state;
class filed_boss_state;
class field_boss_pos_info;
class mail_common_info;
class mail_base_info;
class mail_item_obj;
class combat_act;
class combat_action_data;
class combat_hero_att_order_single;
class combat_hero_att_order;
class combat_end_ahead;
class combat_data;
class combat_form_single;
class combat_form_data;
class combat_finish_single_task;
class combat_camp_finish_task;
class combat_result;
class combat_count_data_single_hero;
class combat_count_data_heroes_obj;
class combat_count_data;
class fight_obj_state;
class fight_obj_state_data;
class bounty_single;
class star_box;
class country_bounty_data;
class item_limit_data;
class friend_member;
class relation_interface_data;
class recommend_member;
class user_info;
class luck_gift_info;
class gift_single;
class gift_data;
class activity_single;
class liveness_box;
class activities_data;
class arena_role_rank_info;
class arena_rank_info_array;
class arena_role_data;
class treasure_single;
class treasure_data;
class sys_notice_data;
class shop_goods;
class shop_goods_list;
class user_goods;
class user_goods_list;
class user_buy_goods;
class challenge_info;
class troop_formation_pair;
class troop_formation;
class king_war_country_sign_up_single;
class king_war_country_sign_up_info;
class king_war_family_info;
class king_war_country_pre_single;
class king_war_country_pre_info;
class country_king_war_info;
class family_war_info;
class king_war_sign_up_data;
class king_war_help_family;
class king_war_helf_info;
class king_war_long_info;
class king_war_role_pos;
class king_war_side_roles;
class king_war_rank_single;
class king_war_rank_list;
class equip_single;
class equip_attr;
class equip_smelt_box;
class world_cup_player;
class world_cup_battle;
class world_cup_data;
class world_cup_bet;
class world_cup_odds;
class achieve_finish_info_single;
class achieve_finish_info;
class achieve_record_single;
class achieve_record;
class achieve_data_single;
class achieve_data;
class tower_trigger;
class tower_trigger_data;
class tower_data;
class red_point_single;
class red_point_data;
class new_role_guide_single;
class new_role_guide_data;
class luckydraw_data;
class luckydraw_info;
class luckydraw_client_single;
class luckydraw_client_data;
class role_dungeon_monster;
class role_dungeon_data;
class role_dungeon_times_data;
class role_all_dungeon_data;
class role_all_dungeon_times_data;
class role_dungeon_condition;
class role_client_dungeon_data;
class role_all_client_dungeon_data;
class teamcheck_data;
class dungeon_schedule_data;
class tactic_single;
class tactic_data;
class role_buff_single;
class role_buff_data;
class goods_single;
class rarity_price_single;
class goods_info;
class goods_item;
class trade_item_info;
class arena_fight_data;
class expedition_stage_single;
class expedition_data;
class fight_save_data;
class skill_save_data;
class hero_save_data;
class page_task_single;
class page_elite_single;
class page_elite_data;
class page_data;
class page_quick_fight_data;
class page_reset_quick_fight_data;
class active_reward_data_single;
class active_reward_data;
class active_reward_task_data;
class cheap_day_single;
class cheap_day_client_single;
class recharge_data;
class random_shop_item;
class random_shop_data;
class role_random_shop_data;
class pve_hero_exp;
class level_reward_recived_list;
class level_reward_mail_recived_list;
class offline_role_data;
class sys_notity_single;
class sys_notity_data;
class public_struct;
class multi_time_data;
class draw_single;
class draw_data;
class redbag_data;
class other_rank_data;
class role_base_data;
class role_simple_data;
class role_blob_data;
class hero_strategy_info;
class hero_strategy_single;
class hero_strategy_equip_info;
class hero_strategy_hero_info;
class hero_strategy_comment_info;
class offline_arena_single;
class offline_arena_general;
class offline_arena_record;
class offline_arena_record_data;
class wish_summon_info;
class hero_chip_info;
class buy_summon_info;
class quick_task_info;
class item_num_info;
class item_num_info_list;
class prize_status_info;
class life_info;
class money_tree_data;
class bussiness_act_data;
class sevenday_login_data_info;
class sevenday_login_save_data;
class recharge_total_data;
class recharge_total_client_data;
class recharge_total_client_single;
class gold_luckydraw_data;
class gold_luckydraw_client_single;
class gold_luckydraw_client_data;
class cur_task_date;
class comp_task_date;
class task_event_single;
class task_event;
class head_data;
class month_card_info;
class month_card_show_info;
class month_card_save_data;
class ex_reason;
class liandan_single;
class liandan_data;
class activity_shop_item_info_single;
class activity_shop_item_info;
class business_active_info;
class level_fund_info;
class level_fund_save_info;
class equip_plan_single;
class patrol_hire_data;
class equip_plan_data;
class exchange_item_data;
class exchange_item_save_info;
class exchange_item_save_data;
class limit_buy_client_data;
class limit_buy_save_info;
class limit_buy_save_data;
class sd_target_info;
class sd_target_save_data;
class sd_target_red_info;
class statistical_save_info;
class statistical_save_data;
class general_event_info;
class general_event_detail;
class general_event_count_data;
class general_event_data;
class general_event_save_data;
class general_info_single;
class general_info_data;
class family_skill_single;
class family_skill_data;
class general_status_save_data;
class gm_msg_to_account;
class rank_time_single;
class office_data;
class office_task_single;
class office_client_data;
class video_hero_base;
class video_arena_ex;
class video_obj_base;
class video_single_base;

enum SERVER_STATE {
  SERVER_STATE_DEL = 0,
  SERVER_STATE_FREE = 1,
  SERVER_STATE_BUSY = 2,
  SERVER_STATE_FIRE = 3,
  SERVER_STATE_CLOSE = 4
};
bool SERVER_STATE_IsValid(int value);
const SERVER_STATE SERVER_STATE_MIN = SERVER_STATE_DEL;
const SERVER_STATE SERVER_STATE_MAX = SERVER_STATE_CLOSE;
const int SERVER_STATE_ARRAYSIZE = SERVER_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SERVER_STATE_descriptor();
inline const ::std::string& SERVER_STATE_Name(SERVER_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SERVER_STATE_descriptor(), value);
}
inline bool SERVER_STATE_Parse(
    const ::std::string& name, SERVER_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SERVER_STATE>(
    SERVER_STATE_descriptor(), name, value);
}
enum MONEY_TYPE {
  MONEY_TYPE_NONE = 0,
  MONEY_TYPE_YUANBAO = 1,
  MONEY_TYPE_SILVER = 2,
  MONEY_TYPE_COPPER = 3,
  MONEY_TYPE_ENERGY = 4,
  MONEY_TYPE_PRESTIGE = 5,
  MONEY_TYPE_ACHIEVE_POINT = 6,
  MONEY_TYPE_LIFEFORCE = 7,
  MONEY_TYPE_LIFE_STONE = 9,
  MONEY_TYPE_LIVENESS = 10,
  MONEY_TYPE_TRADE_POINT = 11,
  MONEY_TYPE_HEROSOUL = 12,
  MONEY_TYPE_HONOR = 13,
  MONEY_TYPE_CONTRIBUTION = 14,
  MONEY_TYPE_MULTI_POINT = 15,
  MONEY_TYPE_ROLE_UNLOCK = 16,
  MONEY_TYPE_VIGOUR = 17,
  MONEY_TYPE_FEATS = 20,
  MONEY_TYPE_FAMILY_FUNDS = 21,
  MONEY_TYPE_COUNTRY_FUNDS = 22,
  MONEY_TYPE_FRIENDSHIP_POINT = 24,
  MONEY_TYPE_EXP = 99,
  MONEY_TYPE_END = 100
};
bool MONEY_TYPE_IsValid(int value);
const MONEY_TYPE MONEY_TYPE_MIN = MONEY_TYPE_NONE;
const MONEY_TYPE MONEY_TYPE_MAX = MONEY_TYPE_END;
const int MONEY_TYPE_ARRAYSIZE = MONEY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MONEY_TYPE_descriptor();
inline const ::std::string& MONEY_TYPE_Name(MONEY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MONEY_TYPE_descriptor(), value);
}
inline bool MONEY_TYPE_Parse(
    const ::std::string& name, MONEY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MONEY_TYPE>(
    MONEY_TYPE_descriptor(), name, value);
}
enum SYSHINT_TYPE {
  SYSHINT_DEFAULT = 0,
  SYSHINT_SCENE = 1,
  SYSHINT_WORLD = 2,
  SYSHINT_COUNTRY = 3,
  SYSHINT_FAMILY = 4
};
bool SYSHINT_TYPE_IsValid(int value);
const SYSHINT_TYPE SYSHINT_TYPE_MIN = SYSHINT_DEFAULT;
const SYSHINT_TYPE SYSHINT_TYPE_MAX = SYSHINT_FAMILY;
const int SYSHINT_TYPE_ARRAYSIZE = SYSHINT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* SYSHINT_TYPE_descriptor();
inline const ::std::string& SYSHINT_TYPE_Name(SYSHINT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    SYSHINT_TYPE_descriptor(), value);
}
inline bool SYSHINT_TYPE_Parse(
    const ::std::string& name, SYSHINT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SYSHINT_TYPE>(
    SYSHINT_TYPE_descriptor(), name, value);
}
enum SHOW_POSTION {
  SHOW_TOP = 0,
  SHOW_TITLE = 1,
  SHOW_SUBTITLE = 2,
  SHOW_LOWRE = 3,
  SHOW_BOTTOM = 4,
  SHOW_MIDDLE = 5
};
bool SHOW_POSTION_IsValid(int value);
const SHOW_POSTION SHOW_POSTION_MIN = SHOW_TOP;
const SHOW_POSTION SHOW_POSTION_MAX = SHOW_MIDDLE;
const int SHOW_POSTION_ARRAYSIZE = SHOW_POSTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* SHOW_POSTION_descriptor();
inline const ::std::string& SHOW_POSTION_Name(SHOW_POSTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    SHOW_POSTION_descriptor(), value);
}
inline bool SHOW_POSTION_Parse(
    const ::std::string& name, SHOW_POSTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SHOW_POSTION>(
    SHOW_POSTION_descriptor(), name, value);
}
enum EM_PK_MODE {
  PK_PEACE = 1,
  PK_SLAUGHTER = 2,
  PK_FAMILY = 3,
  PK_COUNTRY = 4,
  PK_CAMP = 5
};
bool EM_PK_MODE_IsValid(int value);
const EM_PK_MODE EM_PK_MODE_MIN = PK_PEACE;
const EM_PK_MODE EM_PK_MODE_MAX = PK_CAMP;
const int EM_PK_MODE_ARRAYSIZE = EM_PK_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EM_PK_MODE_descriptor();
inline const ::std::string& EM_PK_MODE_Name(EM_PK_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EM_PK_MODE_descriptor(), value);
}
inline bool EM_PK_MODE_Parse(
    const ::std::string& name, EM_PK_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EM_PK_MODE>(
    EM_PK_MODE_descriptor(), name, value);
}
enum EM_SCENEOBJECT_TYPE {
  SCENEOBJECT_USER = 1,
  SCENEOBJECT_MONSTER = 2,
  SCENEOBJECT_CITYDOOR = 3,
  SCENEOBJECT_COLLECT_POINT = 4,
  SCENEOBJECT_TUTOR = 5,
  SCENEOBJECT_USERSHADOW = 6
};
bool EM_SCENEOBJECT_TYPE_IsValid(int value);
const EM_SCENEOBJECT_TYPE EM_SCENEOBJECT_TYPE_MIN = SCENEOBJECT_USER;
const EM_SCENEOBJECT_TYPE EM_SCENEOBJECT_TYPE_MAX = SCENEOBJECT_USERSHADOW;
const int EM_SCENEOBJECT_TYPE_ARRAYSIZE = EM_SCENEOBJECT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EM_SCENEOBJECT_TYPE_descriptor();
inline const ::std::string& EM_SCENEOBJECT_TYPE_Name(EM_SCENEOBJECT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EM_SCENEOBJECT_TYPE_descriptor(), value);
}
inline bool EM_SCENEOBJECT_TYPE_Parse(
    const ::std::string& name, EM_SCENEOBJECT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EM_SCENEOBJECT_TYPE>(
    EM_SCENEOBJECT_TYPE_descriptor(), name, value);
}
enum object_revive_type {
  object_revive_normal = 1,
  object_revive_king_war = 2,
  object_revive_dungeon = 3,
  object_revive_family_war = 4
};
bool object_revive_type_IsValid(int value);
const object_revive_type object_revive_type_MIN = object_revive_normal;
const object_revive_type object_revive_type_MAX = object_revive_family_war;
const int object_revive_type_ARRAYSIZE = object_revive_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* object_revive_type_descriptor();
inline const ::std::string& object_revive_type_Name(object_revive_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    object_revive_type_descriptor(), value);
}
inline bool object_revive_type_Parse(
    const ::std::string& name, object_revive_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<object_revive_type>(
    object_revive_type_descriptor(), name, value);
}
enum ActionType {
  UNINIT = 0,
  MOVE = 1,
  WALK = 2,
  ATTACK = 3,
  REPEL = 4
};
bool ActionType_IsValid(int value);
const ActionType ActionType_MIN = UNINIT;
const ActionType ActionType_MAX = REPEL;
const int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActionType_descriptor();
inline const ::std::string& ActionType_Name(ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActionType_descriptor(), value);
}
inline bool ActionType_Parse(
    const ::std::string& name, ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum ROLE_MODE {
  ROLE_MODE_USER = 1,
  ROLE_MODE_MACHINE = 2,
  ROLE_MODE_RIDE = 3
};
bool ROLE_MODE_IsValid(int value);
const ROLE_MODE ROLE_MODE_MIN = ROLE_MODE_USER;
const ROLE_MODE ROLE_MODE_MAX = ROLE_MODE_RIDE;
const int ROLE_MODE_ARRAYSIZE = ROLE_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROLE_MODE_descriptor();
inline const ::std::string& ROLE_MODE_Name(ROLE_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROLE_MODE_descriptor(), value);
}
inline bool ROLE_MODE_Parse(
    const ::std::string& name, ROLE_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROLE_MODE>(
    ROLE_MODE_descriptor(), name, value);
}
enum rt_buff_change_statue {
  rt_buff_add = 1,
  rt_buff_remove = 2,
  rt_buff_update = 3
};
bool rt_buff_change_statue_IsValid(int value);
const rt_buff_change_statue rt_buff_change_statue_MIN = rt_buff_add;
const rt_buff_change_statue rt_buff_change_statue_MAX = rt_buff_update;
const int rt_buff_change_statue_ARRAYSIZE = rt_buff_change_statue_MAX + 1;

const ::google::protobuf::EnumDescriptor* rt_buff_change_statue_descriptor();
inline const ::std::string& rt_buff_change_statue_Name(rt_buff_change_statue value) {
  return ::google::protobuf::internal::NameOfEnum(
    rt_buff_change_statue_descriptor(), value);
}
inline bool rt_buff_change_statue_Parse(
    const ::std::string& name, rt_buff_change_statue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<rt_buff_change_statue>(
    rt_buff_change_statue_descriptor(), name, value);
}
enum chat_channel {
  chat_channel_system = 1,
  chat_channel_vicinity = 2,
  chat_channel_world = 3,
  chat_channel_country = 4,
  chat_channel_family = 5,
  chat_channel_team = 6,
  chat_channel_create_team = 7,
  chat_channel_team_hold = 8
};
bool chat_channel_IsValid(int value);
const chat_channel chat_channel_MIN = chat_channel_system;
const chat_channel chat_channel_MAX = chat_channel_team_hold;
const int chat_channel_ARRAYSIZE = chat_channel_MAX + 1;

const ::google::protobuf::EnumDescriptor* chat_channel_descriptor();
inline const ::std::string& chat_channel_Name(chat_channel value) {
  return ::google::protobuf::internal::NameOfEnum(
    chat_channel_descriptor(), value);
}
inline bool chat_channel_Parse(
    const ::std::string& name, chat_channel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<chat_channel>(
    chat_channel_descriptor(), name, value);
}
enum chat_type {
  chat_item = 1,
  chat_task = 2,
  chat_help = 3,
  chat_hero = 4
};
bool chat_type_IsValid(int value);
const chat_type chat_type_MIN = chat_item;
const chat_type chat_type_MAX = chat_hero;
const int chat_type_ARRAYSIZE = chat_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* chat_type_descriptor();
inline const ::std::string& chat_type_Name(chat_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    chat_type_descriptor(), value);
}
inline bool chat_type_Parse(
    const ::std::string& name, chat_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<chat_type>(
    chat_type_descriptor(), name, value);
}
enum channel_state {
  channel_free = 1,
  channel_lively = 2,
  channel_hot = 3,
  channel_full = 4
};
bool channel_state_IsValid(int value);
const channel_state channel_state_MIN = channel_free;
const channel_state channel_state_MAX = channel_full;
const int channel_state_ARRAYSIZE = channel_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* channel_state_descriptor();
inline const ::std::string& channel_state_Name(channel_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    channel_state_descriptor(), value);
}
inline bool channel_state_Parse(
    const ::std::string& name, channel_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<channel_state>(
    channel_state_descriptor(), name, value);
}
enum channel_type {
  channel_type_public = 1,
  channel_type_server = 2,
  channel_type_features = 3
};
bool channel_type_IsValid(int value);
const channel_type channel_type_MIN = channel_type_public;
const channel_type channel_type_MAX = channel_type_features;
const int channel_type_ARRAYSIZE = channel_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* channel_type_descriptor();
inline const ::std::string& channel_type_Name(channel_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    channel_type_descriptor(), value);
}
inline bool channel_type_Parse(
    const ::std::string& name, channel_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<channel_type>(
    channel_type_descriptor(), name, value);
}
enum item_type {
  item_type_can_use = 11,
  item_type_other = 12,
  item_type_activity = 13,
  item_type_equip = 31,
  item_type_equip_material = 32,
  item_type_task = 51,
  item_type_task_material = 52,
  item_type_trade = 53
};
bool item_type_IsValid(int value);
const item_type item_type_MIN = item_type_can_use;
const item_type item_type_MAX = item_type_trade;
const int item_type_ARRAYSIZE = item_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* item_type_descriptor();
inline const ::std::string& item_type_Name(item_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    item_type_descriptor(), value);
}
inline bool item_type_Parse(
    const ::std::string& name, item_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<item_type>(
    item_type_descriptor(), name, value);
}
enum item_use_type {
  item_use_type_no = 0,
  item_use_type_1 = 1,
  item_use_type_2 = 2,
  item_use_type_drop = 3,
  item_use_type_trade_buy = 4,
  item_use_type_mount = 5,
  item_use_type_treasure_item = 6,
  item_use_type_note_closed = 7,
  item_use_type_note_opened = 8,
  item_use_type_reduce_pk_value = 9,
  item_use_type_task = 10,
  item_use_type_story = 17,
  item_use_type_plugin = 18,
  item_use_type_multi_time = 19,
  item_use_type_source_package = 20,
  item_use_type_vigour_pill = 21,
  item_use_type_add_role_buff = 22,
  item_use_type_add_title = 24,
  item_use_type_change_plugin = 26,
  item_use_type_key_gift = 27,
  item_use_type_add_activity = 28
};
bool item_use_type_IsValid(int value);
const item_use_type item_use_type_MIN = item_use_type_no;
const item_use_type item_use_type_MAX = item_use_type_add_activity;
const int item_use_type_ARRAYSIZE = item_use_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* item_use_type_descriptor();
inline const ::std::string& item_use_type_Name(item_use_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    item_use_type_descriptor(), value);
}
inline bool item_use_type_Parse(
    const ::std::string& name, item_use_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<item_use_type>(
    item_use_type_descriptor(), name, value);
}
enum trade_buy_type {
  trade_buy_type_normal = 1,
  trade_buy_type_rebuy = 2
};
bool trade_buy_type_IsValid(int value);
const trade_buy_type trade_buy_type_MIN = trade_buy_type_normal;
const trade_buy_type trade_buy_type_MAX = trade_buy_type_rebuy;
const int trade_buy_type_ARRAYSIZE = trade_buy_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* trade_buy_type_descriptor();
inline const ::std::string& trade_buy_type_Name(trade_buy_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    trade_buy_type_descriptor(), value);
}
inline bool trade_buy_type_Parse(
    const ::std::string& name, trade_buy_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<trade_buy_type>(
    trade_buy_type_descriptor(), name, value);
}
enum trade_event_type {
  trade_event_type_normal = 0,
  trade_event_type_popular = 1,
  trade_event_type_black = 2,
  trade_event_type_count = 3
};
bool trade_event_type_IsValid(int value);
const trade_event_type trade_event_type_MIN = trade_event_type_normal;
const trade_event_type trade_event_type_MAX = trade_event_type_count;
const int trade_event_type_ARRAYSIZE = trade_event_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* trade_event_type_descriptor();
inline const ::std::string& trade_event_type_Name(trade_event_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    trade_event_type_descriptor(), value);
}
inline bool trade_event_type_Parse(
    const ::std::string& name, trade_event_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<trade_event_type>(
    trade_event_type_descriptor(), name, value);
}
enum package_type {
  package_type_main = 0,
  package_type_trade = 1
};
bool package_type_IsValid(int value);
const package_type package_type_MIN = package_type_main;
const package_type package_type_MAX = package_type_trade;
const int package_type_ARRAYSIZE = package_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* package_type_descriptor();
inline const ::std::string& package_type_Name(package_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    package_type_descriptor(), value);
}
inline bool package_type_Parse(
    const ::std::string& name, package_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<package_type>(
    package_type_descriptor(), name, value);
}
enum mount_state_type {
  mount_state_type_normal = 1,
  mount_state_type_use = 2,
  mount_state_type_unlock = 3,
  mount_state_type_turn = 4,
  mount_state_type_use_and_turn = 5
};
bool mount_state_type_IsValid(int value);
const mount_state_type mount_state_type_MIN = mount_state_type_normal;
const mount_state_type mount_state_type_MAX = mount_state_type_use_and_turn;
const int mount_state_type_ARRAYSIZE = mount_state_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* mount_state_type_descriptor();
inline const ::std::string& mount_state_type_Name(mount_state_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    mount_state_type_descriptor(), value);
}
inline bool mount_state_type_Parse(
    const ::std::string& name, mount_state_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<mount_state_type>(
    mount_state_type_descriptor(), name, value);
}
enum change_offline_data_type {
  change_offline_data_type_mail = 1,
  change_offline_data_type_db = 2
};
bool change_offline_data_type_IsValid(int value);
const change_offline_data_type change_offline_data_type_MIN = change_offline_data_type_mail;
const change_offline_data_type change_offline_data_type_MAX = change_offline_data_type_db;
const int change_offline_data_type_ARRAYSIZE = change_offline_data_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* change_offline_data_type_descriptor();
inline const ::std::string& change_offline_data_type_Name(change_offline_data_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    change_offline_data_type_descriptor(), value);
}
inline bool change_offline_data_type_Parse(
    const ::std::string& name, change_offline_data_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<change_offline_data_type>(
    change_offline_data_type_descriptor(), name, value);
}
enum collect_cond_type {
  collect_cond_type_task = 1,
  collect_cond_type_level = 2,
  collect_cond_type_king_war_family = 3,
  collect_cond_type_family_war = 4
};
bool collect_cond_type_IsValid(int value);
const collect_cond_type collect_cond_type_MIN = collect_cond_type_task;
const collect_cond_type collect_cond_type_MAX = collect_cond_type_family_war;
const int collect_cond_type_ARRAYSIZE = collect_cond_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* collect_cond_type_descriptor();
inline const ::std::string& collect_cond_type_Name(collect_cond_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    collect_cond_type_descriptor(), value);
}
inline bool collect_cond_type_Parse(
    const ::std::string& name, collect_cond_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<collect_cond_type>(
    collect_cond_type_descriptor(), name, value);
}
enum collect_type {
  collect_type_normal = 1,
  collect_type_artifacts = 2,
  collect_type_platform = 3
};
bool collect_type_IsValid(int value);
const collect_type collect_type_MIN = collect_type_normal;
const collect_type collect_type_MAX = collect_type_platform;
const int collect_type_ARRAYSIZE = collect_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* collect_type_descriptor();
inline const ::std::string& collect_type_Name(collect_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    collect_type_descriptor(), value);
}
inline bool collect_type_Parse(
    const ::std::string& name, collect_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<collect_type>(
    collect_type_descriptor(), name, value);
}
enum drop_sys_type {
  drop_sys_type_pve = 1,
  drop_sys_type_task = 2,
  drop_sys_type_luck_package = 3,
  drop_sys_type_collect = 4,
  drop_sys_type_gm = 5,
  drop_sys_type_bounty = 6,
  drop_sys_type_arena = 7,
  drop_sys_type_equip = 8,
  drop_sys_type_achieve = 9,
  drop_sys_type_lifeforce = 10,
  drop_sys_type_trade = 11,
  drop_sys_type_expedition = 12,
  drop_sys_type_page = 13,
  drop_sys_type_dugeon = 14,
  drop_sys_type_active_reward = 15,
  drop_sys_type_hero_luckydraw = 16,
  drop_sys_type_family_prayer = 17,
  drop_sys_type_level_reward = 18,
  drop_sys_type_offline_arena = 19,
  drop_sys_type_tower = 20,
  drop_sys_type_recharge_gift = 21,
  drop_sys_type_month_card_prize = 22,
  drop_sys_type_liandan_return = 23,
  drop_sys_type_patrol_hire = 24,
  drop_sys_type_activity_ws_rand = 25,
  drop_sys_type_activity_ws_score = 26,
  drop_sys_type_limit_buy = 27,
  drop_sys_type_level_fund = 28,
  drop_sys_type_sevenday_login = 29,
  drop_sys_type_sevenday_target = 30,
  drop_sys_type_career = 31,
  drop_sys_type_relation_award = 32,
  drop_sys_type_handbook = 33
};
bool drop_sys_type_IsValid(int value);
const drop_sys_type drop_sys_type_MIN = drop_sys_type_pve;
const drop_sys_type drop_sys_type_MAX = drop_sys_type_handbook;
const int drop_sys_type_ARRAYSIZE = drop_sys_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* drop_sys_type_descriptor();
inline const ::std::string& drop_sys_type_Name(drop_sys_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    drop_sys_type_descriptor(), value);
}
inline bool drop_sys_type_Parse(
    const ::std::string& name, drop_sys_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<drop_sys_type>(
    drop_sys_type_descriptor(), name, value);
}
enum role_cross_type {
  role_cross_type_arena = 1
};
bool role_cross_type_IsValid(int value);
const role_cross_type role_cross_type_MIN = role_cross_type_arena;
const role_cross_type role_cross_type_MAX = role_cross_type_arena;
const int role_cross_type_ARRAYSIZE = role_cross_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_cross_type_descriptor();
inline const ::std::string& role_cross_type_Name(role_cross_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_cross_type_descriptor(), value);
}
inline bool role_cross_type_Parse(
    const ::std::string& name, role_cross_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_cross_type>(
    role_cross_type_descriptor(), name, value);
}
enum hero_terry_type {
  hero_terry_type_water = 1,
  hero_terry_type_fire = 2,
  hero_terry_type_wind = 3,
  hero_terry_type_yin = 4,
  hero_terry_type_yang = 5
};
bool hero_terry_type_IsValid(int value);
const hero_terry_type hero_terry_type_MIN = hero_terry_type_water;
const hero_terry_type hero_terry_type_MAX = hero_terry_type_yang;
const int hero_terry_type_ARRAYSIZE = hero_terry_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_terry_type_descriptor();
inline const ::std::string& hero_terry_type_Name(hero_terry_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_terry_type_descriptor(), value);
}
inline bool hero_terry_type_Parse(
    const ::std::string& name, hero_terry_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_terry_type>(
    hero_terry_type_descriptor(), name, value);
}
enum hero_rarity_type {
  hero_rarity_type_normal = 0,
  hero_rarity_type_rare = 1,
  hero_rarity_type_super_rare = 2,
  hero_rarity_type_super_super_rare = 3
};
bool hero_rarity_type_IsValid(int value);
const hero_rarity_type hero_rarity_type_MIN = hero_rarity_type_normal;
const hero_rarity_type hero_rarity_type_MAX = hero_rarity_type_super_super_rare;
const int hero_rarity_type_ARRAYSIZE = hero_rarity_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_rarity_type_descriptor();
inline const ::std::string& hero_rarity_type_Name(hero_rarity_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_rarity_type_descriptor(), value);
}
inline bool hero_rarity_type_Parse(
    const ::std::string& name, hero_rarity_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_rarity_type>(
    hero_rarity_type_descriptor(), name, value);
}
enum hero_state_type {
  hero_state_type_none = 0,
  hero_state_type_lock = 1
};
bool hero_state_type_IsValid(int value);
const hero_state_type hero_state_type_MIN = hero_state_type_none;
const hero_state_type hero_state_type_MAX = hero_state_type_lock;
const int hero_state_type_ARRAYSIZE = hero_state_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_state_type_descriptor();
inline const ::std::string& hero_state_type_Name(hero_state_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_state_type_descriptor(), value);
}
inline bool hero_state_type_Parse(
    const ::std::string& name, hero_state_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_state_type>(
    hero_state_type_descriptor(), name, value);
}
enum hero_wakeup_type {
  hero_wakeup_type_add = 0,
  hero_wakeup_type_unlock = 1,
  hero_wakeup_type_replace = 2
};
bool hero_wakeup_type_IsValid(int value);
const hero_wakeup_type hero_wakeup_type_MIN = hero_wakeup_type_add;
const hero_wakeup_type hero_wakeup_type_MAX = hero_wakeup_type_replace;
const int hero_wakeup_type_ARRAYSIZE = hero_wakeup_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* hero_wakeup_type_descriptor();
inline const ::std::string& hero_wakeup_type_Name(hero_wakeup_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    hero_wakeup_type_descriptor(), value);
}
inline bool hero_wakeup_type_Parse(
    const ::std::string& name, hero_wakeup_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<hero_wakeup_type>(
    hero_wakeup_type_descriptor(), name, value);
}
enum object_state_type {
  object_state_none = 0,
  object_state_normal = 1,
  object_state_death = 2,
  object_state_fighting = 3,
  object_state_watch_fighting = 4,
  object_state_busy = 5,
  object_state_attack = 6,
  object_state_alert = 7,
  object_state_arena_match = 8,
  object_state_transmission = 9
};
bool object_state_type_IsValid(int value);
const object_state_type object_state_type_MIN = object_state_none;
const object_state_type object_state_type_MAX = object_state_transmission;
const int object_state_type_ARRAYSIZE = object_state_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* object_state_type_descriptor();
inline const ::std::string& object_state_type_Name(object_state_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    object_state_type_descriptor(), value);
}
inline bool object_state_type_Parse(
    const ::std::string& name, object_state_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<object_state_type>(
    object_state_type_descriptor(), name, value);
}
enum role_mode_state {
  role_mode_state_none = 0,
  role_mode_state_normal = 1,
  role_mode_state_mount = 2,
  role_mode_state_trade = 3
};
bool role_mode_state_IsValid(int value);
const role_mode_state role_mode_state_MIN = role_mode_state_none;
const role_mode_state role_mode_state_MAX = role_mode_state_trade;
const int role_mode_state_ARRAYSIZE = role_mode_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_mode_state_descriptor();
inline const ::std::string& role_mode_state_Name(role_mode_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_mode_state_descriptor(), value);
}
inline bool role_mode_state_Parse(
    const ::std::string& name, role_mode_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_mode_state>(
    role_mode_state_descriptor(), name, value);
}
enum EM_MONSTER_TYPE {
  EM_NONE = 0,
  EM_GENERAL = 1,
  EM_ELITE = 2,
  EM_FIELD_BOSS = 3,
  EM_ARENA_AI = 4,
  EM_AIR_WALL = 5,
  EM_KING_WAR_LONNG = 6,
  EM_FAMILY_WAR_LONNG = 7,
  EM_MONSTER_NPC = 8
};
bool EM_MONSTER_TYPE_IsValid(int value);
const EM_MONSTER_TYPE EM_MONSTER_TYPE_MIN = EM_NONE;
const EM_MONSTER_TYPE EM_MONSTER_TYPE_MAX = EM_MONSTER_NPC;
const int EM_MONSTER_TYPE_ARRAYSIZE = EM_MONSTER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EM_MONSTER_TYPE_descriptor();
inline const ::std::string& EM_MONSTER_TYPE_Name(EM_MONSTER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EM_MONSTER_TYPE_descriptor(), value);
}
inline bool EM_MONSTER_TYPE_Parse(
    const ::std::string& name, EM_MONSTER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EM_MONSTER_TYPE>(
    EM_MONSTER_TYPE_descriptor(), name, value);
}
enum obj_hp_change_type {
  obj_hp_change_type_none = 0,
  obj_hp_change_type_add = 1,
  obj_hp_change_type_minus = 2
};
bool obj_hp_change_type_IsValid(int value);
const obj_hp_change_type obj_hp_change_type_MIN = obj_hp_change_type_none;
const obj_hp_change_type obj_hp_change_type_MAX = obj_hp_change_type_minus;
const int obj_hp_change_type_ARRAYSIZE = obj_hp_change_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* obj_hp_change_type_descriptor();
inline const ::std::string& obj_hp_change_type_Name(obj_hp_change_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    obj_hp_change_type_descriptor(), value);
}
inline bool obj_hp_change_type_Parse(
    const ::std::string& name, obj_hp_change_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<obj_hp_change_type>(
    obj_hp_change_type_descriptor(), name, value);
}
enum function_code_type {
  function_code_type_combat_fast = 0,
  function_code_type_combat_auto = 1,
  function_code_type_jump_map = 2,
  function_code_type_equip = 3,
  function_code_type_mount = 4,
  function_code_type_luckydraw = 5,
  function_code_type_form = 6,
  function_code_type_hero = 7,
  function_code_type_role = 8,
  function_code_type_family = 9,
  function_code_type_country = 10,
  function_code_type_Trading = 11,
  function_code_type_shop = 12,
  function_code_type_achieve = 13,
  function_code_type_activity = 14,
  function_code_type_luckydraw_open = 15,
  function_code_type_welfare = 16,
  function_code_type_firstchange = 17,
  function_code_type_feedback = 18,
  function_code_type_strengthen = 19,
  function_code_type_escape = 20,
  function_code_type_show_lifeforceicon = 21,
  function_code_type_level_reward = 24,
  function_code_type_pack = 25,
  function_code_type_chat = 26,
  function_code_type_equip_grid = 27,
  function_code_type_skill = 28,
  function_code_type_tianxiadashi = 30,
  function_code_type_second_new_guide = 31,
  function_code_type_czlc = 32,
  function_code_type_dungeon = 33,
  function_code_type_rechargetotal = 34
};
bool function_code_type_IsValid(int value);
const function_code_type function_code_type_MIN = function_code_type_combat_fast;
const function_code_type function_code_type_MAX = function_code_type_rechargetotal;
const int function_code_type_ARRAYSIZE = function_code_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* function_code_type_descriptor();
inline const ::std::string& function_code_type_Name(function_code_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    function_code_type_descriptor(), value);
}
inline bool function_code_type_Parse(
    const ::std::string& name, function_code_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<function_code_type>(
    function_code_type_descriptor(), name, value);
}
enum skill_type {
  skill_type_atk = 0,
  skill_type_sp_skill = 1,
  skill_type_passive = 2,
  skill_type_equip_skill = 3,
  skill_type_activate = 4
};
bool skill_type_IsValid(int value);
const skill_type skill_type_MIN = skill_type_atk;
const skill_type skill_type_MAX = skill_type_activate;
const int skill_type_ARRAYSIZE = skill_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* skill_type_descriptor();
inline const ::std::string& skill_type_Name(skill_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    skill_type_descriptor(), value);
}
inline bool skill_type_Parse(
    const ::std::string& name, skill_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<skill_type>(
    skill_type_descriptor(), name, value);
}
enum formation_type {
  formation_type_role_1 = 1,
  formation_type_role_2 = 2,
  formation_type_role_3 = 3,
  formation_type_family = 4,
  formation_type_expedition = 5,
  formation_type_offline_arena = 6,
  formation_type_troop_2 = 7,
  formation_type_troop_3 = 8,
  formation_type_troop_leader_2 = 9,
  formation_type_troop_leader_3 = 10,
  formation_type_count = 11
};
bool formation_type_IsValid(int value);
const formation_type formation_type_MIN = formation_type_role_1;
const formation_type formation_type_MAX = formation_type_count;
const int formation_type_ARRAYSIZE = formation_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* formation_type_descriptor();
inline const ::std::string& formation_type_Name(formation_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    formation_type_descriptor(), value);
}
inline bool formation_type_Parse(
    const ::std::string& name, formation_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<formation_type>(
    formation_type_descriptor(), name, value);
}
enum activity_shop_type {
  activity_shop_type_wusheng_rand = 1,
  activity_shop_type_wusheng_score = 2
};
bool activity_shop_type_IsValid(int value);
const activity_shop_type activity_shop_type_MIN = activity_shop_type_wusheng_rand;
const activity_shop_type activity_shop_type_MAX = activity_shop_type_wusheng_score;
const int activity_shop_type_ARRAYSIZE = activity_shop_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* activity_shop_type_descriptor();
inline const ::std::string& activity_shop_type_Name(activity_shop_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    activity_shop_type_descriptor(), value);
}
inline bool activity_shop_type_Parse(
    const ::std::string& name, activity_shop_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<activity_shop_type>(
    activity_shop_type_descriptor(), name, value);
}
enum EM_CULTIVATE_TYPE {
  EMCUTYPE_LEVEL = 0,
  EMCUTYPE_STARUP = 1,
  EMCUTYPE_ADVANCED = 2,
  EMCUTYPE_TALENTUP = 3,
  EMCUTYPE_TALENTADD = 4,
  EMCUTYPE_FATE = 5,
  EMCUTYPE_SKILLUP = 6,
  EMCUTYPE_TALENTACTIVE = 7,
  EMCUTYPE_TALENTRESET = 8,
  EMCUTYPE_WAKEUP = 9,
  EMCUTYPE_SKILL_UNLOCK = 10,
  EMCUTYPE_SKILL_REPLACE = 11,
  EMCUTYPE_SMELT = 12,
  EMCUTYPE_FAMOUS = 13
};
bool EM_CULTIVATE_TYPE_IsValid(int value);
const EM_CULTIVATE_TYPE EM_CULTIVATE_TYPE_MIN = EMCUTYPE_LEVEL;
const EM_CULTIVATE_TYPE EM_CULTIVATE_TYPE_MAX = EMCUTYPE_FAMOUS;
const int EM_CULTIVATE_TYPE_ARRAYSIZE = EM_CULTIVATE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EM_CULTIVATE_TYPE_descriptor();
inline const ::std::string& EM_CULTIVATE_TYPE_Name(EM_CULTIVATE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EM_CULTIVATE_TYPE_descriptor(), value);
}
inline bool EM_CULTIVATE_TYPE_Parse(
    const ::std::string& name, EM_CULTIVATE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EM_CULTIVATE_TYPE>(
    EM_CULTIVATE_TYPE_descriptor(), name, value);
}
enum transmission_type {
  transmission_type_none = 0,
  transmission_type_user = 1,
  transmission_type_troop = 2
};
bool transmission_type_IsValid(int value);
const transmission_type transmission_type_MIN = transmission_type_none;
const transmission_type transmission_type_MAX = transmission_type_troop;
const int transmission_type_ARRAYSIZE = transmission_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* transmission_type_descriptor();
inline const ::std::string& transmission_type_Name(transmission_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    transmission_type_descriptor(), value);
}
inline bool transmission_type_Parse(
    const ::std::string& name, transmission_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<transmission_type>(
    transmission_type_descriptor(), name, value);
}
enum family_build_type {
  family_build_type_congress = 1,
  family_build_type_house = 2,
  family_build_type_ploy = 3,
  family_build_type_barn = 4,
  family_build_type_shop = 5
};
bool family_build_type_IsValid(int value);
const family_build_type family_build_type_MIN = family_build_type_congress;
const family_build_type family_build_type_MAX = family_build_type_shop;
const int family_build_type_ARRAYSIZE = family_build_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_build_type_descriptor();
inline const ::std::string& family_build_type_Name(family_build_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_build_type_descriptor(), value);
}
inline bool family_build_type_Parse(
    const ::std::string& name, family_build_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_build_type>(
    family_build_type_descriptor(), name, value);
}
enum family_member_type {
  family_member_type_none = 0,
  family_member_type_applay = 1,
  family_member_type_newbie = 2,
  family_member_type_formal = 3
};
bool family_member_type_IsValid(int value);
const family_member_type family_member_type_MIN = family_member_type_none;
const family_member_type family_member_type_MAX = family_member_type_formal;
const int family_member_type_ARRAYSIZE = family_member_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_member_type_descriptor();
inline const ::std::string& family_member_type_Name(family_member_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_member_type_descriptor(), value);
}
inline bool family_member_type_Parse(
    const ::std::string& name, family_member_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_member_type>(
    family_member_type_descriptor(), name, value);
}
enum family_war_state {
  family_war_state_end = 0,
  family_war_state_init = 1,
  family_war_state_prepare = 2,
  family_war_state_start = 3
};
bool family_war_state_IsValid(int value);
const family_war_state family_war_state_MIN = family_war_state_end;
const family_war_state family_war_state_MAX = family_war_state_start;
const int family_war_state_ARRAYSIZE = family_war_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_war_state_descriptor();
inline const ::std::string& family_war_state_Name(family_war_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_war_state_descriptor(), value);
}
inline bool family_war_state_Parse(
    const ::std::string& name, family_war_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_war_state>(
    family_war_state_descriptor(), name, value);
}
enum family_war_result {
  family_war_result_none = 0,
  family_war_result_win = 1,
  family_war_result_failure = 2
};
bool family_war_result_IsValid(int value);
const family_war_result family_war_result_MIN = family_war_result_none;
const family_war_result family_war_result_MAX = family_war_result_failure;
const int family_war_result_ARRAYSIZE = family_war_result_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_war_result_descriptor();
inline const ::std::string& family_war_result_Name(family_war_result value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_war_result_descriptor(), value);
}
inline bool family_war_result_Parse(
    const ::std::string& name, family_war_result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_war_result>(
    family_war_result_descriptor(), name, value);
}
enum family_war_hero_type {
  family_war_hero_none = 0,
  family_war_hero_normal = 1,
  family_war_hero_death = 2
};
bool family_war_hero_type_IsValid(int value);
const family_war_hero_type family_war_hero_type_MIN = family_war_hero_none;
const family_war_hero_type family_war_hero_type_MAX = family_war_hero_death;
const int family_war_hero_type_ARRAYSIZE = family_war_hero_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_war_hero_type_descriptor();
inline const ::std::string& family_war_hero_type_Name(family_war_hero_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_war_hero_type_descriptor(), value);
}
inline bool family_war_hero_type_Parse(
    const ::std::string& name, family_war_hero_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_war_hero_type>(
    family_war_hero_type_descriptor(), name, value);
}
enum family_war_platform_type {
  family_war_platform_none = 0,
  family_war_platform_sun = 1,
  family_war_platform_moon = 2
};
bool family_war_platform_type_IsValid(int value);
const family_war_platform_type family_war_platform_type_MIN = family_war_platform_none;
const family_war_platform_type family_war_platform_type_MAX = family_war_platform_moon;
const int family_war_platform_type_ARRAYSIZE = family_war_platform_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* family_war_platform_type_descriptor();
inline const ::std::string& family_war_platform_type_Name(family_war_platform_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    family_war_platform_type_descriptor(), value);
}
inline bool family_war_platform_type_Parse(
    const ::std::string& name, family_war_platform_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<family_war_platform_type>(
    family_war_platform_type_descriptor(), name, value);
}
enum country_period_type {
  country_period_none = 0,
  country_period_establish = 1,
  country_period_hegemony = 2
};
bool country_period_type_IsValid(int value);
const country_period_type country_period_type_MIN = country_period_none;
const country_period_type country_period_type_MAX = country_period_hegemony;
const int country_period_type_ARRAYSIZE = country_period_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* country_period_type_descriptor();
inline const ::std::string& country_period_type_Name(country_period_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    country_period_type_descriptor(), value);
}
inline bool country_period_type_Parse(
    const ::std::string& name, country_period_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<country_period_type>(
    country_period_type_descriptor(), name, value);
}
enum country_level_type {
  country_level_normal = 0,
  country_level_weak = 1,
  country_level_strong = 2,
  country_level_overlord = 3
};
bool country_level_type_IsValid(int value);
const country_level_type country_level_type_MIN = country_level_normal;
const country_level_type country_level_type_MAX = country_level_overlord;
const int country_level_type_ARRAYSIZE = country_level_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* country_level_type_descriptor();
inline const ::std::string& country_level_type_Name(country_level_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    country_level_type_descriptor(), value);
}
inline bool country_level_type_Parse(
    const ::std::string& name, country_level_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<country_level_type>(
    country_level_type_descriptor(), name, value);
}
enum troop_state_type {
  troop_state_normal = 0,
  troop_state_leave = 1,
  troop_state_offline = 2
};
bool troop_state_type_IsValid(int value);
const troop_state_type troop_state_type_MIN = troop_state_normal;
const troop_state_type troop_state_type_MAX = troop_state_offline;
const int troop_state_type_ARRAYSIZE = troop_state_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* troop_state_type_descriptor();
inline const ::std::string& troop_state_type_Name(troop_state_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    troop_state_type_descriptor(), value);
}
inline bool troop_state_type_Parse(
    const ::std::string& name, troop_state_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<troop_state_type>(
    troop_state_type_descriptor(), name, value);
}
enum fight_type {
  fight_type_none = 0,
  fight_type_study = 1,
  fight_type_field_boss = 2,
  fight_type_task = 3,
  fight_type_dark_monster = 4,
  fight_type_against = 5,
  fight_type_cross_arena_rank = 6,
  fight_type_cross_arena_train = 7,
  fight_type_pk = 8,
  fight_type_light_monster = 9,
  fight_type_challenge = 10,
  fight_type_world_cup = 11,
  fight_type_tower = 12,
  fight_type_expedition = 13,
  fight_type_family_war = 14,
  fight_type_family_pk = 15,
  fight_type_page_pass_pk = 16,
  fight_type_offline_arena = 17
};
bool fight_type_IsValid(int value);
const fight_type fight_type_MIN = fight_type_none;
const fight_type fight_type_MAX = fight_type_offline_arena;
const int fight_type_ARRAYSIZE = fight_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* fight_type_descriptor();
inline const ::std::string& fight_type_Name(fight_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    fight_type_descriptor(), value);
}
inline bool fight_type_Parse(
    const ::std::string& name, fight_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<fight_type>(
    fight_type_descriptor(), name, value);
}
enum city_type {
  city_type_imperial = 1,
  city_type_bussiness = 2,
  city_type_war = 3,
  city_type_assemble = 4,
  city_type_attacker_assemble = 5,
  city_type_near_king = 6
};
bool city_type_IsValid(int value);
const city_type city_type_MIN = city_type_imperial;
const city_type city_type_MAX = city_type_near_king;
const int city_type_ARRAYSIZE = city_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* city_type_descriptor();
inline const ::std::string& city_type_Name(city_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    city_type_descriptor(), value);
}
inline bool city_type_Parse(
    const ::std::string& name, city_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<city_type>(
    city_type_descriptor(), name, value);
}
enum em_field_boss_state {
  FIELD_BOSS_STATE_NONE = 1,
  FIELD_BOSS_STATE_START = 2,
  FIELD_BOSS_STATE_KILL = 3,
  FIELD_BOSS_STATE_GONE = 4
};
bool em_field_boss_state_IsValid(int value);
const em_field_boss_state em_field_boss_state_MIN = FIELD_BOSS_STATE_NONE;
const em_field_boss_state em_field_boss_state_MAX = FIELD_BOSS_STATE_GONE;
const int em_field_boss_state_ARRAYSIZE = em_field_boss_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_field_boss_state_descriptor();
inline const ::std::string& em_field_boss_state_Name(em_field_boss_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_field_boss_state_descriptor(), value);
}
inline bool em_field_boss_state_Parse(
    const ::std::string& name, em_field_boss_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_field_boss_state>(
    em_field_boss_state_descriptor(), name, value);
}
enum em_field_boss_pos {
  FIELD_BOSS_POS_ADD = 1,
  FIELD_BOSS_POS_DEL = 2
};
bool em_field_boss_pos_IsValid(int value);
const em_field_boss_pos em_field_boss_pos_MIN = FIELD_BOSS_POS_ADD;
const em_field_boss_pos em_field_boss_pos_MAX = FIELD_BOSS_POS_DEL;
const int em_field_boss_pos_ARRAYSIZE = em_field_boss_pos_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_field_boss_pos_descriptor();
inline const ::std::string& em_field_boss_pos_Name(em_field_boss_pos value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_field_boss_pos_descriptor(), value);
}
inline bool em_field_boss_pos_Parse(
    const ::std::string& name, em_field_boss_pos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_field_boss_pos>(
    em_field_boss_pos_descriptor(), name, value);
}
enum em_mail_type {
  MAIL_TYPE_NONE = 0,
  MAIL_TYPE_SYS = 1,
  MAIL_TYPE_NORMAL = 2
};
bool em_mail_type_IsValid(int value);
const em_mail_type em_mail_type_MIN = MAIL_TYPE_NONE;
const em_mail_type em_mail_type_MAX = MAIL_TYPE_NORMAL;
const int em_mail_type_ARRAYSIZE = em_mail_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_mail_type_descriptor();
inline const ::std::string& em_mail_type_Name(em_mail_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_mail_type_descriptor(), value);
}
inline bool em_mail_type_Parse(
    const ::std::string& name, em_mail_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_mail_type>(
    em_mail_type_descriptor(), name, value);
}
enum em_mail_state {
  MAIL_STATE_NONE = 0,
  MAIL_STATE_NEW = 1,
  MAIL_STATE_OPENED = 2,
  MAIL_STATE_REMOVE = 3
};
bool em_mail_state_IsValid(int value);
const em_mail_state em_mail_state_MIN = MAIL_STATE_NONE;
const em_mail_state em_mail_state_MAX = MAIL_STATE_REMOVE;
const int em_mail_state_ARRAYSIZE = em_mail_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_mail_state_descriptor();
inline const ::std::string& em_mail_state_Name(em_mail_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_mail_state_descriptor(), value);
}
inline bool em_mail_state_Parse(
    const ::std::string& name, em_mail_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_mail_state>(
    em_mail_state_descriptor(), name, value);
}
enum em_mail_addenda {
  MAIL_ADDENDA_NONE = 0,
  MAIL_ADDENDA_NEW = 1,
  MAIL_ADDENDA_GOT = 2
};
bool em_mail_addenda_IsValid(int value);
const em_mail_addenda em_mail_addenda_MIN = MAIL_ADDENDA_NONE;
const em_mail_addenda em_mail_addenda_MAX = MAIL_ADDENDA_GOT;
const int em_mail_addenda_ARRAYSIZE = em_mail_addenda_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_mail_addenda_descriptor();
inline const ::std::string& em_mail_addenda_Name(em_mail_addenda value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_mail_addenda_descriptor(), value);
}
inline bool em_mail_addenda_Parse(
    const ::std::string& name, em_mail_addenda* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_mail_addenda>(
    em_mail_addenda_descriptor(), name, value);
}
enum em_mail_batch {
  MAIL_BATCH_GET = 1,
  MAIL_BATCH_CLEAR = 2
};
bool em_mail_batch_IsValid(int value);
const em_mail_batch em_mail_batch_MIN = MAIL_BATCH_GET;
const em_mail_batch em_mail_batch_MAX = MAIL_BATCH_CLEAR;
const int em_mail_batch_ARRAYSIZE = em_mail_batch_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_mail_batch_descriptor();
inline const ::std::string& em_mail_batch_Name(em_mail_batch value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_mail_batch_descriptor(), value);
}
inline bool em_mail_batch_Parse(
    const ::std::string& name, em_mail_batch* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_mail_batch>(
    em_mail_batch_descriptor(), name, value);
}
enum em_mail_get_type {
  MAIL_GET_TYPE_NONE = 0,
  MAIL_GET_TYPE_SYS = 1,
  MAIL_GET_TYPE_GLOBAL_MAIL = 2,
  MAIL_GET_TYPE_GM = 3,
  MAIL_GET_TYPE_ARENA = 4,
  MAIL_GET_TYPE_DROP = 5,
  MAIL_GET_TYPE_ADD_HERO = 6,
  MAIL_GET_TYPE_FAMILY_PRAYER = 7,
  MAIL_GET_TYPE_FIELD_BOSS = 8,
  MAIL_GET_TYPE_LEVEL_REWARD = 9,
  MAIL_GET_TYPE_TOWER_OVER = 10,
  MAIL_GET_TYPE_LUCKYDRAW_KING_MONEY = 11,
  MAIL_GET_TYPE_CDKEY = 12,
  MAIL_GET_TYPE_KING_WAR = 13,
  MAIL_GET_TYPE_FAMILY_WAR = 14,
  MAIL_GET_TYPE_RANK = 15
};
bool em_mail_get_type_IsValid(int value);
const em_mail_get_type em_mail_get_type_MIN = MAIL_GET_TYPE_NONE;
const em_mail_get_type em_mail_get_type_MAX = MAIL_GET_TYPE_RANK;
const int em_mail_get_type_ARRAYSIZE = em_mail_get_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* em_mail_get_type_descriptor();
inline const ::std::string& em_mail_get_type_Name(em_mail_get_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    em_mail_get_type_descriptor(), value);
}
inline bool em_mail_get_type_Parse(
    const ::std::string& name, em_mail_get_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<em_mail_get_type>(
    em_mail_get_type_descriptor(), name, value);
}
enum combat_act_type {
  combat_act_type_NULL = 0,
  combat_act_type_skill = 1,
  combat_act_type_buff = 2,
  combat_act_type_buff_remove = 3,
  combat_act_type_tactic_on = 4,
  combat_act_type_tactic_off = 5,
  combat_act_type_dodge = 6,
  combat_act_type_heal = 7,
  combat_act_type_heal_crit = 8,
  combat_act_type_damage = 9,
  combat_act_type_ext = 10,
  combat_act_type_crit = 11,
  combat_act_type_absorb = 12,
  combat_act_type_reflect = 13,
  combat_act_type_leech = 14,
  combat_act_type_share_damage = 15,
  combat_act_type_relive = 16,
  combat_act_type_block = 17,
  combat_act_type_counter = 18,
  combat_act_type_combo = 19,
  combat_act_type_follow = 20,
  combat_act_type_att_speed_inc = 21,
  combat_act_type_att_speed_dec = 22,
  combat_act_type_kill_leech = 23,
  combat_act_type_recover = 24,
  combat_act_type_syn_cd = 25,
  combat_act_type_syn_hp = 26,
  combat_act_type_syn_wave = 27,
  combat_act_type_beheaded = 28,
  combat_act_type_syn_atk_count = 29,
  combat_act_type_buff_damage = 30,
  combat_act_type_buff_heal = 31,
  combat_act_type_buff_dot = 32,
  combat_act_type_accept_damage = 33,
  combat_act_type_steal_buff = 34,
  combat_act_type_be_share_damage = 35,
  combat_act_type_special_skill = 36,
  combat_act_type_immuno = 37,
  combat_act_type_spurting = 38,
  combat_act_type_camera = 39,
  combat_act_type_buff_immuno = 41,
  combat_act_type_buff_oppose = 42,
  combat_act_type_buff_update = 43,
  combat_act_type_summon = 44,
  combat_act_type_pincer_attack = 45,
  combat_act_type_trigger_skill = 46,
  combat_act_type_attr_inc = 47,
  combat_act_type_attr_dec = 48,
  combat_act_type_activation_skill = 51,
  combat_act_type_unactivation_skill = 52,
  combat_act_type_change_model = 53,
  combat_act_type_continue_heal = 54,
  combat_act_type_hero_attack = 55,
  combat_act_type_story_play = 56,
  combat_act_type_rand_damage = 57,
  combat_act_type_bomb = 58,
  combat_act_type_suck_attr = 59,
  combat_act_type_turn_attr = 60,
  combat_act_type_protect_almost_dead = 61,
  combat_act_type_detonate = 62,
  combat_act_type_dispel_buff = 63,
  combat_act_type_death_guard = 64,
  combat_act_type_death_skill = 65,
  combat_act_type_add_skill = 66,
  combat_act_type_count_left_of_buff = 67,
  combat_act_type_one_att_total_hurt = 68,
  combat_act_type_count_of_trigger_skill = 69
};
bool combat_act_type_IsValid(int value);
const combat_act_type combat_act_type_MIN = combat_act_type_NULL;
const combat_act_type combat_act_type_MAX = combat_act_type_count_of_trigger_skill;
const int combat_act_type_ARRAYSIZE = combat_act_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_act_type_descriptor();
inline const ::std::string& combat_act_type_Name(combat_act_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_act_type_descriptor(), value);
}
inline bool combat_act_type_Parse(
    const ::std::string& name, combat_act_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_act_type>(
    combat_act_type_descriptor(), name, value);
}
enum combat_act_step {
  combat_act_step_none = 0,
  combat_act_step_round_start = 1,
  combat_act_step_before_attack = 2,
  combat_act_step_before_attack_target = 3,
  combat_act_step_before_attack_phase = 4,
  combat_act_step_after_attack_phase = 5,
  combat_act_step_after_attack_target = 6,
  combat_act_step_after_attack = 7,
  combat_act_step_round_end = 8
};
bool combat_act_step_IsValid(int value);
const combat_act_step combat_act_step_MIN = combat_act_step_none;
const combat_act_step combat_act_step_MAX = combat_act_step_round_end;
const int combat_act_step_ARRAYSIZE = combat_act_step_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_act_step_descriptor();
inline const ::std::string& combat_act_step_Name(combat_act_step value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_act_step_descriptor(), value);
}
inline bool combat_act_step_Parse(
    const ::std::string& name, combat_act_step* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_act_step>(
    combat_act_step_descriptor(), name, value);
}
enum combat_camp {
  combat_camp_1 = 0,
  combat_camp_2 = 1,
  combat_camp_3 = 2,
  combat_camp_none = 3
};
bool combat_camp_IsValid(int value);
const combat_camp combat_camp_MIN = combat_camp_1;
const combat_camp combat_camp_MAX = combat_camp_none;
const int combat_camp_ARRAYSIZE = combat_camp_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_camp_descriptor();
inline const ::std::string& combat_camp_Name(combat_camp value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_camp_descriptor(), value);
}
inline bool combat_camp_Parse(
    const ::std::string& name, combat_camp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_camp>(
    combat_camp_descriptor(), name, value);
}
enum combat_step {
  combat_step_loading = 1,
  combat_step_form = 2,
  combat_step_round = 3,
  combat_step_end = 4
};
bool combat_step_IsValid(int value);
const combat_step combat_step_MIN = combat_step_loading;
const combat_step combat_step_MAX = combat_step_end;
const int combat_step_ARRAYSIZE = combat_step_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_step_descriptor();
inline const ::std::string& combat_step_Name(combat_step value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_step_descriptor(), value);
}
inline bool combat_step_Parse(
    const ::std::string& name, combat_step* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_step>(
    combat_step_descriptor(), name, value);
}
enum combat_state {
  combat_state_prepare = 1,
  combat_state_play = 2,
  combat_state_fight = 3,
  combat_state_story = 4
};
bool combat_state_IsValid(int value);
const combat_state combat_state_MIN = combat_state_prepare;
const combat_state combat_state_MAX = combat_state_story;
const int combat_state_ARRAYSIZE = combat_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_state_descriptor();
inline const ::std::string& combat_state_Name(combat_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_state_descriptor(), value);
}
inline bool combat_state_Parse(
    const ::std::string& name, combat_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_state>(
    combat_state_descriptor(), name, value);
}
enum combat_obj_state {
  combat_obj_state_none = 0,
  combat_obj_state_loading = 1,
  combat_obj_state_loading_end = 2,
  combat_obj_state_prepare = 3,
  combat_obj_state_prepare_end = 4,
  combat_obj_state_play = 5,
  combat_obj_state_play_end = 6
};
bool combat_obj_state_IsValid(int value);
const combat_obj_state combat_obj_state_MIN = combat_obj_state_none;
const combat_obj_state combat_obj_state_MAX = combat_obj_state_play_end;
const int combat_obj_state_ARRAYSIZE = combat_obj_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_obj_state_descriptor();
inline const ::std::string& combat_obj_state_Name(combat_obj_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_obj_state_descriptor(), value);
}
inline bool combat_obj_state_Parse(
    const ::std::string& name, combat_obj_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_obj_state>(
    combat_obj_state_descriptor(), name, value);
}
enum combat_fight_result {
  combat_fight_result_none = 0,
  combat_fight_result_win = 1,
  combat_fight_result_all_lose = 2,
  combat_fight_result_enemy_escape = 3
};
bool combat_fight_result_IsValid(int value);
const combat_fight_result combat_fight_result_MIN = combat_fight_result_none;
const combat_fight_result combat_fight_result_MAX = combat_fight_result_enemy_escape;
const int combat_fight_result_ARRAYSIZE = combat_fight_result_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_fight_result_descriptor();
inline const ::std::string& combat_fight_result_Name(combat_fight_result value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_fight_result_descriptor(), value);
}
inline bool combat_fight_result_Parse(
    const ::std::string& name, combat_fight_result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_fight_result>(
    combat_fight_result_descriptor(), name, value);
}
enum combat_finish_task_type {
  combat_finish_task_type_none = 0,
  combat_finish_task_type_first_attack = 1,
  combat_finish_task_type_enemy_all_die = 2,
  combat_finish_task_type_alive_more = 3
};
bool combat_finish_task_type_IsValid(int value);
const combat_finish_task_type combat_finish_task_type_MIN = combat_finish_task_type_none;
const combat_finish_task_type combat_finish_task_type_MAX = combat_finish_task_type_alive_more;
const int combat_finish_task_type_ARRAYSIZE = combat_finish_task_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* combat_finish_task_type_descriptor();
inline const ::std::string& combat_finish_task_type_Name(combat_finish_task_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    combat_finish_task_type_descriptor(), value);
}
inline bool combat_finish_task_type_Parse(
    const ::std::string& name, combat_finish_task_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<combat_finish_task_type>(
    combat_finish_task_type_descriptor(), name, value);
}
enum friend_type {
  friend_type_none = 0,
  friend_type_stranger = 1,
  friend_type_troop_stranger = 2,
  friend_type_one_side_friend = 3,
  friend_type_two_side_friend = 4,
  friend_type_black = 5
};
bool friend_type_IsValid(int value);
const friend_type friend_type_MIN = friend_type_none;
const friend_type friend_type_MAX = friend_type_black;
const int friend_type_ARRAYSIZE = friend_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* friend_type_descriptor();
inline const ::std::string& friend_type_Name(friend_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    friend_type_descriptor(), value);
}
inline bool friend_type_Parse(
    const ::std::string& name, friend_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<friend_type>(
    friend_type_descriptor(), name, value);
}
enum change_friendliness_reason {
  change_reason_be_friends = 1,
  change_reason_be_no_friends = 2,
  change_reason_send_gift = 3,
  change_reason_send_friend_point = 4,
  change_reason_fight_together = 5,
  change_reason_treasure = 6
};
bool change_friendliness_reason_IsValid(int value);
const change_friendliness_reason change_friendliness_reason_MIN = change_reason_be_friends;
const change_friendliness_reason change_friendliness_reason_MAX = change_reason_treasure;
const int change_friendliness_reason_ARRAYSIZE = change_friendliness_reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* change_friendliness_reason_descriptor();
inline const ::std::string& change_friendliness_reason_Name(change_friendliness_reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    change_friendliness_reason_descriptor(), value);
}
inline bool change_friendliness_reason_Parse(
    const ::std::string& name, change_friendliness_reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<change_friendliness_reason>(
    change_friendliness_reason_descriptor(), name, value);
}
enum recommend_source {
  recommend_source_country_top = 1,
  recommend_source_top = 2,
  recommend_source_family = 3,
  recommend_source_country = 4,
  recommend_source_same_level = 5,
  recommend_source_rand = 6
};
bool recommend_source_IsValid(int value);
const recommend_source recommend_source_MIN = recommend_source_country_top;
const recommend_source recommend_source_MAX = recommend_source_rand;
const int recommend_source_ARRAYSIZE = recommend_source_MAX + 1;

const ::google::protobuf::EnumDescriptor* recommend_source_descriptor();
inline const ::std::string& recommend_source_Name(recommend_source value) {
  return ::google::protobuf::internal::NameOfEnum(
    recommend_source_descriptor(), value);
}
inline bool recommend_source_Parse(
    const ::std::string& name, recommend_source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<recommend_source>(
    recommend_source_descriptor(), name, value);
}
enum system_notice_type {
  SYS_NOTICE_DEFAULT = 0,
  SYS_NOTICE_LANTERN = 1,
  SYS_NOTICE_HORN = 2,
  SYS_NOTICE_CHANNEL = 3,
  SYS_NOTICE_ADVANCED = 4
};
bool system_notice_type_IsValid(int value);
const system_notice_type system_notice_type_MIN = SYS_NOTICE_DEFAULT;
const system_notice_type system_notice_type_MAX = SYS_NOTICE_ADVANCED;
const int system_notice_type_ARRAYSIZE = system_notice_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* system_notice_type_descriptor();
inline const ::std::string& system_notice_type_Name(system_notice_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    system_notice_type_descriptor(), value);
}
inline bool system_notice_type_Parse(
    const ::std::string& name, system_notice_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<system_notice_type>(
    system_notice_type_descriptor(), name, value);
}
enum shop_type {
  shop_type_none = 0,
  shop_type_gold = 1,
  shop_type_silver = 2,
  shop_type_exchange = 3
};
bool shop_type_IsValid(int value);
const shop_type shop_type_MIN = shop_type_none;
const shop_type shop_type_MAX = shop_type_exchange;
const int shop_type_ARRAYSIZE = shop_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* shop_type_descriptor();
inline const ::std::string& shop_type_Name(shop_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    shop_type_descriptor(), value);
}
inline bool shop_type_Parse(
    const ::std::string& name, shop_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<shop_type>(
    shop_type_descriptor(), name, value);
}
enum shop_refresh_type {
  shop_refresh_type_none = 0,
  shop_refresh_type_day = 1,
  shop_refresh_type_week = 2,
  shop_refresh_type_month = 3,
  shop_refresh_type_forever = 4
};
bool shop_refresh_type_IsValid(int value);
const shop_refresh_type shop_refresh_type_MIN = shop_refresh_type_none;
const shop_refresh_type shop_refresh_type_MAX = shop_refresh_type_forever;
const int shop_refresh_type_ARRAYSIZE = shop_refresh_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* shop_refresh_type_descriptor();
inline const ::std::string& shop_refresh_type_Name(shop_refresh_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    shop_refresh_type_descriptor(), value);
}
inline bool shop_refresh_type_Parse(
    const ::std::string& name, shop_refresh_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<shop_refresh_type>(
    shop_refresh_type_descriptor(), name, value);
}
enum shop_buy_condition {
  shop_buy_condition_none = 0,
  shop_buy_condition_level = 1,
  shop_buy_condition_task = 2,
  shop_buy_condition_pvp = 3
};
bool shop_buy_condition_IsValid(int value);
const shop_buy_condition shop_buy_condition_MIN = shop_buy_condition_none;
const shop_buy_condition shop_buy_condition_MAX = shop_buy_condition_pvp;
const int shop_buy_condition_ARRAYSIZE = shop_buy_condition_MAX + 1;

const ::google::protobuf::EnumDescriptor* shop_buy_condition_descriptor();
inline const ::std::string& shop_buy_condition_Name(shop_buy_condition value) {
  return ::google::protobuf::internal::NameOfEnum(
    shop_buy_condition_descriptor(), value);
}
inline bool shop_buy_condition_Parse(
    const ::std::string& name, shop_buy_condition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<shop_buy_condition>(
    shop_buy_condition_descriptor(), name, value);
}
enum challenge_state {
  challenge_state_process = 0,
  challenge_state_accept = 1,
  challenge_state_refuse = 2,
  challenge_state_win_without_fight = 3,
  challenge_state_lose_without_fight = 4,
  challenge_state_draw = 5,
  challenge_state_win = 6,
  challenge_state_lose = 7
};
bool challenge_state_IsValid(int value);
const challenge_state challenge_state_MIN = challenge_state_process;
const challenge_state challenge_state_MAX = challenge_state_lose;
const int challenge_state_ARRAYSIZE = challenge_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* challenge_state_descriptor();
inline const ::std::string& challenge_state_Name(challenge_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    challenge_state_descriptor(), value);
}
inline bool challenge_state_Parse(
    const ::std::string& name, challenge_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<challenge_state>(
    challenge_state_descriptor(), name, value);
}
enum troop_event {
  troop_event_create = 0,
  troop_event_join = 1,
  troop_event_quit = 2,
  troop_event_kick = 3,
  troop_event_leave = 4,
  troop_event_leader = 5,
  troop_event_modify = 6,
  troop_event_back = 7,
  troop_event_apply = 8,
  troop_event_update = 9,
  troop_event_online = 10,
  troop_event_dissolve = 11,
  troop_event_transmission = 12,
  troop_event_zhuagui_task = 13,
  troop_event_escape = 14,
  troop_event_shadow_quit = 15
};
bool troop_event_IsValid(int value);
const troop_event troop_event_MIN = troop_event_create;
const troop_event troop_event_MAX = troop_event_shadow_quit;
const int troop_event_ARRAYSIZE = troop_event_MAX + 1;

const ::google::protobuf::EnumDescriptor* troop_event_descriptor();
inline const ::std::string& troop_event_Name(troop_event value) {
  return ::google::protobuf::internal::NameOfEnum(
    troop_event_descriptor(), value);
}
inline bool troop_event_Parse(
    const ::std::string& name, troop_event* value) {
  return ::google::protobuf::internal::ParseNamedEnum<troop_event>(
    troop_event_descriptor(), name, value);
}
enum king_war_state {
  king_war_state_end = 0,
  king_war_state_sign_up = 1,
  king_war_state_pre = 2,
  king_war_state_prepare = 3,
  king_war_state_start = 4
};
bool king_war_state_IsValid(int value);
const king_war_state king_war_state_MIN = king_war_state_end;
const king_war_state king_war_state_MAX = king_war_state_start;
const int king_war_state_ARRAYSIZE = king_war_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* king_war_state_descriptor();
inline const ::std::string& king_war_state_Name(king_war_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    king_war_state_descriptor(), value);
}
inline bool king_war_state_Parse(
    const ::std::string& name, king_war_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<king_war_state>(
    king_war_state_descriptor(), name, value);
}
enum king_war_help_state {
  king_war_help_none = 0,
  king_war_help_invited = 1,
  king_war_help_refused = 2,
  king_war_help_fighted = 3
};
bool king_war_help_state_IsValid(int value);
const king_war_help_state king_war_help_state_MIN = king_war_help_none;
const king_war_help_state king_war_help_state_MAX = king_war_help_fighted;
const int king_war_help_state_ARRAYSIZE = king_war_help_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* king_war_help_state_descriptor();
inline const ::std::string& king_war_help_state_Name(king_war_help_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    king_war_help_state_descriptor(), value);
}
inline bool king_war_help_state_Parse(
    const ::std::string& name, king_war_help_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<king_war_help_state>(
    king_war_help_state_descriptor(), name, value);
}
enum world_cup_round {
  world_cup_round_16th_final = 1,
  world_cup_round_8th_final = 2,
  world_cup_round_quarter_final = 3,
  world_cup_round_semi_final = 4,
  world_cup_round_final = 5
};
bool world_cup_round_IsValid(int value);
const world_cup_round world_cup_round_MIN = world_cup_round_16th_final;
const world_cup_round world_cup_round_MAX = world_cup_round_final;
const int world_cup_round_ARRAYSIZE = world_cup_round_MAX + 1;

const ::google::protobuf::EnumDescriptor* world_cup_round_descriptor();
inline const ::std::string& world_cup_round_Name(world_cup_round value) {
  return ::google::protobuf::internal::NameOfEnum(
    world_cup_round_descriptor(), value);
}
inline bool world_cup_round_Parse(
    const ::std::string& name, world_cup_round* value) {
  return ::google::protobuf::internal::ParseNamedEnum<world_cup_round>(
    world_cup_round_descriptor(), name, value);
}
enum world_cup_battle_state {
  world_cup_battle_state_none = 0,
  world_cup_battle_state_bet = 1,
  world_cup_battle_state_playing = 2,
  world_cup_battle_state_end = 3
};
bool world_cup_battle_state_IsValid(int value);
const world_cup_battle_state world_cup_battle_state_MIN = world_cup_battle_state_none;
const world_cup_battle_state world_cup_battle_state_MAX = world_cup_battle_state_end;
const int world_cup_battle_state_ARRAYSIZE = world_cup_battle_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* world_cup_battle_state_descriptor();
inline const ::std::string& world_cup_battle_state_Name(world_cup_battle_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    world_cup_battle_state_descriptor(), value);
}
inline bool world_cup_battle_state_Parse(
    const ::std::string& name, world_cup_battle_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<world_cup_battle_state>(
    world_cup_battle_state_descriptor(), name, value);
}
enum world_cup_bet_result {
  world_cup_bet_result_none = 0,
  world_cup_bet_result_win = 1,
  world_cup_bet_result_lose = 2,
  world_cup_bet_result_draw = 3
};
bool world_cup_bet_result_IsValid(int value);
const world_cup_bet_result world_cup_bet_result_MIN = world_cup_bet_result_none;
const world_cup_bet_result world_cup_bet_result_MAX = world_cup_bet_result_draw;
const int world_cup_bet_result_ARRAYSIZE = world_cup_bet_result_MAX + 1;

const ::google::protobuf::EnumDescriptor* world_cup_bet_result_descriptor();
inline const ::std::string& world_cup_bet_result_Name(world_cup_bet_result value) {
  return ::google::protobuf::internal::NameOfEnum(
    world_cup_bet_result_descriptor(), value);
}
inline bool world_cup_bet_result_Parse(
    const ::std::string& name, world_cup_bet_result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<world_cup_bet_result>(
    world_cup_bet_result_descriptor(), name, value);
}
enum Achieve_Event_Type {
  ACHIEVE_EVENT_TYPE_BEGIN = 0,
  ACHIEVE_MAIN_ROLE_LEVEL = 1,
  ACHIEVE_MAIN_ROLE_FIGHT = 2,
  ACHIEVE_EQUIP_TYPE_NUMBER = 3,
  ACHIEVE_EQUIP_TYPE_SAME = 4,
  ACHIEVE_EQUIP_RECAST = 5,
  ACHIEVE_EQUIP_EXATTR_NUMBER_STAR = 6,
  ACHIEVE_HERO_NUMBER = 7,
  ACHIEVE_HERO_NUMBER_LEVEL = 8,
  ACHIEVE_HERO_NUMBER_TYPE = 9,
  ACHIEVE_HERO_NUMBER_STAR = 10,
  ACHIEVE_HERO_NUMBER_TALENT_LEVEL = 11,
  ACHIEVE_HERO_NUMBER_SKILL_LEVEL = 12,
  ACHIEVE_TOTAL_COPPER = 13,
  ACHIEVE_SHOP_BUY_NUMBER = 14,
  ACHIEVE_MOUNT_NUMBER_TYPE = 15,
  ACHIEVE_TASK_FINISH_NUMBER = 16,
  ACHIEVE_TASK_FINISH_COUNTRY_NUMBER = 17,
  ACHIEVE_TASK_FINISH_FAMILY_NUMBER = 18,
  ACHIEVE_TRADE_NUMBER = 19,
  ACHIEVE_TRADE_TOTAL_GAIN_NUMBER = 20,
  ACHIEVE_COUNTRY_BOUNTY_STAR_NUMBER = 21,
  ACHIEVE_TREASURE_ACTIVITY_NUMBER = 22,
  ACHIEVE_TREASURE_ACTIVITY_SPECIAL_EVENT_NUMBER = 23,
  ACHIEVE_CHANNEL_CHAT = 24,
  ACHIEVE_FAMILY = 25,
  ACHIEVE_COUNTRY = 26,
  ACHIEVE_EMPIRE_CITY_CHALLENGE_NUMBER = 27,
  ACHIEVE_PK_VALUE = 28,
  ACHIEVE_TASK_FINISH_TRIAL_NUMBER = 29,
  ACHIEVE_PACKAGE_COPPER_NUMBER = 30,
  ACHIEVE_HAVE_FRIEND_NUMBER = 31,
  ACHIEVE_TRADE_SINGLE_GAIN = 32,
  ACHIEVE_TASK_FINISH_STAR_TRIAL_NUMBER = 33,
  ACHIEVE_TOTAL_LOGIN = 34,
  ACHIEVE_SUCCESSION_LOGIN = 35,
  ACHIEVE_TASK_FINISH_CHASE_GHOST_NUMBER = 36,
  ACHIEVE_CHASE_GHOST_CIRCLE_NUMBER = 37,
  ACHIEVE_FIELD_BOSS_KILL_NUMBER = 38,
  ACHIEVE_ARENA_BATTLE_SINGLE_WIN_NUMBER = 39,
  ACHIEVE_ARENA_BATTLE_TOTAL_WIN_NUMBER = 40,
  ACHIEVE_TOWER_LEVEL = 41,
  ACHIEVE_EXPEDITION_SINGLE_POINT = 42,
  ACHIEVE_EXPEDITION_STORE_BUY_NUMBER = 43,
  ACHIEVE_EXPEDITION_STORE_TOTAL_COST_HONOUR = 44,
  ACHIEVE_EXPEDITION_HELP_OTHERS = 45,
  ACHIEVE_EXPEDITION_CHALLENGE_PASS_NUMBER = 46,
  ACHIEVE_FAMILY_WAR_NUMBER = 47,
  ACHIEVE_FAMILY_WAR_KILL_PLAYER_NUMBER = 48,
  ACHIEVE_FAMILY_WAR_DRAGON_HARM = 49,
  ACHIEVE_FAMILY_WAR_OCCUPIED_SUN_OR_MOON_NUMBER = 50,
  ACHIEVE_KING_WAR_NUMBER = 51,
  ACHIEVE_KING_WAR_KILL_PLAYER_NUMBER = 52,
  ACHIEVE_KING_WAR_DRAGON_HARM = 53,
  ACHIEVE_KING_WAR_QUICK_REVIVE = 54,
  ACHIEVE_KING_WAR_START_WEAPON = 55,
  ACHIEVE_GRADE_PASS_DUNGEON_NUMBER = 56,
  ACHIEVE_DUNGEON_TOTAL_PASS = 57,
  ACHIEVE_RANK_TYPE_LEVEL = 58,
  ACHIEVE_TASK_FINISH_EXP_CIRCLE_NUMBER = 59,
  ACHIEVE_TASK_EXP_CIRCLE_ITEM_QUALITY_NUMBER = 60,
  ACHIEVE_HERO_UP_LEVEL_NUMBER = 61,
  ACHIEVE_STRENGTHEN_EQUIP_NUMBER = 62,
  ACHIEVE_TOWER_NUMBER = 63,
  ACHIEVE_PATROL_KILL_MONSTER_GROUP_NUMBER = 64,
  ACHIEVE_OPEN_GENERAL = 65,
  ACHIEVE_OFFLINE_BATTLE_TOTAL_POINT = 66,
  ACHIEVE_ARENA_BATTLE_TOTAL_NUMBER = 67,
  ACHIEVE_BASE_PASS_DUNGEON_NUMBER = 68,
  ACHIEVE_FIELD_BOSS_ATTACK_NUMBER = 69,
  ACHIEVE_EXPEDITION_WIN_NUMBER = 70,
  ACHIEVE_ELITE_PAGE_QUICK_FIGHT_NUMBER = 71,
  ACHIEVE_TOWER_QUICK_FIGHT_NUMBER = 72,
  ACHIEVE_HONOR = 101,
  ACHIEVE_HERO_TUPO = 102,
  ACHIEVE_FAMILY_LEVEL = 103,
  ACHIEVE_COUNTY_NUM = 104,
  ACHIEVE_EVENT_TYPE_END = 105
};
bool Achieve_Event_Type_IsValid(int value);
const Achieve_Event_Type Achieve_Event_Type_MIN = ACHIEVE_EVENT_TYPE_BEGIN;
const Achieve_Event_Type Achieve_Event_Type_MAX = ACHIEVE_EVENT_TYPE_END;
const int Achieve_Event_Type_ARRAYSIZE = Achieve_Event_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Achieve_Event_Type_descriptor();
inline const ::std::string& Achieve_Event_Type_Name(Achieve_Event_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Achieve_Event_Type_descriptor(), value);
}
inline bool Achieve_Event_Type_Parse(
    const ::std::string& name, Achieve_Event_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Achieve_Event_Type>(
    Achieve_Event_Type_descriptor(), name, value);
}
enum RED_POINT_TYPE {
  RED_POINT_TYPE_BEGIN = 0,
  RED_POINT_FRIEND_APPLY_LIST = 1,
  RED_POINT_PRIVATE_CHAT = 2,
  RED_POINT_MAIL = 3,
  RED_POINT_FAMILY_APPLY_LIST = 4,
  RED_POINT_ACTIVITY_FIRST_ONCE_ENTER = 5,
  RED_POINT_LIVENESS_GET_TREASURE = 6,
  RED_POINT_TEAM_APPLY_LIST = 7,
  RED_POINT_ADD_MOUNT = 8,
  RED_POINT_GOODS = 9,
  RED_POINT_PAGE = 10,
  RED_POINT_PAGE_ELITE = 11,
  RED_POINT_ACHIEVE_LEVEL_REWARD = 12,
  RED_POINT_OFFLINE_ARENA = 13,
  RED_POINT_TYPE_FULI = 14,
  RED_POINT_TYPE_MONTH_CARD = 15,
  RED_POINT_TYPE_GENERAL_EVENT = 16,
  RED_POINT_TYPE_GENERAL_DETAIL = 17,
  RED_POINT_TYPE_RECHARGE_TOTAL = 18,
  RED_POINT_TYPE_RELATION_AWARD = 19,
  RED_POINT_TYPE_PATROL_HIRE = 20,
  RED_POINT_TYPE_TIME_RANK = 21,
  RED_POINT_TYPE_END = 100
};
bool RED_POINT_TYPE_IsValid(int value);
const RED_POINT_TYPE RED_POINT_TYPE_MIN = RED_POINT_TYPE_BEGIN;
const RED_POINT_TYPE RED_POINT_TYPE_MAX = RED_POINT_TYPE_END;
const int RED_POINT_TYPE_ARRAYSIZE = RED_POINT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* RED_POINT_TYPE_descriptor();
inline const ::std::string& RED_POINT_TYPE_Name(RED_POINT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    RED_POINT_TYPE_descriptor(), value);
}
inline bool RED_POINT_TYPE_Parse(
    const ::std::string& name, RED_POINT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RED_POINT_TYPE>(
    RED_POINT_TYPE_descriptor(), name, value);
}
enum luckydraw_type {
  luckydraw_type_none = 0,
  luckydraw_type_junior = 1,
  luckydraw_type_senior = 2,
  luckydraw_type_wish = 3,
  luckydraw_type_general = 4,
  luckydraw_type_gold = 5
};
bool luckydraw_type_IsValid(int value);
const luckydraw_type luckydraw_type_MIN = luckydraw_type_none;
const luckydraw_type luckydraw_type_MAX = luckydraw_type_gold;
const int luckydraw_type_ARRAYSIZE = luckydraw_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* luckydraw_type_descriptor();
inline const ::std::string& luckydraw_type_Name(luckydraw_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    luckydraw_type_descriptor(), value);
}
inline bool luckydraw_type_Parse(
    const ::std::string& name, luckydraw_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<luckydraw_type>(
    luckydraw_type_descriptor(), name, value);
}
enum dungeon_condition_type {
  dungeon_condition_type_none = 0,
  dungeon_condition_type_task = 1,
  dungeon_condition_type_pass = 2
};
bool dungeon_condition_type_IsValid(int value);
const dungeon_condition_type dungeon_condition_type_MIN = dungeon_condition_type_none;
const dungeon_condition_type dungeon_condition_type_MAX = dungeon_condition_type_pass;
const int dungeon_condition_type_ARRAYSIZE = dungeon_condition_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* dungeon_condition_type_descriptor();
inline const ::std::string& dungeon_condition_type_Name(dungeon_condition_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    dungeon_condition_type_descriptor(), value);
}
inline bool dungeon_condition_type_Parse(
    const ::std::string& name, dungeon_condition_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dungeon_condition_type>(
    dungeon_condition_type_descriptor(), name, value);
}
enum team_check_type {
  team_check_type_none = 0,
  team_check_type_confirm = 1,
  team_check_type_give_up = 2
};
bool team_check_type_IsValid(int value);
const team_check_type team_check_type_MIN = team_check_type_none;
const team_check_type team_check_type_MAX = team_check_type_give_up;
const int team_check_type_ARRAYSIZE = team_check_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* team_check_type_descriptor();
inline const ::std::string& team_check_type_Name(team_check_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    team_check_type_descriptor(), value);
}
inline bool team_check_type_Parse(
    const ::std::string& name, team_check_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<team_check_type>(
    team_check_type_descriptor(), name, value);
}
enum dungeon_state_type {
  dungeon_state_none = 0,
  dungeon_state_wait = 1,
  dungeon_state_start = 2,
  dungeon_state_stop = 3
};
bool dungeon_state_type_IsValid(int value);
const dungeon_state_type dungeon_state_type_MIN = dungeon_state_none;
const dungeon_state_type dungeon_state_type_MAX = dungeon_state_stop;
const int dungeon_state_type_ARRAYSIZE = dungeon_state_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* dungeon_state_type_descriptor();
inline const ::std::string& dungeon_state_type_Name(dungeon_state_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    dungeon_state_type_descriptor(), value);
}
inline bool dungeon_state_type_Parse(
    const ::std::string& name, dungeon_state_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dungeon_state_type>(
    dungeon_state_type_descriptor(), name, value);
}
enum dungeon_result_type {
  dungeon_result_none = 0,
  dungeon_result_success = 1,
  dungeon_result_failed_time_long = 2,
  dungeon_result_failed_fight = 3
};
bool dungeon_result_type_IsValid(int value);
const dungeon_result_type dungeon_result_type_MIN = dungeon_result_none;
const dungeon_result_type dungeon_result_type_MAX = dungeon_result_failed_fight;
const int dungeon_result_type_ARRAYSIZE = dungeon_result_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* dungeon_result_type_descriptor();
inline const ::std::string& dungeon_result_type_Name(dungeon_result_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    dungeon_result_type_descriptor(), value);
}
inline bool dungeon_result_type_Parse(
    const ::std::string& name, dungeon_result_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<dungeon_result_type>(
    dungeon_result_type_descriptor(), name, value);
}
enum goods_state {
  goods_state_none = 1,
  goods_state_public = 2,
  goods_state_selling = 3,
  goods_state_selled = 4,
  goods_state_cancel = 5,
  goods_state_return = 6
};
bool goods_state_IsValid(int value);
const goods_state goods_state_MIN = goods_state_none;
const goods_state goods_state_MAX = goods_state_return;
const int goods_state_ARRAYSIZE = goods_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* goods_state_descriptor();
inline const ::std::string& goods_state_Name(goods_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    goods_state_descriptor(), value);
}
inline bool goods_state_Parse(
    const ::std::string& name, goods_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<goods_state>(
    goods_state_descriptor(), name, value);
}
enum random_shop_state {
  random_shop_state_none = 0,
  random_shop_state_normal = 1,
  random_shop_state_sold = 2
};
bool random_shop_state_IsValid(int value);
const random_shop_state random_shop_state_MIN = random_shop_state_none;
const random_shop_state random_shop_state_MAX = random_shop_state_sold;
const int random_shop_state_ARRAYSIZE = random_shop_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* random_shop_state_descriptor();
inline const ::std::string& random_shop_state_Name(random_shop_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    random_shop_state_descriptor(), value);
}
inline bool random_shop_state_Parse(
    const ::std::string& name, random_shop_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<random_shop_state>(
    random_shop_state_descriptor(), name, value);
}
enum sys_notify_type {
  sys_notify_type_none = 0,
  sys_notify_type_finish_achieve = 1,
  sys_notify_type_activity = 2,
  sys_notify_type_add_hero = 3,
  sys_notify_type_role_level = 4,
  sys_notify_type_hero_up_level = 5,
  sys_notify_type_hero_break = 6,
  sys_notify_type_hero_star = 7,
  sys_notify_type_add_exp = 8,
  sys_notify_type_add_gold = 9,
  sys_notify_type_add_sliver = 10,
  sys_notify_type_add_copper = 11,
  sys_notify_type_add_energy = 12,
  sys_notify_type_add_prestige = 13,
  sys_notify_type_add_achieve_point = 14,
  sys_notify_type_add_lifeforce = 15,
  sys_notify_type_add_item = 16,
  sys_notify_type_add_equip = 17,
  sys_notify_type_add_mount = 18,
  sys_notify_type_add_forge = 19,
  sys_notify_type_family = 20,
  sys_notify_type_life_stone = 22,
  sys_notify_type_liveness = 23,
  sys_notify_type_xiuwei = 24,
  sys_notify_type_herosoul = 25,
  sys_notify_type_honor = 26,
  sys_notify_type_contribution = 27,
  sys_notify_type_hero_wakeup = 28,
  sys_notify_type_tower_trigger = 29,
  sys_notify_type_create_family = 30,
  sys_notify_type_leave_family = 31,
  sys_notify_type_join_family = 32,
  sys_notify_type_field_boss = 33,
  sys_notify_type_draw_hero = 34,
  sys_notify_type_merage_item = 35,
  sys_notify_type_vigour = 36,
  sys_notify_type_money = 38,
  sys_notify_type_wstreasury = 39,
  sys_notify_type_charm = 40,
  sys_notify_type_friendliness = 41,
  sys_notify_type_friendliness_limit = 42
};
bool sys_notify_type_IsValid(int value);
const sys_notify_type sys_notify_type_MIN = sys_notify_type_none;
const sys_notify_type sys_notify_type_MAX = sys_notify_type_friendliness_limit;
const int sys_notify_type_ARRAYSIZE = sys_notify_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* sys_notify_type_descriptor();
inline const ::std::string& sys_notify_type_Name(sys_notify_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    sys_notify_type_descriptor(), value);
}
inline bool sys_notify_type_Parse(
    const ::std::string& name, sys_notify_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<sys_notify_type>(
    sys_notify_type_descriptor(), name, value);
}
enum role_data_type {
  simple_info_type = 1
};
bool role_data_type_IsValid(int value);
const role_data_type role_data_type_MIN = simple_info_type;
const role_data_type role_data_type_MAX = simple_info_type;
const int role_data_type_ARRAYSIZE = role_data_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* role_data_type_descriptor();
inline const ::std::string& role_data_type_Name(role_data_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    role_data_type_descriptor(), value);
}
inline bool role_data_type_Parse(
    const ::std::string& name, role_data_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<role_data_type>(
    role_data_type_descriptor(), name, value);
}
enum WISH_SUMMON_TYPE {
  WISH_SUMMON_NONE = 0,
  WISH_SUMMON_SYS = 1,
  WISH_SUMMON_KING = 2
};
bool WISH_SUMMON_TYPE_IsValid(int value);
const WISH_SUMMON_TYPE WISH_SUMMON_TYPE_MIN = WISH_SUMMON_NONE;
const WISH_SUMMON_TYPE WISH_SUMMON_TYPE_MAX = WISH_SUMMON_KING;
const int WISH_SUMMON_TYPE_ARRAYSIZE = WISH_SUMMON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* WISH_SUMMON_TYPE_descriptor();
inline const ::std::string& WISH_SUMMON_TYPE_Name(WISH_SUMMON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    WISH_SUMMON_TYPE_descriptor(), value);
}
inline bool WISH_SUMMON_TYPE_Parse(
    const ::std::string& name, WISH_SUMMON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WISH_SUMMON_TYPE>(
    WISH_SUMMON_TYPE_descriptor(), name, value);
}
enum HEAD_FRAME_ADD_TYPE {
  HEAD_FRAME_HERO = 1,
  HEAD_FRAME_ACHIEVE = 2,
  HEAD_FRAME_AWAKE = 3,
  HEAD_FRAME_UNLOCK_MAIN_HERO = 4
};
bool HEAD_FRAME_ADD_TYPE_IsValid(int value);
const HEAD_FRAME_ADD_TYPE HEAD_FRAME_ADD_TYPE_MIN = HEAD_FRAME_HERO;
const HEAD_FRAME_ADD_TYPE HEAD_FRAME_ADD_TYPE_MAX = HEAD_FRAME_UNLOCK_MAIN_HERO;
const int HEAD_FRAME_ADD_TYPE_ARRAYSIZE = HEAD_FRAME_ADD_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* HEAD_FRAME_ADD_TYPE_descriptor();
inline const ::std::string& HEAD_FRAME_ADD_TYPE_Name(HEAD_FRAME_ADD_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    HEAD_FRAME_ADD_TYPE_descriptor(), value);
}
inline bool HEAD_FRAME_ADD_TYPE_Parse(
    const ::std::string& name, HEAD_FRAME_ADD_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HEAD_FRAME_ADD_TYPE>(
    HEAD_FRAME_ADD_TYPE_descriptor(), name, value);
}
enum PRIZE_STATUS {
  PRIZE_STATUS_NONE = 0,
  PRIZE_STATUS_CAN = 1,
  PRIZE_STATUS_HAS = 2
};
bool PRIZE_STATUS_IsValid(int value);
const PRIZE_STATUS PRIZE_STATUS_MIN = PRIZE_STATUS_NONE;
const PRIZE_STATUS PRIZE_STATUS_MAX = PRIZE_STATUS_HAS;
const int PRIZE_STATUS_ARRAYSIZE = PRIZE_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* PRIZE_STATUS_descriptor();
inline const ::std::string& PRIZE_STATUS_Name(PRIZE_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    PRIZE_STATUS_descriptor(), value);
}
inline bool PRIZE_STATUS_Parse(
    const ::std::string& name, PRIZE_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PRIZE_STATUS>(
    PRIZE_STATUS_descriptor(), name, value);
}
enum EX_REASON_TYPE {
  EX_REASON_NONE = 0,
  EX_REASON_TASK = 1
};
bool EX_REASON_TYPE_IsValid(int value);
const EX_REASON_TYPE EX_REASON_TYPE_MIN = EX_REASON_NONE;
const EX_REASON_TYPE EX_REASON_TYPE_MAX = EX_REASON_TASK;
const int EX_REASON_TYPE_ARRAYSIZE = EX_REASON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EX_REASON_TYPE_descriptor();
inline const ::std::string& EX_REASON_TYPE_Name(EX_REASON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EX_REASON_TYPE_descriptor(), value);
}
inline bool EX_REASON_TYPE_Parse(
    const ::std::string& name, EX_REASON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EX_REASON_TYPE>(
    EX_REASON_TYPE_descriptor(), name, value);
}
enum BUSINESS_ACTIVE_TYPE {
  FIRST_CZ = 1,
  SEVEN_DAY_LOGIN = 2,
  LOAD_OF_NMS = 3,
  ED_BUY_LIMIT = 4,
  LEVEL_FUND = 5,
  WUSHENG_BOX = 6,
  MONTH_CARD = 7,
  EXCHANGE_ITEM = 8,
  RECHARGE_TOTAL = 9,
  GOLD_LUCKYDRAW = 10,
  TIME_RANK = 11
};
bool BUSINESS_ACTIVE_TYPE_IsValid(int value);
const BUSINESS_ACTIVE_TYPE BUSINESS_ACTIVE_TYPE_MIN = FIRST_CZ;
const BUSINESS_ACTIVE_TYPE BUSINESS_ACTIVE_TYPE_MAX = TIME_RANK;
const int BUSINESS_ACTIVE_TYPE_ARRAYSIZE = BUSINESS_ACTIVE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* BUSINESS_ACTIVE_TYPE_descriptor();
inline const ::std::string& BUSINESS_ACTIVE_TYPE_Name(BUSINESS_ACTIVE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    BUSINESS_ACTIVE_TYPE_descriptor(), value);
}
inline bool BUSINESS_ACTIVE_TYPE_Parse(
    const ::std::string& name, BUSINESS_ACTIVE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BUSINESS_ACTIVE_TYPE>(
    BUSINESS_ACTIVE_TYPE_descriptor(), name, value);
}
enum liandan_state {
  liandan_state_locked = 0,
  liandan_state_free = 1,
  liandan_state_doing = 2,
  liandan_state_done = 3
};
bool liandan_state_IsValid(int value);
const liandan_state liandan_state_MIN = liandan_state_locked;
const liandan_state liandan_state_MAX = liandan_state_done;
const int liandan_state_ARRAYSIZE = liandan_state_MAX + 1;

const ::google::protobuf::EnumDescriptor* liandan_state_descriptor();
inline const ::std::string& liandan_state_Name(liandan_state value) {
  return ::google::protobuf::internal::NameOfEnum(
    liandan_state_descriptor(), value);
}
inline bool liandan_state_Parse(
    const ::std::string& name, liandan_state* value) {
  return ::google::protobuf::internal::ParseNamedEnum<liandan_state>(
    liandan_state_descriptor(), name, value);
}
enum STATISTICAL_OPTION {
  STATISTICAL_OPTION_ADD = 1,
  STATISTICAL_OPTION_CMP_REPLACE = 2,
  STATISTICAL_OPTION_REPLACE = 3
};
bool STATISTICAL_OPTION_IsValid(int value);
const STATISTICAL_OPTION STATISTICAL_OPTION_MIN = STATISTICAL_OPTION_ADD;
const STATISTICAL_OPTION STATISTICAL_OPTION_MAX = STATISTICAL_OPTION_REPLACE;
const int STATISTICAL_OPTION_ARRAYSIZE = STATISTICAL_OPTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* STATISTICAL_OPTION_descriptor();
inline const ::std::string& STATISTICAL_OPTION_Name(STATISTICAL_OPTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    STATISTICAL_OPTION_descriptor(), value);
}
inline bool STATISTICAL_OPTION_Parse(
    const ::std::string& name, STATISTICAL_OPTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<STATISTICAL_OPTION>(
    STATISTICAL_OPTION_descriptor(), name, value);
}
enum GENERAL_EVENT_STATUS {
  GENERAL_EVENT_CLOSE = 0,
  GENERAL_EVENT_WAIT = 1,
  GENERAL_EVENT_OPENING = 2,
  GENERAL_EVENT_DONE = 3
};
bool GENERAL_EVENT_STATUS_IsValid(int value);
const GENERAL_EVENT_STATUS GENERAL_EVENT_STATUS_MIN = GENERAL_EVENT_CLOSE;
const GENERAL_EVENT_STATUS GENERAL_EVENT_STATUS_MAX = GENERAL_EVENT_DONE;
const int GENERAL_EVENT_STATUS_ARRAYSIZE = GENERAL_EVENT_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* GENERAL_EVENT_STATUS_descriptor();
inline const ::std::string& GENERAL_EVENT_STATUS_Name(GENERAL_EVENT_STATUS value) {
  return ::google::protobuf::internal::NameOfEnum(
    GENERAL_EVENT_STATUS_descriptor(), value);
}
inline bool GENERAL_EVENT_STATUS_Parse(
    const ::std::string& name, GENERAL_EVENT_STATUS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GENERAL_EVENT_STATUS>(
    GENERAL_EVENT_STATUS_descriptor(), name, value);
}
// ===================================================================

class object_state_info : public ::google::protobuf::Message {
 public:
  object_state_info();
  virtual ~object_state_info();

  object_state_info(const object_state_info& from);

  inline object_state_info& operator=(const object_state_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const object_state_info& default_instance();

  void Swap(object_state_info* other);

  // implements Message ----------------------------------------------

  object_state_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const object_state_info& from);
  void MergeFrom(const object_state_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.object_state_type obj_state = 1 [default = object_state_none];
  inline bool has_obj_state() const;
  inline void clear_obj_state();
  static const int kObjStateFieldNumber = 1;
  inline ::proto::common::object_state_type obj_state() const;
  inline void set_obj_state(::proto::common::object_state_type value);

  // optional .proto.common.role_mode_state mode_state = 2 [default = role_mode_state_normal];
  inline bool has_mode_state() const;
  inline void clear_mode_state();
  static const int kModeStateFieldNumber = 2;
  inline ::proto::common::role_mode_state mode_state() const;
  inline void set_mode_state(::proto::common::role_mode_state value);

  // optional string obj_state_param = 3;
  inline bool has_obj_state_param() const;
  inline void clear_obj_state_param();
  static const int kObjStateParamFieldNumber = 3;
  inline const ::std::string& obj_state_param() const;
  inline void set_obj_state_param(const ::std::string& value);
  inline void set_obj_state_param(const char* value);
  inline void set_obj_state_param(const char* value, size_t size);
  inline ::std::string* mutable_obj_state_param();
  inline ::std::string* release_obj_state_param();
  inline void set_allocated_obj_state_param(::std::string* obj_state_param);

  // optional uint32 alert_time = 4;
  inline bool has_alert_time() const;
  inline void clear_alert_time();
  static const int kAlertTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 alert_time() const;
  inline void set_alert_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.object_state_info)
 private:
  inline void set_has_obj_state();
  inline void clear_has_obj_state();
  inline void set_has_mode_state();
  inline void clear_has_mode_state();
  inline void set_has_obj_state_param();
  inline void clear_has_obj_state_param();
  inline void set_has_alert_time();
  inline void clear_has_alert_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int obj_state_;
  int mode_state_;
  ::std::string* obj_state_param_;
  ::google::protobuf::uint32 alert_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static object_state_info* default_instance_;
};
// -------------------------------------------------------------------

class mobile_info : public ::google::protobuf::Message {
 public:
  mobile_info();
  virtual ~mobile_info();

  mobile_info(const mobile_info& from);

  inline mobile_info& operator=(const mobile_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mobile_info& default_instance();

  void Swap(mobile_info* other);

  // implements Message ----------------------------------------------

  mobile_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mobile_info& from);
  void MergeFrom(const mobile_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string device_model = 2;
  inline bool has_device_model() const;
  inline void clear_device_model();
  static const int kDeviceModelFieldNumber = 2;
  inline const ::std::string& device_model() const;
  inline void set_device_model(const ::std::string& value);
  inline void set_device_model(const char* value);
  inline void set_device_model(const char* value, size_t size);
  inline ::std::string* mutable_device_model();
  inline ::std::string* release_device_model();
  inline void set_allocated_device_model(::std::string* device_model);

  // optional string device_sys_version = 3;
  inline bool has_device_sys_version() const;
  inline void clear_device_sys_version();
  static const int kDeviceSysVersionFieldNumber = 3;
  inline const ::std::string& device_sys_version() const;
  inline void set_device_sys_version(const ::std::string& value);
  inline void set_device_sys_version(const char* value);
  inline void set_device_sys_version(const char* value, size_t size);
  inline ::std::string* mutable_device_sys_version();
  inline ::std::string* release_device_sys_version();
  inline void set_allocated_device_sys_version(::std::string* device_sys_version);

  // optional string cpu_type = 4;
  inline bool has_cpu_type() const;
  inline void clear_cpu_type();
  static const int kCpuTypeFieldNumber = 4;
  inline const ::std::string& cpu_type() const;
  inline void set_cpu_type(const ::std::string& value);
  inline void set_cpu_type(const char* value);
  inline void set_cpu_type(const char* value, size_t size);
  inline ::std::string* mutable_cpu_type();
  inline ::std::string* release_cpu_type();
  inline void set_allocated_cpu_type(::std::string* cpu_type);

  // optional int32 cpu_count = 5;
  inline bool has_cpu_count() const;
  inline void clear_cpu_count();
  static const int kCpuCountFieldNumber = 5;
  inline ::google::protobuf::int32 cpu_count() const;
  inline void set_cpu_count(::google::protobuf::int32 value);

  // optional int32 memory_size = 6;
  inline bool has_memory_size() const;
  inline void clear_memory_size();
  static const int kMemorySizeFieldNumber = 6;
  inline ::google::protobuf::int32 memory_size() const;
  inline void set_memory_size(::google::protobuf::int32 value);

  // optional string grph_device_name = 7;
  inline bool has_grph_device_name() const;
  inline void clear_grph_device_name();
  static const int kGrphDeviceNameFieldNumber = 7;
  inline const ::std::string& grph_device_name() const;
  inline void set_grph_device_name(const ::std::string& value);
  inline void set_grph_device_name(const char* value);
  inline void set_grph_device_name(const char* value, size_t size);
  inline ::std::string* mutable_grph_device_name();
  inline ::std::string* release_grph_device_name();
  inline void set_allocated_grph_device_name(::std::string* grph_device_name);

  // @@protoc_insertion_point(class_scope:proto.common.mobile_info)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_device_sys_version();
  inline void clear_has_device_sys_version();
  inline void set_has_cpu_type();
  inline void clear_has_cpu_type();
  inline void set_has_cpu_count();
  inline void clear_has_cpu_count();
  inline void set_has_memory_size();
  inline void clear_has_memory_size();
  inline void set_has_grph_device_name();
  inline void clear_has_grph_device_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;
  ::std::string* device_model_;
  ::std::string* device_sys_version_;
  ::std::string* cpu_type_;
  ::google::protobuf::int32 cpu_count_;
  ::google::protobuf::int32 memory_size_;
  ::std::string* grph_device_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mobile_info* default_instance_;
};
// -------------------------------------------------------------------

class chat_param : public ::google::protobuf::Message {
 public:
  chat_param();
  virtual ~chat_param();

  chat_param(const chat_param& from);

  inline chat_param& operator=(const chat_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_param& default_instance();

  void Swap(chat_param* other);

  // implements Message ----------------------------------------------

  chat_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_param& from);
  void MergeFrom(const chat_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.chat_type type = 1 [default = chat_item];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::common::chat_type type() const;
  inline void set_type(::proto::common::chat_type value);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:proto.common.chat_param)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static chat_param* default_instance_;
};
// -------------------------------------------------------------------

class server_info : public ::google::protobuf::Message {
 public:
  server_info();
  virtual ~server_info();

  server_info(const server_info& from);

  inline server_info& operator=(const server_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_info& default_instance();

  void Swap(server_info* other);

  // implements Message ----------------------------------------------

  server_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_info& from);
  void MergeFrom(const server_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional string server_name = 2;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 2;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional string login_ip = 3;
  inline bool has_login_ip() const;
  inline void clear_login_ip();
  static const int kLoginIpFieldNumber = 3;
  inline const ::std::string& login_ip() const;
  inline void set_login_ip(const ::std::string& value);
  inline void set_login_ip(const char* value);
  inline void set_login_ip(const char* value, size_t size);
  inline ::std::string* mutable_login_ip();
  inline ::std::string* release_login_ip();
  inline void set_allocated_login_ip(::std::string* login_ip);

  // optional uint32 login_port = 4;
  inline bool has_login_port() const;
  inline void clear_login_port();
  static const int kLoginPortFieldNumber = 4;
  inline ::google::protobuf::uint32 login_port() const;
  inline void set_login_port(::google::protobuf::uint32 value);

  // optional .proto.common.SERVER_STATE server_state = 5 [default = SERVER_STATE_CLOSE];
  inline bool has_server_state() const;
  inline void clear_server_state();
  static const int kServerStateFieldNumber = 5;
  inline ::proto::common::SERVER_STATE server_state() const;
  inline void set_server_state(::proto::common::SERVER_STATE value);

  // optional uint32 label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline ::google::protobuf::uint32 label() const;
  inline void set_label(::google::protobuf::uint32 value);

  // repeated .proto.common.account_role_data role_list = 7;
  inline int role_list_size() const;
  inline void clear_role_list();
  static const int kRoleListFieldNumber = 7;
  inline const ::proto::common::account_role_data& role_list(int index) const;
  inline ::proto::common::account_role_data* mutable_role_list(int index);
  inline ::proto::common::account_role_data* add_role_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::account_role_data >&
      role_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::account_role_data >*
      mutable_role_list();

  // optional string new_role_id = 8;
  inline bool has_new_role_id() const;
  inline void clear_new_role_id();
  static const int kNewRoleIdFieldNumber = 8;
  inline const ::std::string& new_role_id() const;
  inline void set_new_role_id(const ::std::string& value);
  inline void set_new_role_id(const char* value);
  inline void set_new_role_id(const char* value, size_t size);
  inline ::std::string* mutable_new_role_id();
  inline ::std::string* release_new_role_id();
  inline void set_allocated_new_role_id(::std::string* new_role_id);

  // optional uint32 can_create_new_role = 9;
  inline bool has_can_create_new_role() const;
  inline void clear_can_create_new_role();
  static const int kCanCreateNewRoleFieldNumber = 9;
  inline ::google::protobuf::uint32 can_create_new_role() const;
  inline void set_can_create_new_role(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.server_info)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_login_ip();
  inline void clear_has_login_ip();
  inline void set_has_login_port();
  inline void clear_has_login_port();
  inline void set_has_server_state();
  inline void clear_has_server_state();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_new_role_id();
  inline void clear_has_new_role_id();
  inline void set_has_can_create_new_role();
  inline void clear_has_can_create_new_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_name_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 login_port_;
  ::std::string* login_ip_;
  int server_state_;
  ::google::protobuf::uint32 label_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::account_role_data > role_list_;
  ::std::string* new_role_id_;
  ::google::protobuf::uint32 can_create_new_role_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static server_info* default_instance_;
};
// -------------------------------------------------------------------

class account_role_data : public ::google::protobuf::Message {
 public:
  account_role_data();
  virtual ~account_role_data();

  account_role_data(const account_role_data& from);

  inline account_role_data& operator=(const account_role_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const account_role_data& default_instance();

  void Swap(account_role_data* other);

  // implements Message ----------------------------------------------

  account_role_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const account_role_data& from);
  void MergeFrom(const account_role_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 species = 2;
  inline bool has_species() const;
  inline void clear_species();
  static const int kSpeciesFieldNumber = 2;
  inline ::google::protobuf::uint32 species() const;
  inline void set_species(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 create_time = 4;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 plugin = 6;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 6;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 7;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 7;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.account_role_data)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_species();
  inline void clear_has_species();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::uint32 species_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 channel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static account_role_data* default_instance_;
};
// -------------------------------------------------------------------

class channel_general : public ::google::protobuf::Message {
 public:
  channel_general();
  virtual ~channel_general();

  channel_general(const channel_general& from);

  inline channel_general& operator=(const channel_general& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const channel_general& default_instance();

  void Swap(channel_general* other);

  // implements Message ----------------------------------------------

  channel_general* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const channel_general& from);
  void MergeFrom(const channel_general& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  inline void set_allocated_session_id(::std::string* session_id);

  // optional string guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // @@protoc_insertion_point(class_scope:proto.common.channel_general)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* session_id_;
  ::std::string* guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static channel_general* default_instance_;
};
// -------------------------------------------------------------------

class task_type_count : public ::google::protobuf::Message {
 public:
  task_type_count();
  virtual ~task_type_count();

  task_type_count(const task_type_count& from);

  inline task_type_count& operator=(const task_type_count& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_type_count& default_instance();

  void Swap(task_type_count* other);

  // implements Message ----------------------------------------------

  task_type_count* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_type_count& from);
  void MergeFrom(const task_type_count& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.task_type_count)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_type_count* default_instance_;
};
// -------------------------------------------------------------------

class task_type_data : public ::google::protobuf::Message {
 public:
  task_type_data();
  virtual ~task_type_data();

  task_type_data(const task_type_data& from);

  inline task_type_data& operator=(const task_type_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_type_data& default_instance();

  void Swap(task_type_data* other);

  // implements Message ----------------------------------------------

  task_type_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_type_data& from);
  void MergeFrom(const task_type_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.task_type_count type_count = 1;
  inline int type_count_size() const;
  inline void clear_type_count();
  static const int kTypeCountFieldNumber = 1;
  inline const ::proto::common::task_type_count& type_count(int index) const;
  inline ::proto::common::task_type_count* mutable_type_count(int index);
  inline ::proto::common::task_type_count* add_type_count();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_type_count >&
      type_count() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_type_count >*
      mutable_type_count();

  // @@protoc_insertion_point(class_scope:proto.common.task_type_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::task_type_count > type_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_type_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_study_data : public ::google::protobuf::Message {
 public:
  fight_study_data();
  virtual ~fight_study_data();

  fight_study_data(const fight_study_data& from);

  inline fight_study_data& operator=(const fight_study_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_study_data& default_instance();

  void Swap(fight_study_data* other);

  // implements Message ----------------------------------------------

  fight_study_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_study_data& from);
  void MergeFrom(const fight_study_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 step = 1;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 1;
  inline ::google::protobuf::uint32 step() const;
  inline void set_step(::google::protobuf::uint32 value);

  // optional uint32 step_time = 2;
  inline bool has_step_time() const;
  inline void clear_step_time();
  static const int kStepTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 step_time() const;
  inline void set_step_time(::google::protobuf::uint32 value);

  // optional uint64 target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline ::google::protobuf::uint64 target() const;
  inline void set_target(::google::protobuf::uint64 value);

  // optional uint64 attacker = 4;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 4;
  inline ::google::protobuf::uint64 attacker() const;
  inline void set_attacker(::google::protobuf::uint64 value);

  // optional uint32 study_time = 5;
  inline bool has_study_time() const;
  inline void clear_study_time();
  static const int kStudyTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 study_time() const;
  inline void set_study_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_study_data)
 private:
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_step_time();
  inline void clear_has_step_time();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_study_time();
  inline void clear_has_study_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 step_;
  ::google::protobuf::uint32 step_time_;
  ::google::protobuf::uint64 target_;
  ::google::protobuf::uint64 attacker_;
  ::google::protobuf::uint32 study_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_study_data* default_instance_;
};
// -------------------------------------------------------------------

class role_fight_data : public ::google::protobuf::Message {
 public:
  role_fight_data();
  virtual ~role_fight_data();

  role_fight_data(const role_fight_data& from);

  inline role_fight_data& operator=(const role_fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_fight_data& default_instance();

  void Swap(role_fight_data* other);

  // implements Message ----------------------------------------------

  role_fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_fight_data& from);
  void MergeFrom(const role_fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 fight_uid = 1;
  inline bool has_fight_uid() const;
  inline void clear_fight_uid();
  static const int kFightUidFieldNumber = 1;
  inline ::google::protobuf::uint64 fight_uid() const;
  inline void set_fight_uid(::google::protobuf::uint64 value);

  // optional .proto.common.fight_study_data study = 2;
  inline bool has_study() const;
  inline void clear_study();
  static const int kStudyFieldNumber = 2;
  inline const ::proto::common::fight_study_data& study() const;
  inline ::proto::common::fight_study_data* mutable_study();
  inline ::proto::common::fight_study_data* release_study();
  inline void set_allocated_study(::proto::common::fight_study_data* study);

  // optional uint32 auto_fight_flag = 3;
  inline bool has_auto_fight_flag() const;
  inline void clear_auto_fight_flag();
  static const int kAutoFightFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 auto_fight_flag() const;
  inline void set_auto_fight_flag(::google::protobuf::uint32 value);

  // optional uint64 watching_fight_uid = 4;
  inline bool has_watching_fight_uid() const;
  inline void clear_watching_fight_uid();
  static const int kWatchingFightUidFieldNumber = 4;
  inline ::google::protobuf::uint64 watching_fight_uid() const;
  inline void set_watching_fight_uid(::google::protobuf::uint64 value);

  // optional uint32 ignore_lineup_flag = 5;
  inline bool has_ignore_lineup_flag() const;
  inline void clear_ignore_lineup_flag();
  static const int kIgnoreLineupFlagFieldNumber = 5;
  inline ::google::protobuf::uint32 ignore_lineup_flag() const;
  inline void set_ignore_lineup_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_fight_data)
 private:
  inline void set_has_fight_uid();
  inline void clear_has_fight_uid();
  inline void set_has_study();
  inline void clear_has_study();
  inline void set_has_auto_fight_flag();
  inline void clear_has_auto_fight_flag();
  inline void set_has_watching_fight_uid();
  inline void clear_has_watching_fight_uid();
  inline void set_has_ignore_lineup_flag();
  inline void clear_has_ignore_lineup_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 fight_uid_;
  ::proto::common::fight_study_data* study_;
  ::google::protobuf::uint64 watching_fight_uid_;
  ::google::protobuf::uint32 auto_fight_flag_;
  ::google::protobuf::uint32 ignore_lineup_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_fight_data* default_instance_;
};
// -------------------------------------------------------------------

class role_server_data : public ::google::protobuf::Message {
 public:
  role_server_data();
  virtual ~role_server_data();

  role_server_data(const role_server_data& from);

  inline role_server_data& operator=(const role_server_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_server_data& default_instance();

  void Swap(role_server_data* other);

  // implements Message ----------------------------------------------

  role_server_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_server_data& from);
  void MergeFrom(const role_server_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 gate = 2;
  inline bool has_gate() const;
  inline void clear_gate();
  static const int kGateFieldNumber = 2;
  inline ::google::protobuf::uint32 gate() const;
  inline void set_gate(::google::protobuf::uint32 value);

  // optional string server_name = 3;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 3;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // @@protoc_insertion_point(class_scope:proto.common.role_server_data)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_gate();
  inline void clear_has_gate();
  inline void set_has_server_name();
  inline void clear_has_server_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 gate_;
  ::std::string* server_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_server_data* default_instance_;
};
// -------------------------------------------------------------------

class last_static_map : public ::google::protobuf::Message {
 public:
  last_static_map();
  virtual ~last_static_map();

  last_static_map(const last_static_map& from);

  inline last_static_map& operator=(const last_static_map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const last_static_map& default_instance();

  void Swap(last_static_map* other);

  // implements Message ----------------------------------------------

  last_static_map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const last_static_map& from);
  void MergeFrom(const last_static_map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 last_map_tid = 1;
  inline bool has_last_map_tid() const;
  inline void clear_last_map_tid();
  static const int kLastMapTidFieldNumber = 1;
  inline ::google::protobuf::uint32 last_map_tid() const;
  inline void set_last_map_tid(::google::protobuf::uint32 value);

  // optional float last_pos_x = 2;
  inline bool has_last_pos_x() const;
  inline void clear_last_pos_x();
  static const int kLastPosXFieldNumber = 2;
  inline float last_pos_x() const;
  inline void set_last_pos_x(float value);

  // optional float last_pos_y = 3;
  inline bool has_last_pos_y() const;
  inline void clear_last_pos_y();
  static const int kLastPosYFieldNumber = 3;
  inline float last_pos_y() const;
  inline void set_last_pos_y(float value);

  // optional float last_dir = 4;
  inline bool has_last_dir() const;
  inline void clear_last_dir();
  static const int kLastDirFieldNumber = 4;
  inline float last_dir() const;
  inline void set_last_dir(float value);

  // @@protoc_insertion_point(class_scope:proto.common.last_static_map)
 private:
  inline void set_has_last_map_tid();
  inline void clear_has_last_map_tid();
  inline void set_has_last_pos_x();
  inline void clear_has_last_pos_x();
  inline void set_has_last_pos_y();
  inline void clear_has_last_pos_y();
  inline void set_has_last_dir();
  inline void clear_has_last_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 last_map_tid_;
  float last_pos_x_;
  float last_pos_y_;
  float last_dir_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static last_static_map* default_instance_;
};
// -------------------------------------------------------------------

class role_data : public ::google::protobuf::Message {
 public:
  role_data();
  virtual ~role_data();

  role_data(const role_data& from);

  inline role_data& operator=(const role_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_data& default_instance();

  void Swap(role_data* other);

  // implements Message ----------------------------------------------

  role_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_data& from);
  void MergeFrom(const role_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string did = 2;
  inline bool has_did() const;
  inline void clear_did();
  static const int kDidFieldNumber = 2;
  inline const ::std::string& did() const;
  inline void set_did(const ::std::string& value);
  inline void set_did(const char* value);
  inline void set_did(const char* value, size_t size);
  inline ::std::string* mutable_did();
  inline ::std::string* release_did();
  inline void set_allocated_did(::std::string* did);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 gm = 4;
  inline bool has_gm() const;
  inline void clear_gm();
  static const int kGmFieldNumber = 4;
  inline ::google::protobuf::int32 gm() const;
  inline void set_gm(::google::protobuf::int32 value);

  // optional uint32 create_time = 5;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // optional uint32 last_login_time = 6;
  inline bool has_last_login_time() const;
  inline void clear_last_login_time();
  static const int kLastLoginTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_login_time() const;
  inline void set_last_login_time(::google::protobuf::uint32 value);

  // optional uint32 last_logout_time = 7;
  inline bool has_last_logout_time() const;
  inline void clear_last_logout_time();
  static const int kLastLogoutTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 last_logout_time() const;
  inline void set_last_logout_time(::google::protobuf::uint32 value);

  // optional uint32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 map_tid = 9;
  inline bool has_map_tid() const;
  inline void clear_map_tid();
  static const int kMapTidFieldNumber = 9;
  inline ::google::protobuf::uint32 map_tid() const;
  inline void set_map_tid(::google::protobuf::uint32 value);

  // optional .proto.common.object_common_info obj_info = 10;
  inline bool has_obj_info() const;
  inline void clear_obj_info();
  static const int kObjInfoFieldNumber = 10;
  inline const ::proto::common::object_common_info& obj_info() const;
  inline ::proto::common::object_common_info* mutable_obj_info();
  inline ::proto::common::object_common_info* release_obj_info();
  inline void set_allocated_obj_info(::proto::common::object_common_info* obj_info);

  // optional .proto.common.personal_info per_info = 11;
  inline bool has_per_info() const;
  inline void clear_per_info();
  static const int kPerInfoFieldNumber = 11;
  inline const ::proto::common::personal_info& per_info() const;
  inline ::proto::common::personal_info* mutable_per_info();
  inline ::proto::common::personal_info* release_per_info();
  inline void set_allocated_per_info(::proto::common::personal_info* per_info);

  // optional .proto.common.interior_info interior = 12;
  inline bool has_interior() const;
  inline void clear_interior();
  static const int kInteriorFieldNumber = 12;
  inline const ::proto::common::interior_info& interior() const;
  inline ::proto::common::interior_info* mutable_interior();
  inline ::proto::common::interior_info* release_interior();
  inline void set_allocated_interior(::proto::common::interior_info* interior);

  // optional uint32 fighting = 13;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 13;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 14;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 14;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 role_type = 15;
  inline bool has_role_type() const;
  inline void clear_role_type();
  static const int kRoleTypeFieldNumber = 15;
  inline ::google::protobuf::uint32 role_type() const;
  inline void set_role_type(::google::protobuf::uint32 value);

  // optional .proto.common.role_trade_info trade_info = 16;
  inline bool has_trade_info() const;
  inline void clear_trade_info();
  static const int kTradeInfoFieldNumber = 16;
  inline const ::proto::common::role_trade_info& trade_info() const;
  inline ::proto::common::role_trade_info* mutable_trade_info();
  inline ::proto::common::role_trade_info* release_trade_info();
  inline void set_allocated_trade_info(::proto::common::role_trade_info* trade_info);

  // optional .proto.common.task_type_data ttd = 17;
  inline bool has_ttd() const;
  inline void clear_ttd();
  static const int kTtdFieldNumber = 17;
  inline const ::proto::common::task_type_data& ttd() const;
  inline ::proto::common::task_type_data* mutable_ttd();
  inline ::proto::common::task_type_data* release_ttd();
  inline void set_allocated_ttd(::proto::common::task_type_data* ttd);

  // optional .proto.common.formation_data formation = 18;
  inline bool has_formation() const;
  inline void clear_formation();
  static const int kFormationFieldNumber = 18;
  inline const ::proto::common::formation_data& formation() const;
  inline ::proto::common::formation_data* mutable_formation();
  inline ::proto::common::formation_data* release_formation();
  inline void set_allocated_formation(::proto::common::formation_data* formation);

  // optional .proto.common.role_fight_data fight = 19;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 19;
  inline const ::proto::common::role_fight_data& fight() const;
  inline ::proto::common::role_fight_data* mutable_fight();
  inline ::proto::common::role_fight_data* release_fight();
  inline void set_allocated_fight(::proto::common::role_fight_data* fight);

  // optional uint32 exp = 20;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 20;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional .proto.common.role_server_data server = 21;
  inline bool has_server() const;
  inline void clear_server();
  static const int kServerFieldNumber = 21;
  inline const ::proto::common::role_server_data& server() const;
  inline ::proto::common::role_server_data* mutable_server();
  inline ::proto::common::role_server_data* release_server();
  inline void set_allocated_server(::proto::common::role_server_data* server);

  // optional uint32 continue_login_days = 22;
  inline bool has_continue_login_days() const;
  inline void clear_continue_login_days();
  static const int kContinueLoginDaysFieldNumber = 22;
  inline ::google::protobuf::uint32 continue_login_days() const;
  inline void set_continue_login_days(::google::protobuf::uint32 value);

  // optional uint32 cumulative_login_days = 23;
  inline bool has_cumulative_login_days() const;
  inline void clear_cumulative_login_days();
  static const int kCumulativeLoginDaysFieldNumber = 23;
  inline ::google::protobuf::uint32 cumulative_login_days() const;
  inline void set_cumulative_login_days(::google::protobuf::uint32 value);

  // optional bool is_new_role = 24;
  inline bool has_is_new_role() const;
  inline void clear_is_new_role();
  static const int kIsNewRoleFieldNumber = 24;
  inline bool is_new_role() const;
  inline void set_is_new_role(bool value);

  // optional .proto.common.new_role_guide_data guide_data = 25;
  inline bool has_guide_data() const;
  inline void clear_guide_data();
  static const int kGuideDataFieldNumber = 25;
  inline const ::proto::common::new_role_guide_data& guide_data() const;
  inline ::proto::common::new_role_guide_data* mutable_guide_data();
  inline ::proto::common::new_role_guide_data* release_guide_data();
  inline void set_allocated_guide_data(::proto::common::new_role_guide_data* guide_data);

  // optional string function_code = 26;
  inline bool has_function_code() const;
  inline void clear_function_code();
  static const int kFunctionCodeFieldNumber = 26;
  inline const ::std::string& function_code() const;
  inline void set_function_code(const ::std::string& value);
  inline void set_function_code(const char* value);
  inline void set_function_code(const char* value, size_t size);
  inline ::std::string* mutable_function_code();
  inline ::std::string* release_function_code();
  inline void set_allocated_function_code(::std::string* function_code);

  // optional .proto.common.tactic_data tactic = 27;
  inline bool has_tactic() const;
  inline void clear_tactic();
  static const int kTacticFieldNumber = 27;
  inline const ::proto::common::tactic_data& tactic() const;
  inline ::proto::common::tactic_data* mutable_tactic();
  inline ::proto::common::tactic_data* release_tactic();
  inline void set_allocated_tactic(::proto::common::tactic_data* tactic);

  // optional .proto.common.role_buff_data role_buff = 28;
  inline bool has_role_buff() const;
  inline void clear_role_buff();
  static const int kRoleBuffFieldNumber = 28;
  inline const ::proto::common::role_buff_data& role_buff() const;
  inline ::proto::common::role_buff_data* mutable_role_buff();
  inline ::proto::common::role_buff_data* release_role_buff();
  inline void set_allocated_role_buff(::proto::common::role_buff_data* role_buff);

  // optional .proto.common.last_static_map last_map = 29;
  inline bool has_last_map() const;
  inline void clear_last_map();
  static const int kLastMapFieldNumber = 29;
  inline const ::proto::common::last_static_map& last_map() const;
  inline ::proto::common::last_static_map* mutable_last_map();
  inline ::proto::common::last_static_map* release_last_map();
  inline void set_allocated_last_map(::proto::common::last_static_map* last_map);

  // optional uint32 npc_code = 30;
  inline bool has_npc_code() const;
  inline void clear_npc_code();
  static const int kNpcCodeFieldNumber = 30;
  inline ::google::protobuf::uint32 npc_code() const;
  inline void set_npc_code(::google::protobuf::uint32 value);

  // optional uint32 collect_code = 31;
  inline bool has_collect_code() const;
  inline void clear_collect_code();
  static const int kCollectCodeFieldNumber = 31;
  inline ::google::protobuf::uint32 collect_code() const;
  inline void set_collect_code(::google::protobuf::uint32 value);

  // optional .proto.common.page_data page_list = 32;
  inline bool has_page_list() const;
  inline void clear_page_list();
  static const int kPageListFieldNumber = 32;
  inline const ::proto::common::page_data& page_list() const;
  inline ::proto::common::page_data* mutable_page_list();
  inline ::proto::common::page_data* release_page_list();
  inline void set_allocated_page_list(::proto::common::page_data* page_list);

  // optional .proto.common.active_reward_task_data task_list = 33;
  inline bool has_task_list() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 33;
  inline const ::proto::common::active_reward_task_data& task_list() const;
  inline ::proto::common::active_reward_task_data* mutable_task_list();
  inline ::proto::common::active_reward_task_data* release_task_list();
  inline void set_allocated_task_list(::proto::common::active_reward_task_data* task_list);

  // optional uint32 current_tower = 35;
  inline bool has_current_tower() const;
  inline void clear_current_tower();
  static const int kCurrentTowerFieldNumber = 35;
  inline ::google::protobuf::uint32 current_tower() const;
  inline void set_current_tower(::google::protobuf::uint32 value);

  // optional uint32 update_day_time = 36;
  inline bool has_update_day_time() const;
  inline void clear_update_day_time();
  static const int kUpdateDayTimeFieldNumber = 36;
  inline ::google::protobuf::uint32 update_day_time() const;
  inline void set_update_day_time(::google::protobuf::uint32 value);

  // optional uint32 update_week_time = 37;
  inline bool has_update_week_time() const;
  inline void clear_update_week_time();
  static const int kUpdateWeekTimeFieldNumber = 37;
  inline ::google::protobuf::uint32 update_week_time() const;
  inline void set_update_week_time(::google::protobuf::uint32 value);

  // optional .proto.common.multi_time_data multi_time = 38;
  inline bool has_multi_time() const;
  inline void clear_multi_time();
  static const int kMultiTimeFieldNumber = 38;
  inline const ::proto::common::multi_time_data& multi_time() const;
  inline ::proto::common::multi_time_data* mutable_multi_time();
  inline ::proto::common::multi_time_data* release_multi_time();
  inline void set_allocated_multi_time(::proto::common::multi_time_data* multi_time);

  // optional uint32 mode_state = 39;
  inline bool has_mode_state() const;
  inline void clear_mode_state();
  static const int kModeStateFieldNumber = 39;
  inline ::google::protobuf::uint32 mode_state() const;
  inline void set_mode_state(::google::protobuf::uint32 value);

  // optional .proto.common.life_info life_data = 40;
  inline bool has_life_data() const;
  inline void clear_life_data();
  static const int kLifeDataFieldNumber = 40;
  inline const ::proto::common::life_info& life_data() const;
  inline ::proto::common::life_info* mutable_life_data();
  inline ::proto::common::life_info* release_life_data();
  inline void set_allocated_life_data(::proto::common::life_info* life_data);

  // optional .proto.common.head_data head_frame_info = 41;
  inline bool has_head_frame_info() const;
  inline void clear_head_frame_info();
  static const int kHeadFrameInfoFieldNumber = 41;
  inline const ::proto::common::head_data& head_frame_info() const;
  inline ::proto::common::head_data* mutable_head_frame_info();
  inline ::proto::common::head_data* release_head_frame_info();
  inline void set_allocated_head_frame_info(::proto::common::head_data* head_frame_info);

  // optional uint32 charm = 43;
  inline bool has_charm() const;
  inline void clear_charm();
  static const int kCharmFieldNumber = 43;
  inline ::google::protobuf::uint32 charm() const;
  inline void set_charm(::google::protobuf::uint32 value);

  // repeated uint32 compeleted_guide_id = 44;
  inline int compeleted_guide_id_size() const;
  inline void clear_compeleted_guide_id();
  static const int kCompeletedGuideIdFieldNumber = 44;
  inline ::google::protobuf::uint32 compeleted_guide_id(int index) const;
  inline void set_compeleted_guide_id(int index, ::google::protobuf::uint32 value);
  inline void add_compeleted_guide_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      compeleted_guide_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_compeleted_guide_id();

  // @@protoc_insertion_point(class_scope:proto.common.role_data)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_did();
  inline void clear_has_did();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_gm();
  inline void clear_has_gm();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_last_login_time();
  inline void clear_has_last_login_time();
  inline void set_has_last_logout_time();
  inline void clear_has_last_logout_time();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_map_tid();
  inline void clear_has_map_tid();
  inline void set_has_obj_info();
  inline void clear_has_obj_info();
  inline void set_has_per_info();
  inline void clear_has_per_info();
  inline void set_has_interior();
  inline void clear_has_interior();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();
  inline void set_has_role_type();
  inline void clear_has_role_type();
  inline void set_has_trade_info();
  inline void clear_has_trade_info();
  inline void set_has_ttd();
  inline void clear_has_ttd();
  inline void set_has_formation();
  inline void clear_has_formation();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_server();
  inline void clear_has_server();
  inline void set_has_continue_login_days();
  inline void clear_has_continue_login_days();
  inline void set_has_cumulative_login_days();
  inline void clear_has_cumulative_login_days();
  inline void set_has_is_new_role();
  inline void clear_has_is_new_role();
  inline void set_has_guide_data();
  inline void clear_has_guide_data();
  inline void set_has_function_code();
  inline void clear_has_function_code();
  inline void set_has_tactic();
  inline void clear_has_tactic();
  inline void set_has_role_buff();
  inline void clear_has_role_buff();
  inline void set_has_last_map();
  inline void clear_has_last_map();
  inline void set_has_npc_code();
  inline void clear_has_npc_code();
  inline void set_has_collect_code();
  inline void clear_has_collect_code();
  inline void set_has_page_list();
  inline void clear_has_page_list();
  inline void set_has_task_list();
  inline void clear_has_task_list();
  inline void set_has_current_tower();
  inline void clear_has_current_tower();
  inline void set_has_update_day_time();
  inline void clear_has_update_day_time();
  inline void set_has_update_week_time();
  inline void clear_has_update_week_time();
  inline void set_has_multi_time();
  inline void clear_has_multi_time();
  inline void set_has_mode_state();
  inline void clear_has_mode_state();
  inline void set_has_life_data();
  inline void clear_has_life_data();
  inline void set_has_head_frame_info();
  inline void clear_has_head_frame_info();
  inline void set_has_charm();
  inline void clear_has_charm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* did_;
  ::std::string* name_;
  ::google::protobuf::int32 gm_;
  ::google::protobuf::uint32 create_time_;
  ::google::protobuf::uint32 last_login_time_;
  ::google::protobuf::uint32 last_logout_time_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 map_tid_;
  ::proto::common::object_common_info* obj_info_;
  ::proto::common::personal_info* per_info_;
  ::proto::common::interior_info* interior_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 channel_id_;
  ::proto::common::role_trade_info* trade_info_;
  ::proto::common::task_type_data* ttd_;
  ::google::protobuf::uint32 role_type_;
  ::google::protobuf::uint32 exp_;
  ::proto::common::formation_data* formation_;
  ::proto::common::role_fight_data* fight_;
  ::proto::common::role_server_data* server_;
  ::google::protobuf::uint32 continue_login_days_;
  ::google::protobuf::uint32 cumulative_login_days_;
  ::proto::common::new_role_guide_data* guide_data_;
  ::std::string* function_code_;
  ::proto::common::tactic_data* tactic_;
  bool is_new_role_;
  ::google::protobuf::uint32 npc_code_;
  ::proto::common::role_buff_data* role_buff_;
  ::proto::common::last_static_map* last_map_;
  ::proto::common::page_data* page_list_;
  ::google::protobuf::uint32 collect_code_;
  ::google::protobuf::uint32 current_tower_;
  ::proto::common::active_reward_task_data* task_list_;
  ::google::protobuf::uint32 update_day_time_;
  ::google::protobuf::uint32 update_week_time_;
  ::proto::common::multi_time_data* multi_time_;
  ::proto::common::life_info* life_data_;
  ::google::protobuf::uint32 mode_state_;
  ::google::protobuf::uint32 charm_;
  ::proto::common::head_data* head_frame_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > compeleted_guide_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_data* default_instance_;
};
// -------------------------------------------------------------------

class country_common : public ::google::protobuf::Message {
 public:
  country_common();
  virtual ~country_common();

  country_common(const country_common& from);

  inline country_common& operator=(const country_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_common& default_instance();

  void Swap(country_common* other);

  // implements Message ----------------------------------------------

  country_common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_common& from);
  void MergeFrom(const country_common& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 country_id = 1;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional uint32 country_flag = 2;
  inline bool has_country_flag() const;
  inline void clear_country_flag();
  static const int kCountryFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 country_flag() const;
  inline void set_country_flag(::google::protobuf::uint32 value);

  // optional string country_name = 3;
  inline bool has_country_name() const;
  inline void clear_country_name();
  static const int kCountryNameFieldNumber = 3;
  inline const ::std::string& country_name() const;
  inline void set_country_name(const ::std::string& value);
  inline void set_country_name(const char* value);
  inline void set_country_name(const char* value, size_t size);
  inline ::std::string* mutable_country_name();
  inline ::std::string* release_country_name();
  inline void set_allocated_country_name(::std::string* country_name);

  // @@protoc_insertion_point(class_scope:proto.common.country_common)
 private:
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_country_flag();
  inline void clear_has_country_flag();
  inline void set_has_country_name();
  inline void clear_has_country_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 country_id_;
  ::google::protobuf::uint32 country_flag_;
  ::std::string* country_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_common* default_instance_;
};
// -------------------------------------------------------------------

class object_common_info : public ::google::protobuf::Message {
 public:
  object_common_info();
  virtual ~object_common_info();

  object_common_info(const object_common_info& from);

  inline object_common_info& operator=(const object_common_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const object_common_info& default_instance();

  void Swap(object_common_info* other);

  // implements Message ----------------------------------------------

  object_common_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const object_common_info& from);
  void MergeFrom(const object_common_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string object_id = 1;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  inline const ::std::string& object_id() const;
  inline void set_object_id(const ::std::string& value);
  inline void set_object_id(const char* value);
  inline void set_object_id(const char* value, size_t size);
  inline ::std::string* mutable_object_id();
  inline ::std::string* release_object_id();
  inline void set_allocated_object_id(::std::string* object_id);

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 2;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional string object_name = 3;
  inline bool has_object_name() const;
  inline void clear_object_name();
  static const int kObjectNameFieldNumber = 3;
  inline const ::std::string& object_name() const;
  inline void set_object_name(const ::std::string& value);
  inline void set_object_name(const char* value);
  inline void set_object_name(const char* value, size_t size);
  inline ::std::string* mutable_object_name();
  inline ::std::string* release_object_name();
  inline void set_allocated_object_name(::std::string* object_name);

  // optional uint32 speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline ::google::protobuf::uint32 speed() const;
  inline void set_speed(::google::protobuf::uint32 value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional .proto.common.country_common country = 6;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 6;
  inline const ::proto::common::country_common& country() const;
  inline ::proto::common::country_common* mutable_country();
  inline ::proto::common::country_common* release_country();
  inline void set_allocated_country(::proto::common::country_common* country);

  // optional .proto.common.object_state_info object_state = 7;
  inline bool has_object_state() const;
  inline void clear_object_state();
  static const int kObjectStateFieldNumber = 7;
  inline const ::proto::common::object_state_info& object_state() const;
  inline ::proto::common::object_state_info* mutable_object_state();
  inline ::proto::common::object_state_info* release_object_state();
  inline void set_allocated_object_state(::proto::common::object_state_info* object_state);

  // optional uint32 plugin = 8;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 8;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 country_officer = 9;
  inline bool has_country_officer() const;
  inline void clear_country_officer();
  static const int kCountryOfficerFieldNumber = 9;
  inline ::google::protobuf::uint32 country_officer() const;
  inline void set_country_officer(::google::protobuf::uint32 value);

  // optional uint32 mode_id = 10;
  inline bool has_mode_id() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 10;
  inline ::google::protobuf::uint32 mode_id() const;
  inline void set_mode_id(::google::protobuf::uint32 value);

  // optional float current_x = 11;
  inline bool has_current_x() const;
  inline void clear_current_x();
  static const int kCurrentXFieldNumber = 11;
  inline float current_x() const;
  inline void set_current_x(float value);

  // optional float current_y = 12;
  inline bool has_current_y() const;
  inline void clear_current_y();
  static const int kCurrentYFieldNumber = 12;
  inline float current_y() const;
  inline void set_current_y(float value);

  // optional float direction = 13;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 13;
  inline float direction() const;
  inline void set_direction(float value);

  // optional uint32 max_hp = 14;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 14;
  inline ::google::protobuf::uint32 max_hp() const;
  inline void set_max_hp(::google::protobuf::uint32 value);

  // optional uint32 current_hp = 15;
  inline bool has_current_hp() const;
  inline void clear_current_hp();
  static const int kCurrentHpFieldNumber = 15;
  inline ::google::protobuf::uint32 current_hp() const;
  inline void set_current_hp(::google::protobuf::uint32 value);

  // optional string family_id = 16;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 16;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional string family_name = 17;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 17;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 fighting_value = 18;
  inline bool has_fighting_value() const;
  inline void clear_fighting_value();
  static const int kFightingValueFieldNumber = 18;
  inline ::google::protobuf::uint32 fighting_value() const;
  inline void set_fighting_value(::google::protobuf::uint32 value);

  // optional uint32 mount_tid = 19;
  inline bool has_mount_tid() const;
  inline void clear_mount_tid();
  static const int kMountTidFieldNumber = 19;
  inline ::google::protobuf::uint32 mount_tid() const;
  inline void set_mount_tid(::google::protobuf::uint32 value);

  // optional uint32 npc_tid = 20;
  inline bool has_npc_tid() const;
  inline void clear_npc_tid();
  static const int kNpcTidFieldNumber = 20;
  inline ::google::protobuf::uint32 npc_tid() const;
  inline void set_npc_tid(::google::protobuf::uint32 value);

  // optional uint32 collect_tid = 21;
  inline bool has_collect_tid() const;
  inline void clear_collect_tid();
  static const int kCollectTidFieldNumber = 21;
  inline ::google::protobuf::uint32 collect_tid() const;
  inline void set_collect_tid(::google::protobuf::uint32 value);

  // optional uint32 pk_value = 23;
  inline bool has_pk_value() const;
  inline void clear_pk_value();
  static const int kPkValueFieldNumber = 23;
  inline ::google::protobuf::uint32 pk_value() const;
  inline void set_pk_value(::google::protobuf::uint32 value);

  // optional string troop_id = 24;
  inline bool has_troop_id() const;
  inline void clear_troop_id();
  static const int kTroopIdFieldNumber = 24;
  inline const ::std::string& troop_id() const;
  inline void set_troop_id(const ::std::string& value);
  inline void set_troop_id(const char* value);
  inline void set_troop_id(const char* value, size_t size);
  inline ::std::string* mutable_troop_id();
  inline ::std::string* release_troop_id();
  inline void set_allocated_troop_id(::std::string* troop_id);

  // optional bool is_leader = 25;
  inline bool has_is_leader() const;
  inline void clear_is_leader();
  static const int kIsLeaderFieldNumber = 25;
  inline bool is_leader() const;
  inline void set_is_leader(bool value);

  // optional uint32 family_officer = 26;
  inline bool has_family_officer() const;
  inline void clear_family_officer();
  static const int kFamilyOfficerFieldNumber = 26;
  inline ::google::protobuf::uint32 family_officer() const;
  inline void set_family_officer(::google::protobuf::uint32 value);

  // repeated uint32 role_buff = 27;
  inline int role_buff_size() const;
  inline void clear_role_buff();
  static const int kRoleBuffFieldNumber = 27;
  inline ::google::protobuf::uint32 role_buff(int index) const;
  inline void set_role_buff(int index, ::google::protobuf::uint32 value);
  inline void add_role_buff(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      role_buff() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_role_buff();

  // optional uint32 state_level = 28;
  inline bool has_state_level() const;
  inline void clear_state_level();
  static const int kStateLevelFieldNumber = 28;
  inline ::google::protobuf::uint32 state_level() const;
  inline void set_state_level(::google::protobuf::uint32 value);

  // optional uint32 head = 29;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 29;
  inline ::google::protobuf::uint32 head() const;
  inline void set_head(::google::protobuf::uint32 value);

  // optional uint32 pk_mode = 30;
  inline bool has_pk_mode() const;
  inline void clear_pk_mode();
  static const int kPkModeFieldNumber = 30;
  inline ::google::protobuf::uint32 pk_mode() const;
  inline void set_pk_mode(::google::protobuf::uint32 value);

  // optional uint32 pk_ex = 31;
  inline bool has_pk_ex() const;
  inline void clear_pk_ex();
  static const int kPkExFieldNumber = 31;
  inline ::google::protobuf::uint32 pk_ex() const;
  inline void set_pk_ex(::google::protobuf::uint32 value);

  // optional uint32 cur_title = 32;
  inline bool has_cur_title() const;
  inline void clear_cur_title();
  static const int kCurTitleFieldNumber = 32;
  inline ::google::protobuf::uint32 cur_title() const;
  inline void set_cur_title(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.object_common_info)
 private:
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_object_name();
  inline void clear_has_object_name();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_object_state();
  inline void clear_has_object_state();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_country_officer();
  inline void clear_has_country_officer();
  inline void set_has_mode_id();
  inline void clear_has_mode_id();
  inline void set_has_current_x();
  inline void clear_has_current_x();
  inline void set_has_current_y();
  inline void clear_has_current_y();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_current_hp();
  inline void clear_has_current_hp();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_fighting_value();
  inline void clear_has_fighting_value();
  inline void set_has_mount_tid();
  inline void clear_has_mount_tid();
  inline void set_has_npc_tid();
  inline void clear_has_npc_tid();
  inline void set_has_collect_tid();
  inline void clear_has_collect_tid();
  inline void set_has_pk_value();
  inline void clear_has_pk_value();
  inline void set_has_troop_id();
  inline void clear_has_troop_id();
  inline void set_has_is_leader();
  inline void clear_has_is_leader();
  inline void set_has_family_officer();
  inline void clear_has_family_officer();
  inline void set_has_state_level();
  inline void clear_has_state_level();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_pk_mode();
  inline void clear_has_pk_mode();
  inline void set_has_pk_ex();
  inline void clear_has_pk_ex();
  inline void set_has_cur_title();
  inline void clear_has_cur_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_id_;
  ::std::string* object_name_;
  int object_type_;
  ::google::protobuf::uint32 speed_;
  ::proto::common::country_common* country_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 plugin_;
  ::proto::common::object_state_info* object_state_;
  ::google::protobuf::uint32 country_officer_;
  ::google::protobuf::uint32 mode_id_;
  float current_x_;
  float current_y_;
  float direction_;
  ::google::protobuf::uint32 max_hp_;
  ::std::string* family_id_;
  ::google::protobuf::uint32 current_hp_;
  ::google::protobuf::uint32 fighting_value_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 mount_tid_;
  ::google::protobuf::uint32 npc_tid_;
  ::google::protobuf::uint32 collect_tid_;
  ::google::protobuf::uint32 pk_value_;
  ::std::string* troop_id_;
  bool is_leader_;
  ::google::protobuf::uint32 family_officer_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > role_buff_;
  ::google::protobuf::uint32 state_level_;
  ::google::protobuf::uint32 head_;
  ::google::protobuf::uint32 pk_mode_;
  ::google::protobuf::uint32 pk_ex_;
  ::google::protobuf::uint32 cur_title_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static object_common_info* default_instance_;
};
// -------------------------------------------------------------------

class personal_info : public ::google::protobuf::Message {
 public:
  personal_info();
  virtual ~personal_info();

  personal_info(const personal_info& from);

  inline personal_info& operator=(const personal_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const personal_info& default_instance();

  void Swap(personal_info* other);

  // implements Message ----------------------------------------------

  personal_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const personal_info& from);
  void MergeFrom(const personal_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 yuanbao = 1;
  inline bool has_yuanbao() const;
  inline void clear_yuanbao();
  static const int kYuanbaoFieldNumber = 1;
  inline ::google::protobuf::uint32 yuanbao() const;
  inline void set_yuanbao(::google::protobuf::uint32 value);

  // optional uint32 silver = 2;
  inline bool has_silver() const;
  inline void clear_silver();
  static const int kSilverFieldNumber = 2;
  inline ::google::protobuf::uint32 silver() const;
  inline void set_silver(::google::protobuf::uint32 value);

  // optional uint32 copper = 3;
  inline bool has_copper() const;
  inline void clear_copper();
  static const int kCopperFieldNumber = 3;
  inline ::google::protobuf::uint32 copper() const;
  inline void set_copper(::google::protobuf::uint32 value);

  // optional uint32 pk_mode = 7;
  inline bool has_pk_mode() const;
  inline void clear_pk_mode();
  static const int kPkModeFieldNumber = 7;
  inline ::google::protobuf::uint32 pk_mode() const;
  inline void set_pk_mode(::google::protobuf::uint32 value);

  // optional uint32 pk_punishment = 8;
  inline bool has_pk_punishment() const;
  inline void clear_pk_punishment();
  static const int kPkPunishmentFieldNumber = 8;
  inline ::google::protobuf::uint32 pk_punishment() const;
  inline void set_pk_punishment(::google::protobuf::uint32 value);

  // optional uint32 garrison_city = 9;
  inline bool has_garrison_city() const;
  inline void clear_garrison_city();
  static const int kGarrisonCityFieldNumber = 9;
  inline ::google::protobuf::uint32 garrison_city() const;
  inline void set_garrison_city(::google::protobuf::uint32 value);

  // optional uint32 offline_reward_calc_time = 10;
  inline bool has_offline_reward_calc_time() const;
  inline void clear_offline_reward_calc_time();
  static const int kOfflineRewardCalcTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 offline_reward_calc_time() const;
  inline void set_offline_reward_calc_time(::google::protobuf::uint32 value);

  // optional string family_id = 11;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 11;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional uint32 city_id = 12;
  inline bool has_city_id() const;
  inline void clear_city_id();
  static const int kCityIdFieldNumber = 12;
  inline ::google::protobuf::uint32 city_id() const;
  inline void set_city_id(::google::protobuf::uint32 value);

  // optional uint32 luck_gift_gold = 18;
  inline bool has_luck_gift_gold() const;
  inline void clear_luck_gift_gold();
  static const int kLuckGiftGoldFieldNumber = 18;
  inline ::google::protobuf::uint32 luck_gift_gold() const;
  inline void set_luck_gift_gold(::google::protobuf::uint32 value);

  // optional string hero_uid = 19;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 19;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // optional uint32 prestige = 20;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 20;
  inline ::google::protobuf::uint32 prestige() const;
  inline void set_prestige(::google::protobuf::uint32 value);

  // optional uint32 prestige_total = 21;
  inline bool has_prestige_total() const;
  inline void clear_prestige_total();
  static const int kPrestigeTotalFieldNumber = 21;
  inline ::google::protobuf::uint32 prestige_total() const;
  inline void set_prestige_total(::google::protobuf::uint32 value);

  // optional uint32 prestige_level = 22;
  inline bool has_prestige_level() const;
  inline void clear_prestige_level();
  static const int kPrestigeLevelFieldNumber = 22;
  inline ::google::protobuf::uint32 prestige_level() const;
  inline void set_prestige_level(::google::protobuf::uint32 value);

  // optional uint32 cur_form_id = 23;
  inline bool has_cur_form_id() const;
  inline void clear_cur_form_id();
  static const int kCurFormIdFieldNumber = 23;
  inline ::google::protobuf::uint32 cur_form_id() const;
  inline void set_cur_form_id(::google::protobuf::uint32 value);

  // optional uint32 pk_value_reduce_time = 24;
  inline bool has_pk_value_reduce_time() const;
  inline void clear_pk_value_reduce_time();
  static const int kPkValueReduceTimeFieldNumber = 24;
  inline ::google::protobuf::uint32 pk_value_reduce_time() const;
  inline void set_pk_value_reduce_time(::google::protobuf::uint32 value);

  // optional uint32 pk_value = 25;
  inline bool has_pk_value() const;
  inline void clear_pk_value();
  static const int kPkValueFieldNumber = 25;
  inline ::google::protobuf::uint32 pk_value() const;
  inline void set_pk_value(::google::protobuf::uint32 value);

  // optional uint32 pk_count = 26;
  inline bool has_pk_count() const;
  inline void clear_pk_count();
  static const int kPkCountFieldNumber = 26;
  inline ::google::protobuf::uint32 pk_count() const;
  inline void set_pk_count(::google::protobuf::uint32 value);

  // optional uint32 target_count = 27;
  inline bool has_target_count() const;
  inline void clear_target_count();
  static const int kTargetCountFieldNumber = 27;
  inline ::google::protobuf::uint32 target_count() const;
  inline void set_target_count(::google::protobuf::uint32 value);

  // optional uint32 errantry = 28;
  inline bool has_errantry() const;
  inline void clear_errantry();
  static const int kErrantryFieldNumber = 28;
  inline ::google::protobuf::uint32 errantry() const;
  inline void set_errantry(::google::protobuf::uint32 value);

  // optional uint32 energy = 29;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 29;
  inline ::google::protobuf::uint32 energy() const;
  inline void set_energy(::google::protobuf::uint32 value);

  // optional uint32 equip_smelt_value = 30;
  inline bool has_equip_smelt_value() const;
  inline void clear_equip_smelt_value();
  static const int kEquipSmeltValueFieldNumber = 30;
  inline ::google::protobuf::uint32 equip_smelt_value() const;
  inline void set_equip_smelt_value(::google::protobuf::uint32 value);

  // repeated uint32 equip_smelt_box = 31;
  inline int equip_smelt_box_size() const;
  inline void clear_equip_smelt_box();
  static const int kEquipSmeltBoxFieldNumber = 31;
  inline ::google::protobuf::uint32 equip_smelt_box(int index) const;
  inline void set_equip_smelt_box(int index, ::google::protobuf::uint32 value);
  inline void add_equip_smelt_box(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      equip_smelt_box() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_equip_smelt_box();

  // optional uint32 achieve_point = 32;
  inline bool has_achieve_point() const;
  inline void clear_achieve_point();
  static const int kAchievePointFieldNumber = 32;
  inline ::google::protobuf::uint32 achieve_point() const;
  inline void set_achieve_point(::google::protobuf::uint32 value);

  // optional uint32 achieve_level = 33;
  inline bool has_achieve_level() const;
  inline void clear_achieve_level();
  static const int kAchieveLevelFieldNumber = 33;
  inline ::google::protobuf::uint32 achieve_level() const;
  inline void set_achieve_level(::google::protobuf::uint32 value);

  // optional uint32 achieve_recv_reward_level = 34;
  inline bool has_achieve_recv_reward_level() const;
  inline void clear_achieve_recv_reward_level();
  static const int kAchieveRecvRewardLevelFieldNumber = 34;
  inline ::google::protobuf::uint32 achieve_recv_reward_level() const;
  inline void set_achieve_recv_reward_level(::google::protobuf::uint32 value);

  // optional uint32 lifeforce = 35;
  inline bool has_lifeforce() const;
  inline void clear_lifeforce();
  static const int kLifeforceFieldNumber = 35;
  inline ::google::protobuf::uint32 lifeforce() const;
  inline void set_lifeforce(::google::protobuf::uint32 value);

  // optional uint32 lifestar_level = 36;
  inline bool has_lifestar_level() const;
  inline void clear_lifestar_level();
  static const int kLifestarLevelFieldNumber = 36;
  inline ::google::protobuf::uint32 lifestar_level() const;
  inline void set_lifestar_level(::google::protobuf::uint32 value);

  // optional uint32 lifestate_level = 37;
  inline bool has_lifestate_level() const;
  inline void clear_lifestate_level();
  static const int kLifestateLevelFieldNumber = 37;
  inline ::google::protobuf::uint32 lifestate_level() const;
  inline void set_lifestate_level(::google::protobuf::uint32 value);

  // optional uint32 plugin = 38;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 38;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 prestige_today = 39;
  inline bool has_prestige_today() const;
  inline void clear_prestige_today();
  static const int kPrestigeTodayFieldNumber = 39;
  inline ::google::protobuf::uint32 prestige_today() const;
  inline void set_prestige_today(::google::protobuf::uint32 value);

  // optional uint32 life_stone = 40;
  inline bool has_life_stone() const;
  inline void clear_life_stone();
  static const int kLifeStoneFieldNumber = 40;
  inline ::google::protobuf::uint32 life_stone() const;
  inline void set_life_stone(::google::protobuf::uint32 value);

  // optional uint32 contribution = 43;
  inline bool has_contribution() const;
  inline void clear_contribution();
  static const int kContributionFieldNumber = 43;
  inline ::google::protobuf::uint32 contribution() const;
  inline void set_contribution(::google::protobuf::uint32 value);

  // optional uint32 herosoul = 44;
  inline bool has_herosoul() const;
  inline void clear_herosoul();
  static const int kHerosoulFieldNumber = 44;
  inline ::google::protobuf::uint32 herosoul() const;
  inline void set_herosoul(::google::protobuf::uint32 value);

  // optional uint32 honor = 45;
  inline bool has_honor() const;
  inline void clear_honor();
  static const int kHonorFieldNumber = 45;
  inline ::google::protobuf::uint32 honor() const;
  inline void set_honor(::google::protobuf::uint32 value);

  // optional uint32 honor_week = 46;
  inline bool has_honor_week() const;
  inline void clear_honor_week();
  static const int kHonorWeekFieldNumber = 46;
  inline ::google::protobuf::uint32 honor_week() const;
  inline void set_honor_week(::google::protobuf::uint32 value);

  // optional uint32 honor_limit = 47;
  inline bool has_honor_limit() const;
  inline void clear_honor_limit();
  static const int kHonorLimitFieldNumber = 47;
  inline ::google::protobuf::uint32 honor_limit() const;
  inline void set_honor_limit(::google::protobuf::uint32 value);

  // optional uint32 patrol_count = 48;
  inline bool has_patrol_count() const;
  inline void clear_patrol_count();
  static const int kPatrolCountFieldNumber = 48;
  inline ::google::protobuf::uint32 patrol_count() const;
  inline void set_patrol_count(::google::protobuf::uint32 value);

  // optional uint32 multi_point = 49;
  inline bool has_multi_point() const;
  inline void clear_multi_point();
  static const int kMultiPointFieldNumber = 49;
  inline ::google::protobuf::uint32 multi_point() const;
  inline void set_multi_point(::google::protobuf::uint32 value);

  // optional uint32 equip_lucky = 50;
  inline bool has_equip_lucky() const;
  inline void clear_equip_lucky();
  static const int kEquipLuckyFieldNumber = 50;
  inline ::google::protobuf::uint32 equip_lucky() const;
  inline void set_equip_lucky(::google::protobuf::uint32 value);

  // optional uint32 role_unlock = 51;
  inline bool has_role_unlock() const;
  inline void clear_role_unlock();
  static const int kRoleUnlockFieldNumber = 51;
  inline ::google::protobuf::uint32 role_unlock() const;
  inline void set_role_unlock(::google::protobuf::uint32 value);

  // optional uint32 vigour = 52;
  inline bool has_vigour() const;
  inline void clear_vigour();
  static const int kVigourFieldNumber = 52;
  inline ::google::protobuf::uint32 vigour() const;
  inline void set_vigour(::google::protobuf::uint32 value);

  // optional uint32 vigour_buy = 53;
  inline bool has_vigour_buy() const;
  inline void clear_vigour_buy();
  static const int kVigourBuyFieldNumber = 53;
  inline ::google::protobuf::uint32 vigour_buy() const;
  inline void set_vigour_buy(::google::protobuf::uint32 value);

  // optional uint32 vigour_time = 54;
  inline bool has_vigour_time() const;
  inline void clear_vigour_time();
  static const int kVigourTimeFieldNumber = 54;
  inline ::google::protobuf::uint32 vigour_time() const;
  inline void set_vigour_time(::google::protobuf::uint32 value);

  // optional uint32 head_frame = 55;
  inline bool has_head_frame() const;
  inline void clear_head_frame();
  static const int kHeadFrameFieldNumber = 55;
  inline ::google::protobuf::uint32 head_frame() const;
  inline void set_head_frame(::google::protobuf::uint32 value);

  // optional uint32 month_card_id = 56;
  inline bool has_month_card_id() const;
  inline void clear_month_card_id();
  static const int kMonthCardIdFieldNumber = 56;
  inline ::google::protobuf::uint32 month_card_id() const;
  inline void set_month_card_id(::google::protobuf::uint32 value);

  // optional uint32 wusheng_score = 57;
  inline bool has_wusheng_score() const;
  inline void clear_wusheng_score();
  static const int kWushengScoreFieldNumber = 57;
  inline ::google::protobuf::uint32 wusheng_score() const;
  inline void set_wusheng_score(::google::protobuf::uint32 value);

  // optional uint32 wusheng_score_today = 58;
  inline bool has_wusheng_score_today() const;
  inline void clear_wusheng_score_today();
  static const int kWushengScoreTodayFieldNumber = 58;
  inline ::google::protobuf::uint32 wusheng_score_today() const;
  inline void set_wusheng_score_today(::google::protobuf::uint32 value);

  // optional uint32 wusheng_lucky = 59;
  inline bool has_wusheng_lucky() const;
  inline void clear_wusheng_lucky();
  static const int kWushengLuckyFieldNumber = 59;
  inline ::google::protobuf::uint32 wusheng_lucky() const;
  inline void set_wusheng_lucky(::google::protobuf::uint32 value);

  // optional uint32 patrol_point = 60;
  inline bool has_patrol_point() const;
  inline void clear_patrol_point();
  static const int kPatrolPointFieldNumber = 60;
  inline ::google::protobuf::uint32 patrol_point() const;
  inline void set_patrol_point(::google::protobuf::uint32 value);

  // optional uint32 patrol_hook = 61;
  inline bool has_patrol_hook() const;
  inline void clear_patrol_hook();
  static const int kPatrolHookFieldNumber = 61;
  inline ::google::protobuf::uint32 patrol_hook() const;
  inline void set_patrol_hook(::google::protobuf::uint32 value);

  // optional uint32 feats = 62;
  inline bool has_feats() const;
  inline void clear_feats();
  static const int kFeatsFieldNumber = 62;
  inline ::google::protobuf::uint32 feats() const;
  inline void set_feats(::google::protobuf::uint32 value);

  // optional uint32 ignore_lineup_flag = 63;
  inline bool has_ignore_lineup_flag() const;
  inline void clear_ignore_lineup_flag();
  static const int kIgnoreLineupFlagFieldNumber = 63;
  inline ::google::protobuf::uint32 ignore_lineup_flag() const;
  inline void set_ignore_lineup_flag(::google::protobuf::uint32 value);

  // repeated uint32 career_id = 64;
  inline int career_id_size() const;
  inline void clear_career_id();
  static const int kCareerIdFieldNumber = 64;
  inline ::google::protobuf::uint32 career_id(int index) const;
  inline void set_career_id(int index, ::google::protobuf::uint32 value);
  inline void add_career_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      career_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_career_id();

  // optional uint32 change_name = 65;
  inline bool has_change_name() const;
  inline void clear_change_name();
  static const int kChangeNameFieldNumber = 65;
  inline ::google::protobuf::uint32 change_name() const;
  inline void set_change_name(::google::protobuf::uint32 value);

  // repeated uint32 title_id = 66;
  inline int title_id_size() const;
  inline void clear_title_id();
  static const int kTitleIdFieldNumber = 66;
  inline ::google::protobuf::uint32 title_id(int index) const;
  inline void set_title_id(int index, ::google::protobuf::uint32 value);
  inline void add_title_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      title_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_title_id();

  // optional uint32 cur_title = 67;
  inline bool has_cur_title() const;
  inline void clear_cur_title();
  static const int kCurTitleFieldNumber = 67;
  inline ::google::protobuf::uint32 cur_title() const;
  inline void set_cur_title(::google::protobuf::uint32 value);

  // optional uint32 friendship_point = 69;
  inline bool has_friendship_point() const;
  inline void clear_friendship_point();
  static const int kFriendshipPointFieldNumber = 69;
  inline ::google::protobuf::uint32 friendship_point() const;
  inline void set_friendship_point(::google::protobuf::uint32 value);

  // optional uint32 wusheng_today_buy = 70;
  inline bool has_wusheng_today_buy() const;
  inline void clear_wusheng_today_buy();
  static const int kWushengTodayBuyFieldNumber = 70;
  inline ::google::protobuf::uint32 wusheng_today_buy() const;
  inline void set_wusheng_today_buy(::google::protobuf::uint32 value);

  // repeated uint32 handbook = 71;
  inline int handbook_size() const;
  inline void clear_handbook();
  static const int kHandbookFieldNumber = 71;
  inline ::google::protobuf::uint32 handbook(int index) const;
  inline void set_handbook(int index, ::google::protobuf::uint32 value);
  inline void add_handbook(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      handbook() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_handbook();

  // @@protoc_insertion_point(class_scope:proto.common.personal_info)
 private:
  inline void set_has_yuanbao();
  inline void clear_has_yuanbao();
  inline void set_has_silver();
  inline void clear_has_silver();
  inline void set_has_copper();
  inline void clear_has_copper();
  inline void set_has_pk_mode();
  inline void clear_has_pk_mode();
  inline void set_has_pk_punishment();
  inline void clear_has_pk_punishment();
  inline void set_has_garrison_city();
  inline void clear_has_garrison_city();
  inline void set_has_offline_reward_calc_time();
  inline void clear_has_offline_reward_calc_time();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_city_id();
  inline void clear_has_city_id();
  inline void set_has_luck_gift_gold();
  inline void clear_has_luck_gift_gold();
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_prestige_total();
  inline void clear_has_prestige_total();
  inline void set_has_prestige_level();
  inline void clear_has_prestige_level();
  inline void set_has_cur_form_id();
  inline void clear_has_cur_form_id();
  inline void set_has_pk_value_reduce_time();
  inline void clear_has_pk_value_reduce_time();
  inline void set_has_pk_value();
  inline void clear_has_pk_value();
  inline void set_has_pk_count();
  inline void clear_has_pk_count();
  inline void set_has_target_count();
  inline void clear_has_target_count();
  inline void set_has_errantry();
  inline void clear_has_errantry();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_equip_smelt_value();
  inline void clear_has_equip_smelt_value();
  inline void set_has_achieve_point();
  inline void clear_has_achieve_point();
  inline void set_has_achieve_level();
  inline void clear_has_achieve_level();
  inline void set_has_achieve_recv_reward_level();
  inline void clear_has_achieve_recv_reward_level();
  inline void set_has_lifeforce();
  inline void clear_has_lifeforce();
  inline void set_has_lifestar_level();
  inline void clear_has_lifestar_level();
  inline void set_has_lifestate_level();
  inline void clear_has_lifestate_level();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_prestige_today();
  inline void clear_has_prestige_today();
  inline void set_has_life_stone();
  inline void clear_has_life_stone();
  inline void set_has_contribution();
  inline void clear_has_contribution();
  inline void set_has_herosoul();
  inline void clear_has_herosoul();
  inline void set_has_honor();
  inline void clear_has_honor();
  inline void set_has_honor_week();
  inline void clear_has_honor_week();
  inline void set_has_honor_limit();
  inline void clear_has_honor_limit();
  inline void set_has_patrol_count();
  inline void clear_has_patrol_count();
  inline void set_has_multi_point();
  inline void clear_has_multi_point();
  inline void set_has_equip_lucky();
  inline void clear_has_equip_lucky();
  inline void set_has_role_unlock();
  inline void clear_has_role_unlock();
  inline void set_has_vigour();
  inline void clear_has_vigour();
  inline void set_has_vigour_buy();
  inline void clear_has_vigour_buy();
  inline void set_has_vigour_time();
  inline void clear_has_vigour_time();
  inline void set_has_head_frame();
  inline void clear_has_head_frame();
  inline void set_has_month_card_id();
  inline void clear_has_month_card_id();
  inline void set_has_wusheng_score();
  inline void clear_has_wusheng_score();
  inline void set_has_wusheng_score_today();
  inline void clear_has_wusheng_score_today();
  inline void set_has_wusheng_lucky();
  inline void clear_has_wusheng_lucky();
  inline void set_has_patrol_point();
  inline void clear_has_patrol_point();
  inline void set_has_patrol_hook();
  inline void clear_has_patrol_hook();
  inline void set_has_feats();
  inline void clear_has_feats();
  inline void set_has_ignore_lineup_flag();
  inline void clear_has_ignore_lineup_flag();
  inline void set_has_change_name();
  inline void clear_has_change_name();
  inline void set_has_cur_title();
  inline void clear_has_cur_title();
  inline void set_has_friendship_point();
  inline void clear_has_friendship_point();
  inline void set_has_wusheng_today_buy();
  inline void clear_has_wusheng_today_buy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 yuanbao_;
  ::google::protobuf::uint32 silver_;
  ::google::protobuf::uint32 copper_;
  ::google::protobuf::uint32 pk_mode_;
  ::google::protobuf::uint32 pk_punishment_;
  ::google::protobuf::uint32 garrison_city_;
  ::std::string* family_id_;
  ::google::protobuf::uint32 offline_reward_calc_time_;
  ::google::protobuf::uint32 city_id_;
  ::std::string* hero_uid_;
  ::google::protobuf::uint32 luck_gift_gold_;
  ::google::protobuf::uint32 prestige_;
  ::google::protobuf::uint32 prestige_total_;
  ::google::protobuf::uint32 prestige_level_;
  ::google::protobuf::uint32 cur_form_id_;
  ::google::protobuf::uint32 pk_value_reduce_time_;
  ::google::protobuf::uint32 pk_value_;
  ::google::protobuf::uint32 pk_count_;
  ::google::protobuf::uint32 target_count_;
  ::google::protobuf::uint32 errantry_;
  ::google::protobuf::uint32 energy_;
  ::google::protobuf::uint32 equip_smelt_value_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > equip_smelt_box_;
  ::google::protobuf::uint32 achieve_point_;
  ::google::protobuf::uint32 achieve_level_;
  ::google::protobuf::uint32 achieve_recv_reward_level_;
  ::google::protobuf::uint32 lifeforce_;
  ::google::protobuf::uint32 lifestar_level_;
  ::google::protobuf::uint32 lifestate_level_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 prestige_today_;
  ::google::protobuf::uint32 life_stone_;
  ::google::protobuf::uint32 contribution_;
  ::google::protobuf::uint32 herosoul_;
  ::google::protobuf::uint32 honor_;
  ::google::protobuf::uint32 honor_week_;
  ::google::protobuf::uint32 honor_limit_;
  ::google::protobuf::uint32 patrol_count_;
  ::google::protobuf::uint32 multi_point_;
  ::google::protobuf::uint32 equip_lucky_;
  ::google::protobuf::uint32 role_unlock_;
  ::google::protobuf::uint32 vigour_;
  ::google::protobuf::uint32 vigour_buy_;
  ::google::protobuf::uint32 vigour_time_;
  ::google::protobuf::uint32 head_frame_;
  ::google::protobuf::uint32 month_card_id_;
  ::google::protobuf::uint32 wusheng_score_;
  ::google::protobuf::uint32 wusheng_score_today_;
  ::google::protobuf::uint32 wusheng_lucky_;
  ::google::protobuf::uint32 patrol_point_;
  ::google::protobuf::uint32 patrol_hook_;
  ::google::protobuf::uint32 feats_;
  ::google::protobuf::uint32 ignore_lineup_flag_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > career_id_;
  ::google::protobuf::uint32 change_name_;
  ::google::protobuf::uint32 cur_title_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > title_id_;
  ::google::protobuf::uint32 friendship_point_;
  ::google::protobuf::uint32 wusheng_today_buy_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > handbook_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(60 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static personal_info* default_instance_;
};
// -------------------------------------------------------------------

class interior_info : public ::google::protobuf::Message {
 public:
  interior_info();
  virtual ~interior_info();

  interior_info(const interior_info& from);

  inline interior_info& operator=(const interior_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const interior_info& default_instance();

  void Swap(interior_info* other);

  // implements Message ----------------------------------------------

  interior_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const interior_info& from);
  void MergeFrom(const interior_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional uint32 star_level = 3;
  inline bool has_star_level() const;
  inline void clear_star_level();
  static const int kStarLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 star_level() const;
  inline void set_star_level(::google::protobuf::uint32 value);

  // optional uint32 start_time = 4;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 span_time = 5;
  inline bool has_span_time() const;
  inline void clear_span_time();
  static const int kSpanTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 span_time() const;
  inline void set_span_time(::google::protobuf::uint32 value);

  // optional uint32 last_reward_time = 6;
  inline bool has_last_reward_time() const;
  inline void clear_last_reward_time();
  static const int kLastRewardTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_reward_time() const;
  inline void set_last_reward_time(::google::protobuf::uint32 value);

  // repeated uint32 hero_id_list = 7;
  inline int hero_id_list_size() const;
  inline void clear_hero_id_list();
  static const int kHeroIdListFieldNumber = 7;
  inline ::google::protobuf::uint32 hero_id_list(int index) const;
  inline void set_hero_id_list(int index, ::google::protobuf::uint32 value);
  inline void add_hero_id_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hero_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hero_id_list();

  // optional uint32 left_times = 8;
  inline bool has_left_times() const;
  inline void clear_left_times();
  static const int kLeftTimesFieldNumber = 8;
  inline ::google::protobuf::uint32 left_times() const;
  inline void set_left_times(::google::protobuf::uint32 value);

  // optional uint32 is_start = 9;
  inline bool has_is_start() const;
  inline void clear_is_start();
  static const int kIsStartFieldNumber = 9;
  inline ::google::protobuf::uint32 is_start() const;
  inline void set_is_start(::google::protobuf::uint32 value);

  // optional uint32 copper_left_time = 10;
  inline bool has_copper_left_time() const;
  inline void clear_copper_left_time();
  static const int kCopperLeftTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 copper_left_time() const;
  inline void set_copper_left_time(::google::protobuf::uint32 value);

  // optional uint32 copper_count = 11;
  inline bool has_copper_count() const;
  inline void clear_copper_count();
  static const int kCopperCountFieldNumber = 11;
  inline ::google::protobuf::uint32 copper_count() const;
  inline void set_copper_count(::google::protobuf::uint32 value);

  // optional uint32 task_left_time = 12;
  inline bool has_task_left_time() const;
  inline void clear_task_left_time();
  static const int kTaskLeftTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 task_left_time() const;
  inline void set_task_left_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.interior_info)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_star_level();
  inline void clear_has_star_level();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_span_time();
  inline void clear_has_span_time();
  inline void set_has_last_reward_time();
  inline void clear_has_last_reward_time();
  inline void set_has_left_times();
  inline void clear_has_left_times();
  inline void set_has_is_start();
  inline void clear_has_is_start();
  inline void set_has_copper_left_time();
  inline void clear_has_copper_left_time();
  inline void set_has_copper_count();
  inline void clear_has_copper_count();
  inline void set_has_task_left_time();
  inline void clear_has_task_left_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 star_level_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 span_time_;
  ::google::protobuf::uint32 last_reward_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hero_id_list_;
  ::google::protobuf::uint32 left_times_;
  ::google::protobuf::uint32 is_start_;
  ::google::protobuf::uint32 copper_left_time_;
  ::google::protobuf::uint32 copper_count_;
  ::google::protobuf::uint32 task_left_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static interior_info* default_instance_;
};
// -------------------------------------------------------------------

class role_cross_data : public ::google::protobuf::Message {
 public:
  role_cross_data();
  virtual ~role_cross_data();

  role_cross_data(const role_cross_data& from);

  inline role_cross_data& operator=(const role_cross_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_cross_data& default_instance();

  void Swap(role_cross_data* other);

  // implements Message ----------------------------------------------

  role_cross_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_cross_data& from);
  void MergeFrom(const role_cross_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.role_data rd = 1;
  inline bool has_rd() const;
  inline void clear_rd();
  static const int kRdFieldNumber = 1;
  inline const ::proto::common::role_data& rd() const;
  inline ::proto::common::role_data* mutable_rd();
  inline ::proto::common::role_data* release_rd();
  inline void set_allocated_rd(::proto::common::role_data* rd);

  // optional .proto.common.hero_data hd = 2;
  inline bool has_hd() const;
  inline void clear_hd();
  static const int kHdFieldNumber = 2;
  inline const ::proto::common::hero_data& hd() const;
  inline ::proto::common::hero_data* mutable_hd();
  inline ::proto::common::hero_data* release_hd();
  inline void set_allocated_hd(::proto::common::hero_data* hd);

  // optional .proto.common.item_data item_data = 3;
  inline bool has_item_data() const;
  inline void clear_item_data();
  static const int kItemDataFieldNumber = 3;
  inline const ::proto::common::item_data& item_data() const;
  inline ::proto::common::item_data* mutable_item_data();
  inline ::proto::common::item_data* release_item_data();
  inline void set_allocated_item_data(::proto::common::item_data* item_data);

  // @@protoc_insertion_point(class_scope:proto.common.role_cross_data)
 private:
  inline void set_has_rd();
  inline void clear_has_rd();
  inline void set_has_hd();
  inline void clear_has_hd();
  inline void set_has_item_data();
  inline void clear_has_item_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::role_data* rd_;
  ::proto::common::hero_data* hd_;
  ::proto::common::item_data* item_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_cross_data* default_instance_;
};
// -------------------------------------------------------------------

class mirror_fight_data : public ::google::protobuf::Message {
 public:
  mirror_fight_data();
  virtual ~mirror_fight_data();

  mirror_fight_data(const mirror_fight_data& from);

  inline mirror_fight_data& operator=(const mirror_fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mirror_fight_data& default_instance();

  void Swap(mirror_fight_data* other);

  // implements Message ----------------------------------------------

  mirror_fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mirror_fight_data& from);
  void MergeFrom(const mirror_fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.obj_single obj = 1;
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 1;
  inline const ::proto::common::obj_single& obj() const;
  inline ::proto::common::obj_single* mutable_obj();
  inline ::proto::common::obj_single* release_obj();
  inline void set_allocated_obj(::proto::common::obj_single* obj);

  // optional .proto.common.hero_data heros = 2;
  inline bool has_heros() const;
  inline void clear_heros();
  static const int kHerosFieldNumber = 2;
  inline const ::proto::common::hero_data& heros() const;
  inline ::proto::common::hero_data* mutable_heros();
  inline ::proto::common::hero_data* release_heros();
  inline void set_allocated_heros(::proto::common::hero_data* heros);

  // optional uint32 formation_id = 3;
  inline bool has_formation_id() const;
  inline void clear_formation_id();
  static const int kFormationIdFieldNumber = 3;
  inline ::google::protobuf::uint32 formation_id() const;
  inline void set_formation_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.mirror_fight_data)
 private:
  inline void set_has_obj();
  inline void clear_has_obj();
  inline void set_has_heros();
  inline void clear_has_heros();
  inline void set_has_formation_id();
  inline void clear_has_formation_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::obj_single* obj_;
  ::proto::common::hero_data* heros_;
  ::google::protobuf::uint32 formation_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mirror_fight_data* default_instance_;
};
// -------------------------------------------------------------------

class attr_single : public ::google::protobuf::Message {
 public:
  attr_single();
  virtual ~attr_single();

  attr_single(const attr_single& from);

  inline attr_single& operator=(const attr_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const attr_single& default_instance();

  void Swap(attr_single* other);

  // implements Message ----------------------------------------------

  attr_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const attr_single& from);
  void MergeFrom(const attr_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.common.attr_single)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static attr_single* default_instance_;
};
// -------------------------------------------------------------------

class attr_data : public ::google::protobuf::Message {
 public:
  attr_data();
  virtual ~attr_data();

  attr_data(const attr_data& from);

  inline attr_data& operator=(const attr_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const attr_data& default_instance();

  void Swap(attr_data* other);

  // implements Message ----------------------------------------------

  attr_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const attr_data& from);
  void MergeFrom(const attr_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.attr_single attrs = 1;
  inline int attrs_size() const;
  inline void clear_attrs();
  static const int kAttrsFieldNumber = 1;
  inline const ::proto::common::attr_single& attrs(int index) const;
  inline ::proto::common::attr_single* mutable_attrs(int index);
  inline ::proto::common::attr_single* add_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::attr_single >&
      attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::attr_single >*
      mutable_attrs();

  // @@protoc_insertion_point(class_scope:proto.common.attr_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::attr_single > attrs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static attr_data* default_instance_;
};
// -------------------------------------------------------------------

class hero_state : public ::google::protobuf::Message {
 public:
  hero_state();
  virtual ~hero_state();

  hero_state(const hero_state& from);

  inline hero_state& operator=(const hero_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_state& default_instance();

  void Swap(hero_state* other);

  // implements Message ----------------------------------------------

  hero_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_state& from);
  void MergeFrom(const hero_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // optional uint32 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional uint32 hp = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 3;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.hero_state)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hero_uid_;
  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_state* default_instance_;
};
// -------------------------------------------------------------------

class hero_state_data : public ::google::protobuf::Message {
 public:
  hero_state_data();
  virtual ~hero_state_data();

  hero_state_data(const hero_state_data& from);

  inline hero_state_data& operator=(const hero_state_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_state_data& default_instance();

  void Swap(hero_state_data* other);

  // implements Message ----------------------------------------------

  hero_state_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_state_data& from);
  void MergeFrom(const hero_state_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.hero_state states = 1;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 1;
  inline const ::proto::common::hero_state& states(int index) const;
  inline ::proto::common::hero_state* mutable_states(int index);
  inline ::proto::common::hero_state* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_state >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_state >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:proto.common.hero_state_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_state > states_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_state_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_attr : public ::google::protobuf::Message {
 public:
  fight_attr();
  virtual ~fight_attr();

  fight_attr(const fight_attr& from);

  inline fight_attr& operator=(const fight_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_attr& default_instance();

  void Swap(fight_attr* other);

  // implements Message ----------------------------------------------

  fight_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_attr& from);
  void MergeFrom(const fight_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.attr_data attr = 1;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 1;
  inline const ::proto::common::attr_data& attr() const;
  inline ::proto::common::attr_data* mutable_attr();
  inline ::proto::common::attr_data* release_attr();
  inline void set_allocated_attr(::proto::common::attr_data* attr);

  // optional uint32 fighting = 2;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 2;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional string master = 3;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 3;
  inline const ::std::string& master() const;
  inline void set_master(const ::std::string& value);
  inline void set_master(const char* value);
  inline void set_master(const char* value, size_t size);
  inline ::std::string* mutable_master();
  inline ::std::string* release_master();
  inline void set_allocated_master(::std::string* master);

  // optional uint32 pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional uint32 camp = 5;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 5;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // optional .proto.common.hero_state start = 6;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 6;
  inline const ::proto::common::hero_state& start() const;
  inline ::proto::common::hero_state* mutable_start();
  inline ::proto::common::hero_state* release_start();
  inline void set_allocated_start(::proto::common::hero_state* start);

  // optional .proto.common.hero_state update = 7;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 7;
  inline const ::proto::common::hero_state& update() const;
  inline ::proto::common::hero_state* mutable_update();
  inline ::proto::common::hero_state* release_update();
  inline void set_allocated_update(::proto::common::hero_state* update);

  // optional .proto.common.attr_data next_level = 8;
  inline bool has_next_level() const;
  inline void clear_next_level();
  static const int kNextLevelFieldNumber = 8;
  inline const ::proto::common::attr_data& next_level() const;
  inline ::proto::common::attr_data* mutable_next_level();
  inline ::proto::common::attr_data* release_next_level();
  inline void set_allocated_next_level(::proto::common::attr_data* next_level);

  // optional .proto.common.attr_data next_grade = 9;
  inline bool has_next_grade() const;
  inline void clear_next_grade();
  static const int kNextGradeFieldNumber = 9;
  inline const ::proto::common::attr_data& next_grade() const;
  inline ::proto::common::attr_data* mutable_next_grade();
  inline ::proto::common::attr_data* release_next_grade();
  inline void set_allocated_next_grade(::proto::common::attr_data* next_grade);

  // optional .proto.common.attr_data next_star = 10;
  inline bool has_next_star() const;
  inline void clear_next_star();
  static const int kNextStarFieldNumber = 10;
  inline const ::proto::common::attr_data& next_star() const;
  inline ::proto::common::attr_data* mutable_next_star();
  inline ::proto::common::attr_data* release_next_star();
  inline void set_allocated_next_star(::proto::common::attr_data* next_star);

  // optional .proto.common.attr_data wakeup = 11;
  inline bool has_wakeup() const;
  inline void clear_wakeup();
  static const int kWakeupFieldNumber = 11;
  inline const ::proto::common::attr_data& wakeup() const;
  inline ::proto::common::attr_data* mutable_wakeup();
  inline ::proto::common::attr_data* release_wakeup();
  inline void set_allocated_wakeup(::proto::common::attr_data* wakeup);

  // optional .proto.common.attr_data base_attr = 12;
  inline bool has_base_attr() const;
  inline void clear_base_attr();
  static const int kBaseAttrFieldNumber = 12;
  inline const ::proto::common::attr_data& base_attr() const;
  inline ::proto::common::attr_data* mutable_base_attr();
  inline ::proto::common::attr_data* release_base_attr();
  inline void set_allocated_base_attr(::proto::common::attr_data* base_attr);

  // optional uint32 wave_num = 13;
  inline bool has_wave_num() const;
  inline void clear_wave_num();
  static const int kWaveNumFieldNumber = 13;
  inline ::google::protobuf::uint32 wave_num() const;
  inline void set_wave_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_attr)
 private:
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_next_level();
  inline void clear_has_next_level();
  inline void set_has_next_grade();
  inline void clear_has_next_grade();
  inline void set_has_next_star();
  inline void clear_has_next_star();
  inline void set_has_wakeup();
  inline void clear_has_wakeup();
  inline void set_has_base_attr();
  inline void clear_has_base_attr();
  inline void set_has_wave_num();
  inline void clear_has_wave_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::attr_data* attr_;
  ::std::string* master_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 pos_;
  ::proto::common::hero_state* start_;
  ::proto::common::hero_state* update_;
  ::proto::common::attr_data* next_level_;
  ::proto::common::attr_data* next_grade_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 wave_num_;
  ::proto::common::attr_data* next_star_;
  ::proto::common::attr_data* wakeup_;
  ::proto::common::attr_data* base_attr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_attr* default_instance_;
};
// -------------------------------------------------------------------

class hero_equip : public ::google::protobuf::Message {
 public:
  hero_equip();
  virtual ~hero_equip();

  hero_equip(const hero_equip& from);

  inline hero_equip& operator=(const hero_equip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_equip& default_instance();

  void Swap(hero_equip* other);

  // implements Message ----------------------------------------------

  hero_equip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_equip& from);
  void MergeFrom(const hero_equip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional string equip_uid = 2;
  inline bool has_equip_uid() const;
  inline void clear_equip_uid();
  static const int kEquipUidFieldNumber = 2;
  inline const ::std::string& equip_uid() const;
  inline void set_equip_uid(const ::std::string& value);
  inline void set_equip_uid(const char* value);
  inline void set_equip_uid(const char* value, size_t size);
  inline ::std::string* mutable_equip_uid();
  inline ::std::string* release_equip_uid();
  inline void set_allocated_equip_uid(::std::string* equip_uid);

  // @@protoc_insertion_point(class_scope:proto.common.hero_equip)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_equip_uid();
  inline void clear_has_equip_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* equip_uid_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_equip* default_instance_;
};
// -------------------------------------------------------------------

class hero_skill_single : public ::google::protobuf::Message {
 public:
  hero_skill_single();
  virtual ~hero_skill_single();

  hero_skill_single(const hero_skill_single& from);

  inline hero_skill_single& operator=(const hero_skill_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_skill_single& default_instance();

  void Swap(hero_skill_single* other);

  // implements Message ----------------------------------------------

  hero_skill_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_skill_single& from);
  void MergeFrom(const hero_skill_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 skill_level = 2;
  inline bool has_skill_level() const;
  inline void clear_skill_level();
  static const int kSkillLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_level() const;
  inline void set_skill_level(::google::protobuf::uint32 value);

  // optional uint32 skill_pos = 3;
  inline bool has_skill_pos() const;
  inline void clear_skill_pos();
  static const int kSkillPosFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_pos() const;
  inline void set_skill_pos(::google::protobuf::uint32 value);

  // optional uint32 skill_index = 4;
  inline bool has_skill_index() const;
  inline void clear_skill_index();
  static const int kSkillIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 skill_index() const;
  inline void set_skill_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.hero_skill_single)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_level();
  inline void clear_has_skill_level();
  inline void set_has_skill_pos();
  inline void clear_has_skill_pos();
  inline void set_has_skill_index();
  inline void clear_has_skill_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 skill_level_;
  ::google::protobuf::uint32 skill_pos_;
  ::google::protobuf::uint32 skill_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_skill_single* default_instance_;
};
// -------------------------------------------------------------------

class hero_skill_data : public ::google::protobuf::Message {
 public:
  hero_skill_data();
  virtual ~hero_skill_data();

  hero_skill_data(const hero_skill_data& from);

  inline hero_skill_data& operator=(const hero_skill_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_skill_data& default_instance();

  void Swap(hero_skill_data* other);

  // implements Message ----------------------------------------------

  hero_skill_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_skill_data& from);
  void MergeFrom(const hero_skill_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.hero_skill_single skill_list = 1;
  inline int skill_list_size() const;
  inline void clear_skill_list();
  static const int kSkillListFieldNumber = 1;
  inline const ::proto::common::hero_skill_single& skill_list(int index) const;
  inline ::proto::common::hero_skill_single* mutable_skill_list(int index);
  inline ::proto::common::hero_skill_single* add_skill_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_skill_single >&
      skill_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_skill_single >*
      mutable_skill_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_skill_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_skill_single > skill_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_skill_data* default_instance_;
};
// -------------------------------------------------------------------

class base_attr : public ::google::protobuf::Message {
 public:
  base_attr();
  virtual ~base_attr();

  base_attr(const base_attr& from);

  inline base_attr& operator=(const base_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const base_attr& default_instance();

  void Swap(base_attr* other);

  // implements Message ----------------------------------------------

  base_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const base_attr& from);
  void MergeFrom(const base_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 species = 6;
  inline bool has_species() const;
  inline void clear_species();
  static const int kSpeciesFieldNumber = 6;
  inline ::google::protobuf::uint32 species() const;
  inline void set_species(::google::protobuf::uint32 value);

  // optional uint32 quality = 7;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 7;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // optional uint32 in_form = 8;
  inline bool has_in_form() const;
  inline void clear_in_form();
  static const int kInFormFieldNumber = 8;
  inline ::google::protobuf::uint32 in_form() const;
  inline void set_in_form(::google::protobuf::uint32 value);

  // repeated .proto.common.hero_equip equips = 9;
  inline int equips_size() const;
  inline void clear_equips();
  static const int kEquipsFieldNumber = 9;
  inline const ::proto::common::hero_equip& equips(int index) const;
  inline ::proto::common::hero_equip* mutable_equips(int index);
  inline ::proto::common::hero_equip* add_equips();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_equip >&
      equips() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_equip >*
      mutable_equips();

  // optional uint32 country = 10;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 10;
  inline ::google::protobuf::uint32 country() const;
  inline void set_country(::google::protobuf::uint32 value);

  // optional uint32 grade = 11;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 11;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // optional uint32 talent_level = 12;
  inline bool has_talent_level() const;
  inline void clear_talent_level();
  static const int kTalentLevelFieldNumber = 12;
  inline ::google::protobuf::uint32 talent_level() const;
  inline void set_talent_level(::google::protobuf::uint32 value);

  // optional string unique_id = 13;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 13;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  inline void set_allocated_unique_id(::std::string* unique_id);

  // optional uint32 star = 14;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 14;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // optional uint32 degree = 15;
  inline bool has_degree() const;
  inline void clear_degree();
  static const int kDegreeFieldNumber = 15;
  inline ::google::protobuf::uint32 degree() const;
  inline void set_degree(::google::protobuf::uint32 value);

  // optional uint32 talent_count = 16;
  inline bool has_talent_count() const;
  inline void clear_talent_count();
  static const int kTalentCountFieldNumber = 16;
  inline ::google::protobuf::uint32 talent_count() const;
  inline void set_talent_count(::google::protobuf::uint32 value);

  // optional uint32 talent_degree = 17;
  inline bool has_talent_degree() const;
  inline void clear_talent_degree();
  static const int kTalentDegreeFieldNumber = 17;
  inline ::google::protobuf::uint32 talent_degree() const;
  inline void set_talent_degree(::google::protobuf::uint32 value);

  // repeated uint32 famous = 18;
  inline int famous_size() const;
  inline void clear_famous();
  static const int kFamousFieldNumber = 18;
  inline ::google::protobuf::uint32 famous(int index) const;
  inline void set_famous(int index, ::google::protobuf::uint32 value);
  inline void add_famous(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      famous() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_famous();

  // optional uint32 exp_today = 20;
  inline bool has_exp_today() const;
  inline void clear_exp_today();
  static const int kExpTodayFieldNumber = 20;
  inline ::google::protobuf::uint32 exp_today() const;
  inline void set_exp_today(::google::protobuf::uint32 value);

  // optional uint32 talent_use = 21;
  inline bool has_talent_use() const;
  inline void clear_talent_use();
  static const int kTalentUseFieldNumber = 21;
  inline ::google::protobuf::uint32 talent_use() const;
  inline void set_talent_use(::google::protobuf::uint32 value);

  // optional .proto.common.hero_skill_data skill_data = 22;
  inline bool has_skill_data() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 22;
  inline const ::proto::common::hero_skill_data& skill_data() const;
  inline ::proto::common::hero_skill_data* mutable_skill_data();
  inline ::proto::common::hero_skill_data* release_skill_data();
  inline void set_allocated_skill_data(::proto::common::hero_skill_data* skill_data);

  // optional string last_equip_plan = 23;
  inline bool has_last_equip_plan() const;
  inline void clear_last_equip_plan();
  static const int kLastEquipPlanFieldNumber = 23;
  inline const ::std::string& last_equip_plan() const;
  inline void set_last_equip_plan(const ::std::string& value);
  inline void set_last_equip_plan(const char* value);
  inline void set_last_equip_plan(const char* value, size_t size);
  inline ::std::string* mutable_last_equip_plan();
  inline ::std::string* release_last_equip_plan();
  inline void set_allocated_last_equip_plan(::std::string* last_equip_plan);

  // optional uint32 active_talent_use = 24;
  inline bool has_active_talent_use() const;
  inline void clear_active_talent_use();
  static const int kActiveTalentUseFieldNumber = 24;
  inline ::google::protobuf::uint32 active_talent_use() const;
  inline void set_active_talent_use(::google::protobuf::uint32 value);

  // repeated uint32 plugins = 25;
  inline int plugins_size() const;
  inline void clear_plugins();
  static const int kPluginsFieldNumber = 25;
  inline ::google::protobuf::uint32 plugins(int index) const;
  inline void set_plugins(int index, ::google::protobuf::uint32 value);
  inline void add_plugins(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      plugins() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_plugins();

  // optional uint32 current_plugin = 26;
  inline bool has_current_plugin() const;
  inline void clear_current_plugin();
  static const int kCurrentPluginFieldNumber = 26;
  inline ::google::protobuf::uint32 current_plugin() const;
  inline void set_current_plugin(::google::protobuf::uint32 value);

  // optional string fight_hero_uid = 27;
  inline bool has_fight_hero_uid() const;
  inline void clear_fight_hero_uid();
  static const int kFightHeroUidFieldNumber = 27;
  inline const ::std::string& fight_hero_uid() const;
  inline void set_fight_hero_uid(const ::std::string& value);
  inline void set_fight_hero_uid(const char* value);
  inline void set_fight_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_fight_hero_uid();
  inline ::std::string* release_fight_hero_uid();
  inline void set_allocated_fight_hero_uid(::std::string* fight_hero_uid);

  // optional string nick_name = 28;
  inline bool has_nick_name() const;
  inline void clear_nick_name();
  static const int kNickNameFieldNumber = 28;
  inline const ::std::string& nick_name() const;
  inline void set_nick_name(const ::std::string& value);
  inline void set_nick_name(const char* value);
  inline void set_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_nick_name();
  inline ::std::string* release_nick_name();
  inline void set_allocated_nick_name(::std::string* nick_name);

  // optional uint32 wakeup = 29;
  inline bool has_wakeup() const;
  inline void clear_wakeup();
  static const int kWakeupFieldNumber = 29;
  inline ::google::protobuf::uint32 wakeup() const;
  inline void set_wakeup(::google::protobuf::uint32 value);

  // optional uint32 delete_flag = 30;
  inline bool has_delete_flag() const;
  inline void clear_delete_flag();
  static const int kDeleteFlagFieldNumber = 30;
  inline ::google::protobuf::uint32 delete_flag() const;
  inline void set_delete_flag(::google::protobuf::uint32 value);

  // optional uint32 terry = 31;
  inline bool has_terry() const;
  inline void clear_terry();
  static const int kTerryFieldNumber = 31;
  inline ::google::protobuf::uint32 terry() const;
  inline void set_terry(::google::protobuf::uint32 value);

  // optional uint32 grade_id = 32;
  inline bool has_grade_id() const;
  inline void clear_grade_id();
  static const int kGradeIdFieldNumber = 32;
  inline ::google::protobuf::uint32 grade_id() const;
  inline void set_grade_id(::google::protobuf::uint32 value);

  // optional uint32 debut = 33;
  inline bool has_debut() const;
  inline void clear_debut();
  static const int kDebutFieldNumber = 33;
  inline ::google::protobuf::uint32 debut() const;
  inline void set_debut(::google::protobuf::uint32 value);

  // optional uint32 resource_id = 34;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 34;
  inline ::google::protobuf::uint32 resource_id() const;
  inline void set_resource_id(::google::protobuf::uint32 value);

  // optional uint32 monster_type = 35;
  inline bool has_monster_type() const;
  inline void clear_monster_type();
  static const int kMonsterTypeFieldNumber = 35;
  inline ::google::protobuf::uint32 monster_type() const;
  inline void set_monster_type(::google::protobuf::uint32 value);

  // optional uint32 scale = 36;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 36;
  inline ::google::protobuf::uint32 scale() const;
  inline void set_scale(::google::protobuf::uint32 value);

  // optional string hero_name_id = 37;
  inline bool has_hero_name_id() const;
  inline void clear_hero_name_id();
  static const int kHeroNameIdFieldNumber = 37;
  inline const ::std::string& hero_name_id() const;
  inline void set_hero_name_id(const ::std::string& value);
  inline void set_hero_name_id(const char* value);
  inline void set_hero_name_id(const char* value, size_t size);
  inline ::std::string* mutable_hero_name_id();
  inline ::std::string* release_hero_name_id();
  inline void set_allocated_hero_name_id(::std::string* hero_name_id);

  // optional uint32 boss_hp_plies = 38;
  inline bool has_boss_hp_plies() const;
  inline void clear_boss_hp_plies();
  static const int kBossHpPliesFieldNumber = 38;
  inline ::google::protobuf::uint32 boss_hp_plies() const;
  inline void set_boss_hp_plies(::google::protobuf::uint32 value);

  // optional uint32 event_type = 39;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 39;
  inline ::google::protobuf::uint32 event_type() const;
  inline void set_event_type(::google::protobuf::uint32 value);

  // optional string event_param = 40;
  inline bool has_event_param() const;
  inline void clear_event_param();
  static const int kEventParamFieldNumber = 40;
  inline const ::std::string& event_param() const;
  inline void set_event_param(const ::std::string& value);
  inline void set_event_param(const char* value);
  inline void set_event_param(const char* value, size_t size);
  inline ::std::string* mutable_event_param();
  inline ::std::string* release_event_param();
  inline void set_allocated_event_param(::std::string* event_param);

  // optional uint32 plot_id = 41;
  inline bool has_plot_id() const;
  inline void clear_plot_id();
  static const int kPlotIdFieldNumber = 41;
  inline ::google::protobuf::uint32 plot_id() const;
  inline void set_plot_id(::google::protobuf::uint32 value);

  // optional uint32 would_show = 42;
  inline bool has_would_show() const;
  inline void clear_would_show();
  static const int kWouldShowFieldNumber = 42;
  inline ::google::protobuf::uint32 would_show() const;
  inline void set_would_show(::google::protobuf::uint32 value);

  // optional uint32 hero_state = 43;
  inline bool has_hero_state() const;
  inline void clear_hero_state();
  static const int kHeroStateFieldNumber = 43;
  inline ::google::protobuf::uint32 hero_state() const;
  inline void set_hero_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.base_attr)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_species();
  inline void clear_has_species();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_in_form();
  inline void clear_has_in_form();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_talent_level();
  inline void clear_has_talent_level();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_degree();
  inline void clear_has_degree();
  inline void set_has_talent_count();
  inline void clear_has_talent_count();
  inline void set_has_talent_degree();
  inline void clear_has_talent_degree();
  inline void set_has_exp_today();
  inline void clear_has_exp_today();
  inline void set_has_talent_use();
  inline void clear_has_talent_use();
  inline void set_has_skill_data();
  inline void clear_has_skill_data();
  inline void set_has_last_equip_plan();
  inline void clear_has_last_equip_plan();
  inline void set_has_active_talent_use();
  inline void clear_has_active_talent_use();
  inline void set_has_current_plugin();
  inline void clear_has_current_plugin();
  inline void set_has_fight_hero_uid();
  inline void clear_has_fight_hero_uid();
  inline void set_has_nick_name();
  inline void clear_has_nick_name();
  inline void set_has_wakeup();
  inline void clear_has_wakeup();
  inline void set_has_delete_flag();
  inline void clear_has_delete_flag();
  inline void set_has_terry();
  inline void clear_has_terry();
  inline void set_has_grade_id();
  inline void clear_has_grade_id();
  inline void set_has_debut();
  inline void clear_has_debut();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_monster_type();
  inline void clear_has_monster_type();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_hero_name_id();
  inline void clear_has_hero_name_id();
  inline void set_has_boss_hp_plies();
  inline void clear_has_boss_hp_plies();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_param();
  inline void clear_has_event_param();
  inline void set_has_plot_id();
  inline void clear_has_plot_id();
  inline void set_has_would_show();
  inline void clear_has_would_show();
  inline void set_has_hero_state();
  inline void clear_has_hero_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 id_;
  ::std::string* name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 species_;
  ::google::protobuf::uint32 quality_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_equip > equips_;
  ::google::protobuf::uint32 in_form_;
  ::google::protobuf::uint32 country_;
  ::google::protobuf::uint32 grade_;
  ::google::protobuf::uint32 talent_level_;
  ::std::string* unique_id_;
  ::google::protobuf::uint32 star_;
  ::google::protobuf::uint32 degree_;
  ::google::protobuf::uint32 talent_count_;
  ::google::protobuf::uint32 talent_degree_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > famous_;
  ::google::protobuf::uint32 exp_today_;
  ::google::protobuf::uint32 talent_use_;
  ::proto::common::hero_skill_data* skill_data_;
  ::std::string* last_equip_plan_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > plugins_;
  ::google::protobuf::uint32 active_talent_use_;
  ::google::protobuf::uint32 current_plugin_;
  ::std::string* fight_hero_uid_;
  ::std::string* nick_name_;
  ::google::protobuf::uint32 wakeup_;
  ::google::protobuf::uint32 delete_flag_;
  ::google::protobuf::uint32 terry_;
  ::google::protobuf::uint32 grade_id_;
  ::google::protobuf::uint32 debut_;
  ::google::protobuf::uint32 resource_id_;
  ::google::protobuf::uint32 monster_type_;
  ::google::protobuf::uint32 scale_;
  ::std::string* hero_name_id_;
  ::google::protobuf::uint32 boss_hp_plies_;
  ::google::protobuf::uint32 event_type_;
  ::std::string* event_param_;
  ::google::protobuf::uint32 plot_id_;
  ::google::protobuf::uint32 would_show_;
  ::google::protobuf::uint32 hero_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static base_attr* default_instance_;
};
// -------------------------------------------------------------------

class skill_single : public ::google::protobuf::Message {
 public:
  skill_single();
  virtual ~skill_single();

  skill_single(const skill_single& from);

  inline skill_single& operator=(const skill_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skill_single& default_instance();

  void Swap(skill_single* other);

  // implements Message ----------------------------------------------

  skill_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skill_single& from);
  void MergeFrom(const skill_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 skill_level = 2;
  inline bool has_skill_level() const;
  inline void clear_skill_level();
  static const int kSkillLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_level() const;
  inline void set_skill_level(::google::protobuf::uint32 value);

  // optional uint32 skill_cd = 3;
  inline bool has_skill_cd() const;
  inline void clear_skill_cd();
  static const int kSkillCdFieldNumber = 3;
  inline ::google::protobuf::uint32 skill_cd() const;
  inline void set_skill_cd(::google::protobuf::uint32 value);

  // optional string hero_uid = 4;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 4;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // @@protoc_insertion_point(class_scope:proto.common.skill_single)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_level();
  inline void clear_has_skill_level();
  inline void set_has_skill_cd();
  inline void clear_has_skill_cd();
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 skill_level_;
  ::std::string* hero_uid_;
  ::google::protobuf::uint32 skill_cd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static skill_single* default_instance_;
};
// -------------------------------------------------------------------

class skill_data : public ::google::protobuf::Message {
 public:
  skill_data();
  virtual ~skill_data();

  skill_data(const skill_data& from);

  inline skill_data& operator=(const skill_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skill_data& default_instance();

  void Swap(skill_data* other);

  // implements Message ----------------------------------------------

  skill_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skill_data& from);
  void MergeFrom(const skill_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.skill_single skills = 1;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 1;
  inline const ::proto::common::skill_single& skills(int index) const;
  inline ::proto::common::skill_single* mutable_skills(int index);
  inline ::proto::common::skill_single* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >*
      mutable_skills();

  // @@protoc_insertion_point(class_scope:proto.common.skill_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single > skills_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static skill_data* default_instance_;
};
// -------------------------------------------------------------------

class item_data : public ::google::protobuf::Message {
 public:
  item_data();
  virtual ~item_data();

  item_data(const item_data& from);

  inline item_data& operator=(const item_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const item_data& default_instance();

  void Swap(item_data* other);

  // implements Message ----------------------------------------------

  item_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_data& from);
  void MergeFrom(const item_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.item_single item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::proto::common::item_single& item_list(int index) const;
  inline ::proto::common::item_single* mutable_item_list(int index);
  inline ::proto::common::item_single* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:proto.common.item_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::item_single > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static item_data* default_instance_;
};
// -------------------------------------------------------------------

class item_single : public ::google::protobuf::Message {
 public:
  item_single();
  virtual ~item_single();

  item_single(const item_single& from);

  inline item_single& operator=(const item_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const item_single& default_instance();

  void Swap(item_single* other);

  // implements Message ----------------------------------------------

  item_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_single& from);
  void MergeFrom(const item_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional uint32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // optional uint32 package = 5;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 5;
  inline ::google::protobuf::uint32 package() const;
  inline void set_package(::google::protobuf::uint32 value);

  // optional int32 up_num = 6;
  inline bool has_up_num() const;
  inline void clear_up_num();
  static const int kUpNumFieldNumber = 6;
  inline ::google::protobuf::int32 up_num() const;
  inline void set_up_num(::google::protobuf::int32 value);

  // optional uint32 pos = 7;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 7;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional uint32 param = 8;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 8;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 param2 = 9;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 9;
  inline ::google::protobuf::uint32 param2() const;
  inline void set_param2(::google::protobuf::uint32 value);

  // optional string find_role = 10;
  inline bool has_find_role() const;
  inline void clear_find_role();
  static const int kFindRoleFieldNumber = 10;
  inline const ::std::string& find_role() const;
  inline void set_find_role(const ::std::string& value);
  inline void set_find_role(const char* value);
  inline void set_find_role(const char* value, size_t size);
  inline ::std::string* mutable_find_role();
  inline ::std::string* release_find_role();
  inline void set_allocated_find_role(::std::string* find_role);

  // optional .proto.common.equip_single equip_info = 11;
  inline bool has_equip_info() const;
  inline void clear_equip_info();
  static const int kEquipInfoFieldNumber = 11;
  inline const ::proto::common::equip_single& equip_info() const;
  inline ::proto::common::equip_single* mutable_equip_info();
  inline ::proto::common::equip_single* release_equip_info();
  inline void set_allocated_equip_info(::proto::common::equip_single* equip_info);

  // optional uint32 rarity = 12;
  inline bool has_rarity() const;
  inline void clear_rarity();
  static const int kRarityFieldNumber = 12;
  inline ::google::protobuf::uint32 rarity() const;
  inline void set_rarity(::google::protobuf::uint32 value);

  // optional uint32 state = 13;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 13;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 expired_time = 14;
  inline bool has_expired_time() const;
  inline void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 14;
  inline ::google::protobuf::uint32 expired_time() const;
  inline void set_expired_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.item_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_up_num();
  inline void clear_has_up_num();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_find_role();
  inline void clear_has_find_role();
  inline void set_has_equip_info();
  inline void clear_has_equip_info();
  inline void set_has_rarity();
  inline void clear_has_rarity();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_expired_time();
  inline void clear_has_expired_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 package_;
  ::google::protobuf::int32 up_num_;
  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 param2_;
  ::std::string* find_role_;
  ::proto::common::equip_single* equip_info_;
  ::google::protobuf::uint32 rarity_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 expired_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static item_single* default_instance_;
};
// -------------------------------------------------------------------

class talent_single : public ::google::protobuf::Message {
 public:
  talent_single();
  virtual ~talent_single();

  talent_single(const talent_single& from);

  inline talent_single& operator=(const talent_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const talent_single& default_instance();

  void Swap(talent_single* other);

  // implements Message ----------------------------------------------

  talent_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const talent_single& from);
  void MergeFrom(const talent_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.talent_single)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static talent_single* default_instance_;
};
// -------------------------------------------------------------------

class talent_data : public ::google::protobuf::Message {
 public:
  talent_data();
  virtual ~talent_data();

  talent_data(const talent_data& from);

  inline talent_data& operator=(const talent_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const talent_data& default_instance();

  void Swap(talent_data* other);

  // implements Message ----------------------------------------------

  talent_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const talent_data& from);
  void MergeFrom(const talent_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.talent_single talent_list = 1;
  inline int talent_list_size() const;
  inline void clear_talent_list();
  static const int kTalentListFieldNumber = 1;
  inline const ::proto::common::talent_single& talent_list(int index) const;
  inline ::proto::common::talent_single* mutable_talent_list(int index);
  inline ::proto::common::talent_single* add_talent_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::talent_single >&
      talent_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::talent_single >*
      mutable_talent_list();

  // @@protoc_insertion_point(class_scope:proto.common.talent_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::talent_single > talent_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static talent_data* default_instance_;
};
// -------------------------------------------------------------------

class formation_pair : public ::google::protobuf::Message {
 public:
  formation_pair();
  virtual ~formation_pair();

  formation_pair(const formation_pair& from);

  inline formation_pair& operator=(const formation_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const formation_pair& default_instance();

  void Swap(formation_pair* other);

  // implements Message ----------------------------------------------

  formation_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const formation_pair& from);
  void MergeFrom(const formation_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional string unique_id = 2;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 2;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  inline void set_allocated_unique_id(::std::string* unique_id);

  // optional uint32 plugin = 3;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 3;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 grade = 4;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 4;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // optional uint32 star = 5;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 5;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // optional uint32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string owner_id = 7;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 7;
  inline const ::std::string& owner_id() const;
  inline void set_owner_id(const ::std::string& value);
  inline void set_owner_id(const char* value);
  inline void set_owner_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_id();
  inline ::std::string* release_owner_id();
  inline void set_allocated_owner_id(::std::string* owner_id);

  // @@protoc_insertion_point(class_scope:proto.common.formation_pair)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* unique_id_;
  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 grade_;
  ::google::protobuf::uint32 star_;
  ::std::string* owner_id_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static formation_pair* default_instance_;
};
// -------------------------------------------------------------------

class formation_single : public ::google::protobuf::Message {
 public:
  formation_single();
  virtual ~formation_single();

  formation_single(const formation_single& from);

  inline formation_single& operator=(const formation_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const formation_single& default_instance();

  void Swap(formation_single* other);

  // implements Message ----------------------------------------------

  formation_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const formation_single& from);
  void MergeFrom(const formation_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 formation_index = 1;
  inline bool has_formation_index() const;
  inline void clear_formation_index();
  static const int kFormationIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 formation_index() const;
  inline void set_formation_index(::google::protobuf::uint32 value);

  // optional uint32 tactic_id = 2;
  inline bool has_tactic_id() const;
  inline void clear_tactic_id();
  static const int kTacticIdFieldNumber = 2;
  inline ::google::protobuf::uint32 tactic_id() const;
  inline void set_tactic_id(::google::protobuf::uint32 value);

  // repeated .proto.common.formation_pair formations = 3;
  inline int formations_size() const;
  inline void clear_formations();
  static const int kFormationsFieldNumber = 3;
  inline const ::proto::common::formation_pair& formations(int index) const;
  inline ::proto::common::formation_pair* mutable_formations(int index);
  inline ::proto::common::formation_pair* add_formations();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::formation_pair >&
      formations() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::formation_pair >*
      mutable_formations();

  // @@protoc_insertion_point(class_scope:proto.common.formation_single)
 private:
  inline void set_has_formation_index();
  inline void clear_has_formation_index();
  inline void set_has_tactic_id();
  inline void clear_has_tactic_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 formation_index_;
  ::google::protobuf::uint32 tactic_id_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::formation_pair > formations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static formation_single* default_instance_;
};
// -------------------------------------------------------------------

class formation_data : public ::google::protobuf::Message {
 public:
  formation_data();
  virtual ~formation_data();

  formation_data(const formation_data& from);

  inline formation_data& operator=(const formation_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const formation_data& default_instance();

  void Swap(formation_data* other);

  // implements Message ----------------------------------------------

  formation_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const formation_data& from);
  void MergeFrom(const formation_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.formation_single formation_list = 1;
  inline int formation_list_size() const;
  inline void clear_formation_list();
  static const int kFormationListFieldNumber = 1;
  inline const ::proto::common::formation_single& formation_list(int index) const;
  inline ::proto::common::formation_single* mutable_formation_list(int index);
  inline ::proto::common::formation_single* add_formation_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::formation_single >&
      formation_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::formation_single >*
      mutable_formation_list();

  // optional uint32 cur_formation_id = 2;
  inline bool has_cur_formation_id() const;
  inline void clear_cur_formation_id();
  static const int kCurFormationIdFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_formation_id() const;
  inline void set_cur_formation_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.formation_data)
 private:
  inline void set_has_cur_formation_id();
  inline void clear_has_cur_formation_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::formation_single > formation_list_;
  ::google::protobuf::uint32 cur_formation_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static formation_data* default_instance_;
};
// -------------------------------------------------------------------

class fate_pair : public ::google::protobuf::Message {
 public:
  fate_pair();
  virtual ~fate_pair();

  fate_pair(const fate_pair& from);

  inline fate_pair& operator=(const fate_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fate_pair& default_instance();

  void Swap(fate_pair* other);

  // implements Message ----------------------------------------------

  fate_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fate_pair& from);
  void MergeFrom(const fate_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fate_tid = 1;
  inline bool has_fate_tid() const;
  inline void clear_fate_tid();
  static const int kFateTidFieldNumber = 1;
  inline ::google::protobuf::uint32 fate_tid() const;
  inline void set_fate_tid(::google::protobuf::uint32 value);

  // optional int32 fate_level = 2;
  inline bool has_fate_level() const;
  inline void clear_fate_level();
  static const int kFateLevelFieldNumber = 2;
  inline ::google::protobuf::int32 fate_level() const;
  inline void set_fate_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fate_pair)
 private:
  inline void set_has_fate_tid();
  inline void clear_has_fate_tid();
  inline void set_has_fate_level();
  inline void clear_has_fate_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 fate_tid_;
  ::google::protobuf::int32 fate_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fate_pair* default_instance_;
};
// -------------------------------------------------------------------

class hero_single : public ::google::protobuf::Message {
 public:
  hero_single();
  virtual ~hero_single();

  hero_single(const hero_single& from);

  inline hero_single& operator=(const hero_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_single& default_instance();

  void Swap(hero_single* other);

  // implements Message ----------------------------------------------

  hero_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_single& from);
  void MergeFrom(const hero_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.base_attr base_attr = 1;
  inline bool has_base_attr() const;
  inline void clear_base_attr();
  static const int kBaseAttrFieldNumber = 1;
  inline const ::proto::common::base_attr& base_attr() const;
  inline ::proto::common::base_attr* mutable_base_attr();
  inline ::proto::common::base_attr* release_base_attr();
  inline void set_allocated_base_attr(::proto::common::base_attr* base_attr);

  // optional .proto.common.fight_attr fight_attr = 2;
  inline bool has_fight_attr() const;
  inline void clear_fight_attr();
  static const int kFightAttrFieldNumber = 2;
  inline const ::proto::common::fight_attr& fight_attr() const;
  inline ::proto::common::fight_attr* mutable_fight_attr();
  inline ::proto::common::fight_attr* release_fight_attr();
  inline void set_allocated_fight_attr(::proto::common::fight_attr* fight_attr);

  // optional .proto.common.talent_data talent_data = 3;
  inline bool has_talent_data() const;
  inline void clear_talent_data();
  static const int kTalentDataFieldNumber = 3;
  inline const ::proto::common::talent_data& talent_data() const;
  inline ::proto::common::talent_data* mutable_talent_data();
  inline ::proto::common::talent_data* release_talent_data();
  inline void set_allocated_talent_data(::proto::common::talent_data* talent_data);

  // optional .proto.common.skill_data skill = 4;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 4;
  inline const ::proto::common::skill_data& skill() const;
  inline ::proto::common::skill_data* mutable_skill();
  inline ::proto::common::skill_data* release_skill();
  inline void set_allocated_skill(::proto::common::skill_data* skill);

  // optional int32 save_hp = 5;
  inline bool has_save_hp() const;
  inline void clear_save_hp();
  static const int kSaveHpFieldNumber = 5;
  inline ::google::protobuf::int32 save_hp() const;
  inline void set_save_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.common.hero_single)
 private:
  inline void set_has_base_attr();
  inline void clear_has_base_attr();
  inline void set_has_fight_attr();
  inline void clear_has_fight_attr();
  inline void set_has_talent_data();
  inline void clear_has_talent_data();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_save_hp();
  inline void clear_has_save_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::base_attr* base_attr_;
  ::proto::common::fight_attr* fight_attr_;
  ::proto::common::talent_data* talent_data_;
  ::proto::common::skill_data* skill_;
  ::google::protobuf::int32 save_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_single* default_instance_;
};
// -------------------------------------------------------------------

class hero_data : public ::google::protobuf::Message {
 public:
  hero_data();
  virtual ~hero_data();

  hero_data(const hero_data& from);

  inline hero_data& operator=(const hero_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_data& default_instance();

  void Swap(hero_data* other);

  // implements Message ----------------------------------------------

  hero_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_data& from);
  void MergeFrom(const hero_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.hero_single hero_list = 1;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 1;
  inline const ::proto::common::hero_single& hero_list(int index) const;
  inline ::proto::common::hero_single* mutable_hero_list(int index);
  inline ::proto::common::hero_single* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_special_hero_single : public ::google::protobuf::Message {
 public:
  fight_special_hero_single();
  virtual ~fight_special_hero_single();

  fight_special_hero_single(const fight_special_hero_single& from);

  inline fight_special_hero_single& operator=(const fight_special_hero_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_special_hero_single& default_instance();

  void Swap(fight_special_hero_single* other);

  // implements Message ----------------------------------------------

  fight_special_hero_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_special_hero_single& from);
  void MergeFrom(const fight_special_hero_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 save_hp = 3;
  inline bool has_save_hp() const;
  inline void clear_save_hp();
  static const int kSaveHpFieldNumber = 3;
  inline ::google::protobuf::uint32 save_hp() const;
  inline void set_save_hp(::google::protobuf::uint32 value);

  // optional uint32 max_hp = 4;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 4;
  inline ::google::protobuf::uint32 max_hp() const;
  inline void set_max_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_special_hero_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_save_hp();
  inline void clear_has_save_hp();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 save_hp_;
  ::google::protobuf::uint32 max_hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_special_hero_single* default_instance_;
};
// -------------------------------------------------------------------

class fight_special_hero_data : public ::google::protobuf::Message {
 public:
  fight_special_hero_data();
  virtual ~fight_special_hero_data();

  fight_special_hero_data(const fight_special_hero_data& from);

  inline fight_special_hero_data& operator=(const fight_special_hero_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_special_hero_data& default_instance();

  void Swap(fight_special_hero_data* other);

  // implements Message ----------------------------------------------

  fight_special_hero_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_special_hero_data& from);
  void MergeFrom(const fight_special_hero_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_special_hero_single hero_list = 1;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 1;
  inline const ::proto::common::fight_special_hero_single& hero_list(int index) const;
  inline ::proto::common::fight_special_hero_single* mutable_hero_list(int index);
  inline ::proto::common::fight_special_hero_single* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_special_hero_single >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_special_hero_single >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_special_hero_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_special_hero_single > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_special_hero_data* default_instance_;
};
// -------------------------------------------------------------------

class luckydraw_award : public ::google::protobuf::Message {
 public:
  luckydraw_award();
  virtual ~luckydraw_award();

  luckydraw_award(const luckydraw_award& from);

  inline luckydraw_award& operator=(const luckydraw_award& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luckydraw_award& default_instance();

  void Swap(luckydraw_award* other);

  // implements Message ----------------------------------------------

  luckydraw_award* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luckydraw_award& from);
  void MergeFrom(const luckydraw_award& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hero_tid = 1;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 1;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional uint32 item_tid = 2;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 2;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_count = 3;
  inline bool has_item_count() const;
  inline void clear_item_count();
  static const int kItemCountFieldNumber = 3;
  inline ::google::protobuf::uint32 item_count() const;
  inline void set_item_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.luckydraw_award)
 private:
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_count();
  inline void clear_has_item_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luckydraw_award* default_instance_;
};
// -------------------------------------------------------------------

class role_change_data : public ::google::protobuf::Message {
 public:
  role_change_data();
  virtual ~role_change_data();

  role_change_data(const role_change_data& from);

  inline role_change_data& operator=(const role_change_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_change_data& default_instance();

  void Swap(role_change_data* other);

  // implements Message ----------------------------------------------

  role_change_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_change_data& from);
  void MergeFrom(const role_change_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.personal_info per_info = 1;
  inline bool has_per_info() const;
  inline void clear_per_info();
  static const int kPerInfoFieldNumber = 1;
  inline const ::proto::common::personal_info& per_info() const;
  inline ::proto::common::personal_info* mutable_per_info();
  inline ::proto::common::personal_info* release_per_info();
  inline void set_allocated_per_info(::proto::common::personal_info* per_info);

  // optional .proto.common.item_data item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::proto::common::item_data& item() const;
  inline ::proto::common::item_data* mutable_item();
  inline ::proto::common::item_data* release_item();
  inline void set_allocated_item(::proto::common::item_data* item);

  // optional .proto.common.hero_data hero = 3;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 3;
  inline const ::proto::common::hero_data& hero() const;
  inline ::proto::common::hero_data* mutable_hero();
  inline ::proto::common::hero_data* release_hero();
  inline void set_allocated_hero(::proto::common::hero_data* hero);

  // optional .proto.common.role_trade_info trade_info = 5;
  inline bool has_trade_info() const;
  inline void clear_trade_info();
  static const int kTradeInfoFieldNumber = 5;
  inline const ::proto::common::role_trade_info& trade_info() const;
  inline ::proto::common::role_trade_info* mutable_trade_info();
  inline ::proto::common::role_trade_info* release_trade_info();
  inline void set_allocated_trade_info(::proto::common::role_trade_info* trade_info);

  // optional .proto.common.role_trade_item trade_item = 6;
  inline bool has_trade_item() const;
  inline void clear_trade_item();
  static const int kTradeItemFieldNumber = 6;
  inline const ::proto::common::role_trade_item& trade_item() const;
  inline ::proto::common::role_trade_item* mutable_trade_item();
  inline ::proto::common::role_trade_item* release_trade_item();
  inline void set_allocated_trade_item(::proto::common::role_trade_item* trade_item);

  // optional uint32 level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 exp = 8;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 8;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional .proto.common.mount_data mount = 9;
  inline bool has_mount() const;
  inline void clear_mount();
  static const int kMountFieldNumber = 9;
  inline const ::proto::common::mount_data& mount() const;
  inline ::proto::common::mount_data* mutable_mount();
  inline ::proto::common::mount_data* release_mount();
  inline void set_allocated_mount(::proto::common::mount_data* mount);

  // optional .proto.common.multi_time_data multi_time = 10;
  inline bool has_multi_time() const;
  inline void clear_multi_time();
  static const int kMultiTimeFieldNumber = 10;
  inline const ::proto::common::multi_time_data& multi_time() const;
  inline ::proto::common::multi_time_data* mutable_multi_time();
  inline ::proto::common::multi_time_data* release_multi_time();
  inline void set_allocated_multi_time(::proto::common::multi_time_data* multi_time);

  // optional .proto.common.recharge_data recharge = 11;
  inline bool has_recharge() const;
  inline void clear_recharge();
  static const int kRechargeFieldNumber = 11;
  inline const ::proto::common::recharge_data& recharge() const;
  inline ::proto::common::recharge_data* mutable_recharge();
  inline ::proto::common::recharge_data* release_recharge();
  inline void set_allocated_recharge(::proto::common::recharge_data* recharge);

  // optional uint32 charm = 12;
  inline bool has_charm() const;
  inline void clear_charm();
  static const int kCharmFieldNumber = 12;
  inline ::google::protobuf::uint32 charm() const;
  inline void set_charm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_change_data)
 private:
  inline void set_has_per_info();
  inline void clear_has_per_info();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_hero();
  inline void clear_has_hero();
  inline void set_has_trade_info();
  inline void clear_has_trade_info();
  inline void set_has_trade_item();
  inline void clear_has_trade_item();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_mount();
  inline void clear_has_mount();
  inline void set_has_multi_time();
  inline void clear_has_multi_time();
  inline void set_has_recharge();
  inline void clear_has_recharge();
  inline void set_has_charm();
  inline void clear_has_charm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::personal_info* per_info_;
  ::proto::common::item_data* item_;
  ::proto::common::hero_data* hero_;
  ::proto::common::role_trade_info* trade_info_;
  ::proto::common::role_trade_item* trade_item_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 exp_;
  ::proto::common::mount_data* mount_;
  ::proto::common::multi_time_data* multi_time_;
  ::proto::common::recharge_data* recharge_;
  ::google::protobuf::uint32 charm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_change_data* default_instance_;
};
// -------------------------------------------------------------------

class task_state : public ::google::protobuf::Message {
 public:
  task_state();
  virtual ~task_state();

  task_state(const task_state& from);

  inline task_state& operator=(const task_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_state& default_instance();

  void Swap(task_state* other);

  // implements Message ----------------------------------------------

  task_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_state& from);
  void MergeFrom(const task_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string progress = 2;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 2;
  inline const ::std::string& progress() const;
  inline void set_progress(const ::std::string& value);
  inline void set_progress(const char* value);
  inline void set_progress(const char* value, size_t size);
  inline ::std::string* mutable_progress();
  inline ::std::string* release_progress();
  inline void set_allocated_progress(::std::string* progress);

  // optional uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 circle_count = 4;
  inline bool has_circle_count() const;
  inline void clear_circle_count();
  static const int kCircleCountFieldNumber = 4;
  inline ::google::protobuf::uint32 circle_count() const;
  inline void set_circle_count(::google::protobuf::uint32 value);

  // optional uint32 max_circle_count = 5;
  inline bool has_max_circle_count() const;
  inline void clear_max_circle_count();
  static const int kMaxCircleCountFieldNumber = 5;
  inline ::google::protobuf::uint32 max_circle_count() const;
  inline void set_max_circle_count(::google::protobuf::uint32 value);

  // optional uint64 uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 circle_id = 9;
  inline bool has_circle_id() const;
  inline void clear_circle_id();
  static const int kCircleIdFieldNumber = 9;
  inline ::google::protobuf::uint32 circle_id() const;
  inline void set_circle_id(::google::protobuf::uint32 value);

  // optional uint32 accept_level = 10;
  inline bool has_accept_level() const;
  inline void clear_accept_level();
  static const int kAcceptLevelFieldNumber = 10;
  inline ::google::protobuf::uint32 accept_level() const;
  inline void set_accept_level(::google::protobuf::uint32 value);

  // optional uint32 star = 11;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 11;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.task_state)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_circle_count();
  inline void clear_has_circle_count();
  inline void set_has_max_circle_count();
  inline void clear_has_max_circle_count();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_circle_id();
  inline void clear_has_circle_id();
  inline void set_has_accept_level();
  inline void clear_has_accept_level();
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* progress_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 circle_count_;
  ::google::protobuf::uint32 max_circle_count_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 circle_id_;
  ::google::protobuf::uint32 accept_level_;
  ::google::protobuf::uint32 star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_state* default_instance_;
};
// -------------------------------------------------------------------

class task_data : public ::google::protobuf::Message {
 public:
  task_data();
  virtual ~task_data();

  task_data(const task_data& from);

  inline task_data& operator=(const task_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_data& default_instance();

  void Swap(task_data* other);

  // implements Message ----------------------------------------------

  task_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_data& from);
  void MergeFrom(const task_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.task_state tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::proto::common::task_state& tasks(int index) const;
  inline ::proto::common::task_state* mutable_tasks(int index);
  inline ::proto::common::task_state* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >*
      mutable_tasks();

  // optional uint32 shilian_count = 2;
  inline bool has_shilian_count() const;
  inline void clear_shilian_count();
  static const int kShilianCountFieldNumber = 2;
  inline ::google::protobuf::uint32 shilian_count() const;
  inline void set_shilian_count(::google::protobuf::uint32 value);

  // repeated uint32 shilian_seq = 3;
  inline int shilian_seq_size() const;
  inline void clear_shilian_seq();
  static const int kShilianSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 shilian_seq(int index) const;
  inline void set_shilian_seq(int index, ::google::protobuf::uint32 value);
  inline void add_shilian_seq(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      shilian_seq() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_shilian_seq();

  // repeated uint32 circle_task_comp_list = 4;
  inline int circle_task_comp_list_size() const;
  inline void clear_circle_task_comp_list();
  static const int kCircleTaskCompListFieldNumber = 4;
  inline ::google::protobuf::uint32 circle_task_comp_list(int index) const;
  inline void set_circle_task_comp_list(int index, ::google::protobuf::uint32 value);
  inline void add_circle_task_comp_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      circle_task_comp_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_circle_task_comp_list();

  // repeated uint32 comp_task_list = 5;
  inline int comp_task_list_size() const;
  inline void clear_comp_task_list();
  static const int kCompTaskListFieldNumber = 5;
  inline ::google::protobuf::uint32 comp_task_list(int index) const;
  inline void set_comp_task_list(int index, ::google::protobuf::uint32 value);
  inline void add_comp_task_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      comp_task_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_comp_task_list();

  // optional .proto.common.task_event event_data = 6;
  inline bool has_event_data() const;
  inline void clear_event_data();
  static const int kEventDataFieldNumber = 6;
  inline const ::proto::common::task_event& event_data() const;
  inline ::proto::common::task_event* mutable_event_data();
  inline ::proto::common::task_event* release_event_data();
  inline void set_allocated_event_data(::proto::common::task_event* event_data);

  // @@protoc_insertion_point(class_scope:proto.common.task_data)
 private:
  inline void set_has_shilian_count();
  inline void clear_has_shilian_count();
  inline void set_has_event_data();
  inline void clear_has_event_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::task_state > tasks_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > shilian_seq_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > circle_task_comp_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > comp_task_list_;
  ::proto::common::task_event* event_data_;
  ::google::protobuf::uint32 shilian_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_data* default_instance_;
};
// -------------------------------------------------------------------

class family_member : public ::google::protobuf::Message {
 public:
  family_member();
  virtual ~family_member();

  family_member(const family_member& from);

  inline family_member& operator=(const family_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_member& default_instance();

  void Swap(family_member* other);

  // implements Message ----------------------------------------------

  family_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_member& from);
  void MergeFrom(const family_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 officer = 3;
  inline bool has_officer() const;
  inline void clear_officer();
  static const int kOfficerFieldNumber = 3;
  inline ::google::protobuf::uint32 officer() const;
  inline void set_officer(::google::protobuf::uint32 value);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 fighting = 5;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 5;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 last_offline_time = 6;
  inline bool has_last_offline_time() const;
  inline void clear_last_offline_time();
  static const int kLastOfflineTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 last_offline_time() const;
  inline void set_last_offline_time(::google::protobuf::uint32 value);

  // optional uint32 total_family_contribution = 7;
  inline bool has_total_family_contribution() const;
  inline void clear_total_family_contribution();
  static const int kTotalFamilyContributionFieldNumber = 7;
  inline ::google::protobuf::uint32 total_family_contribution() const;
  inline void set_total_family_contribution(::google::protobuf::uint32 value);

  // optional uint32 left_family_contribution = 8;
  inline bool has_left_family_contribution() const;
  inline void clear_left_family_contribution();
  static const int kLeftFamilyContributionFieldNumber = 8;
  inline ::google::protobuf::uint32 left_family_contribution() const;
  inline void set_left_family_contribution(::google::protobuf::uint32 value);

  // optional uint32 plugin = 9;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 9;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 glory = 10;
  inline bool has_glory() const;
  inline void clear_glory();
  static const int kGloryFieldNumber = 10;
  inline ::google::protobuf::uint32 glory() const;
  inline void set_glory(::google::protobuf::uint32 value);

  // optional uint32 prayer_contribution = 11;
  inline bool has_prayer_contribution() const;
  inline void clear_prayer_contribution();
  static const int kPrayerContributionFieldNumber = 11;
  inline ::google::protobuf::uint32 prayer_contribution() const;
  inline void set_prayer_contribution(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_member)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_officer();
  inline void clear_has_officer();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_last_offline_time();
  inline void clear_has_last_offline_time();
  inline void set_has_total_family_contribution();
  inline void clear_has_total_family_contribution();
  inline void set_has_left_family_contribution();
  inline void clear_has_left_family_contribution();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_glory();
  inline void clear_has_glory();
  inline void set_has_prayer_contribution();
  inline void clear_has_prayer_contribution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 officer_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 last_offline_time_;
  ::google::protobuf::uint32 total_family_contribution_;
  ::google::protobuf::uint32 left_family_contribution_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 glory_;
  ::google::protobuf::uint32 prayer_contribution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_member* default_instance_;
};
// -------------------------------------------------------------------

class family_data : public ::google::protobuf::Message {
 public:
  family_data();
  virtual ~family_data();

  family_data(const family_data& from);

  inline family_data& operator=(const family_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_data& default_instance();

  void Swap(family_data* other);

  // implements Message ----------------------------------------------

  family_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_data& from);
  void MergeFrom(const family_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline ::google::protobuf::uint32 country() const;
  inline void set_country(::google::protobuf::uint32 value);

  // optional string patriarch = 5;
  inline bool has_patriarch() const;
  inline void clear_patriarch();
  static const int kPatriarchFieldNumber = 5;
  inline const ::std::string& patriarch() const;
  inline void set_patriarch(const ::std::string& value);
  inline void set_patriarch(const char* value);
  inline void set_patriarch(const char* value, size_t size);
  inline ::std::string* mutable_patriarch();
  inline ::std::string* release_patriarch();
  inline void set_allocated_patriarch(::std::string* patriarch);

  // optional string creator = 6;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 6;
  inline const ::std::string& creator() const;
  inline void set_creator(const ::std::string& value);
  inline void set_creator(const char* value);
  inline void set_creator(const char* value, size_t size);
  inline ::std::string* mutable_creator();
  inline ::std::string* release_creator();
  inline void set_allocated_creator(::std::string* creator);

  // optional uint32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 max_money = 8;
  inline bool has_max_money() const;
  inline void clear_max_money();
  static const int kMaxMoneyFieldNumber = 8;
  inline ::google::protobuf::uint32 max_money() const;
  inline void set_max_money(::google::protobuf::uint32 value);

  // optional uint32 matain_cost = 9;
  inline bool has_matain_cost() const;
  inline void clear_matain_cost();
  static const int kMatainCostFieldNumber = 9;
  inline ::google::protobuf::uint32 matain_cost() const;
  inline void set_matain_cost(::google::protobuf::uint32 value);

  // optional string declaration = 10;
  inline bool has_declaration() const;
  inline void clear_declaration();
  static const int kDeclarationFieldNumber = 10;
  inline const ::std::string& declaration() const;
  inline void set_declaration(const ::std::string& value);
  inline void set_declaration(const char* value);
  inline void set_declaration(const char* value, size_t size);
  inline ::std::string* mutable_declaration();
  inline ::std::string* release_declaration();
  inline void set_allocated_declaration(::std::string* declaration);

  // optional string notice = 11;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 11;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional uint32 prosperity = 12;
  inline bool has_prosperity() const;
  inline void clear_prosperity();
  static const int kProsperityFieldNumber = 12;
  inline ::google::protobuf::uint32 prosperity() const;
  inline void set_prosperity(::google::protobuf::uint32 value);

  // optional uint32 prestige = 13;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 13;
  inline ::google::protobuf::uint32 prestige() const;
  inline void set_prestige(::google::protobuf::uint32 value);

  // optional uint32 territory = 14;
  inline bool has_territory() const;
  inline void clear_territory();
  static const int kTerritoryFieldNumber = 14;
  inline ::google::protobuf::uint32 territory() const;
  inline void set_territory(::google::protobuf::uint32 value);

  // optional bool auto_newbie = 15;
  inline bool has_auto_newbie() const;
  inline void clear_auto_newbie();
  static const int kAutoNewbieFieldNumber = 15;
  inline bool auto_newbie() const;
  inline void set_auto_newbie(bool value);

  // optional uint32 member_cnt_max = 16;
  inline bool has_member_cnt_max() const;
  inline void clear_member_cnt_max();
  static const int kMemberCntMaxFieldNumber = 16;
  inline ::google::protobuf::uint32 member_cnt_max() const;
  inline void set_member_cnt_max(::google::protobuf::uint32 value);

  // optional uint32 loyalty = 17;
  inline bool has_loyalty() const;
  inline void clear_loyalty();
  static const int kLoyaltyFieldNumber = 17;
  inline ::google::protobuf::uint32 loyalty() const;
  inline void set_loyalty(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_patriarch();
  inline void clear_has_patriarch();
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_max_money();
  inline void clear_has_max_money();
  inline void set_has_matain_cost();
  inline void clear_has_matain_cost();
  inline void set_has_declaration();
  inline void clear_has_declaration();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_prosperity();
  inline void clear_has_prosperity();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_territory();
  inline void clear_has_territory();
  inline void set_has_auto_newbie();
  inline void clear_has_auto_newbie();
  inline void set_has_member_cnt_max();
  inline void clear_has_member_cnt_max();
  inline void set_has_loyalty();
  inline void clear_has_loyalty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 country_;
  ::std::string* patriarch_;
  ::std::string* creator_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 max_money_;
  ::std::string* declaration_;
  ::google::protobuf::uint32 matain_cost_;
  ::google::protobuf::uint32 prosperity_;
  ::std::string* notice_;
  ::google::protobuf::uint32 prestige_;
  ::google::protobuf::uint32 territory_;
  bool auto_newbie_;
  ::google::protobuf::uint32 member_cnt_max_;
  ::google::protobuf::uint32 loyalty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_data* default_instance_;
};
// -------------------------------------------------------------------

class family_list_info : public ::google::protobuf::Message {
 public:
  family_list_info();
  virtual ~family_list_info();

  family_list_info(const family_list_info& from);

  inline family_list_info& operator=(const family_list_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_list_info& default_instance();

  void Swap(family_list_info* other);

  // implements Message ----------------------------------------------

  family_list_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_list_info& from);
  void MergeFrom(const family_list_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.family_data base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::proto::common::family_data& base() const;
  inline ::proto::common::family_data* mutable_base();
  inline ::proto::common::family_data* release_base();
  inline void set_allocated_base(::proto::common::family_data* base);

  // optional uint32 member_cnt = 2;
  inline bool has_member_cnt() const;
  inline void clear_member_cnt();
  static const int kMemberCntFieldNumber = 2;
  inline ::google::protobuf::uint32 member_cnt() const;
  inline void set_member_cnt(::google::protobuf::uint32 value);

  // optional string patriarch_name = 3;
  inline bool has_patriarch_name() const;
  inline void clear_patriarch_name();
  static const int kPatriarchNameFieldNumber = 3;
  inline const ::std::string& patriarch_name() const;
  inline void set_patriarch_name(const ::std::string& value);
  inline void set_patriarch_name(const char* value);
  inline void set_patriarch_name(const char* value, size_t size);
  inline ::std::string* mutable_patriarch_name();
  inline ::std::string* release_patriarch_name();
  inline void set_allocated_patriarch_name(::std::string* patriarch_name);

  // optional string patriarch_uid = 4;
  inline bool has_patriarch_uid() const;
  inline void clear_patriarch_uid();
  static const int kPatriarchUidFieldNumber = 4;
  inline const ::std::string& patriarch_uid() const;
  inline void set_patriarch_uid(const ::std::string& value);
  inline void set_patriarch_uid(const char* value);
  inline void set_patriarch_uid(const char* value, size_t size);
  inline ::std::string* mutable_patriarch_uid();
  inline ::std::string* release_patriarch_uid();
  inline void set_allocated_patriarch_uid(::std::string* patriarch_uid);

  // @@protoc_insertion_point(class_scope:proto.common.family_list_info)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_member_cnt();
  inline void clear_has_member_cnt();
  inline void set_has_patriarch_name();
  inline void clear_has_patriarch_name();
  inline void set_has_patriarch_uid();
  inline void clear_has_patriarch_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::family_data* base_;
  ::std::string* patriarch_name_;
  ::std::string* patriarch_uid_;
  ::google::protobuf::uint32 member_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_list_info* default_instance_;
};
// -------------------------------------------------------------------

class family_build_data : public ::google::protobuf::Message {
 public:
  family_build_data();
  virtual ~family_build_data();

  family_build_data(const family_build_data& from);

  inline family_build_data& operator=(const family_build_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_build_data& default_instance();

  void Swap(family_build_data* other);

  // implements Message ----------------------------------------------

  family_build_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_build_data& from);
  void MergeFrom(const family_build_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.family_build_type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::common::family_build_type type() const;
  inline void set_type(::proto::common::family_build_type value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 cd_time = 3;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 cd_time() const;
  inline void set_cd_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_build_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 cd_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_build_data* default_instance_;
};
// -------------------------------------------------------------------

class family_apply_member : public ::google::protobuf::Message {
 public:
  family_apply_member();
  virtual ~family_apply_member();

  family_apply_member(const family_apply_member& from);

  inline family_apply_member& operator=(const family_apply_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_apply_member& default_instance();

  void Swap(family_apply_member* other);

  // implements Message ----------------------------------------------

  family_apply_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_apply_member& from);
  void MergeFrom(const family_apply_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 fighting = 4;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 4;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 plugin = 5;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 5;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 apply_time = 6;
  inline bool has_apply_time() const;
  inline void clear_apply_time();
  static const int kApplyTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 apply_time() const;
  inline void set_apply_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_apply_member)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_apply_time();
  inline void clear_has_apply_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 apply_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_apply_member* default_instance_;
};
// -------------------------------------------------------------------

class family_gift_data : public ::google::protobuf::Message {
 public:
  family_gift_data();
  virtual ~family_gift_data();

  family_gift_data(const family_gift_data& from);

  inline family_gift_data& operator=(const family_gift_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_gift_data& default_instance();

  void Swap(family_gift_data* other);

  // implements Message ----------------------------------------------

  family_gift_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_gift_data& from);
  void MergeFrom(const family_gift_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional uint32 gift_times = 2;
  inline bool has_gift_times() const;
  inline void clear_gift_times();
  static const int kGiftTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 gift_times() const;
  inline void set_gift_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_gift_data)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_gift_times();
  inline void clear_has_gift_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::google::protobuf::uint32 gift_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_gift_data* default_instance_;
};
// -------------------------------------------------------------------

class family_gift_data_list : public ::google::protobuf::Message {
 public:
  family_gift_data_list();
  virtual ~family_gift_data_list();

  family_gift_data_list(const family_gift_data_list& from);

  inline family_gift_data_list& operator=(const family_gift_data_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_gift_data_list& default_instance();

  void Swap(family_gift_data_list* other);

  // implements Message ----------------------------------------------

  family_gift_data_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_gift_data_list& from);
  void MergeFrom(const family_gift_data_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_gift_data gift_datas = 1;
  inline int gift_datas_size() const;
  inline void clear_gift_datas();
  static const int kGiftDatasFieldNumber = 1;
  inline const ::proto::common::family_gift_data& gift_datas(int index) const;
  inline ::proto::common::family_gift_data* mutable_gift_datas(int index);
  inline ::proto::common::family_gift_data* add_gift_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_gift_data >&
      gift_datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_gift_data >*
      mutable_gift_datas();

  // @@protoc_insertion_point(class_scope:proto.common.family_gift_data_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_gift_data > gift_datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_gift_data_list* default_instance_;
};
// -------------------------------------------------------------------

class family_prayer_data : public ::google::protobuf::Message {
 public:
  family_prayer_data();
  virtual ~family_prayer_data();

  family_prayer_data(const family_prayer_data& from);

  inline family_prayer_data& operator=(const family_prayer_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_prayer_data& default_instance();

  void Swap(family_prayer_data* other);

  // implements Message ----------------------------------------------

  family_prayer_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_prayer_data& from);
  void MergeFrom(const family_prayer_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 officer = 3;
  inline bool has_officer() const;
  inline void clear_officer();
  static const int kOfficerFieldNumber = 3;
  inline ::google::protobuf::uint32 officer() const;
  inline void set_officer(::google::protobuf::uint32 value);

  // optional uint32 plugin = 4;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 4;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 prayer_contribution = 6;
  inline bool has_prayer_contribution() const;
  inline void clear_prayer_contribution();
  static const int kPrayerContributionFieldNumber = 6;
  inline ::google::protobuf::uint32 prayer_contribution() const;
  inline void set_prayer_contribution(::google::protobuf::uint32 value);

  // optional uint32 hero_tid = 7;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 7;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional uint32 hero_curr_num = 8;
  inline bool has_hero_curr_num() const;
  inline void clear_hero_curr_num();
  static const int kHeroCurrNumFieldNumber = 8;
  inline ::google::protobuf::uint32 hero_curr_num() const;
  inline void set_hero_curr_num(::google::protobuf::uint32 value);

  // optional uint32 hero_max_num = 9;
  inline bool has_hero_max_num() const;
  inline void clear_hero_max_num();
  static const int kHeroMaxNumFieldNumber = 9;
  inline ::google::protobuf::uint32 hero_max_num() const;
  inline void set_hero_max_num(::google::protobuf::uint32 value);

  // optional uint32 start_time = 10;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 complete_time = 11;
  inline bool has_complete_time() const;
  inline void clear_complete_time();
  static const int kCompleteTimeFieldNumber = 11;
  inline ::google::protobuf::uint32 complete_time() const;
  inline void set_complete_time(::google::protobuf::uint32 value);

  // optional .proto.common.family_gift_data_list list = 12;
  inline bool has_list() const;
  inline void clear_list();
  static const int kListFieldNumber = 12;
  inline const ::proto::common::family_gift_data_list& list() const;
  inline ::proto::common::family_gift_data_list* mutable_list();
  inline ::proto::common::family_gift_data_list* release_list();
  inline void set_allocated_list(::proto::common::family_gift_data_list* list);

  // @@protoc_insertion_point(class_scope:proto.common.family_prayer_data)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_officer();
  inline void clear_has_officer();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_prayer_contribution();
  inline void clear_has_prayer_contribution();
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_hero_curr_num();
  inline void clear_has_hero_curr_num();
  inline void set_has_hero_max_num();
  inline void clear_has_hero_max_num();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_complete_time();
  inline void clear_has_complete_time();
  inline void set_has_list();
  inline void clear_has_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 officer_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 prayer_contribution_;
  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 hero_curr_num_;
  ::google::protobuf::uint32 hero_max_num_;
  ::google::protobuf::uint32 start_time_;
  ::proto::common::family_gift_data_list* list_;
  ::google::protobuf::uint32 complete_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_prayer_data* default_instance_;
};
// -------------------------------------------------------------------

class family_prayer_list : public ::google::protobuf::Message {
 public:
  family_prayer_list();
  virtual ~family_prayer_list();

  family_prayer_list(const family_prayer_list& from);

  inline family_prayer_list& operator=(const family_prayer_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_prayer_list& default_instance();

  void Swap(family_prayer_list* other);

  // implements Message ----------------------------------------------

  family_prayer_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_prayer_list& from);
  void MergeFrom(const family_prayer_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_prayer_data lists = 1;
  inline int lists_size() const;
  inline void clear_lists();
  static const int kListsFieldNumber = 1;
  inline const ::proto::common::family_prayer_data& lists(int index) const;
  inline ::proto::common::family_prayer_data* mutable_lists(int index);
  inline ::proto::common::family_prayer_data* add_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_data >&
      lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_data >*
      mutable_lists();

  // @@protoc_insertion_point(class_scope:proto.common.family_prayer_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_data > lists_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_prayer_list* default_instance_;
};
// -------------------------------------------------------------------

class family_prayer_record_data : public ::google::protobuf::Message {
 public:
  family_prayer_record_data();
  virtual ~family_prayer_record_data();

  family_prayer_record_data(const family_prayer_record_data& from);

  inline family_prayer_record_data& operator=(const family_prayer_record_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_prayer_record_data& default_instance();

  void Swap(family_prayer_record_data* other);

  // implements Message ----------------------------------------------

  family_prayer_record_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_prayer_record_data& from);
  void MergeFrom(const family_prayer_record_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 officer = 3;
  inline bool has_officer() const;
  inline void clear_officer();
  static const int kOfficerFieldNumber = 3;
  inline ::google::protobuf::uint32 officer() const;
  inline void set_officer(::google::protobuf::uint32 value);

  // optional uint32 plugin = 4;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 4;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 hero_tid = 6;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 6;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional uint32 hero_num = 7;
  inline bool has_hero_num() const;
  inline void clear_hero_num();
  static const int kHeroNumFieldNumber = 7;
  inline ::google::protobuf::uint32 hero_num() const;
  inline void set_hero_num(::google::protobuf::uint32 value);

  // optional uint32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_prayer_record_data)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_officer();
  inline void clear_has_officer();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_hero_num();
  inline void clear_has_hero_num();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 officer_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 hero_num_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_prayer_record_data* default_instance_;
};
// -------------------------------------------------------------------

class family_prayer_record_list : public ::google::protobuf::Message {
 public:
  family_prayer_record_list();
  virtual ~family_prayer_record_list();

  family_prayer_record_list(const family_prayer_record_list& from);

  inline family_prayer_record_list& operator=(const family_prayer_record_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_prayer_record_list& default_instance();

  void Swap(family_prayer_record_list* other);

  // implements Message ----------------------------------------------

  family_prayer_record_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_prayer_record_list& from);
  void MergeFrom(const family_prayer_record_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_prayer_record_data gift_list = 1;
  inline int gift_list_size() const;
  inline void clear_gift_list();
  static const int kGiftListFieldNumber = 1;
  inline const ::proto::common::family_prayer_record_data& gift_list(int index) const;
  inline ::proto::common::family_prayer_record_data* mutable_gift_list(int index);
  inline ::proto::common::family_prayer_record_data* add_gift_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >&
      gift_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >*
      mutable_gift_list();

  // repeated .proto.common.family_prayer_record_data receive_list = 2;
  inline int receive_list_size() const;
  inline void clear_receive_list();
  static const int kReceiveListFieldNumber = 2;
  inline const ::proto::common::family_prayer_record_data& receive_list(int index) const;
  inline ::proto::common::family_prayer_record_data* mutable_receive_list(int index);
  inline ::proto::common::family_prayer_record_data* add_receive_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >&
      receive_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >*
      mutable_receive_list();

  // @@protoc_insertion_point(class_scope:proto.common.family_prayer_record_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data > gift_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data > receive_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_prayer_record_list* default_instance_;
};
// -------------------------------------------------------------------

class family_invite_result : public ::google::protobuf::Message {
 public:
  family_invite_result();
  virtual ~family_invite_result();

  family_invite_result(const family_invite_result& from);

  inline family_invite_result& operator=(const family_invite_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_invite_result& default_instance();

  void Swap(family_invite_result* other);

  // implements Message ----------------------------------------------

  family_invite_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_invite_result& from);
  void MergeFrom(const family_invite_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional string family_uid = 2;
  inline bool has_family_uid() const;
  inline void clear_family_uid();
  static const int kFamilyUidFieldNumber = 2;
  inline const ::std::string& family_uid() const;
  inline void set_family_uid(const ::std::string& value);
  inline void set_family_uid(const char* value);
  inline void set_family_uid(const char* value, size_t size);
  inline ::std::string* mutable_family_uid();
  inline ::std::string* release_family_uid();
  inline void set_allocated_family_uid(::std::string* family_uid);

  // optional string inviter_uid = 3;
  inline bool has_inviter_uid() const;
  inline void clear_inviter_uid();
  static const int kInviterUidFieldNumber = 3;
  inline const ::std::string& inviter_uid() const;
  inline void set_inviter_uid(const ::std::string& value);
  inline void set_inviter_uid(const char* value);
  inline void set_inviter_uid(const char* value, size_t size);
  inline ::std::string* mutable_inviter_uid();
  inline ::std::string* release_inviter_uid();
  inline void set_allocated_inviter_uid(::std::string* inviter_uid);

  // @@protoc_insertion_point(class_scope:proto.common.family_invite_result)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_family_uid();
  inline void clear_has_family_uid();
  inline void set_has_inviter_uid();
  inline void clear_has_inviter_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_uid_;
  ::std::string* inviter_uid_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_invite_result* default_instance_;
};
// -------------------------------------------------------------------

class family_shop_item : public ::google::protobuf::Message {
 public:
  family_shop_item();
  virtual ~family_shop_item();

  family_shop_item(const family_shop_item& from);

  inline family_shop_item& operator=(const family_shop_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_shop_item& default_instance();

  void Swap(family_shop_item* other);

  // implements Message ----------------------------------------------

  family_shop_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_shop_item& from);
  void MergeFrom(const family_shop_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_item = 1;
  inline bool has_shop_item() const;
  inline void clear_shop_item();
  static const int kShopItemFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_item() const;
  inline void set_shop_item(::google::protobuf::uint32 value);

  // optional uint32 sold_count = 2;
  inline bool has_sold_count() const;
  inline void clear_sold_count();
  static const int kSoldCountFieldNumber = 2;
  inline ::google::protobuf::uint32 sold_count() const;
  inline void set_sold_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_shop_item)
 private:
  inline void set_has_shop_item();
  inline void clear_has_shop_item();
  inline void set_has_sold_count();
  inline void clear_has_sold_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shop_item_;
  ::google::protobuf::uint32 sold_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_shop_item* default_instance_;
};
// -------------------------------------------------------------------

class family_shop_data : public ::google::protobuf::Message {
 public:
  family_shop_data();
  virtual ~family_shop_data();

  family_shop_data(const family_shop_data& from);

  inline family_shop_data& operator=(const family_shop_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_shop_data& default_instance();

  void Swap(family_shop_data* other);

  // implements Message ----------------------------------------------

  family_shop_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_shop_data& from);
  void MergeFrom(const family_shop_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 next_refresh_time = 1;
  inline bool has_next_refresh_time() const;
  inline void clear_next_refresh_time();
  static const int kNextRefreshTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 next_refresh_time() const;
  inline void set_next_refresh_time(::google::protobuf::uint32 value);

  // repeated .proto.common.family_shop_item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::proto::common::family_shop_item& items(int index) const;
  inline ::proto::common::family_shop_item* mutable_items(int index);
  inline ::proto::common::family_shop_item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:proto.common.family_shop_data)
 private:
  inline void set_has_next_refresh_time();
  inline void clear_has_next_refresh_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_item > items_;
  ::google::protobuf::uint32 next_refresh_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_shop_data* default_instance_;
};
// -------------------------------------------------------------------

class family_shop_personal_item : public ::google::protobuf::Message {
 public:
  family_shop_personal_item();
  virtual ~family_shop_personal_item();

  family_shop_personal_item(const family_shop_personal_item& from);

  inline family_shop_personal_item& operator=(const family_shop_personal_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_shop_personal_item& default_instance();

  void Swap(family_shop_personal_item* other);

  // implements Message ----------------------------------------------

  family_shop_personal_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_shop_personal_item& from);
  void MergeFrom(const family_shop_personal_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_index = 1;
  inline bool has_shop_index() const;
  inline void clear_shop_index();
  static const int kShopIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_index() const;
  inline void set_shop_index(::google::protobuf::uint32 value);

  // optional uint32 buy_count = 2;
  inline bool has_buy_count() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 2;
  inline ::google::protobuf::uint32 buy_count() const;
  inline void set_buy_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_shop_personal_item)
 private:
  inline void set_has_shop_index();
  inline void clear_has_shop_index();
  inline void set_has_buy_count();
  inline void clear_has_buy_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shop_index_;
  ::google::protobuf::uint32 buy_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_shop_personal_item* default_instance_;
};
// -------------------------------------------------------------------

class family_shop_personal_data : public ::google::protobuf::Message {
 public:
  family_shop_personal_data();
  virtual ~family_shop_personal_data();

  family_shop_personal_data(const family_shop_personal_data& from);

  inline family_shop_personal_data& operator=(const family_shop_personal_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_shop_personal_data& default_instance();

  void Swap(family_shop_personal_data* other);

  // implements Message ----------------------------------------------

  family_shop_personal_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_shop_personal_data& from);
  void MergeFrom(const family_shop_personal_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 next_refresh_time = 1;
  inline bool has_next_refresh_time() const;
  inline void clear_next_refresh_time();
  static const int kNextRefreshTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 next_refresh_time() const;
  inline void set_next_refresh_time(::google::protobuf::uint32 value);

  // repeated .proto.common.family_shop_personal_item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::proto::common::family_shop_personal_item& items(int index) const;
  inline ::proto::common::family_shop_personal_item* mutable_items(int index);
  inline ::proto::common::family_shop_personal_item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_personal_item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_personal_item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:proto.common.family_shop_personal_data)
 private:
  inline void set_has_next_refresh_time();
  inline void clear_has_next_refresh_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_personal_item > items_;
  ::google::protobuf::uint32 next_refresh_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_shop_personal_data* default_instance_;
};
// -------------------------------------------------------------------

class family_impeach_data : public ::google::protobuf::Message {
 public:
  family_impeach_data();
  virtual ~family_impeach_data();

  family_impeach_data(const family_impeach_data& from);

  inline family_impeach_data& operator=(const family_impeach_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_impeach_data& default_instance();

  void Swap(family_impeach_data* other);

  // implements Message ----------------------------------------------

  family_impeach_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_impeach_data& from);
  void MergeFrom(const family_impeach_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string impeacher = 1;
  inline bool has_impeacher() const;
  inline void clear_impeacher();
  static const int kImpeacherFieldNumber = 1;
  inline const ::std::string& impeacher() const;
  inline void set_impeacher(const ::std::string& value);
  inline void set_impeacher(const char* value);
  inline void set_impeacher(const char* value, size_t size);
  inline ::std::string* mutable_impeacher();
  inline ::std::string* release_impeacher();
  inline void set_allocated_impeacher(::std::string* impeacher);

  // optional uint32 approve_impeach_cnt = 2;
  inline bool has_approve_impeach_cnt() const;
  inline void clear_approve_impeach_cnt();
  static const int kApproveImpeachCntFieldNumber = 2;
  inline ::google::protobuf::uint32 approve_impeach_cnt() const;
  inline void set_approve_impeach_cnt(::google::protobuf::uint32 value);

  // optional uint32 time_left = 3;
  inline bool has_time_left() const;
  inline void clear_time_left();
  static const int kTimeLeftFieldNumber = 3;
  inline ::google::protobuf::uint32 time_left() const;
  inline void set_time_left(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_impeach_data)
 private:
  inline void set_has_impeacher();
  inline void clear_has_impeacher();
  inline void set_has_approve_impeach_cnt();
  inline void clear_has_approve_impeach_cnt();
  inline void set_has_time_left();
  inline void clear_has_time_left();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* impeacher_;
  ::google::protobuf::uint32 approve_impeach_cnt_;
  ::google::protobuf::uint32 time_left_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_impeach_data* default_instance_;
};
// -------------------------------------------------------------------

class family_war_data : public ::google::protobuf::Message {
 public:
  family_war_data();
  virtual ~family_war_data();

  family_war_data(const family_war_data& from);

  inline family_war_data& operator=(const family_war_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_war_data& default_instance();

  void Swap(family_war_data* other);

  // implements Message ----------------------------------------------

  family_war_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_war_data& from);
  void MergeFrom(const family_war_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string family_id = 1;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 1;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 family_prestige = 3;
  inline bool has_family_prestige() const;
  inline void clear_family_prestige();
  static const int kFamilyPrestigeFieldNumber = 3;
  inline ::google::protobuf::uint32 family_prestige() const;
  inline void set_family_prestige(::google::protobuf::uint32 value);

  // optional uint32 family_score = 4;
  inline bool has_family_score() const;
  inline void clear_family_score();
  static const int kFamilyScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 family_score() const;
  inline void set_family_score(::google::protobuf::uint32 value);

  // optional uint32 family_rank = 5;
  inline bool has_family_rank() const;
  inline void clear_family_rank();
  static const int kFamilyRankFieldNumber = 5;
  inline ::google::protobuf::uint32 family_rank() const;
  inline void set_family_rank(::google::protobuf::uint32 value);

  // optional .proto.common.family_war_result result = 6 [default = family_war_result_none];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 6;
  inline ::proto::common::family_war_result result() const;
  inline void set_result(::proto::common::family_war_result value);

  // @@protoc_insertion_point(class_scope:proto.common.family_war_data)
 private:
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_family_prestige();
  inline void clear_has_family_prestige();
  inline void set_has_family_score();
  inline void clear_has_family_score();
  inline void set_has_family_rank();
  inline void clear_has_family_rank();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_id_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 family_prestige_;
  ::google::protobuf::uint32 family_score_;
  ::google::protobuf::uint32 family_rank_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_war_data* default_instance_;
};
// -------------------------------------------------------------------

class family_against_data : public ::google::protobuf::Message {
 public:
  family_against_data();
  virtual ~family_against_data();

  family_against_data(const family_against_data& from);

  inline family_against_data& operator=(const family_against_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_against_data& default_instance();

  void Swap(family_against_data* other);

  // implements Message ----------------------------------------------

  family_against_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_against_data& from);
  void MergeFrom(const family_against_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.family_war_data left_side = 1;
  inline bool has_left_side() const;
  inline void clear_left_side();
  static const int kLeftSideFieldNumber = 1;
  inline const ::proto::common::family_war_data& left_side() const;
  inline ::proto::common::family_war_data* mutable_left_side();
  inline ::proto::common::family_war_data* release_left_side();
  inline void set_allocated_left_side(::proto::common::family_war_data* left_side);

  // optional .proto.common.family_war_data right_side = 2;
  inline bool has_right_side() const;
  inline void clear_right_side();
  static const int kRightSideFieldNumber = 2;
  inline const ::proto::common::family_war_data& right_side() const;
  inline ::proto::common::family_war_data* mutable_right_side();
  inline ::proto::common::family_war_data* release_right_side();
  inline void set_allocated_right_side(::proto::common::family_war_data* right_side);

  // @@protoc_insertion_point(class_scope:proto.common.family_against_data)
 private:
  inline void set_has_left_side();
  inline void clear_has_left_side();
  inline void set_has_right_side();
  inline void clear_has_right_side();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::family_war_data* left_side_;
  ::proto::common::family_war_data* right_side_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_against_data* default_instance_;
};
// -------------------------------------------------------------------

class family_object_pos : public ::google::protobuf::Message {
 public:
  family_object_pos();
  virtual ~family_object_pos();

  family_object_pos(const family_object_pos& from);

  inline family_object_pos& operator=(const family_object_pos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_object_pos& default_instance();

  void Swap(family_object_pos* other);

  // implements Message ----------------------------------------------

  family_object_pos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_object_pos& from);
  void MergeFrom(const family_object_pos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pos_x = 1;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 1;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // optional uint32 pos_y = 2;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 2;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_object_pos)
 private:
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_object_pos* default_instance_;
};
// -------------------------------------------------------------------

class family_against_list : public ::google::protobuf::Message {
 public:
  family_against_list();
  virtual ~family_against_list();

  family_against_list(const family_against_list& from);

  inline family_against_list& operator=(const family_against_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_against_list& default_instance();

  void Swap(family_against_list* other);

  // implements Message ----------------------------------------------

  family_against_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_against_list& from);
  void MergeFrom(const family_against_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_against_data data_list = 1;
  inline int data_list_size() const;
  inline void clear_data_list();
  static const int kDataListFieldNumber = 1;
  inline const ::proto::common::family_against_data& data_list(int index) const;
  inline ::proto::common::family_against_data* mutable_data_list(int index);
  inline ::proto::common::family_against_data* add_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_against_data >&
      data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_against_data >*
      mutable_data_list();

  // @@protoc_insertion_point(class_scope:proto.common.family_against_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_against_data > data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_against_list* default_instance_;
};
// -------------------------------------------------------------------

class family_war_history_data : public ::google::protobuf::Message {
 public:
  family_war_history_data();
  virtual ~family_war_history_data();

  family_war_history_data(const family_war_history_data& from);

  inline family_war_history_data& operator=(const family_war_history_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_war_history_data& default_instance();

  void Swap(family_war_history_data* other);

  // implements Message ----------------------------------------------

  family_war_history_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_war_history_data& from);
  void MergeFrom(const family_war_history_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_war_data data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::proto::common::family_war_data& data(int index) const;
  inline ::proto::common::family_war_data* mutable_data(int index);
  inline ::proto::common::family_war_data* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_war_data >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_war_data >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:proto.common.family_war_history_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_war_data > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_war_history_data* default_instance_;
};
// -------------------------------------------------------------------

class family_war_hero_data : public ::google::protobuf::Message {
 public:
  family_war_hero_data();
  virtual ~family_war_hero_data();

  family_war_hero_data(const family_war_hero_data& from);

  inline family_war_hero_data& operator=(const family_war_hero_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_war_hero_data& default_instance();

  void Swap(family_war_hero_data* other);

  // implements Message ----------------------------------------------

  family_war_hero_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_war_hero_data& from);
  void MergeFrom(const family_war_hero_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // optional .proto.common.family_war_hero_type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::proto::common::family_war_hero_type type() const;
  inline void set_type(::proto::common::family_war_hero_type value);

  // @@protoc_insertion_point(class_scope:proto.common.family_war_hero_data)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hero_uid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_war_hero_data* default_instance_;
};
// -------------------------------------------------------------------

class country_base_data : public ::google::protobuf::Message {
 public:
  country_base_data();
  virtual ~country_base_data();

  country_base_data(const country_base_data& from);

  inline country_base_data& operator=(const country_base_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_base_data& default_instance();

  void Swap(country_base_data* other);

  // implements Message ----------------------------------------------

  country_base_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_base_data& from);
  void MergeFrom(const country_base_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string king_name = 2;
  inline bool has_king_name() const;
  inline void clear_king_name();
  static const int kKingNameFieldNumber = 2;
  inline const ::std::string& king_name() const;
  inline void set_king_name(const ::std::string& value);
  inline void set_king_name(const char* value);
  inline void set_king_name(const char* value, size_t size);
  inline ::std::string* mutable_king_name();
  inline ::std::string* release_king_name();
  inline void set_allocated_king_name(::std::string* king_name);

  // optional string king_family = 3;
  inline bool has_king_family() const;
  inline void clear_king_family();
  static const int kKingFamilyFieldNumber = 3;
  inline const ::std::string& king_family() const;
  inline void set_king_family(const ::std::string& value);
  inline void set_king_family(const char* value);
  inline void set_king_family(const char* value, size_t size);
  inline ::std::string* mutable_king_family();
  inline ::std::string* release_king_family();
  inline void set_allocated_king_family(::std::string* king_family);

  // optional string notice = 4;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 4;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 flag = 6;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 6;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // optional string year_name = 7;
  inline bool has_year_name() const;
  inline void clear_year_name();
  static const int kYearNameFieldNumber = 7;
  inline const ::std::string& year_name() const;
  inline void set_year_name(const ::std::string& value);
  inline void set_year_name(const char* value);
  inline void set_year_name(const char* value, size_t size);
  inline ::std::string* mutable_year_name();
  inline ::std::string* release_year_name();
  inline void set_allocated_year_name(::std::string* year_name);

  // @@protoc_insertion_point(class_scope:proto.common.country_base_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_king_name();
  inline void clear_has_king_name();
  inline void set_has_king_family();
  inline void clear_has_king_family();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_year_name();
  inline void clear_has_year_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* king_name_;
  ::std::string* king_family_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 flag_;
  ::std::string* notice_;
  ::std::string* name_;
  ::std::string* year_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_base_data* default_instance_;
};
// -------------------------------------------------------------------

class country_officer_data : public ::google::protobuf::Message {
 public:
  country_officer_data();
  virtual ~country_officer_data();

  country_officer_data(const country_officer_data& from);

  inline country_officer_data& operator=(const country_officer_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_officer_data& default_instance();

  void Swap(country_officer_data* other);

  // implements Message ----------------------------------------------

  country_officer_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_officer_data& from);
  void MergeFrom(const country_officer_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 plugin = 4;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 4;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 refresh = 5;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 5;
  inline ::google::protobuf::uint32 refresh() const;
  inline void set_refresh(::google::protobuf::uint32 value);

  // optional uint32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 fighting = 7;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 7;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 hero_plugin = 8;
  inline bool has_hero_plugin() const;
  inline void clear_hero_plugin();
  static const int kHeroPluginFieldNumber = 8;
  inline ::google::protobuf::uint32 hero_plugin() const;
  inline void set_hero_plugin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.country_officer_data)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_refresh();
  inline void clear_has_refresh();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_hero_plugin();
  inline void clear_has_hero_plugin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 refresh_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 hero_plugin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_officer_data* default_instance_;
};
// -------------------------------------------------------------------

class country_info_data : public ::google::protobuf::Message {
 public:
  country_info_data();
  virtual ~country_info_data();

  country_info_data(const country_info_data& from);

  inline country_info_data& operator=(const country_info_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_info_data& default_instance();

  void Swap(country_info_data* other);

  // implements Message ----------------------------------------------

  country_info_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_info_data& from);
  void MergeFrom(const country_info_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.country_base_data base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::proto::common::country_base_data& base() const;
  inline ::proto::common::country_base_data* mutable_base();
  inline ::proto::common::country_base_data* release_base();
  inline void set_allocated_base(::proto::common::country_base_data* base);

  // optional uint32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // optional uint32 level_type = 4;
  inline bool has_level_type() const;
  inline void clear_level_type();
  static const int kLevelTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 level_type() const;
  inline void set_level_type(::google::protobuf::uint32 value);

  // optional uint32 free_times = 5;
  inline bool has_free_times() const;
  inline void clear_free_times();
  static const int kFreeTimesFieldNumber = 5;
  inline ::google::protobuf::uint32 free_times() const;
  inline void set_free_times(::google::protobuf::uint32 value);

  // optional uint32 free_times2 = 6;
  inline bool has_free_times2() const;
  inline void clear_free_times2();
  static const int kFreeTimes2FieldNumber = 6;
  inline ::google::protobuf::uint32 free_times2() const;
  inline void set_free_times2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.country_info_data)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_level_type();
  inline void clear_has_level_type();
  inline void set_has_free_times();
  inline void clear_has_free_times();
  inline void set_has_free_times2();
  inline void clear_has_free_times2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::country_base_data* base_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 power_;
  ::google::protobuf::uint32 level_type_;
  ::google::protobuf::uint32 free_times_;
  ::google::protobuf::uint32 free_times2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_info_data* default_instance_;
};
// -------------------------------------------------------------------

class country_family_data : public ::google::protobuf::Message {
 public:
  country_family_data();
  virtual ~country_family_data();

  country_family_data(const country_family_data& from);

  inline country_family_data& operator=(const country_family_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_family_data& default_instance();

  void Swap(country_family_data* other);

  // implements Message ----------------------------------------------

  country_family_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_family_data& from);
  void MergeFrom(const country_family_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string family_uid = 1;
  inline bool has_family_uid() const;
  inline void clear_family_uid();
  static const int kFamilyUidFieldNumber = 1;
  inline const ::std::string& family_uid() const;
  inline void set_family_uid(const ::std::string& value);
  inline void set_family_uid(const char* value);
  inline void set_family_uid(const char* value, size_t size);
  inline ::std::string* mutable_family_uid();
  inline ::std::string* release_family_uid();
  inline void set_allocated_family_uid(::std::string* family_uid);

  // optional string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional string patriarch = 3;
  inline bool has_patriarch() const;
  inline void clear_patriarch();
  static const int kPatriarchFieldNumber = 3;
  inline const ::std::string& patriarch() const;
  inline void set_patriarch(const ::std::string& value);
  inline void set_patriarch(const char* value);
  inline void set_patriarch(const char* value, size_t size);
  inline ::std::string* mutable_patriarch();
  inline ::std::string* release_patriarch();
  inline void set_allocated_patriarch(::std::string* patriarch);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 prestige = 5;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 5;
  inline ::google::protobuf::uint32 prestige() const;
  inline void set_prestige(::google::protobuf::uint32 value);

  // optional uint32 loyalty = 6;
  inline bool has_loyalty() const;
  inline void clear_loyalty();
  static const int kLoyaltyFieldNumber = 6;
  inline ::google::protobuf::uint32 loyalty() const;
  inline void set_loyalty(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.country_family_data)
 private:
  inline void set_has_family_uid();
  inline void clear_has_family_uid();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_patriarch();
  inline void clear_has_patriarch();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_loyalty();
  inline void clear_has_loyalty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_uid_;
  ::std::string* family_name_;
  ::std::string* patriarch_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 prestige_;
  ::google::protobuf::uint32 loyalty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_family_data* default_instance_;
};
// -------------------------------------------------------------------

class country_family_list : public ::google::protobuf::Message {
 public:
  country_family_list();
  virtual ~country_family_list();

  country_family_list(const country_family_list& from);

  inline country_family_list& operator=(const country_family_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_family_list& default_instance();

  void Swap(country_family_list* other);

  // implements Message ----------------------------------------------

  country_family_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_family_list& from);
  void MergeFrom(const country_family_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.country_family_data datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::proto::common::country_family_data& datas(int index) const;
  inline ::proto::common::country_family_data* mutable_datas(int index);
  inline ::proto::common::country_family_data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::country_family_data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::country_family_data >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:proto.common.country_family_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::country_family_data > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_family_list* default_instance_;
};
// -------------------------------------------------------------------

class server_channel_single : public ::google::protobuf::Message {
 public:
  server_channel_single();
  virtual ~server_channel_single();

  server_channel_single(const server_channel_single& from);

  inline server_channel_single& operator=(const server_channel_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_channel_single& default_instance();

  void Swap(server_channel_single* other);

  // implements Message ----------------------------------------------

  server_channel_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_channel_single& from);
  void MergeFrom(const server_channel_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .proto.common.channel_type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::proto::common::channel_type type() const;
  inline void set_type(::proto::common::channel_type value);

  // optional .proto.common.channel_state state = 4 [default = channel_free];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::proto::common::channel_state state() const;
  inline void set_state(::proto::common::channel_state value);

  // @@protoc_insertion_point(class_scope:proto.common.server_channel_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 uid_;
  int type_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static server_channel_single* default_instance_;
};
// -------------------------------------------------------------------

class fh_channel_role_list : public ::google::protobuf::Message {
 public:
  fh_channel_role_list();
  virtual ~fh_channel_role_list();

  fh_channel_role_list(const fh_channel_role_list& from);

  inline fh_channel_role_list& operator=(const fh_channel_role_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fh_channel_role_list& default_instance();

  void Swap(fh_channel_role_list* other);

  // implements Message ----------------------------------------------

  fh_channel_role_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fh_channel_role_list& from);
  void MergeFrom(const fh_channel_role_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 notify_role_arrary = 1;
  inline int notify_role_arrary_size() const;
  inline void clear_notify_role_arrary();
  static const int kNotifyRoleArraryFieldNumber = 1;
  inline ::google::protobuf::uint64 notify_role_arrary(int index) const;
  inline void set_notify_role_arrary(int index, ::google::protobuf::uint64 value);
  inline void add_notify_role_arrary(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      notify_role_arrary() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_notify_role_arrary();

  // @@protoc_insertion_point(class_scope:proto.common.fh_channel_role_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > notify_role_arrary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fh_channel_role_list* default_instance_;
};
// -------------------------------------------------------------------

class server_channel_data : public ::google::protobuf::Message {
 public:
  server_channel_data();
  virtual ~server_channel_data();

  server_channel_data(const server_channel_data& from);

  inline server_channel_data& operator=(const server_channel_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const server_channel_data& default_instance();

  void Swap(server_channel_data* other);

  // implements Message ----------------------------------------------

  server_channel_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const server_channel_data& from);
  void MergeFrom(const server_channel_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.server_channel_single server_channel_single = 1;
  inline int server_channel_single_size() const;
  inline void clear_server_channel_single();
  static const int kServerChannelSingleFieldNumber = 1;
  inline const ::proto::common::server_channel_single& server_channel_single(int index) const;
  inline ::proto::common::server_channel_single* mutable_server_channel_single(int index);
  inline ::proto::common::server_channel_single* add_server_channel_single();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::server_channel_single >&
      server_channel_single() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::server_channel_single >*
      mutable_server_channel_single();

  // @@protoc_insertion_point(class_scope:proto.common.server_channel_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::server_channel_single > server_channel_single_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static server_channel_data* default_instance_;
};
// -------------------------------------------------------------------

class chat_syn_user_info : public ::google::protobuf::Message {
 public:
  chat_syn_user_info();
  virtual ~chat_syn_user_info();

  chat_syn_user_info(const chat_syn_user_info& from);

  inline chat_syn_user_info& operator=(const chat_syn_user_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_syn_user_info& default_instance();

  void Swap(chat_syn_user_info* other);

  // implements Message ----------------------------------------------

  chat_syn_user_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_syn_user_info& from);
  void MergeFrom(const chat_syn_user_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 gate_id = 2;
  inline bool has_gate_id() const;
  inline void clear_gate_id();
  static const int kGateIdFieldNumber = 2;
  inline ::google::protobuf::uint32 gate_id() const;
  inline void set_gate_id(::google::protobuf::uint32 value);

  // optional string nickname = 3;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 3;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional uint32 country_id = 4;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 4;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional uint64 family_id = 5;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 5;
  inline ::google::protobuf::uint64 family_id() const;
  inline void set_family_id(::google::protobuf::uint64 value);

  // optional uint32 channel_id = 6;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 6;
  inline ::google::protobuf::uint32 channel_id() const;
  inline void set_channel_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.chat_syn_user_info)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gate_id();
  inline void clear_has_gate_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_channel_id();
  inline void clear_has_channel_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* nickname_;
  ::google::protobuf::uint32 gate_id_;
  ::google::protobuf::uint32 country_id_;
  ::google::protobuf::uint64 family_id_;
  ::google::protobuf::uint32 channel_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static chat_syn_user_info* default_instance_;
};
// -------------------------------------------------------------------

class chat_common_data : public ::google::protobuf::Message {
 public:
  chat_common_data();
  virtual ~chat_common_data();

  chat_common_data(const chat_common_data& from);

  inline chat_common_data& operator=(const chat_common_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_common_data& default_instance();

  void Swap(chat_common_data* other);

  // implements Message ----------------------------------------------

  chat_common_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_common_data& from);
  void MergeFrom(const chat_common_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.chat_channel chat_channel = 1 [default = chat_channel_vicinity];
  inline bool has_chat_channel() const;
  inline void clear_chat_channel();
  static const int kChatChannelFieldNumber = 1;
  inline ::proto::common::chat_channel chat_channel() const;
  inline void set_chat_channel(::proto::common::chat_channel value);

  // required string src_uid = 2;
  inline bool has_src_uid() const;
  inline void clear_src_uid();
  static const int kSrcUidFieldNumber = 2;
  inline const ::std::string& src_uid() const;
  inline void set_src_uid(const ::std::string& value);
  inline void set_src_uid(const char* value);
  inline void set_src_uid(const char* value, size_t size);
  inline ::std::string* mutable_src_uid();
  inline ::std::string* release_src_uid();
  inline void set_allocated_src_uid(::std::string* src_uid);

  // required string src_name = 3;
  inline bool has_src_name() const;
  inline void clear_src_name();
  static const int kSrcNameFieldNumber = 3;
  inline const ::std::string& src_name() const;
  inline void set_src_name(const ::std::string& value);
  inline void set_src_name(const char* value);
  inline void set_src_name(const char* value, size_t size);
  inline ::std::string* mutable_src_name();
  inline ::std::string* release_src_name();
  inline void set_allocated_src_name(::std::string* src_name);

  // required string chat_info = 4;
  inline bool has_chat_info() const;
  inline void clear_chat_info();
  static const int kChatInfoFieldNumber = 4;
  inline const ::std::string& chat_info() const;
  inline void set_chat_info(const ::std::string& value);
  inline void set_chat_info(const char* value);
  inline void set_chat_info(const char* value, size_t size);
  inline ::std::string* mutable_chat_info();
  inline ::std::string* release_chat_info();
  inline void set_allocated_chat_info(::std::string* chat_info);

  // required uint32 head_icon_id = 5;
  inline bool has_head_icon_id() const;
  inline void clear_head_icon_id();
  static const int kHeadIconIdFieldNumber = 5;
  inline ::google::protobuf::uint32 head_icon_id() const;
  inline void set_head_icon_id(::google::protobuf::uint32 value);

  // required uint32 role_level = 6;
  inline bool has_role_level() const;
  inline void clear_role_level();
  static const int kRoleLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 role_level() const;
  inline void set_role_level(::google::protobuf::uint32 value);

  // optional string param = 7;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 7;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // optional string tar_role_id = 8;
  inline bool has_tar_role_id() const;
  inline void clear_tar_role_id();
  static const int kTarRoleIdFieldNumber = 8;
  inline const ::std::string& tar_role_id() const;
  inline void set_tar_role_id(const ::std::string& value);
  inline void set_tar_role_id(const char* value);
  inline void set_tar_role_id(const char* value, size_t size);
  inline ::std::string* mutable_tar_role_id();
  inline ::std::string* release_tar_role_id();
  inline void set_allocated_tar_role_id(::std::string* tar_role_id);

  // @@protoc_insertion_point(class_scope:proto.common.chat_common_data)
 private:
  inline void set_has_chat_channel();
  inline void clear_has_chat_channel();
  inline void set_has_src_uid();
  inline void clear_has_src_uid();
  inline void set_has_src_name();
  inline void clear_has_src_name();
  inline void set_has_chat_info();
  inline void clear_has_chat_info();
  inline void set_has_head_icon_id();
  inline void clear_has_head_icon_id();
  inline void set_has_role_level();
  inline void clear_has_role_level();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_tar_role_id();
  inline void clear_has_tar_role_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* src_uid_;
  ::std::string* src_name_;
  int chat_channel_;
  ::google::protobuf::uint32 head_icon_id_;
  ::std::string* chat_info_;
  ::std::string* param_;
  ::std::string* tar_role_id_;
  ::google::protobuf::uint32 role_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static chat_common_data* default_instance_;
};
// -------------------------------------------------------------------

class chat_common_role_info : public ::google::protobuf::Message {
 public:
  chat_common_role_info();
  virtual ~chat_common_role_info();

  chat_common_role_info(const chat_common_role_info& from);

  inline chat_common_role_info& operator=(const chat_common_role_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chat_common_role_info& default_instance();

  void Swap(chat_common_role_info* other);

  // implements Message ----------------------------------------------

  chat_common_role_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chat_common_role_info& from);
  void MergeFrom(const chat_common_role_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.item_single item_single = 1;
  inline int item_single_size() const;
  inline void clear_item_single();
  static const int kItemSingleFieldNumber = 1;
  inline const ::proto::common::item_single& item_single(int index) const;
  inline ::proto::common::item_single* mutable_item_single(int index);
  inline ::proto::common::item_single* add_item_single();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
      item_single() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
      mutable_item_single();

  // repeated .proto.common.hero_single hero_single = 2;
  inline int hero_single_size() const;
  inline void clear_hero_single();
  static const int kHeroSingleFieldNumber = 2;
  inline const ::proto::common::hero_single& hero_single(int index) const;
  inline ::proto::common::hero_single* mutable_hero_single(int index);
  inline ::proto::common::hero_single* add_hero_single();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
      hero_single() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
      mutable_hero_single();

  // @@protoc_insertion_point(class_scope:proto.common.chat_common_role_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::item_single > item_single_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single > hero_single_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static chat_common_role_info* default_instance_;
};
// -------------------------------------------------------------------

class user_troop_member : public ::google::protobuf::Message {
 public:
  user_troop_member();
  virtual ~user_troop_member();

  user_troop_member(const user_troop_member& from);

  inline user_troop_member& operator=(const user_troop_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_troop_member& default_instance();

  void Swap(user_troop_member* other);

  // implements Message ----------------------------------------------

  user_troop_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_troop_member& from);
  void MergeFrom(const user_troop_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 plugin = 3;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 3;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 fighting = 4;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 4;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 7 [default = SCENEOBJECT_USER];
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 7;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional uint32 fight_times = 8;
  inline bool has_fight_times() const;
  inline void clear_fight_times();
  static const int kFightTimesFieldNumber = 8;
  inline ::google::protobuf::uint32 fight_times() const;
  inline void set_fight_times(::google::protobuf::uint32 value);

  // optional string owner_uid = 9;
  inline bool has_owner_uid() const;
  inline void clear_owner_uid();
  static const int kOwnerUidFieldNumber = 9;
  inline const ::std::string& owner_uid() const;
  inline void set_owner_uid(const ::std::string& value);
  inline void set_owner_uid(const char* value);
  inline void set_owner_uid(const char* value, size_t size);
  inline ::std::string* mutable_owner_uid();
  inline ::std::string* release_owner_uid();
  inline void set_allocated_owner_uid(::std::string* owner_uid);

  // @@protoc_insertion_point(class_scope:proto.common.user_troop_member)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_fight_times();
  inline void clear_has_fight_times();
  inline void set_has_owner_uid();
  inline void clear_has_owner_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 state_;
  int object_type_;
  ::google::protobuf::uint32 fight_times_;
  ::std::string* owner_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_troop_member* default_instance_;
};
// -------------------------------------------------------------------

class troop_data : public ::google::protobuf::Message {
 public:
  troop_data();
  virtual ~troop_data();

  troop_data(const troop_data& from);

  inline troop_data& operator=(const troop_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const troop_data& default_instance();

  void Swap(troop_data* other);

  // implements Message ----------------------------------------------

  troop_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const troop_data& from);
  void MergeFrom(const troop_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional bool is_free_join = 3;
  inline bool has_is_free_join() const;
  inline void clear_is_free_join();
  static const int kIsFreeJoinFieldNumber = 3;
  inline bool is_free_join() const;
  inline void set_is_free_join(bool value);

  // optional string leader = 4;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 4;
  inline const ::std::string& leader() const;
  inline void set_leader(const ::std::string& value);
  inline void set_leader(const char* value);
  inline void set_leader(const char* value, size_t size);
  inline ::std::string* mutable_leader();
  inline ::std::string* release_leader();
  inline void set_allocated_leader(::std::string* leader);

  // repeated .proto.common.user_troop_member members = 5;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 5;
  inline const ::proto::common::user_troop_member& members(int index) const;
  inline ::proto::common::user_troop_member* mutable_members(int index);
  inline ::proto::common::user_troop_member* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::user_troop_member >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::user_troop_member >*
      mutable_members();

  // optional uint32 level_min = 7;
  inline bool has_level_min() const;
  inline void clear_level_min();
  static const int kLevelMinFieldNumber = 7;
  inline ::google::protobuf::uint32 level_min() const;
  inline void set_level_min(::google::protobuf::uint32 value);

  // optional uint32 level_max = 8;
  inline bool has_level_max() const;
  inline void clear_level_max();
  static const int kLevelMaxFieldNumber = 8;
  inline ::google::protobuf::uint32 level_max() const;
  inline void set_level_max(::google::protobuf::uint32 value);

  // optional uint32 fighting = 9;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 9;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional .proto.common.task_state zg_task_info = 10;
  inline bool has_zg_task_info() const;
  inline void clear_zg_task_info();
  static const int kZgTaskInfoFieldNumber = 10;
  inline const ::proto::common::task_state& zg_task_info() const;
  inline ::proto::common::task_state* mutable_zg_task_info();
  inline ::proto::common::task_state* release_zg_task_info();
  inline void set_allocated_zg_task_info(::proto::common::task_state* zg_task_info);

  // @@protoc_insertion_point(class_scope:proto.common.troop_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_free_join();
  inline void clear_has_is_free_join();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_level_min();
  inline void clear_has_level_min();
  inline void set_has_level_max();
  inline void clear_has_level_max();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_zg_task_info();
  inline void clear_has_zg_task_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 type_;
  bool is_free_join_;
  ::std::string* leader_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::user_troop_member > members_;
  ::google::protobuf::uint32 level_min_;
  ::google::protobuf::uint32 level_max_;
  ::proto::common::task_state* zg_task_info_;
  ::google::protobuf::uint32 fighting_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static troop_data* default_instance_;
};
// -------------------------------------------------------------------

class troop_type : public ::google::protobuf::Message {
 public:
  troop_type();
  virtual ~troop_type();

  troop_type(const troop_type& from);

  inline troop_type& operator=(const troop_type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const troop_type& default_instance();

  void Swap(troop_type* other);

  // implements Message ----------------------------------------------

  troop_type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const troop_type& from);
  void MergeFrom(const troop_type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 big_type = 1;
  inline bool has_big_type() const;
  inline void clear_big_type();
  static const int kBigTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 big_type() const;
  inline void set_big_type(::google::protobuf::uint32 value);

  // repeated uint32 types = 2;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 2;
  inline ::google::protobuf::uint32 types(int index) const;
  inline void set_types(int index, ::google::protobuf::uint32 value);
  inline void add_types(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      types() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_types();

  // @@protoc_insertion_point(class_scope:proto.common.troop_type)
 private:
  inline void set_has_big_type();
  inline void clear_has_big_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > types_;
  ::google::protobuf::uint32 big_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static troop_type* default_instance_;
};
// -------------------------------------------------------------------

class user_troop_member_hero_list : public ::google::protobuf::Message {
 public:
  user_troop_member_hero_list();
  virtual ~user_troop_member_hero_list();

  user_troop_member_hero_list(const user_troop_member_hero_list& from);

  inline user_troop_member_hero_list& operator=(const user_troop_member_hero_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_troop_member_hero_list& default_instance();

  void Swap(user_troop_member_hero_list* other);

  // implements Message ----------------------------------------------

  user_troop_member_hero_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_troop_member_hero_list& from);
  void MergeFrom(const user_troop_member_hero_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_id = 1;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 1;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // repeated .proto.common.hero_single heroes = 3;
  inline int heroes_size() const;
  inline void clear_heroes();
  static const int kHeroesFieldNumber = 3;
  inline const ::proto::common::hero_single& heroes(int index) const;
  inline ::proto::common::hero_single* mutable_heroes(int index);
  inline ::proto::common::hero_single* add_heroes();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
      heroes() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
      mutable_heroes();

  // @@protoc_insertion_point(class_scope:proto.common.user_troop_member_hero_list)
 private:
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_role_name();
  inline void clear_has_role_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_id_;
  ::std::string* role_name_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single > heroes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_troop_member_hero_list* default_instance_;
};
// -------------------------------------------------------------------

class city_base_info : public ::google::protobuf::Message {
 public:
  city_base_info();
  virtual ~city_base_info();

  city_base_info(const city_base_info& from);

  inline city_base_info& operator=(const city_base_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_base_info& default_instance();

  void Swap(city_base_info* other);

  // implements Message ----------------------------------------------

  city_base_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_base_info& from);
  void MergeFrom(const city_base_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 city_id = 1;
  inline bool has_city_id() const;
  inline void clear_city_id();
  static const int kCityIdFieldNumber = 1;
  inline ::google::protobuf::uint32 city_id() const;
  inline void set_city_id(::google::protobuf::uint32 value);

  // optional uint32 prosperity_value = 2;
  inline bool has_prosperity_value() const;
  inline void clear_prosperity_value();
  static const int kProsperityValueFieldNumber = 2;
  inline ::google::protobuf::uint32 prosperity_value() const;
  inline void set_prosperity_value(::google::protobuf::uint32 value);

  // optional uint32 city_hold_value = 3;
  inline bool has_city_hold_value() const;
  inline void clear_city_hold_value();
  static const int kCityHoldValueFieldNumber = 3;
  inline ::google::protobuf::uint32 city_hold_value() const;
  inline void set_city_hold_value(::google::protobuf::uint32 value);

  // optional uint32 hold_country_id = 4;
  inline bool has_hold_country_id() const;
  inline void clear_hold_country_id();
  static const int kHoldCountryIdFieldNumber = 4;
  inline ::google::protobuf::uint32 hold_country_id() const;
  inline void set_hold_country_id(::google::protobuf::uint32 value);

  // optional uint32 prosperity_level = 5;
  inline bool has_prosperity_level() const;
  inline void clear_prosperity_level();
  static const int kProsperityLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 prosperity_level() const;
  inline void set_prosperity_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.city_base_info)
 private:
  inline void set_has_city_id();
  inline void clear_has_city_id();
  inline void set_has_prosperity_value();
  inline void clear_has_prosperity_value();
  inline void set_has_city_hold_value();
  inline void clear_has_city_hold_value();
  inline void set_has_hold_country_id();
  inline void clear_has_hold_country_id();
  inline void set_has_prosperity_level();
  inline void clear_has_prosperity_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 city_id_;
  ::google::protobuf::uint32 prosperity_value_;
  ::google::protobuf::uint32 city_hold_value_;
  ::google::protobuf::uint32 hold_country_id_;
  ::google::protobuf::uint32 prosperity_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static city_base_info* default_instance_;
};
// -------------------------------------------------------------------

class role_trade_info : public ::google::protobuf::Message {
 public:
  role_trade_info();
  virtual ~role_trade_info();

  role_trade_info(const role_trade_info& from);

  inline role_trade_info& operator=(const role_trade_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_trade_info& default_instance();

  void Swap(role_trade_info* other);

  // implements Message ----------------------------------------------

  role_trade_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_trade_info& from);
  void MergeFrom(const role_trade_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trade_point = 1;
  inline bool has_trade_point() const;
  inline void clear_trade_point();
  static const int kTradePointFieldNumber = 1;
  inline ::google::protobuf::uint32 trade_point() const;
  inline void set_trade_point(::google::protobuf::uint32 value);

  // optional uint32 trade_bag_weight = 2;
  inline bool has_trade_bag_weight() const;
  inline void clear_trade_bag_weight();
  static const int kTradeBagWeightFieldNumber = 2;
  inline ::google::protobuf::uint32 trade_bag_weight() const;
  inline void set_trade_bag_weight(::google::protobuf::uint32 value);

  // optional uint32 last_reset_buy_num_time = 3;
  inline bool has_last_reset_buy_num_time() const;
  inline void clear_last_reset_buy_num_time();
  static const int kLastResetBuyNumTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 last_reset_buy_num_time() const;
  inline void set_last_reset_buy_num_time(::google::protobuf::uint32 value);

  // optional uint32 total_week_gain = 4;
  inline bool has_total_week_gain() const;
  inline void clear_total_week_gain();
  static const int kTotalWeekGainFieldNumber = 4;
  inline ::google::protobuf::uint32 total_week_gain() const;
  inline void set_total_week_gain(::google::protobuf::uint32 value);

  // optional uint32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_trade_info)
 private:
  inline void set_has_trade_point();
  inline void clear_has_trade_point();
  inline void set_has_trade_bag_weight();
  inline void clear_has_trade_bag_weight();
  inline void set_has_last_reset_buy_num_time();
  inline void clear_has_last_reset_buy_num_time();
  inline void set_has_total_week_gain();
  inline void clear_has_total_week_gain();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 trade_point_;
  ::google::protobuf::uint32 trade_bag_weight_;
  ::google::protobuf::uint32 last_reset_buy_num_time_;
  ::google::protobuf::uint32 total_week_gain_;
  ::google::protobuf::uint32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_trade_info* default_instance_;
};
// -------------------------------------------------------------------

class role_trade_item_single : public ::google::protobuf::Message {
 public:
  role_trade_item_single();
  virtual ~role_trade_item_single();

  role_trade_item_single(const role_trade_item_single& from);

  inline role_trade_item_single& operator=(const role_trade_item_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_trade_item_single& default_instance();

  void Swap(role_trade_item_single* other);

  // implements Message ----------------------------------------------

  role_trade_item_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_trade_item_single& from);
  void MergeFrom(const role_trade_item_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_buy_num = 2;
  inline bool has_item_buy_num() const;
  inline void clear_item_buy_num();
  static const int kItemBuyNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_buy_num() const;
  inline void set_item_buy_num(::google::protobuf::uint32 value);

  // optional uint32 item_max_buy_num = 3;
  inline bool has_item_max_buy_num() const;
  inline void clear_item_max_buy_num();
  static const int kItemMaxBuyNumFieldNumber = 3;
  inline ::google::protobuf::uint32 item_max_buy_num() const;
  inline void set_item_max_buy_num(::google::protobuf::uint32 value);

  // optional uint32 item_buy_price = 4;
  inline bool has_item_buy_price() const;
  inline void clear_item_buy_price();
  static const int kItemBuyPriceFieldNumber = 4;
  inline ::google::protobuf::uint32 item_buy_price() const;
  inline void set_item_buy_price(::google::protobuf::uint32 value);

  // optional uint32 item_max_buy_num_addi = 5;
  inline bool has_item_max_buy_num_addi() const;
  inline void clear_item_max_buy_num_addi();
  static const int kItemMaxBuyNumAddiFieldNumber = 5;
  inline ::google::protobuf::uint32 item_max_buy_num_addi() const;
  inline void set_item_max_buy_num_addi(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_trade_item_single)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_buy_num();
  inline void clear_has_item_buy_num();
  inline void set_has_item_max_buy_num();
  inline void clear_has_item_max_buy_num();
  inline void set_has_item_buy_price();
  inline void clear_has_item_buy_price();
  inline void set_has_item_max_buy_num_addi();
  inline void clear_has_item_max_buy_num_addi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_buy_num_;
  ::google::protobuf::uint32 item_max_buy_num_;
  ::google::protobuf::uint32 item_buy_price_;
  ::google::protobuf::uint32 item_max_buy_num_addi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_trade_item_single* default_instance_;
};
// -------------------------------------------------------------------

class role_trade_item : public ::google::protobuf::Message {
 public:
  role_trade_item();
  virtual ~role_trade_item();

  role_trade_item(const role_trade_item& from);

  inline role_trade_item& operator=(const role_trade_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_trade_item& default_instance();

  void Swap(role_trade_item* other);

  // implements Message ----------------------------------------------

  role_trade_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_trade_item& from);
  void MergeFrom(const role_trade_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.role_trade_item_single trade_item_list = 1;
  inline int trade_item_list_size() const;
  inline void clear_trade_item_list();
  static const int kTradeItemListFieldNumber = 1;
  inline const ::proto::common::role_trade_item_single& trade_item_list(int index) const;
  inline ::proto::common::role_trade_item_single* mutable_trade_item_list(int index);
  inline ::proto::common::role_trade_item_single* add_trade_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_trade_item_single >&
      trade_item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_trade_item_single >*
      mutable_trade_item_list();

  // @@protoc_insertion_point(class_scope:proto.common.role_trade_item)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_trade_item_single > trade_item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_trade_item* default_instance_;
};
// -------------------------------------------------------------------

class city_trade_shop_item_info : public ::google::protobuf::Message {
 public:
  city_trade_shop_item_info();
  virtual ~city_trade_shop_item_info();

  city_trade_shop_item_info(const city_trade_shop_item_info& from);

  inline city_trade_shop_item_info& operator=(const city_trade_shop_item_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_trade_shop_item_info& default_instance();

  void Swap(city_trade_shop_item_info* other);

  // implements Message ----------------------------------------------

  city_trade_shop_item_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_trade_shop_item_info& from);
  void MergeFrom(const city_trade_shop_item_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 can_buy_max_num = 2;
  inline bool has_can_buy_max_num() const;
  inline void clear_can_buy_max_num();
  static const int kCanBuyMaxNumFieldNumber = 2;
  inline ::google::protobuf::uint32 can_buy_max_num() const;
  inline void set_can_buy_max_num(::google::protobuf::uint32 value);

  // optional uint32 item_buy_price = 3;
  inline bool has_item_buy_price() const;
  inline void clear_item_buy_price();
  static const int kItemBuyPriceFieldNumber = 3;
  inline ::google::protobuf::uint32 item_buy_price() const;
  inline void set_item_buy_price(::google::protobuf::uint32 value);

  // optional uint32 item_sell_price = 4;
  inline bool has_item_sell_price() const;
  inline void clear_item_sell_price();
  static const int kItemSellPriceFieldNumber = 4;
  inline ::google::protobuf::uint32 item_sell_price() const;
  inline void set_item_sell_price(::google::protobuf::uint32 value);

  // optional int32 trade_market = 5;
  inline bool has_trade_market() const;
  inline void clear_trade_market();
  static const int kTradeMarketFieldNumber = 5;
  inline ::google::protobuf::int32 trade_market() const;
  inline void set_trade_market(::google::protobuf::int32 value);

  // optional int32 new_trade_market = 6;
  inline bool has_new_trade_market() const;
  inline void clear_new_trade_market();
  static const int kNewTradeMarketFieldNumber = 6;
  inline ::google::protobuf::int32 new_trade_market() const;
  inline void set_new_trade_market(::google::protobuf::int32 value);

  // optional uint32 city_buy_max_num = 7;
  inline bool has_city_buy_max_num() const;
  inline void clear_city_buy_max_num();
  static const int kCityBuyMaxNumFieldNumber = 7;
  inline ::google::protobuf::uint32 city_buy_max_num() const;
  inline void set_city_buy_max_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.city_trade_shop_item_info)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_can_buy_max_num();
  inline void clear_has_can_buy_max_num();
  inline void set_has_item_buy_price();
  inline void clear_has_item_buy_price();
  inline void set_has_item_sell_price();
  inline void clear_has_item_sell_price();
  inline void set_has_trade_market();
  inline void clear_has_trade_market();
  inline void set_has_new_trade_market();
  inline void clear_has_new_trade_market();
  inline void set_has_city_buy_max_num();
  inline void clear_has_city_buy_max_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 can_buy_max_num_;
  ::google::protobuf::uint32 item_buy_price_;
  ::google::protobuf::uint32 item_sell_price_;
  ::google::protobuf::int32 trade_market_;
  ::google::protobuf::int32 new_trade_market_;
  ::google::protobuf::uint32 city_buy_max_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static city_trade_shop_item_info* default_instance_;
};
// -------------------------------------------------------------------

class city_trade_shop_info : public ::google::protobuf::Message {
 public:
  city_trade_shop_info();
  virtual ~city_trade_shop_info();

  city_trade_shop_info(const city_trade_shop_info& from);

  inline city_trade_shop_info& operator=(const city_trade_shop_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_trade_shop_info& default_instance();

  void Swap(city_trade_shop_info* other);

  // implements Message ----------------------------------------------

  city_trade_shop_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_trade_shop_info& from);
  void MergeFrom(const city_trade_shop_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.city_base_info city_info = 1;
  inline bool has_city_info() const;
  inline void clear_city_info();
  static const int kCityInfoFieldNumber = 1;
  inline const ::proto::common::city_base_info& city_info() const;
  inline ::proto::common::city_base_info* mutable_city_info();
  inline ::proto::common::city_base_info* release_city_info();
  inline void set_allocated_city_info(::proto::common::city_base_info* city_info);

  // repeated .proto.common.city_trade_shop_item_info item_list = 2;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 2;
  inline const ::proto::common::city_trade_shop_item_info& item_list(int index) const;
  inline ::proto::common::city_trade_shop_item_info* mutable_item_list(int index);
  inline ::proto::common::city_trade_shop_item_info* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::city_trade_shop_item_info >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::city_trade_shop_item_info >*
      mutable_item_list();

  // optional uint32 trade_id = 3;
  inline bool has_trade_id() const;
  inline void clear_trade_id();
  static const int kTradeIdFieldNumber = 3;
  inline ::google::protobuf::uint32 trade_id() const;
  inline void set_trade_id(::google::protobuf::uint32 value);

  // optional uint32 event_item_id = 4;
  inline bool has_event_item_id() const;
  inline void clear_event_item_id();
  static const int kEventItemIdFieldNumber = 4;
  inline ::google::protobuf::uint32 event_item_id() const;
  inline void set_event_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.city_trade_shop_info)
 private:
  inline void set_has_city_info();
  inline void clear_has_city_info();
  inline void set_has_trade_id();
  inline void clear_has_trade_id();
  inline void set_has_event_item_id();
  inline void clear_has_event_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::city_base_info* city_info_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::city_trade_shop_item_info > item_list_;
  ::google::protobuf::uint32 trade_id_;
  ::google::protobuf::uint32 event_item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static city_trade_shop_info* default_instance_;
};
// -------------------------------------------------------------------

class city_trade_event_info : public ::google::protobuf::Message {
 public:
  city_trade_event_info();
  virtual ~city_trade_event_info();

  city_trade_event_info(const city_trade_event_info& from);

  inline city_trade_event_info& operator=(const city_trade_event_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const city_trade_event_info& default_instance();

  void Swap(city_trade_event_info* other);

  // implements Message ----------------------------------------------

  city_trade_event_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const city_trade_event_info& from);
  void MergeFrom(const city_trade_event_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 city_tid = 1;
  inline bool has_city_tid() const;
  inline void clear_city_tid();
  static const int kCityTidFieldNumber = 1;
  inline ::google::protobuf::uint32 city_tid() const;
  inline void set_city_tid(::google::protobuf::uint32 value);

  // optional .proto.common.trade_event_type event_type = 2 [default = trade_event_type_normal];
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 2;
  inline ::proto::common::trade_event_type event_type() const;
  inline void set_event_type(::proto::common::trade_event_type value);

  // optional uint32 trade_event_param = 3;
  inline bool has_trade_event_param() const;
  inline void clear_trade_event_param();
  static const int kTradeEventParamFieldNumber = 3;
  inline ::google::protobuf::uint32 trade_event_param() const;
  inline void set_trade_event_param(::google::protobuf::uint32 value);

  // optional uint32 trade_event_param2 = 4;
  inline bool has_trade_event_param2() const;
  inline void clear_trade_event_param2();
  static const int kTradeEventParam2FieldNumber = 4;
  inline ::google::protobuf::uint32 trade_event_param2() const;
  inline void set_trade_event_param2(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.city_trade_event_info)
 private:
  inline void set_has_city_tid();
  inline void clear_has_city_tid();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_trade_event_param();
  inline void clear_has_trade_event_param();
  inline void set_has_trade_event_param2();
  inline void clear_has_trade_event_param2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 city_tid_;
  int event_type_;
  ::google::protobuf::uint32 trade_event_param_;
  ::google::protobuf::uint32 trade_event_param2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static city_trade_event_info* default_instance_;
};
// -------------------------------------------------------------------

class trade_supplement_info : public ::google::protobuf::Message {
 public:
  trade_supplement_info();
  virtual ~trade_supplement_info();

  trade_supplement_info(const trade_supplement_info& from);

  inline trade_supplement_info& operator=(const trade_supplement_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trade_supplement_info& default_instance();

  void Swap(trade_supplement_info* other);

  // implements Message ----------------------------------------------

  trade_supplement_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trade_supplement_info& from);
  void MergeFrom(const trade_supplement_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.trade_supplement_info)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static trade_supplement_info* default_instance_;
};
// -------------------------------------------------------------------

class grid_single : public ::google::protobuf::Message {
 public:
  grid_single();
  virtual ~grid_single();

  grid_single(const grid_single& from);

  inline grid_single& operator=(const grid_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const grid_single& default_instance();

  void Swap(grid_single* other);

  // implements Message ----------------------------------------------

  grid_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const grid_single& from);
  void MergeFrom(const grid_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .proto.common.attr_data attr = 2;
  inline bool has_attr() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 2;
  inline const ::proto::common::attr_data& attr() const;
  inline ::proto::common::attr_data* mutable_attr();
  inline ::proto::common::attr_data* release_attr();
  inline void set_allocated_attr(::proto::common::attr_data* attr);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.grid_single)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_attr();
  inline void clear_has_attr();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::attr_data* attr_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static grid_single* default_instance_;
};
// -------------------------------------------------------------------

class grid_data : public ::google::protobuf::Message {
 public:
  grid_data();
  virtual ~grid_data();

  grid_data(const grid_data& from);

  inline grid_data& operator=(const grid_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const grid_data& default_instance();

  void Swap(grid_data* other);

  // implements Message ----------------------------------------------

  grid_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const grid_data& from);
  void MergeFrom(const grid_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.grid_single grid = 1;
  inline int grid_size() const;
  inline void clear_grid();
  static const int kGridFieldNumber = 1;
  inline const ::proto::common::grid_single& grid(int index) const;
  inline ::proto::common::grid_single* mutable_grid(int index);
  inline ::proto::common::grid_single* add_grid();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::grid_single >&
      grid() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::grid_single >*
      mutable_grid();

  // @@protoc_insertion_point(class_scope:proto.common.grid_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::grid_single > grid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static grid_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_dark_param : public ::google::protobuf::Message {
 public:
  fight_dark_param();
  virtual ~fight_dark_param();

  fight_dark_param(const fight_dark_param& from);

  inline fight_dark_param& operator=(const fight_dark_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_dark_param& default_instance();

  void Swap(fight_dark_param* other);

  // implements Message ----------------------------------------------

  fight_dark_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_dark_param& from);
  void MergeFrom(const fight_dark_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monster_id = 1;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // optional uint32 task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_dark_param)
 private:
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 monster_id_;
  ::google::protobuf::uint32 task_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_dark_param* default_instance_;
};
// -------------------------------------------------------------------

class fight_light_param : public ::google::protobuf::Message {
 public:
  fight_light_param();
  virtual ~fight_light_param();

  fight_light_param(const fight_light_param& from);

  inline fight_light_param& operator=(const fight_light_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_light_param& default_instance();

  void Swap(fight_light_param* other);

  // implements Message ----------------------------------------------

  fight_light_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_light_param& from);
  void MergeFrom(const fight_light_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monster_id = 1;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // optional string object_id = 2;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  inline const ::std::string& object_id() const;
  inline void set_object_id(const ::std::string& value);
  inline void set_object_id(const char* value);
  inline void set_object_id(const char* value, size_t size);
  inline ::std::string* mutable_object_id();
  inline ::std::string* release_object_id();
  inline void set_allocated_object_id(::std::string* object_id);

  // @@protoc_insertion_point(class_scope:proto.common.fight_light_param)
 private:
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_object_id();
  inline void clear_has_object_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_id_;
  ::google::protobuf::uint32 monster_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_light_param* default_instance_;
};
// -------------------------------------------------------------------

class cross_arena_ex : public ::google::protobuf::Message {
 public:
  cross_arena_ex();
  virtual ~cross_arena_ex();

  cross_arena_ex(const cross_arena_ex& from);

  inline cross_arena_ex& operator=(const cross_arena_ex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cross_arena_ex& default_instance();

  void Swap(cross_arena_ex* other);

  // implements Message ----------------------------------------------

  cross_arena_ex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cross_arena_ex& from);
  void MergeFrom(const cross_arena_ex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rank_lv = 1;
  inline bool has_rank_lv() const;
  inline void clear_rank_lv();
  static const int kRankLvFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_lv() const;
  inline void set_rank_lv(::google::protobuf::uint32 value);

  // optional uint32 score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.cross_arena_ex)
 private:
  inline void set_has_rank_lv();
  inline void clear_has_rank_lv();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rank_lv_;
  ::google::protobuf::uint32 score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static cross_arena_ex* default_instance_;
};
// -------------------------------------------------------------------

class cross_arena_param : public ::google::protobuf::Message {
 public:
  cross_arena_param();
  virtual ~cross_arena_param();

  cross_arena_param(const cross_arena_param& from);

  inline cross_arena_param& operator=(const cross_arena_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cross_arena_param& default_instance();

  void Swap(cross_arena_param* other);

  // implements Message ----------------------------------------------

  cross_arena_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cross_arena_param& from);
  void MergeFrom(const cross_arena_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.cross_arena_ex obj1 = 1;
  inline bool has_obj1() const;
  inline void clear_obj1();
  static const int kObj1FieldNumber = 1;
  inline const ::proto::common::cross_arena_ex& obj1() const;
  inline ::proto::common::cross_arena_ex* mutable_obj1();
  inline ::proto::common::cross_arena_ex* release_obj1();
  inline void set_allocated_obj1(::proto::common::cross_arena_ex* obj1);

  // optional .proto.common.cross_arena_ex obj2 = 2;
  inline bool has_obj2() const;
  inline void clear_obj2();
  static const int kObj2FieldNumber = 2;
  inline const ::proto::common::cross_arena_ex& obj2() const;
  inline ::proto::common::cross_arena_ex* mutable_obj2();
  inline ::proto::common::cross_arena_ex* release_obj2();
  inline void set_allocated_obj2(::proto::common::cross_arena_ex* obj2);

  // optional uint32 arena_ai_id = 3;
  inline bool has_arena_ai_id() const;
  inline void clear_arena_ai_id();
  static const int kArenaAiIdFieldNumber = 3;
  inline ::google::protobuf::uint32 arena_ai_id() const;
  inline void set_arena_ai_id(::google::protobuf::uint32 value);

  // optional uint32 monster_id = 4;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 4;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.cross_arena_param)
 private:
  inline void set_has_obj1();
  inline void clear_has_obj1();
  inline void set_has_obj2();
  inline void clear_has_obj2();
  inline void set_has_arena_ai_id();
  inline void clear_has_arena_ai_id();
  inline void set_has_monster_id();
  inline void clear_has_monster_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::cross_arena_ex* obj1_;
  ::proto::common::cross_arena_ex* obj2_;
  ::google::protobuf::uint32 arena_ai_id_;
  ::google::protobuf::uint32 monster_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static cross_arena_param* default_instance_;
};
// -------------------------------------------------------------------

class fight_param : public ::google::protobuf::Message {
 public:
  fight_param();
  virtual ~fight_param();

  fight_param(const fight_param& from);

  inline fight_param& operator=(const fight_param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_param& default_instance();

  void Swap(fight_param* other);

  // implements Message ----------------------------------------------

  fight_param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_param& from);
  void MergeFrom(const fight_param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.fight_type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::common::fight_type type() const;
  inline void set_type(::proto::common::fight_type value);

  // optional .proto.common.fight_state start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline const ::proto::common::fight_state& start() const;
  inline ::proto::common::fight_state* mutable_start();
  inline ::proto::common::fight_state* release_start();
  inline void set_allocated_start(::proto::common::fight_state* start);

  // optional .proto.common.fight_dark_param dark = 3;
  inline bool has_dark() const;
  inline void clear_dark();
  static const int kDarkFieldNumber = 3;
  inline const ::proto::common::fight_dark_param& dark() const;
  inline ::proto::common::fight_dark_param* mutable_dark();
  inline ::proto::common::fight_dark_param* release_dark();
  inline void set_allocated_dark(::proto::common::fight_dark_param* dark);

  // optional .proto.common.fight_light_param light = 4;
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 4;
  inline const ::proto::common::fight_light_param& light() const;
  inline ::proto::common::fight_light_param* mutable_light();
  inline ::proto::common::fight_light_param* release_light();
  inline void set_allocated_light(::proto::common::fight_light_param* light);

  // optional .proto.common.cross_arena_param cross_arena = 5;
  inline bool has_cross_arena() const;
  inline void clear_cross_arena();
  static const int kCrossArenaFieldNumber = 5;
  inline const ::proto::common::cross_arena_param& cross_arena() const;
  inline ::proto::common::cross_arena_param* mutable_cross_arena();
  inline ::proto::common::cross_arena_param* release_cross_arena();
  inline void set_allocated_cross_arena(::proto::common::cross_arena_param* cross_arena);

  // optional uint32 stage_id = 6;
  inline bool has_stage_id() const;
  inline void clear_stage_id();
  static const int kStageIdFieldNumber = 6;
  inline ::google::protobuf::uint32 stage_id() const;
  inline void set_stage_id(::google::protobuf::uint32 value);

  // optional uint32 against_id = 7;
  inline bool has_against_id() const;
  inline void clear_against_id();
  static const int kAgainstIdFieldNumber = 7;
  inline ::google::protobuf::uint32 against_id() const;
  inline void set_against_id(::google::protobuf::uint32 value);

  // optional uint64 trigger_id = 8;
  inline bool has_trigger_id() const;
  inline void clear_trigger_id();
  static const int kTriggerIdFieldNumber = 8;
  inline ::google::protobuf::uint64 trigger_id() const;
  inline void set_trigger_id(::google::protobuf::uint64 value);

  // optional uint32 prepare_time = 9;
  inline bool has_prepare_time() const;
  inline void clear_prepare_time();
  static const int kPrepareTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 prepare_time() const;
  inline void set_prepare_time(::google::protobuf::uint32 value);

  // optional uint32 offline_arena_class = 10;
  inline bool has_offline_arena_class() const;
  inline void clear_offline_arena_class();
  static const int kOfflineArenaClassFieldNumber = 10;
  inline ::google::protobuf::uint32 offline_arena_class() const;
  inline void set_offline_arena_class(::google::protobuf::uint32 value);

  // optional uint32 page_id = 11;
  inline bool has_page_id() const;
  inline void clear_page_id();
  static const int kPageIdFieldNumber = 11;
  inline ::google::protobuf::uint32 page_id() const;
  inline void set_page_id(::google::protobuf::uint32 value);

  // optional uint32 max_rounds = 12;
  inline bool has_max_rounds() const;
  inline void clear_max_rounds();
  static const int kMaxRoundsFieldNumber = 12;
  inline ::google::protobuf::uint32 max_rounds() const;
  inline void set_max_rounds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_param)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_dark();
  inline void clear_has_dark();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_cross_arena();
  inline void clear_has_cross_arena();
  inline void set_has_stage_id();
  inline void clear_has_stage_id();
  inline void set_has_against_id();
  inline void clear_has_against_id();
  inline void set_has_trigger_id();
  inline void clear_has_trigger_id();
  inline void set_has_prepare_time();
  inline void clear_has_prepare_time();
  inline void set_has_offline_arena_class();
  inline void clear_has_offline_arena_class();
  inline void set_has_page_id();
  inline void clear_has_page_id();
  inline void set_has_max_rounds();
  inline void clear_has_max_rounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::fight_state* start_;
  ::proto::common::fight_dark_param* dark_;
  int type_;
  ::google::protobuf::uint32 stage_id_;
  ::proto::common::fight_light_param* light_;
  ::proto::common::cross_arena_param* cross_arena_;
  ::google::protobuf::uint64 trigger_id_;
  ::google::protobuf::uint32 against_id_;
  ::google::protobuf::uint32 prepare_time_;
  ::google::protobuf::uint32 offline_arena_class_;
  ::google::protobuf::uint32 page_id_;
  ::google::protobuf::uint32 max_rounds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_param* default_instance_;
};
// -------------------------------------------------------------------

class fight_common : public ::google::protobuf::Message {
 public:
  fight_common();
  virtual ~fight_common();

  fight_common(const fight_common& from);

  inline fight_common& operator=(const fight_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_common& default_instance();

  void Swap(fight_common* other);

  // implements Message ----------------------------------------------

  fight_common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_common& from);
  void MergeFrom(const fight_common& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fight_id = 1;
  inline bool has_fight_id() const;
  inline void clear_fight_id();
  static const int kFightIdFieldNumber = 1;
  inline const ::std::string& fight_id() const;
  inline void set_fight_id(const ::std::string& value);
  inline void set_fight_id(const char* value);
  inline void set_fight_id(const char* value, size_t size);
  inline ::std::string* mutable_fight_id();
  inline ::std::string* release_fight_id();
  inline void set_allocated_fight_id(::std::string* fight_id);

  // optional .proto.common.fight_param param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::proto::common::fight_param& param() const;
  inline ::proto::common::fight_param* mutable_param();
  inline ::proto::common::fight_param* release_param();
  inline void set_allocated_param(::proto::common::fight_param* param);

  // optional uint32 self_position_id = 3;
  inline bool has_self_position_id() const;
  inline void clear_self_position_id();
  static const int kSelfPositionIdFieldNumber = 3;
  inline ::google::protobuf::uint32 self_position_id() const;
  inline void set_self_position_id(::google::protobuf::uint32 value);

  // optional uint32 enemy_position_id = 4;
  inline bool has_enemy_position_id() const;
  inline void clear_enemy_position_id();
  static const int kEnemyPositionIdFieldNumber = 4;
  inline ::google::protobuf::uint32 enemy_position_id() const;
  inline void set_enemy_position_id(::google::protobuf::uint32 value);

  // optional string fight_initiator = 5;
  inline bool has_fight_initiator() const;
  inline void clear_fight_initiator();
  static const int kFightInitiatorFieldNumber = 5;
  inline const ::std::string& fight_initiator() const;
  inline void set_fight_initiator(const ::std::string& value);
  inline void set_fight_initiator(const char* value);
  inline void set_fight_initiator(const char* value, size_t size);
  inline ::std::string* mutable_fight_initiator();
  inline ::std::string* release_fight_initiator();
  inline void set_allocated_fight_initiator(::std::string* fight_initiator);

  // @@protoc_insertion_point(class_scope:proto.common.fight_common)
 private:
  inline void set_has_fight_id();
  inline void clear_has_fight_id();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_self_position_id();
  inline void clear_has_self_position_id();
  inline void set_has_enemy_position_id();
  inline void clear_has_enemy_position_id();
  inline void set_has_fight_initiator();
  inline void clear_has_fight_initiator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fight_id_;
  ::proto::common::fight_param* param_;
  ::google::protobuf::uint32 self_position_id_;
  ::google::protobuf::uint32 enemy_position_id_;
  ::std::string* fight_initiator_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_common* default_instance_;
};
// -------------------------------------------------------------------

class obj_single : public ::google::protobuf::Message {
 public:
  obj_single();
  virtual ~obj_single();

  obj_single(const obj_single& from);

  inline obj_single& operator=(const obj_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const obj_single& default_instance();

  void Swap(obj_single* other);

  // implements Message ----------------------------------------------

  obj_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const obj_single& from);
  void MergeFrom(const obj_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string object_uid = 1;
  inline bool has_object_uid() const;
  inline void clear_object_uid();
  static const int kObjectUidFieldNumber = 1;
  inline const ::std::string& object_uid() const;
  inline void set_object_uid(const ::std::string& value);
  inline void set_object_uid(const char* value);
  inline void set_object_uid(const char* value, size_t size);
  inline ::std::string* mutable_object_uid();
  inline ::std::string* release_object_uid();
  inline void set_allocated_object_uid(::std::string* object_uid);

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2 [default = SCENEOBJECT_USER];
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 2;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional uint32 monster_id = 3;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 3;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // optional uint32 camp = 4;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 4;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // optional uint32 auto_fight = 5;
  inline bool has_auto_fight() const;
  inline void clear_auto_fight();
  static const int kAutoFightFieldNumber = 5;
  inline ::google::protobuf::uint32 auto_fight() const;
  inline void set_auto_fight(::google::protobuf::uint32 value);

  // optional uint32 sp = 6;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 6;
  inline ::google::protobuf::uint32 sp() const;
  inline void set_sp(::google::protobuf::uint32 value);

  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 head_id = 9;
  inline bool has_head_id() const;
  inline void clear_head_id();
  static const int kHeadIdFieldNumber = 9;
  inline ::google::protobuf::uint32 head_id() const;
  inline void set_head_id(::google::protobuf::uint32 value);

  // optional uint32 country = 10;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 10;
  inline ::google::protobuf::uint32 country() const;
  inline void set_country(::google::protobuf::uint32 value);

  // optional string family_name = 11;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 11;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 fighting = 12;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 12;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 life_level = 13;
  inline bool has_life_level() const;
  inline void clear_life_level();
  static const int kLifeLevelFieldNumber = 13;
  inline ::google::protobuf::uint32 life_level() const;
  inline void set_life_level(::google::protobuf::uint32 value);

  // optional uint32 team_member_size = 14;
  inline bool has_team_member_size() const;
  inline void clear_team_member_size();
  static const int kTeamMemberSizeFieldNumber = 14;
  inline ::google::protobuf::uint32 team_member_size() const;
  inline void set_team_member_size(::google::protobuf::uint32 value);

  // optional int32 team_member_pos = 15;
  inline bool has_team_member_pos() const;
  inline void clear_team_member_pos();
  static const int kTeamMemberPosFieldNumber = 15;
  inline ::google::protobuf::int32 team_member_pos() const;
  inline void set_team_member_pos(::google::protobuf::int32 value);

  // optional uint32 auto_ignore_lineup = 16;
  inline bool has_auto_ignore_lineup() const;
  inline void clear_auto_ignore_lineup();
  static const int kAutoIgnoreLineupFieldNumber = 16;
  inline ::google::protobuf::uint32 auto_ignore_lineup() const;
  inline void set_auto_ignore_lineup(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.obj_single)
 private:
  inline void set_has_object_uid();
  inline void clear_has_object_uid();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_auto_fight();
  inline void clear_has_auto_fight();
  inline void set_has_sp();
  inline void clear_has_sp();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_head_id();
  inline void clear_has_head_id();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_life_level();
  inline void clear_has_life_level();
  inline void set_has_team_member_size();
  inline void clear_has_team_member_size();
  inline void set_has_team_member_pos();
  inline void clear_has_team_member_pos();
  inline void set_has_auto_ignore_lineup();
  inline void clear_has_auto_ignore_lineup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_uid_;
  int object_type_;
  ::google::protobuf::uint32 monster_id_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 auto_fight_;
  ::std::string* name_;
  ::google::protobuf::uint32 sp_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 head_id_;
  ::google::protobuf::uint32 country_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 life_level_;
  ::google::protobuf::uint32 team_member_size_;
  ::google::protobuf::int32 team_member_pos_;
  ::google::protobuf::uint32 auto_ignore_lineup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static obj_single* default_instance_;
};
// -------------------------------------------------------------------

class obj_data : public ::google::protobuf::Message {
 public:
  obj_data();
  virtual ~obj_data();

  obj_data(const obj_data& from);

  inline obj_data& operator=(const obj_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const obj_data& default_instance();

  void Swap(obj_data* other);

  // implements Message ----------------------------------------------

  obj_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const obj_data& from);
  void MergeFrom(const obj_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.obj_single obj = 1;
  inline int obj_size() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 1;
  inline const ::proto::common::obj_single& obj(int index) const;
  inline ::proto::common::obj_single* mutable_obj(int index);
  inline ::proto::common::obj_single* add_obj();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::obj_single >&
      obj() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::obj_single >*
      mutable_obj();

  // @@protoc_insertion_point(class_scope:proto.common.obj_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::obj_single > obj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static obj_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_camp : public ::google::protobuf::Message {
 public:
  fight_camp();
  virtual ~fight_camp();

  fight_camp(const fight_camp& from);

  inline fight_camp& operator=(const fight_camp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_camp& default_instance();

  void Swap(fight_camp* other);

  // implements Message ----------------------------------------------

  fight_camp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_camp& from);
  void MergeFrom(const fight_camp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.obj_data objs = 1;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 1;
  inline const ::proto::common::obj_data& objs() const;
  inline ::proto::common::obj_data* mutable_objs();
  inline ::proto::common::obj_data* release_objs();
  inline void set_allocated_objs(::proto::common::obj_data* objs);

  // optional .proto.common.hero_data heroes = 2;
  inline bool has_heroes() const;
  inline void clear_heroes();
  static const int kHeroesFieldNumber = 2;
  inline const ::proto::common::hero_data& heroes() const;
  inline ::proto::common::hero_data* mutable_heroes();
  inline ::proto::common::hero_data* release_heroes();
  inline void set_allocated_heroes(::proto::common::hero_data* heroes);

  // optional uint32 camp = 3;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 3;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // optional uint32 tactic = 4;
  inline bool has_tactic() const;
  inline void clear_tactic();
  static const int kTacticFieldNumber = 4;
  inline ::google::protobuf::uint32 tactic() const;
  inline void set_tactic(::google::protobuf::uint32 value);

  // optional uint32 tactic_switch = 5;
  inline bool has_tactic_switch() const;
  inline void clear_tactic_switch();
  static const int kTacticSwitchFieldNumber = 5;
  inline ::google::protobuf::uint32 tactic_switch() const;
  inline void set_tactic_switch(::google::protobuf::uint32 value);

  // optional .proto.common.hero_data help_heroes = 6;
  inline bool has_help_heroes() const;
  inline void clear_help_heroes();
  static const int kHelpHeroesFieldNumber = 6;
  inline const ::proto::common::hero_data& help_heroes() const;
  inline ::proto::common::hero_data* mutable_help_heroes();
  inline ::proto::common::hero_data* release_help_heroes();
  inline void set_allocated_help_heroes(::proto::common::hero_data* help_heroes);

  // @@protoc_insertion_point(class_scope:proto.common.fight_camp)
 private:
  inline void set_has_objs();
  inline void clear_has_objs();
  inline void set_has_heroes();
  inline void clear_has_heroes();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_tactic();
  inline void clear_has_tactic();
  inline void set_has_tactic_switch();
  inline void clear_has_tactic_switch();
  inline void set_has_help_heroes();
  inline void clear_has_help_heroes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::obj_data* objs_;
  ::proto::common::hero_data* heroes_;
  ::google::protobuf::uint32 camp_;
  ::google::protobuf::uint32 tactic_;
  ::proto::common::hero_data* help_heroes_;
  ::google::protobuf::uint32 tactic_switch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_camp* default_instance_;
};
// -------------------------------------------------------------------

class fight_state : public ::google::protobuf::Message {
 public:
  fight_state();
  virtual ~fight_state();

  fight_state(const fight_state& from);

  inline fight_state& operator=(const fight_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_state& default_instance();

  void Swap(fight_state* other);

  // implements Message ----------------------------------------------

  fight_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_state& from);
  void MergeFrom(const fight_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.hero_state_data self = 1;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 1;
  inline const ::proto::common::hero_state_data& self() const;
  inline ::proto::common::hero_state_data* mutable_self();
  inline ::proto::common::hero_state_data* release_self();
  inline void set_allocated_self(::proto::common::hero_state_data* self);

  // optional .proto.common.hero_state_data enemy = 2;
  inline bool has_enemy() const;
  inline void clear_enemy();
  static const int kEnemyFieldNumber = 2;
  inline const ::proto::common::hero_state_data& enemy() const;
  inline ::proto::common::hero_state_data* mutable_enemy();
  inline ::proto::common::hero_state_data* release_enemy();
  inline void set_allocated_enemy(::proto::common::hero_state_data* enemy);

  // @@protoc_insertion_point(class_scope:proto.common.fight_state)
 private:
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_enemy();
  inline void clear_has_enemy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::hero_state_data* self_;
  ::proto::common::hero_state_data* enemy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_state* default_instance_;
};
// -------------------------------------------------------------------

class fight_data : public ::google::protobuf::Message {
 public:
  fight_data();
  virtual ~fight_data();

  fight_data(const fight_data& from);

  inline fight_data& operator=(const fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_data& default_instance();

  void Swap(fight_data* other);

  // implements Message ----------------------------------------------

  fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_data& from);
  void MergeFrom(const fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.fight_common common = 1;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 1;
  inline const ::proto::common::fight_common& common() const;
  inline ::proto::common::fight_common* mutable_common();
  inline ::proto::common::fight_common* release_common();
  inline void set_allocated_common(::proto::common::fight_common* common);

  // optional .proto.common.fight_camp self = 2;
  inline bool has_self() const;
  inline void clear_self();
  static const int kSelfFieldNumber = 2;
  inline const ::proto::common::fight_camp& self() const;
  inline ::proto::common::fight_camp* mutable_self();
  inline ::proto::common::fight_camp* release_self();
  inline void set_allocated_self(::proto::common::fight_camp* self);

  // optional .proto.common.fight_camp enemy = 3;
  inline bool has_enemy() const;
  inline void clear_enemy();
  static const int kEnemyFieldNumber = 3;
  inline const ::proto::common::fight_camp& enemy() const;
  inline ::proto::common::fight_camp* mutable_enemy();
  inline ::proto::common::fight_camp* release_enemy();
  inline void set_allocated_enemy(::proto::common::fight_camp* enemy);

  // @@protoc_insertion_point(class_scope:proto.common.fight_data)
 private:
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_self();
  inline void clear_has_self();
  inline void set_has_enemy();
  inline void clear_has_enemy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::fight_common* common_;
  ::proto::common::fight_camp* self_;
  ::proto::common::fight_camp* enemy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_recovery_obj_single : public ::google::protobuf::Message {
 public:
  fight_recovery_obj_single();
  virtual ~fight_recovery_obj_single();

  fight_recovery_obj_single(const fight_recovery_obj_single& from);

  inline fight_recovery_obj_single& operator=(const fight_recovery_obj_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_recovery_obj_single& default_instance();

  void Swap(fight_recovery_obj_single* other);

  // implements Message ----------------------------------------------

  fight_recovery_obj_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_recovery_obj_single& from);
  void MergeFrom(const fight_recovery_obj_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 sp = 2;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 2;
  inline ::google::protobuf::uint32 sp() const;
  inline void set_sp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_recovery_obj_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sp();
  inline void clear_has_sp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::uint32 sp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_recovery_obj_single* default_instance_;
};
// -------------------------------------------------------------------

class fight_recovery_obj_data : public ::google::protobuf::Message {
 public:
  fight_recovery_obj_data();
  virtual ~fight_recovery_obj_data();

  fight_recovery_obj_data(const fight_recovery_obj_data& from);

  inline fight_recovery_obj_data& operator=(const fight_recovery_obj_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_recovery_obj_data& default_instance();

  void Swap(fight_recovery_obj_data* other);

  // implements Message ----------------------------------------------

  fight_recovery_obj_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_recovery_obj_data& from);
  void MergeFrom(const fight_recovery_obj_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_recovery_obj_single objs = 1;
  inline int objs_size() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 1;
  inline const ::proto::common::fight_recovery_obj_single& objs(int index) const;
  inline ::proto::common::fight_recovery_obj_single* mutable_objs(int index);
  inline ::proto::common::fight_recovery_obj_single* add_objs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_obj_single >&
      objs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_obj_single >*
      mutable_objs();

  // @@protoc_insertion_point(class_scope:proto.common.fight_recovery_obj_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_obj_single > objs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_recovery_obj_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_buff_single_data : public ::google::protobuf::Message {
 public:
  fight_buff_single_data();
  virtual ~fight_buff_single_data();

  fight_buff_single_data(const fight_buff_single_data& from);

  inline fight_buff_single_data& operator=(const fight_buff_single_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_buff_single_data& default_instance();

  void Swap(fight_buff_single_data* other);

  // implements Message ----------------------------------------------

  fight_buff_single_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_buff_single_data& from);
  void MergeFrom(const fight_buff_single_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 buff_id = 1;
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::uint32 buff_id() const;
  inline void set_buff_id(::google::protobuf::uint32 value);

  // optional string attacker = 2;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 2;
  inline const ::std::string& attacker() const;
  inline void set_attacker(const ::std::string& value);
  inline void set_attacker(const char* value);
  inline void set_attacker(const char* value, size_t size);
  inline ::std::string* mutable_attacker();
  inline ::std::string* release_attacker();
  inline void set_allocated_attacker(::std::string* attacker);

  // optional uint32 layer = 3;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline ::google::protobuf::uint32 layer() const;
  inline void set_layer(::google::protobuf::uint32 value);

  // optional uint32 round = 4;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 4;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // optional uint32 buff_tid = 5;
  inline bool has_buff_tid() const;
  inline void clear_buff_tid();
  static const int kBuffTidFieldNumber = 5;
  inline ::google::protobuf::uint32 buff_tid() const;
  inline void set_buff_tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_buff_single_data)
 private:
  inline void set_has_buff_id();
  inline void clear_has_buff_id();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_buff_tid();
  inline void clear_has_buff_tid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* attacker_;
  ::google::protobuf::uint32 buff_id_;
  ::google::protobuf::uint32 layer_;
  ::google::protobuf::uint32 round_;
  ::google::protobuf::uint32 buff_tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_buff_single_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_buff_data : public ::google::protobuf::Message {
 public:
  fight_buff_data();
  virtual ~fight_buff_data();

  fight_buff_data(const fight_buff_data& from);

  inline fight_buff_data& operator=(const fight_buff_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_buff_data& default_instance();

  void Swap(fight_buff_data* other);

  // implements Message ----------------------------------------------

  fight_buff_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_buff_data& from);
  void MergeFrom(const fight_buff_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_buff_single_data buff_list = 1;
  inline int buff_list_size() const;
  inline void clear_buff_list();
  static const int kBuffListFieldNumber = 1;
  inline const ::proto::common::fight_buff_single_data& buff_list(int index) const;
  inline ::proto::common::fight_buff_single_data* mutable_buff_list(int index);
  inline ::proto::common::fight_buff_single_data* add_buff_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_buff_single_data >&
      buff_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_buff_single_data >*
      mutable_buff_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_buff_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_buff_single_data > buff_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_buff_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_hero_skill_single_data : public ::google::protobuf::Message {
 public:
  fight_hero_skill_single_data();
  virtual ~fight_hero_skill_single_data();

  fight_hero_skill_single_data(const fight_hero_skill_single_data& from);

  inline fight_hero_skill_single_data& operator=(const fight_hero_skill_single_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_hero_skill_single_data& default_instance();

  void Swap(fight_hero_skill_single_data* other);

  // implements Message ----------------------------------------------

  fight_hero_skill_single_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_hero_skill_single_data& from);
  void MergeFrom(const fight_hero_skill_single_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 skill_cd = 2;
  inline bool has_skill_cd() const;
  inline void clear_skill_cd();
  static const int kSkillCdFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_cd() const;
  inline void set_skill_cd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_hero_skill_single_data)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_cd();
  inline void clear_has_skill_cd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 skill_cd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_hero_skill_single_data* default_instance_;
};
// -------------------------------------------------------------------

class combat_all_action_data : public ::google::protobuf::Message {
 public:
  combat_all_action_data();
  virtual ~combat_all_action_data();

  combat_all_action_data(const combat_all_action_data& from);

  inline combat_all_action_data& operator=(const combat_all_action_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_all_action_data& default_instance();

  void Swap(combat_all_action_data* other);

  // implements Message ----------------------------------------------

  combat_all_action_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_all_action_data& from);
  void MergeFrom(const combat_all_action_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_action_data action_data = 1;
  inline int action_data_size() const;
  inline void clear_action_data();
  static const int kActionDataFieldNumber = 1;
  inline const ::proto::common::combat_action_data& action_data(int index) const;
  inline ::proto::common::combat_action_data* mutable_action_data(int index);
  inline ::proto::common::combat_action_data* add_action_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_action_data >&
      action_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_action_data >*
      mutable_action_data();

  // @@protoc_insertion_point(class_scope:proto.common.combat_all_action_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_action_data > action_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_all_action_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_video_data : public ::google::protobuf::Message {
 public:
  fight_video_data();
  virtual ~fight_video_data();

  fight_video_data(const fight_video_data& from);

  inline fight_video_data& operator=(const fight_video_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_video_data& default_instance();

  void Swap(fight_video_data* other);

  // implements Message ----------------------------------------------

  fight_video_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_video_data& from);
  void MergeFrom(const fight_video_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.fight_data data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::proto::common::fight_data& data() const;
  inline ::proto::common::fight_data* mutable_data();
  inline ::proto::common::fight_data* release_data();
  inline void set_allocated_data(::proto::common::fight_data* data);

  // optional .proto.common.combat_all_action_data action_data = 2;
  inline bool has_action_data() const;
  inline void clear_action_data();
  static const int kActionDataFieldNumber = 2;
  inline const ::proto::common::combat_all_action_data& action_data() const;
  inline ::proto::common::combat_all_action_data* mutable_action_data();
  inline ::proto::common::combat_all_action_data* release_action_data();
  inline void set_allocated_action_data(::proto::common::combat_all_action_data* action_data);

  // optional .proto.common.combat_count_data result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline const ::proto::common::combat_count_data& result() const;
  inline ::proto::common::combat_count_data* mutable_result();
  inline ::proto::common::combat_count_data* release_result();
  inline void set_allocated_result(::proto::common::combat_count_data* result);

  // @@protoc_insertion_point(class_scope:proto.common.fight_video_data)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_action_data();
  inline void clear_has_action_data();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::fight_data* data_;
  ::proto::common::combat_all_action_data* action_data_;
  ::proto::common::combat_count_data* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_video_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_hero_skill_data : public ::google::protobuf::Message {
 public:
  fight_hero_skill_data();
  virtual ~fight_hero_skill_data();

  fight_hero_skill_data(const fight_hero_skill_data& from);

  inline fight_hero_skill_data& operator=(const fight_hero_skill_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_hero_skill_data& default_instance();

  void Swap(fight_hero_skill_data* other);

  // implements Message ----------------------------------------------

  fight_hero_skill_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_hero_skill_data& from);
  void MergeFrom(const fight_hero_skill_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.skill_single skill_list = 1;
  inline int skill_list_size() const;
  inline void clear_skill_list();
  static const int kSkillListFieldNumber = 1;
  inline const ::proto::common::skill_single& skill_list(int index) const;
  inline ::proto::common::skill_single* mutable_skill_list(int index);
  inline ::proto::common::skill_single* add_skill_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >&
      skill_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >*
      mutable_skill_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_hero_skill_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single > skill_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_hero_skill_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_hero_attr_single_data : public ::google::protobuf::Message {
 public:
  fight_hero_attr_single_data();
  virtual ~fight_hero_attr_single_data();

  fight_hero_attr_single_data(const fight_hero_attr_single_data& from);

  inline fight_hero_attr_single_data& operator=(const fight_hero_attr_single_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_hero_attr_single_data& default_instance();

  void Swap(fight_hero_attr_single_data* other);

  // implements Message ----------------------------------------------

  fight_hero_attr_single_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_hero_attr_single_data& from);
  void MergeFrom(const fight_hero_attr_single_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_hero_attr_single_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_hero_attr_single_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_hero_attr_data : public ::google::protobuf::Message {
 public:
  fight_hero_attr_data();
  virtual ~fight_hero_attr_data();

  fight_hero_attr_data(const fight_hero_attr_data& from);

  inline fight_hero_attr_data& operator=(const fight_hero_attr_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_hero_attr_data& default_instance();

  void Swap(fight_hero_attr_data* other);

  // implements Message ----------------------------------------------

  fight_hero_attr_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_hero_attr_data& from);
  void MergeFrom(const fight_hero_attr_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_hero_attr_single_data attr_list = 1;
  inline int attr_list_size() const;
  inline void clear_attr_list();
  static const int kAttrListFieldNumber = 1;
  inline const ::proto::common::fight_hero_attr_single_data& attr_list(int index) const;
  inline ::proto::common::fight_hero_attr_single_data* mutable_attr_list(int index);
  inline ::proto::common::fight_hero_attr_single_data* add_attr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_hero_attr_single_data >&
      attr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_hero_attr_single_data >*
      mutable_attr_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_hero_attr_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_hero_attr_single_data > attr_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_hero_attr_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_recovery_hero_single_data : public ::google::protobuf::Message {
 public:
  fight_recovery_hero_single_data();
  virtual ~fight_recovery_hero_single_data();

  fight_recovery_hero_single_data(const fight_recovery_hero_single_data& from);

  inline fight_recovery_hero_single_data& operator=(const fight_recovery_hero_single_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_recovery_hero_single_data& default_instance();

  void Swap(fight_recovery_hero_single_data* other);

  // implements Message ----------------------------------------------

  fight_recovery_hero_single_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_recovery_hero_single_data& from);
  void MergeFrom(const fight_recovery_hero_single_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional uint32 cur_hp = 2;
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_hp() const;
  inline void set_cur_hp(::google::protobuf::uint32 value);

  // optional .proto.common.fight_buff_data buff_data = 3;
  inline bool has_buff_data() const;
  inline void clear_buff_data();
  static const int kBuffDataFieldNumber = 3;
  inline const ::proto::common::fight_buff_data& buff_data() const;
  inline ::proto::common::fight_buff_data* mutable_buff_data();
  inline ::proto::common::fight_buff_data* release_buff_data();
  inline void set_allocated_buff_data(::proto::common::fight_buff_data* buff_data);

  // optional uint32 mark_id = 4;
  inline bool has_mark_id() const;
  inline void clear_mark_id();
  static const int kMarkIdFieldNumber = 4;
  inline ::google::protobuf::uint32 mark_id() const;
  inline void set_mark_id(::google::protobuf::uint32 value);

  // optional .proto.common.fight_hero_skill_data skill_data = 5;
  inline bool has_skill_data() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 5;
  inline const ::proto::common::fight_hero_skill_data& skill_data() const;
  inline ::proto::common::fight_hero_skill_data* mutable_skill_data();
  inline ::proto::common::fight_hero_skill_data* release_skill_data();
  inline void set_allocated_skill_data(::proto::common::fight_hero_skill_data* skill_data);

  // optional uint32 speed = 6;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 6;
  inline ::google::protobuf::uint32 speed() const;
  inline void set_speed(::google::protobuf::uint32 value);

  // optional .proto.common.fight_hero_attr_data attrs = 7;
  inline bool has_attrs() const;
  inline void clear_attrs();
  static const int kAttrsFieldNumber = 7;
  inline const ::proto::common::fight_hero_attr_data& attrs() const;
  inline ::proto::common::fight_hero_attr_data* mutable_attrs();
  inline ::proto::common::fight_hero_attr_data* release_attrs();
  inline void set_allocated_attrs(::proto::common::fight_hero_attr_data* attrs);

  // @@protoc_insertion_point(class_scope:proto.common.fight_recovery_hero_single_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();
  inline void set_has_buff_data();
  inline void clear_has_buff_data();
  inline void set_has_mark_id();
  inline void clear_has_mark_id();
  inline void set_has_skill_data();
  inline void clear_has_skill_data();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_attrs();
  inline void clear_has_attrs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::proto::common::fight_buff_data* buff_data_;
  ::google::protobuf::uint32 cur_hp_;
  ::google::protobuf::uint32 mark_id_;
  ::proto::common::fight_hero_skill_data* skill_data_;
  ::proto::common::fight_hero_attr_data* attrs_;
  ::google::protobuf::uint32 speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_recovery_hero_single_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_recovery_hero_data : public ::google::protobuf::Message {
 public:
  fight_recovery_hero_data();
  virtual ~fight_recovery_hero_data();

  fight_recovery_hero_data(const fight_recovery_hero_data& from);

  inline fight_recovery_hero_data& operator=(const fight_recovery_hero_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_recovery_hero_data& default_instance();

  void Swap(fight_recovery_hero_data* other);

  // implements Message ----------------------------------------------

  fight_recovery_hero_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_recovery_hero_data& from);
  void MergeFrom(const fight_recovery_hero_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_recovery_hero_single_data hero_list = 1;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 1;
  inline const ::proto::common::fight_recovery_hero_single_data& hero_list(int index) const;
  inline ::proto::common::fight_recovery_hero_single_data* mutable_hero_list(int index);
  inline ::proto::common::fight_recovery_hero_single_data* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_hero_single_data >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_hero_single_data >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_recovery_hero_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_hero_single_data > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_recovery_hero_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_recovery_data : public ::google::protobuf::Message {
 public:
  fight_recovery_data();
  virtual ~fight_recovery_data();

  fight_recovery_data(const fight_recovery_data& from);

  inline fight_recovery_data& operator=(const fight_recovery_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_recovery_data& default_instance();

  void Swap(fight_recovery_data* other);

  // implements Message ----------------------------------------------

  fight_recovery_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_recovery_data& from);
  void MergeFrom(const fight_recovery_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.fight_recovery_obj_data objs = 1;
  inline bool has_objs() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 1;
  inline const ::proto::common::fight_recovery_obj_data& objs() const;
  inline ::proto::common::fight_recovery_obj_data* mutable_objs();
  inline ::proto::common::fight_recovery_obj_data* release_objs();
  inline void set_allocated_objs(::proto::common::fight_recovery_obj_data* objs);

  // optional .proto.common.fight_recovery_hero_data heroes = 2;
  inline bool has_heroes() const;
  inline void clear_heroes();
  static const int kHeroesFieldNumber = 2;
  inline const ::proto::common::fight_recovery_hero_data& heroes() const;
  inline ::proto::common::fight_recovery_hero_data* mutable_heroes();
  inline ::proto::common::fight_recovery_hero_data* release_heroes();
  inline void set_allocated_heroes(::proto::common::fight_recovery_hero_data* heroes);

  // optional .proto.common.formation_single self_formation_data = 3;
  inline bool has_self_formation_data() const;
  inline void clear_self_formation_data();
  static const int kSelfFormationDataFieldNumber = 3;
  inline const ::proto::common::formation_single& self_formation_data() const;
  inline ::proto::common::formation_single* mutable_self_formation_data();
  inline ::proto::common::formation_single* release_self_formation_data();
  inline void set_allocated_self_formation_data(::proto::common::formation_single* self_formation_data);

  // optional .proto.common.formation_single enemy_formation_data = 4;
  inline bool has_enemy_formation_data() const;
  inline void clear_enemy_formation_data();
  static const int kEnemyFormationDataFieldNumber = 4;
  inline const ::proto::common::formation_single& enemy_formation_data() const;
  inline ::proto::common::formation_single* mutable_enemy_formation_data();
  inline ::proto::common::formation_single* release_enemy_formation_data();
  inline void set_allocated_enemy_formation_data(::proto::common::formation_single* enemy_formation_data);

  // @@protoc_insertion_point(class_scope:proto.common.fight_recovery_data)
 private:
  inline void set_has_objs();
  inline void clear_has_objs();
  inline void set_has_heroes();
  inline void clear_has_heroes();
  inline void set_has_self_formation_data();
  inline void clear_has_self_formation_data();
  inline void set_has_enemy_formation_data();
  inline void clear_has_enemy_formation_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::fight_recovery_obj_data* objs_;
  ::proto::common::fight_recovery_hero_data* heroes_;
  ::proto::common::formation_single* self_formation_data_;
  ::proto::common::formation_single* enemy_formation_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_recovery_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_process : public ::google::protobuf::Message {
 public:
  fight_process();
  virtual ~fight_process();

  fight_process(const fight_process& from);

  inline fight_process& operator=(const fight_process& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_process& default_instance();

  void Swap(fight_process* other);

  // implements Message ----------------------------------------------

  fight_process* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_process& from);
  void MergeFrom(const fight_process& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.fight_state state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline const ::proto::common::fight_state& state() const;
  inline ::proto::common::fight_state* mutable_state();
  inline ::proto::common::fight_state* release_state();
  inline void set_allocated_state(::proto::common::fight_state* state);

  // @@protoc_insertion_point(class_scope:proto.common.fight_process)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::fight_state* state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_process* default_instance_;
};
// -------------------------------------------------------------------

class fight_result : public ::google::protobuf::Message {
 public:
  fight_result();
  virtual ~fight_result();

  fight_result(const fight_result& from);

  inline fight_result& operator=(const fight_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_result& default_instance();

  void Swap(fight_result* other);

  // implements Message ----------------------------------------------

  fight_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_result& from);
  void MergeFrom(const fight_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fight_id = 1;
  inline bool has_fight_id() const;
  inline void clear_fight_id();
  static const int kFightIdFieldNumber = 1;
  inline const ::std::string& fight_id() const;
  inline void set_fight_id(const ::std::string& value);
  inline void set_fight_id(const char* value);
  inline void set_fight_id(const char* value, size_t size);
  inline ::std::string* mutable_fight_id();
  inline ::std::string* release_fight_id();
  inline void set_allocated_fight_id(::std::string* fight_id);

  // optional .proto.common.fight_process process = 2;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 2;
  inline const ::proto::common::fight_process& process() const;
  inline ::proto::common::fight_process* mutable_process();
  inline ::proto::common::fight_process* release_process();
  inline void set_allocated_process(::proto::common::fight_process* process);

  // optional uint32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_result)
 private:
  inline void set_has_fight_id();
  inline void clear_has_fight_id();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fight_id_;
  ::proto::common::fight_process* process_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_result* default_instance_;
};
// -------------------------------------------------------------------

class rank_role_base : public ::google::protobuf::Message {
 public:
  rank_role_base();
  virtual ~rank_role_base();

  rank_role_base(const rank_role_base& from);

  inline rank_role_base& operator=(const rank_role_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_role_base& default_instance();

  void Swap(rank_role_base* other);

  // implements Message ----------------------------------------------

  rank_role_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_role_base& from);
  void MergeFrom(const rank_role_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 plugin = 2;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 2;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 head_frame_id = 3;
  inline bool has_head_frame_id() const;
  inline void clear_head_frame_id();
  static const int kHeadFrameIdFieldNumber = 3;
  inline ::google::protobuf::uint32 head_frame_id() const;
  inline void set_head_frame_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.rank_role_base)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_head_frame_id();
  inline void clear_has_head_frame_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 head_frame_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_role_base* default_instance_;
};
// -------------------------------------------------------------------

class rank_family_base : public ::google::protobuf::Message {
 public:
  rank_family_base();
  virtual ~rank_family_base();

  rank_family_base(const rank_family_base& from);

  inline rank_family_base& operator=(const rank_family_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_family_base& default_instance();

  void Swap(rank_family_base* other);

  // implements Message ----------------------------------------------

  rank_family_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_family_base& from);
  void MergeFrom(const rank_family_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.rank_family_base)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_family_base* default_instance_;
};
// -------------------------------------------------------------------

class rank_score_tower : public ::google::protobuf::Message {
 public:
  rank_score_tower();
  virtual ~rank_score_tower();

  rank_score_tower(const rank_score_tower& from);

  inline rank_score_tower& operator=(const rank_score_tower& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_score_tower& default_instance();

  void Swap(rank_score_tower* other);

  // implements Message ----------------------------------------------

  rank_score_tower* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_score_tower& from);
  void MergeFrom(const rank_score_tower& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cost_day = 1;
  inline bool has_cost_day() const;
  inline void clear_cost_day();
  static const int kCostDayFieldNumber = 1;
  inline ::google::protobuf::uint32 cost_day() const;
  inline void set_cost_day(::google::protobuf::uint32 value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.rank_score_tower)
 private:
  inline void set_has_cost_day();
  inline void clear_has_cost_day();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cost_day_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_score_tower* default_instance_;
};
// -------------------------------------------------------------------

class rank_score_achievement : public ::google::protobuf::Message {
 public:
  rank_score_achievement();
  virtual ~rank_score_achievement();

  rank_score_achievement(const rank_score_achievement& from);

  inline rank_score_achievement& operator=(const rank_score_achievement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_score_achievement& default_instance();

  void Swap(rank_score_achievement* other);

  // implements Message ----------------------------------------------

  rank_score_achievement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_score_achievement& from);
  void MergeFrom(const rank_score_achievement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.rank_score_achievement)
 private:
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_score_achievement* default_instance_;
};
// -------------------------------------------------------------------

class rank_data_extra : public ::google::protobuf::Message {
 public:
  rank_data_extra();
  virtual ~rank_data_extra();

  rank_data_extra(const rank_data_extra& from);

  inline rank_data_extra& operator=(const rank_data_extra& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_data_extra& default_instance();

  void Swap(rank_data_extra* other);

  // implements Message ----------------------------------------------

  rank_data_extra* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_data_extra& from);
  void MergeFrom(const rank_data_extra& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.rank_score_tower tower = 1;
  inline bool has_tower() const;
  inline void clear_tower();
  static const int kTowerFieldNumber = 1;
  inline const ::proto::common::rank_score_tower& tower() const;
  inline ::proto::common::rank_score_tower* mutable_tower();
  inline ::proto::common::rank_score_tower* release_tower();
  inline void set_allocated_tower(::proto::common::rank_score_tower* tower);

  // optional .proto.common.rank_score_achievement achieve = 2;
  inline bool has_achieve() const;
  inline void clear_achieve();
  static const int kAchieveFieldNumber = 2;
  inline const ::proto::common::rank_score_achievement& achieve() const;
  inline ::proto::common::rank_score_achievement* mutable_achieve();
  inline ::proto::common::rank_score_achievement* release_achieve();
  inline void set_allocated_achieve(::proto::common::rank_score_achievement* achieve);

  // @@protoc_insertion_point(class_scope:proto.common.rank_data_extra)
 private:
  inline void set_has_tower();
  inline void clear_has_tower();
  inline void set_has_achieve();
  inline void clear_has_achieve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::rank_score_tower* tower_;
  ::proto::common::rank_score_achievement* achieve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_data_extra* default_instance_;
};
// -------------------------------------------------------------------

class rank_single_data : public ::google::protobuf::Message {
 public:
  rank_single_data();
  virtual ~rank_single_data();

  rank_single_data(const rank_single_data& from);

  inline rank_single_data& operator=(const rank_single_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_single_data& default_instance();

  void Swap(rank_single_data* other);

  // implements Message ----------------------------------------------

  rank_single_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_single_data& from);
  void MergeFrom(const rank_single_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // optional uint32 index = 5;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional .proto.common.rank_role_base role_data = 6;
  inline bool has_role_data() const;
  inline void clear_role_data();
  static const int kRoleDataFieldNumber = 6;
  inline const ::proto::common::rank_role_base& role_data() const;
  inline ::proto::common::rank_role_base* mutable_role_data();
  inline ::proto::common::rank_role_base* release_role_data();
  inline void set_allocated_role_data(::proto::common::rank_role_base* role_data);

  // optional .proto.common.rank_family_base family_data = 7;
  inline bool has_family_data() const;
  inline void clear_family_data();
  static const int kFamilyDataFieldNumber = 7;
  inline const ::proto::common::rank_family_base& family_data() const;
  inline ::proto::common::rank_family_base* mutable_family_data();
  inline ::proto::common::rank_family_base* release_family_data();
  inline void set_allocated_family_data(::proto::common::rank_family_base* family_data);

  // optional .proto.common.country_common country_data = 8;
  inline bool has_country_data() const;
  inline void clear_country_data();
  static const int kCountryDataFieldNumber = 8;
  inline const ::proto::common::country_common& country_data() const;
  inline ::proto::common::country_common* mutable_country_data();
  inline ::proto::common::country_common* release_country_data();
  inline void set_allocated_country_data(::proto::common::country_common* country_data);

  // repeated string custom_data = 10;
  inline int custom_data_size() const;
  inline void clear_custom_data();
  static const int kCustomDataFieldNumber = 10;
  inline const ::std::string& custom_data(int index) const;
  inline ::std::string* mutable_custom_data(int index);
  inline void set_custom_data(int index, const ::std::string& value);
  inline void set_custom_data(int index, const char* value);
  inline void set_custom_data(int index, const char* value, size_t size);
  inline ::std::string* add_custom_data();
  inline void add_custom_data(const ::std::string& value);
  inline void add_custom_data(const char* value);
  inline void add_custom_data(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& custom_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_custom_data();

  // @@protoc_insertion_point(class_scope:proto.common.rank_single_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_role_data();
  inline void clear_has_role_data();
  inline void set_has_family_data();
  inline void clear_has_family_data();
  inline void set_has_country_data();
  inline void clear_has_country_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 index_;
  ::proto::common::rank_role_base* role_data_;
  ::proto::common::rank_family_base* family_data_;
  ::proto::common::country_common* country_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> custom_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_single_data* default_instance_;
};
// -------------------------------------------------------------------

class mount_data_single : public ::google::protobuf::Message {
 public:
  mount_data_single();
  virtual ~mount_data_single();

  mount_data_single(const mount_data_single& from);

  inline mount_data_single& operator=(const mount_data_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mount_data_single& default_instance();

  void Swap(mount_data_single* other);

  // implements Message ----------------------------------------------

  mount_data_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mount_data_single& from);
  void MergeFrom(const mount_data_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 mount_tid = 1;
  inline bool has_mount_tid() const;
  inline void clear_mount_tid();
  static const int kMountTidFieldNumber = 1;
  inline ::google::protobuf::uint32 mount_tid() const;
  inline void set_mount_tid(::google::protobuf::uint32 value);

  // optional .proto.common.mount_state_type mount_state = 2;
  inline bool has_mount_state() const;
  inline void clear_mount_state();
  static const int kMountStateFieldNumber = 2;
  inline ::proto::common::mount_state_type mount_state() const;
  inline void set_mount_state(::proto::common::mount_state_type value);

  // @@protoc_insertion_point(class_scope:proto.common.mount_data_single)
 private:
  inline void set_has_mount_tid();
  inline void clear_has_mount_tid();
  inline void set_has_mount_state();
  inline void clear_has_mount_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mount_tid_;
  int mount_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mount_data_single* default_instance_;
};
// -------------------------------------------------------------------

class mount_data : public ::google::protobuf::Message {
 public:
  mount_data();
  virtual ~mount_data();

  mount_data(const mount_data& from);

  inline mount_data& operator=(const mount_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mount_data& default_instance();

  void Swap(mount_data* other);

  // implements Message ----------------------------------------------

  mount_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mount_data& from);
  void MergeFrom(const mount_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.mount_data_single mount_data_list = 1;
  inline int mount_data_list_size() const;
  inline void clear_mount_data_list();
  static const int kMountDataListFieldNumber = 1;
  inline const ::proto::common::mount_data_single& mount_data_list(int index) const;
  inline ::proto::common::mount_data_single* mutable_mount_data_list(int index);
  inline ::proto::common::mount_data_single* add_mount_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::mount_data_single >&
      mount_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::mount_data_single >*
      mutable_mount_data_list();

  // @@protoc_insertion_point(class_scope:proto.common.mount_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::mount_data_single > mount_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mount_data* default_instance_;
};
// -------------------------------------------------------------------

class field_boss_rank : public ::google::protobuf::Message {
 public:
  field_boss_rank();
  virtual ~field_boss_rank();

  field_boss_rank(const field_boss_rank& from);

  inline field_boss_rank& operator=(const field_boss_rank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const field_boss_rank& default_instance();

  void Swap(field_boss_rank* other);

  // implements Message ----------------------------------------------

  field_boss_rank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const field_boss_rank& from);
  void MergeFrom(const field_boss_rank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 hurt = 3;
  inline bool has_hurt() const;
  inline void clear_hurt();
  static const int kHurtFieldNumber = 3;
  inline ::google::protobuf::uint32 hurt() const;
  inline void set_hurt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.field_boss_rank)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hurt();
  inline void clear_has_hurt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 hurt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static field_boss_rank* default_instance_;
};
// -------------------------------------------------------------------

class filed_boss_one_state : public ::google::protobuf::Message {
 public:
  filed_boss_one_state();
  virtual ~filed_boss_one_state();

  filed_boss_one_state(const filed_boss_one_state& from);

  inline filed_boss_one_state& operator=(const filed_boss_one_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const filed_boss_one_state& default_instance();

  void Swap(filed_boss_one_state* other);

  // implements Message ----------------------------------------------

  filed_boss_one_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const filed_boss_one_state& from);
  void MergeFrom(const filed_boss_one_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 monster_tid = 2;
  inline bool has_monster_tid() const;
  inline void clear_monster_tid();
  static const int kMonsterTidFieldNumber = 2;
  inline ::google::protobuf::uint32 monster_tid() const;
  inline void set_monster_tid(::google::protobuf::uint32 value);

  // optional .proto.common.em_field_boss_state state = 3 [default = FIELD_BOSS_STATE_NONE];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::proto::common::em_field_boss_state state() const;
  inline void set_state(::proto::common::em_field_boss_state value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 map_id = 5;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 5;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 pos_x = 6;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 6;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // optional uint32 pos_y = 7;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 7;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.filed_boss_one_state)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_monster_tid();
  inline void clear_has_monster_tid();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 monster_tid_;
  ::std::string* name_;
  int state_;
  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static filed_boss_one_state* default_instance_;
};
// -------------------------------------------------------------------

class filed_boss_state : public ::google::protobuf::Message {
 public:
  filed_boss_state();
  virtual ~filed_boss_state();

  filed_boss_state(const filed_boss_state& from);

  inline filed_boss_state& operator=(const filed_boss_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const filed_boss_state& default_instance();

  void Swap(filed_boss_state* other);

  // implements Message ----------------------------------------------

  filed_boss_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const filed_boss_state& from);
  void MergeFrom(const filed_boss_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // repeated .proto.common.filed_boss_one_state states = 2;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 2;
  inline const ::proto::common::filed_boss_one_state& states(int index) const;
  inline ::proto::common::filed_boss_one_state* mutable_states(int index);
  inline ::proto::common::filed_boss_one_state* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::filed_boss_one_state >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::filed_boss_one_state >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:proto.common.filed_boss_state)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::filed_boss_one_state > states_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static filed_boss_state* default_instance_;
};
// -------------------------------------------------------------------

class field_boss_pos_info : public ::google::protobuf::Message {
 public:
  field_boss_pos_info();
  virtual ~field_boss_pos_info();

  field_boss_pos_info(const field_boss_pos_info& from);

  inline field_boss_pos_info& operator=(const field_boss_pos_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const field_boss_pos_info& default_instance();

  void Swap(field_boss_pos_info* other);

  // implements Message ----------------------------------------------

  field_boss_pos_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const field_boss_pos_info& from);
  void MergeFrom(const field_boss_pos_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.em_field_boss_pos pos_act = 1;
  inline bool has_pos_act() const;
  inline void clear_pos_act();
  static const int kPosActFieldNumber = 1;
  inline ::proto::common::em_field_boss_pos pos_act() const;
  inline void set_pos_act(::proto::common::em_field_boss_pos value);

  // optional string object_id = 2;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  inline const ::std::string& object_id() const;
  inline void set_object_id(const ::std::string& value);
  inline void set_object_id(const char* value);
  inline void set_object_id(const char* value, size_t size);
  inline ::std::string* mutable_object_id();
  inline ::std::string* release_object_id();
  inline void set_allocated_object_id(::std::string* object_id);

  // optional uint32 monster_id = 3;
  inline bool has_monster_id() const;
  inline void clear_monster_id();
  static const int kMonsterIdFieldNumber = 3;
  inline ::google::protobuf::uint32 monster_id() const;
  inline void set_monster_id(::google::protobuf::uint32 value);

  // optional uint32 pos_x = 4;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 4;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // optional uint32 pos_y = 5;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 5;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.field_boss_pos_info)
 private:
  inline void set_has_pos_act();
  inline void clear_has_pos_act();
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_monster_id();
  inline void clear_has_monster_id();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_id_;
  int pos_act_;
  ::google::protobuf::uint32 monster_id_;
  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static field_boss_pos_info* default_instance_;
};
// -------------------------------------------------------------------

class mail_common_info : public ::google::protobuf::Message {
 public:
  mail_common_info();
  virtual ~mail_common_info();

  mail_common_info(const mail_common_info& from);

  inline mail_common_info& operator=(const mail_common_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mail_common_info& default_instance();

  void Swap(mail_common_info* other);

  // implements Message ----------------------------------------------

  mail_common_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mail_common_info& from);
  void MergeFrom(const mail_common_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .proto.common.em_mail_type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::proto::common::em_mail_type type() const;
  inline void set_type(::proto::common::em_mail_type value);

  // optional .proto.common.em_mail_state state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::proto::common::em_mail_state state() const;
  inline void set_state(::proto::common::em_mail_state value);

  // optional .proto.common.em_mail_addenda addenda = 4;
  inline bool has_addenda() const;
  inline void clear_addenda();
  static const int kAddendaFieldNumber = 4;
  inline ::proto::common::em_mail_addenda addenda() const;
  inline void set_addenda(::proto::common::em_mail_addenda value);

  // @@protoc_insertion_point(class_scope:proto.common.mail_common_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_addenda();
  inline void clear_has_addenda();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  int type_;
  int state_;
  int addenda_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mail_common_info* default_instance_;
};
// -------------------------------------------------------------------

class mail_base_info : public ::google::protobuf::Message {
 public:
  mail_base_info();
  virtual ~mail_base_info();

  mail_base_info(const mail_base_info& from);

  inline mail_base_info& operator=(const mail_base_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mail_base_info& default_instance();

  void Swap(mail_base_info* other);

  // implements Message ----------------------------------------------

  mail_base_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mail_base_info& from);
  void MergeFrom(const mail_base_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.mail_common_info common_info = 1;
  inline bool has_common_info() const;
  inline void clear_common_info();
  static const int kCommonInfoFieldNumber = 1;
  inline const ::proto::common::mail_common_info& common_info() const;
  inline ::proto::common::mail_common_info* mutable_common_info();
  inline ::proto::common::mail_common_info* release_common_info();
  inline void set_allocated_common_info(::proto::common::mail_common_info* common_info);

  // optional uint32 content_id = 2;
  inline bool has_content_id() const;
  inline void clear_content_id();
  static const int kContentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 content_id() const;
  inline void set_content_id(::google::protobuf::uint32 value);

  // optional string from_name = 3;
  inline bool has_from_name() const;
  inline void clear_from_name();
  static const int kFromNameFieldNumber = 3;
  inline const ::std::string& from_name() const;
  inline void set_from_name(const ::std::string& value);
  inline void set_from_name(const char* value);
  inline void set_from_name(const char* value, size_t size);
  inline ::std::string* mutable_from_name();
  inline ::std::string* release_from_name();
  inline void set_allocated_from_name(::std::string* from_name);

  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional uint32 create_time = 5;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // optional uint32 del_time = 6;
  inline bool has_del_time() const;
  inline void clear_del_time();
  static const int kDelTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 del_time() const;
  inline void set_del_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.mail_base_info)
 private:
  inline void set_has_common_info();
  inline void clear_has_common_info();
  inline void set_has_content_id();
  inline void clear_has_content_id();
  inline void set_has_from_name();
  inline void clear_has_from_name();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_del_time();
  inline void clear_has_del_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::mail_common_info* common_info_;
  ::std::string* from_name_;
  ::google::protobuf::uint32 content_id_;
  ::google::protobuf::uint32 create_time_;
  ::std::string* title_;
  ::google::protobuf::uint32 del_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mail_base_info* default_instance_;
};
// -------------------------------------------------------------------

class mail_item_obj : public ::google::protobuf::Message {
 public:
  mail_item_obj();
  virtual ~mail_item_obj();

  mail_item_obj(const mail_item_obj& from);

  inline mail_item_obj& operator=(const mail_item_obj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mail_item_obj& default_instance();

  void Swap(mail_item_obj* other);

  // implements Message ----------------------------------------------

  mail_item_obj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mail_item_obj& from);
  void MergeFrom(const mail_item_obj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_id = 1;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 item_id() const;
  inline void set_item_id(::google::protobuf::uint32 value);

  // optional uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.mail_item_obj)
 private:
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_id_;
  ::google::protobuf::uint32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static mail_item_obj* default_instance_;
};
// -------------------------------------------------------------------

class combat_act : public ::google::protobuf::Message {
 public:
  combat_act();
  virtual ~combat_act();

  combat_act(const combat_act& from);

  inline combat_act& operator=(const combat_act& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_act& default_instance();

  void Swap(combat_act* other);

  // implements Message ----------------------------------------------

  combat_act* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_act& from);
  void MergeFrom(const combat_act& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.combat_act_type act_type = 1 [default = combat_act_type_skill];
  inline bool has_act_type() const;
  inline void clear_act_type();
  static const int kActTypeFieldNumber = 1;
  inline ::proto::common::combat_act_type act_type() const;
  inline void set_act_type(::proto::common::combat_act_type value);

  // optional uint32 act_value = 2;
  inline bool has_act_value() const;
  inline void clear_act_value();
  static const int kActValueFieldNumber = 2;
  inline ::google::protobuf::uint32 act_value() const;
  inline void set_act_value(::google::protobuf::uint32 value);

  // repeated string target = 3;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::std::string& target(int index) const;
  inline ::std::string* mutable_target(int index);
  inline void set_target(int index, const ::std::string& value);
  inline void set_target(int index, const char* value);
  inline void set_target(int index, const char* value, size_t size);
  inline ::std::string* add_target();
  inline void add_target(const ::std::string& value);
  inline void add_target(const char* value);
  inline void add_target(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // optional string attacker = 4;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 4;
  inline const ::std::string& attacker() const;
  inline void set_attacker(const ::std::string& value);
  inline void set_attacker(const char* value);
  inline void set_attacker(const char* value, size_t size);
  inline ::std::string* mutable_attacker();
  inline ::std::string* release_attacker();
  inline void set_allocated_attacker(::std::string* attacker);

  // optional .proto.common.combat_state step = 5;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 5;
  inline ::proto::common::combat_state step() const;
  inline void set_step(::proto::common::combat_state value);

  // optional uint32 remain_value = 6;
  inline bool has_remain_value() const;
  inline void clear_remain_value();
  static const int kRemainValueFieldNumber = 6;
  inline ::google::protobuf::uint32 remain_value() const;
  inline void set_remain_value(::google::protobuf::uint32 value);

  // optional uint32 remain_value2 = 7;
  inline bool has_remain_value2() const;
  inline void clear_remain_value2();
  static const int kRemainValue2FieldNumber = 7;
  inline ::google::protobuf::uint32 remain_value2() const;
  inline void set_remain_value2(::google::protobuf::uint32 value);

  // optional uint32 param = 8;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 8;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 param1 = 9;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 9;
  inline ::google::protobuf::uint32 param1() const;
  inline void set_param1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_act)
 private:
  inline void set_has_act_type();
  inline void clear_has_act_type();
  inline void set_has_act_value();
  inline void clear_has_act_value();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_remain_value();
  inline void clear_has_remain_value();
  inline void set_has_remain_value2();
  inline void clear_has_remain_value2();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_param1();
  inline void clear_has_param1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int act_type_;
  ::google::protobuf::uint32 act_value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::std::string* attacker_;
  int step_;
  ::google::protobuf::uint32 remain_value_;
  ::google::protobuf::uint32 remain_value2_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 param1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_act* default_instance_;
};
// -------------------------------------------------------------------

class combat_action_data : public ::google::protobuf::Message {
 public:
  combat_action_data();
  virtual ~combat_action_data();

  combat_action_data(const combat_action_data& from);

  inline combat_action_data& operator=(const combat_action_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_action_data& default_instance();

  void Swap(combat_action_data* other);

  // implements Message ----------------------------------------------

  combat_action_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_action_data& from);
  void MergeFrom(const combat_action_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_act actions = 1;
  inline int actions_size() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 1;
  inline const ::proto::common::combat_act& actions(int index) const;
  inline ::proto::common::combat_act* mutable_actions(int index);
  inline ::proto::common::combat_act* add_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_act >&
      actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_act >*
      mutable_actions();

  // @@protoc_insertion_point(class_scope:proto.common.combat_action_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_act > actions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_action_data* default_instance_;
};
// -------------------------------------------------------------------

class combat_hero_att_order_single : public ::google::protobuf::Message {
 public:
  combat_hero_att_order_single();
  virtual ~combat_hero_att_order_single();

  combat_hero_att_order_single(const combat_hero_att_order_single& from);

  inline combat_hero_att_order_single& operator=(const combat_hero_att_order_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_hero_att_order_single& default_instance();

  void Swap(combat_hero_att_order_single* other);

  // implements Message ----------------------------------------------

  combat_hero_att_order_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_hero_att_order_single& from);
  void MergeFrom(const combat_hero_att_order_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // optional uint32 att_speed = 2;
  inline bool has_att_speed() const;
  inline void clear_att_speed();
  static const int kAttSpeedFieldNumber = 2;
  inline ::google::protobuf::uint32 att_speed() const;
  inline void set_att_speed(::google::protobuf::uint32 value);

  // optional uint32 att_more_speed = 3;
  inline bool has_att_more_speed() const;
  inline void clear_att_more_speed();
  static const int kAttMoreSpeedFieldNumber = 3;
  inline ::google::protobuf::uint32 att_more_speed() const;
  inline void set_att_more_speed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_hero_att_order_single)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_att_speed();
  inline void clear_has_att_speed();
  inline void set_has_att_more_speed();
  inline void clear_has_att_more_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hero_uid_;
  ::google::protobuf::uint32 att_speed_;
  ::google::protobuf::uint32 att_more_speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_hero_att_order_single* default_instance_;
};
// -------------------------------------------------------------------

class combat_hero_att_order : public ::google::protobuf::Message {
 public:
  combat_hero_att_order();
  virtual ~combat_hero_att_order();

  combat_hero_att_order(const combat_hero_att_order& from);

  inline combat_hero_att_order& operator=(const combat_hero_att_order& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_hero_att_order& default_instance();

  void Swap(combat_hero_att_order* other);

  // implements Message ----------------------------------------------

  combat_hero_att_order* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_hero_att_order& from);
  void MergeFrom(const combat_hero_att_order& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_hero_att_order_single hero_list = 1;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 1;
  inline const ::proto::common::combat_hero_att_order_single& hero_list(int index) const;
  inline ::proto::common::combat_hero_att_order_single* mutable_hero_list(int index);
  inline ::proto::common::combat_hero_att_order_single* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_hero_att_order_single >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_hero_att_order_single >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.combat_hero_att_order)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_hero_att_order_single > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_hero_att_order* default_instance_;
};
// -------------------------------------------------------------------

class combat_end_ahead : public ::google::protobuf::Message {
 public:
  combat_end_ahead();
  virtual ~combat_end_ahead();

  combat_end_ahead(const combat_end_ahead& from);

  inline combat_end_ahead& operator=(const combat_end_ahead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_end_ahead& default_instance();

  void Swap(combat_end_ahead* other);

  // implements Message ----------------------------------------------

  combat_end_ahead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_end_ahead& from);
  void MergeFrom(const combat_end_ahead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cond_type = 1;
  inline bool has_cond_type() const;
  inline void clear_cond_type();
  static const int kCondTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 cond_type() const;
  inline void set_cond_type(::google::protobuf::uint32 value);

  // optional uint32 param1 = 2;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 2;
  inline ::google::protobuf::uint32 param1() const;
  inline void set_param1(::google::protobuf::uint32 value);

  // optional uint32 param2 = 3;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 3;
  inline ::google::protobuf::uint32 param2() const;
  inline void set_param2(::google::protobuf::uint32 value);

  // optional uint32 param3 = 4;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 4;
  inline ::google::protobuf::uint32 param3() const;
  inline void set_param3(::google::protobuf::uint32 value);

  // optional uint32 param4 = 5;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 5;
  inline ::google::protobuf::uint32 param4() const;
  inline void set_param4(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_end_ahead)
 private:
  inline void set_has_cond_type();
  inline void clear_has_cond_type();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cond_type_;
  ::google::protobuf::uint32 param1_;
  ::google::protobuf::uint32 param2_;
  ::google::protobuf::uint32 param3_;
  ::google::protobuf::uint32 param4_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_end_ahead* default_instance_;
};
// -------------------------------------------------------------------

class combat_data : public ::google::protobuf::Message {
 public:
  combat_data();
  virtual ~combat_data();

  combat_data(const combat_data& from);

  inline combat_data& operator=(const combat_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_data& default_instance();

  void Swap(combat_data* other);

  // implements Message ----------------------------------------------

  combat_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_data& from);
  void MergeFrom(const combat_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fight_uid = 1;
  inline bool has_fight_uid() const;
  inline void clear_fight_uid();
  static const int kFightUidFieldNumber = 1;
  inline const ::std::string& fight_uid() const;
  inline void set_fight_uid(const ::std::string& value);
  inline void set_fight_uid(const char* value);
  inline void set_fight_uid(const char* value, size_t size);
  inline ::std::string* mutable_fight_uid();
  inline ::std::string* release_fight_uid();
  inline void set_allocated_fight_uid(::std::string* fight_uid);

  // optional .proto.common.combat_step step = 2;
  inline bool has_step() const;
  inline void clear_step();
  static const int kStepFieldNumber = 2;
  inline ::proto::common::combat_step step() const;
  inline void set_step(::proto::common::combat_step value);

  // optional uint32 round = 3;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 3;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // optional .proto.common.combat_state state = 4 [default = combat_state_prepare];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::proto::common::combat_state state() const;
  inline void set_state(::proto::common::combat_state value);

  // optional .proto.common.combat_action_data action_data = 5;
  inline bool has_action_data() const;
  inline void clear_action_data();
  static const int kActionDataFieldNumber = 5;
  inline const ::proto::common::combat_action_data& action_data() const;
  inline ::proto::common::combat_action_data* mutable_action_data();
  inline ::proto::common::combat_action_data* release_action_data();
  inline void set_allocated_action_data(::proto::common::combat_action_data* action_data);

  // optional .proto.common.fight_data data = 6;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::proto::common::fight_data& data() const;
  inline ::proto::common::fight_data* mutable_data();
  inline ::proto::common::fight_data* release_data();
  inline void set_allocated_data(::proto::common::fight_data* data);

  // optional uint32 remain_time = 7;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional .proto.common.combat_hero_att_order att_order = 8;
  inline bool has_att_order() const;
  inline void clear_att_order();
  static const int kAttOrderFieldNumber = 8;
  inline const ::proto::common::combat_hero_att_order& att_order() const;
  inline ::proto::common::combat_hero_att_order* mutable_att_order();
  inline ::proto::common::combat_hero_att_order* release_att_order();
  inline void set_allocated_att_order(::proto::common::combat_hero_att_order* att_order);

  // optional string cur_att_hero_uid = 9;
  inline bool has_cur_att_hero_uid() const;
  inline void clear_cur_att_hero_uid();
  static const int kCurAttHeroUidFieldNumber = 9;
  inline const ::std::string& cur_att_hero_uid() const;
  inline void set_cur_att_hero_uid(const ::std::string& value);
  inline void set_cur_att_hero_uid(const char* value);
  inline void set_cur_att_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_cur_att_hero_uid();
  inline ::std::string* release_cur_att_hero_uid();
  inline void set_allocated_cur_att_hero_uid(::std::string* cur_att_hero_uid);

  // optional uint32 hero_att_round = 10;
  inline bool has_hero_att_round() const;
  inline void clear_hero_att_round();
  static const int kHeroAttRoundFieldNumber = 10;
  inline ::google::protobuf::uint32 hero_att_round() const;
  inline void set_hero_att_round(::google::protobuf::uint32 value);

  // optional .proto.common.fight_hero_skill_data skill_data = 11;
  inline bool has_skill_data() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 11;
  inline const ::proto::common::fight_hero_skill_data& skill_data() const;
  inline ::proto::common::fight_hero_skill_data* mutable_skill_data();
  inline ::proto::common::fight_hero_skill_data* release_skill_data();
  inline void set_allocated_skill_data(::proto::common::fight_hero_skill_data* skill_data);

  // optional .proto.common.combat_hero_att_order first_att_order = 12;
  inline bool has_first_att_order() const;
  inline void clear_first_att_order();
  static const int kFirstAttOrderFieldNumber = 12;
  inline const ::proto::common::combat_hero_att_order& first_att_order() const;
  inline ::proto::common::combat_hero_att_order* mutable_first_att_order();
  inline ::proto::common::combat_hero_att_order* release_first_att_order();
  inline void set_allocated_first_att_order(::proto::common::combat_hero_att_order* first_att_order);

  // optional uint32 watching_role_num = 13;
  inline bool has_watching_role_num() const;
  inline void clear_watching_role_num();
  static const int kWatchingRoleNumFieldNumber = 13;
  inline ::google::protobuf::uint32 watching_role_num() const;
  inline void set_watching_role_num(::google::protobuf::uint32 value);

  // optional uint32 cur_wave_num = 14;
  inline bool has_cur_wave_num() const;
  inline void clear_cur_wave_num();
  static const int kCurWaveNumFieldNumber = 14;
  inline ::google::protobuf::uint32 cur_wave_num() const;
  inline void set_cur_wave_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_data)
 private:
  inline void set_has_fight_uid();
  inline void clear_has_fight_uid();
  inline void set_has_step();
  inline void clear_has_step();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_action_data();
  inline void clear_has_action_data();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_att_order();
  inline void clear_has_att_order();
  inline void set_has_cur_att_hero_uid();
  inline void clear_has_cur_att_hero_uid();
  inline void set_has_hero_att_round();
  inline void clear_has_hero_att_round();
  inline void set_has_skill_data();
  inline void clear_has_skill_data();
  inline void set_has_first_att_order();
  inline void clear_has_first_att_order();
  inline void set_has_watching_role_num();
  inline void clear_has_watching_role_num();
  inline void set_has_cur_wave_num();
  inline void clear_has_cur_wave_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fight_uid_;
  int step_;
  ::google::protobuf::uint32 round_;
  ::proto::common::combat_action_data* action_data_;
  int state_;
  ::google::protobuf::uint32 remain_time_;
  ::proto::common::fight_data* data_;
  ::proto::common::combat_hero_att_order* att_order_;
  ::std::string* cur_att_hero_uid_;
  ::proto::common::fight_hero_skill_data* skill_data_;
  ::google::protobuf::uint32 hero_att_round_;
  ::google::protobuf::uint32 watching_role_num_;
  ::proto::common::combat_hero_att_order* first_att_order_;
  ::google::protobuf::uint32 cur_wave_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_data* default_instance_;
};
// -------------------------------------------------------------------

class combat_form_single : public ::google::protobuf::Message {
 public:
  combat_form_single();
  virtual ~combat_form_single();

  combat_form_single(const combat_form_single& from);

  inline combat_form_single& operator=(const combat_form_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_form_single& default_instance();

  void Swap(combat_form_single* other);

  // implements Message ----------------------------------------------

  combat_form_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_form_single& from);
  void MergeFrom(const combat_form_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string attacker = 1;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 1;
  inline const ::std::string& attacker() const;
  inline void set_attacker(const ::std::string& value);
  inline void set_attacker(const char* value);
  inline void set_attacker(const char* value, size_t size);
  inline ::std::string* mutable_attacker();
  inline ::std::string* release_attacker();
  inline void set_allocated_attacker(::std::string* attacker);

  // optional uint32 skill = 2;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 2;
  inline ::google::protobuf::uint32 skill() const;
  inline void set_skill(::google::protobuf::uint32 value);

  // optional string target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // @@protoc_insertion_point(class_scope:proto.common.combat_form_single)
 private:
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* attacker_;
  ::std::string* target_;
  ::google::protobuf::uint32 skill_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_form_single* default_instance_;
};
// -------------------------------------------------------------------

class combat_form_data : public ::google::protobuf::Message {
 public:
  combat_form_data();
  virtual ~combat_form_data();

  combat_form_data(const combat_form_data& from);

  inline combat_form_data& operator=(const combat_form_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_form_data& default_instance();

  void Swap(combat_form_data* other);

  // implements Message ----------------------------------------------

  combat_form_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_form_data& from);
  void MergeFrom(const combat_form_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_form_single forms = 1;
  inline int forms_size() const;
  inline void clear_forms();
  static const int kFormsFieldNumber = 1;
  inline const ::proto::common::combat_form_single& forms(int index) const;
  inline ::proto::common::combat_form_single* mutable_forms(int index);
  inline ::proto::common::combat_form_single* add_forms();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_form_single >&
      forms() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_form_single >*
      mutable_forms();

  // @@protoc_insertion_point(class_scope:proto.common.combat_form_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_form_single > forms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_form_data* default_instance_;
};
// -------------------------------------------------------------------

class combat_finish_single_task : public ::google::protobuf::Message {
 public:
  combat_finish_single_task();
  virtual ~combat_finish_single_task();

  combat_finish_single_task(const combat_finish_single_task& from);

  inline combat_finish_single_task& operator=(const combat_finish_single_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_finish_single_task& default_instance();

  void Swap(combat_finish_single_task* other);

  // implements Message ----------------------------------------------

  combat_finish_single_task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_finish_single_task& from);
  void MergeFrom(const combat_finish_single_task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.combat_finish_task_type finish_task = 1 [default = combat_finish_task_type_none];
  inline bool has_finish_task() const;
  inline void clear_finish_task();
  static const int kFinishTaskFieldNumber = 1;
  inline ::proto::common::combat_finish_task_type finish_task() const;
  inline void set_finish_task(::proto::common::combat_finish_task_type value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_finish_single_task)
 private:
  inline void set_has_finish_task();
  inline void clear_has_finish_task();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int finish_task_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_finish_single_task* default_instance_;
};
// -------------------------------------------------------------------

class combat_camp_finish_task : public ::google::protobuf::Message {
 public:
  combat_camp_finish_task();
  virtual ~combat_camp_finish_task();

  combat_camp_finish_task(const combat_camp_finish_task& from);

  inline combat_camp_finish_task& operator=(const combat_camp_finish_task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_camp_finish_task& default_instance();

  void Swap(combat_camp_finish_task* other);

  // implements Message ----------------------------------------------

  combat_camp_finish_task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_camp_finish_task& from);
  void MergeFrom(const combat_camp_finish_task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_finish_single_task finish_tasks = 2;
  inline int finish_tasks_size() const;
  inline void clear_finish_tasks();
  static const int kFinishTasksFieldNumber = 2;
  inline const ::proto::common::combat_finish_single_task& finish_tasks(int index) const;
  inline ::proto::common::combat_finish_single_task* mutable_finish_tasks(int index);
  inline ::proto::common::combat_finish_single_task* add_finish_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_finish_single_task >&
      finish_tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_finish_single_task >*
      mutable_finish_tasks();

  // @@protoc_insertion_point(class_scope:proto.common.combat_camp_finish_task)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_finish_single_task > finish_tasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_camp_finish_task* default_instance_;
};
// -------------------------------------------------------------------

class combat_result : public ::google::protobuf::Message {
 public:
  combat_result();
  virtual ~combat_result();

  combat_result(const combat_result& from);

  inline combat_result& operator=(const combat_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_result& default_instance();

  void Swap(combat_result* other);

  // implements Message ----------------------------------------------

  combat_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_result& from);
  void MergeFrom(const combat_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 win_camp = 1;
  inline bool has_win_camp() const;
  inline void clear_win_camp();
  static const int kWinCampFieldNumber = 1;
  inline ::google::protobuf::uint32 win_camp() const;
  inline void set_win_camp(::google::protobuf::uint32 value);

  // optional .proto.common.combat_fight_result result = 2 [default = combat_fight_result_none];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::proto::common::combat_fight_result result() const;
  inline void set_result(::proto::common::combat_fight_result value);

  // optional .proto.common.combat_camp_finish_task win_camp_tasks = 3;
  inline bool has_win_camp_tasks() const;
  inline void clear_win_camp_tasks();
  static const int kWinCampTasksFieldNumber = 3;
  inline const ::proto::common::combat_camp_finish_task& win_camp_tasks() const;
  inline ::proto::common::combat_camp_finish_task* mutable_win_camp_tasks();
  inline ::proto::common::combat_camp_finish_task* release_win_camp_tasks();
  inline void set_allocated_win_camp_tasks(::proto::common::combat_camp_finish_task* win_camp_tasks);

  // optional .proto.common.combat_camp_finish_task lose_camp_tasks = 4;
  inline bool has_lose_camp_tasks() const;
  inline void clear_lose_camp_tasks();
  static const int kLoseCampTasksFieldNumber = 4;
  inline const ::proto::common::combat_camp_finish_task& lose_camp_tasks() const;
  inline ::proto::common::combat_camp_finish_task* mutable_lose_camp_tasks();
  inline ::proto::common::combat_camp_finish_task* release_lose_camp_tasks();
  inline void set_allocated_lose_camp_tasks(::proto::common::combat_camp_finish_task* lose_camp_tasks);

  // @@protoc_insertion_point(class_scope:proto.common.combat_result)
 private:
  inline void set_has_win_camp();
  inline void clear_has_win_camp();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_win_camp_tasks();
  inline void clear_has_win_camp_tasks();
  inline void set_has_lose_camp_tasks();
  inline void clear_has_lose_camp_tasks();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 win_camp_;
  int result_;
  ::proto::common::combat_camp_finish_task* win_camp_tasks_;
  ::proto::common::combat_camp_finish_task* lose_camp_tasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_result* default_instance_;
};
// -------------------------------------------------------------------

class combat_count_data_single_hero : public ::google::protobuf::Message {
 public:
  combat_count_data_single_hero();
  virtual ~combat_count_data_single_hero();

  combat_count_data_single_hero(const combat_count_data_single_hero& from);

  inline combat_count_data_single_hero& operator=(const combat_count_data_single_hero& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_count_data_single_hero& default_instance();

  void Swap(combat_count_data_single_hero* other);

  // implements Message ----------------------------------------------

  combat_count_data_single_hero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_count_data_single_hero& from);
  void MergeFrom(const combat_count_data_single_hero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hero_tid = 1;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 1;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional uint32 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional uint32 heal = 3;
  inline bool has_heal() const;
  inline void clear_heal();
  static const int kHealFieldNumber = 3;
  inline ::google::protobuf::uint32 heal() const;
  inline void set_heal(::google::protobuf::uint32 value);

  // optional uint32 damage = 4;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 4;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // optional uint32 accept_damage = 5;
  inline bool has_accept_damage() const;
  inline void clear_accept_damage();
  static const int kAcceptDamageFieldNumber = 5;
  inline ::google::protobuf::uint32 accept_damage() const;
  inline void set_accept_damage(::google::protobuf::uint32 value);

  // optional uint32 plugin = 6;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 6;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.combat_count_data_single_hero)
 private:
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_heal();
  inline void clear_has_heal();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_accept_damage();
  inline void clear_has_accept_damage();
  inline void set_has_plugin();
  inline void clear_has_plugin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 heal_;
  ::google::protobuf::uint32 damage_;
  ::google::protobuf::uint32 accept_damage_;
  ::google::protobuf::uint32 plugin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_count_data_single_hero* default_instance_;
};
// -------------------------------------------------------------------

class combat_count_data_heroes_obj : public ::google::protobuf::Message {
 public:
  combat_count_data_heroes_obj();
  virtual ~combat_count_data_heroes_obj();

  combat_count_data_heroes_obj(const combat_count_data_heroes_obj& from);

  inline combat_count_data_heroes_obj& operator=(const combat_count_data_heroes_obj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_count_data_heroes_obj& default_instance();

  void Swap(combat_count_data_heroes_obj* other);

  // implements Message ----------------------------------------------

  combat_count_data_heroes_obj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_count_data_heroes_obj& from);
  void MergeFrom(const combat_count_data_heroes_obj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string obj_uid = 1;
  inline bool has_obj_uid() const;
  inline void clear_obj_uid();
  static const int kObjUidFieldNumber = 1;
  inline const ::std::string& obj_uid() const;
  inline void set_obj_uid(const ::std::string& value);
  inline void set_obj_uid(const char* value);
  inline void set_obj_uid(const char* value, size_t size);
  inline ::std::string* mutable_obj_uid();
  inline ::std::string* release_obj_uid();
  inline void set_allocated_obj_uid(::std::string* obj_uid);

  // repeated .proto.common.combat_count_data_single_hero hero_list = 2;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 2;
  inline const ::proto::common::combat_count_data_single_hero& hero_list(int index) const;
  inline ::proto::common::combat_count_data_single_hero* mutable_hero_list(int index);
  inline ::proto::common::combat_count_data_single_hero* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_single_hero >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_single_hero >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.combat_count_data_heroes_obj)
 private:
  inline void set_has_obj_uid();
  inline void clear_has_obj_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* obj_uid_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_single_hero > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_count_data_heroes_obj* default_instance_;
};
// -------------------------------------------------------------------

class combat_count_data : public ::google::protobuf::Message {
 public:
  combat_count_data();
  virtual ~combat_count_data();

  combat_count_data(const combat_count_data& from);

  inline combat_count_data& operator=(const combat_count_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const combat_count_data& default_instance();

  void Swap(combat_count_data* other);

  // implements Message ----------------------------------------------

  combat_count_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const combat_count_data& from);
  void MergeFrom(const combat_count_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.combat_count_data_heroes_obj obj_list = 1;
  inline int obj_list_size() const;
  inline void clear_obj_list();
  static const int kObjListFieldNumber = 1;
  inline const ::proto::common::combat_count_data_heroes_obj& obj_list(int index) const;
  inline ::proto::common::combat_count_data_heroes_obj* mutable_obj_list(int index);
  inline ::proto::common::combat_count_data_heroes_obj* add_obj_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_heroes_obj >&
      obj_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_heroes_obj >*
      mutable_obj_list();

  // @@protoc_insertion_point(class_scope:proto.common.combat_count_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_heroes_obj > obj_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static combat_count_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_obj_state : public ::google::protobuf::Message {
 public:
  fight_obj_state();
  virtual ~fight_obj_state();

  fight_obj_state(const fight_obj_state& from);

  inline fight_obj_state& operator=(const fight_obj_state& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_obj_state& default_instance();

  void Swap(fight_obj_state* other);

  // implements Message ----------------------------------------------

  fight_obj_state* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_obj_state& from);
  void MergeFrom(const fight_obj_state& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string object_uid = 1;
  inline bool has_object_uid() const;
  inline void clear_object_uid();
  static const int kObjectUidFieldNumber = 1;
  inline const ::std::string& object_uid() const;
  inline void set_object_uid(const ::std::string& value);
  inline void set_object_uid(const char* value);
  inline void set_object_uid(const char* value, size_t size);
  inline ::std::string* mutable_object_uid();
  inline ::std::string* release_object_uid();
  inline void set_allocated_object_uid(::std::string* object_uid);

  // optional .proto.common.combat_obj_state state = 2 [default = combat_obj_state_none];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::proto::common::combat_obj_state state() const;
  inline void set_state(::proto::common::combat_obj_state value);

  // @@protoc_insertion_point(class_scope:proto.common.fight_obj_state)
 private:
  inline void set_has_object_uid();
  inline void clear_has_object_uid();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_uid_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_obj_state* default_instance_;
};
// -------------------------------------------------------------------

class fight_obj_state_data : public ::google::protobuf::Message {
 public:
  fight_obj_state_data();
  virtual ~fight_obj_state_data();

  fight_obj_state_data(const fight_obj_state_data& from);

  inline fight_obj_state_data& operator=(const fight_obj_state_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_obj_state_data& default_instance();

  void Swap(fight_obj_state_data* other);

  // implements Message ----------------------------------------------

  fight_obj_state_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_obj_state_data& from);
  void MergeFrom(const fight_obj_state_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.fight_obj_state states = 1;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 1;
  inline const ::proto::common::fight_obj_state& states(int index) const;
  inline ::proto::common::fight_obj_state* mutable_states(int index);
  inline ::proto::common::fight_obj_state* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_obj_state >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_obj_state >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:proto.common.fight_obj_state_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::fight_obj_state > states_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_obj_state_data* default_instance_;
};
// -------------------------------------------------------------------

class bounty_single : public ::google::protobuf::Message {
 public:
  bounty_single();
  virtual ~bounty_single();

  bounty_single(const bounty_single& from);

  inline bounty_single& operator=(const bounty_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bounty_single& default_instance();

  void Swap(bounty_single* other);

  // implements Message ----------------------------------------------

  bounty_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const bounty_single& from);
  void MergeFrom(const bounty_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 bounty_id = 1;
  inline bool has_bounty_id() const;
  inline void clear_bounty_id();
  static const int kBountyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 bounty_id() const;
  inline void set_bounty_id(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 star = 3;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 3;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.bounty_single)
 private:
  inline void set_has_bounty_id();
  inline void clear_has_bounty_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 bounty_id_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static bounty_single* default_instance_;
};
// -------------------------------------------------------------------

class star_box : public ::google::protobuf::Message {
 public:
  star_box();
  virtual ~star_box();

  star_box(const star_box& from);

  inline star_box& operator=(const star_box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const star_box& default_instance();

  void Swap(star_box* other);

  // implements Message ----------------------------------------------

  star_box* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const star_box& from);
  void MergeFrom(const star_box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 star = 1;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 1;
  inline ::google::protobuf::uint32 star() const;
  inline void set_star(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.star_box)
 private:
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 star_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static star_box* default_instance_;
};
// -------------------------------------------------------------------

class country_bounty_data : public ::google::protobuf::Message {
 public:
  country_bounty_data();
  virtual ~country_bounty_data();

  country_bounty_data(const country_bounty_data& from);

  inline country_bounty_data& operator=(const country_bounty_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_bounty_data& default_instance();

  void Swap(country_bounty_data* other);

  // implements Message ----------------------------------------------

  country_bounty_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_bounty_data& from);
  void MergeFrom(const country_bounty_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 accept_count = 1;
  inline bool has_accept_count() const;
  inline void clear_accept_count();
  static const int kAcceptCountFieldNumber = 1;
  inline ::google::protobuf::uint32 accept_count() const;
  inline void set_accept_count(::google::protobuf::uint32 value);

  // optional uint32 max_accept_count = 2;
  inline bool has_max_accept_count() const;
  inline void clear_max_accept_count();
  static const int kMaxAcceptCountFieldNumber = 2;
  inline ::google::protobuf::uint32 max_accept_count() const;
  inline void set_max_accept_count(::google::protobuf::uint32 value);

  // optional uint32 refresh_count = 3;
  inline bool has_refresh_count() const;
  inline void clear_refresh_count();
  static const int kRefreshCountFieldNumber = 3;
  inline ::google::protobuf::uint32 refresh_count() const;
  inline void set_refresh_count(::google::protobuf::uint32 value);

  // optional uint32 star_count = 4;
  inline bool has_star_count() const;
  inline void clear_star_count();
  static const int kStarCountFieldNumber = 4;
  inline ::google::protobuf::uint32 star_count() const;
  inline void set_star_count(::google::protobuf::uint32 value);

  // repeated .proto.common.star_box box_list = 5;
  inline int box_list_size() const;
  inline void clear_box_list();
  static const int kBoxListFieldNumber = 5;
  inline const ::proto::common::star_box& box_list(int index) const;
  inline ::proto::common::star_box* mutable_box_list(int index);
  inline ::proto::common::star_box* add_box_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::star_box >&
      box_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::star_box >*
      mutable_box_list();

  // repeated .proto.common.bounty_single bounty_data = 6;
  inline int bounty_data_size() const;
  inline void clear_bounty_data();
  static const int kBountyDataFieldNumber = 6;
  inline const ::proto::common::bounty_single& bounty_data(int index) const;
  inline ::proto::common::bounty_single* mutable_bounty_data(int index);
  inline ::proto::common::bounty_single* add_bounty_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::bounty_single >&
      bounty_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::bounty_single >*
      mutable_bounty_data();

  // optional uint32 accept_level = 7;
  inline bool has_accept_level() const;
  inline void clear_accept_level();
  static const int kAcceptLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 accept_level() const;
  inline void set_accept_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.country_bounty_data)
 private:
  inline void set_has_accept_count();
  inline void clear_has_accept_count();
  inline void set_has_max_accept_count();
  inline void clear_has_max_accept_count();
  inline void set_has_refresh_count();
  inline void clear_has_refresh_count();
  inline void set_has_star_count();
  inline void clear_has_star_count();
  inline void set_has_accept_level();
  inline void clear_has_accept_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 accept_count_;
  ::google::protobuf::uint32 max_accept_count_;
  ::google::protobuf::uint32 refresh_count_;
  ::google::protobuf::uint32 star_count_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::star_box > box_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::bounty_single > bounty_data_;
  ::google::protobuf::uint32 accept_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_bounty_data* default_instance_;
};
// -------------------------------------------------------------------

class item_limit_data : public ::google::protobuf::Message {
 public:
  item_limit_data();
  virtual ~item_limit_data();

  item_limit_data(const item_limit_data& from);

  inline item_limit_data& operator=(const item_limit_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const item_limit_data& default_instance();

  void Swap(item_limit_data* other);

  // implements Message ----------------------------------------------

  item_limit_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_limit_data& from);
  void MergeFrom(const item_limit_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional uint32 last_give_time = 3;
  inline bool has_last_give_time() const;
  inline void clear_last_give_time();
  static const int kLastGiveTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 last_give_time() const;
  inline void set_last_give_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.item_limit_data)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_last_give_time();
  inline void clear_has_last_give_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_num_;
  ::google::protobuf::uint32 last_give_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static item_limit_data* default_instance_;
};
// -------------------------------------------------------------------

class friend_member : public ::google::protobuf::Message {
 public:
  friend_member();
  virtual ~friend_member();

  friend_member(const friend_member& from);

  inline friend_member& operator=(const friend_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const friend_member& default_instance();

  void Swap(friend_member* other);

  // implements Message ----------------------------------------------

  friend_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const friend_member& from);
  void MergeFrom(const friend_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string friend_uid = 1;
  inline bool has_friend_uid() const;
  inline void clear_friend_uid();
  static const int kFriendUidFieldNumber = 1;
  inline const ::std::string& friend_uid() const;
  inline void set_friend_uid(const ::std::string& value);
  inline void set_friend_uid(const char* value);
  inline void set_friend_uid(const char* value, size_t size);
  inline ::std::string* mutable_friend_uid();
  inline ::std::string* release_friend_uid();
  inline void set_allocated_friend_uid(::std::string* friend_uid);

  // optional uint32 contact_time = 2;
  inline bool has_contact_time() const;
  inline void clear_contact_time();
  static const int kContactTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 contact_time() const;
  inline void set_contact_time(::google::protobuf::uint32 value);

  // optional .proto.common.friend_type ftype = 3;
  inline bool has_ftype() const;
  inline void clear_ftype();
  static const int kFtypeFieldNumber = 3;
  inline ::proto::common::friend_type ftype() const;
  inline void set_ftype(::proto::common::friend_type value);

  // optional uint32 is_top = 4;
  inline bool has_is_top() const;
  inline void clear_is_top();
  static const int kIsTopFieldNumber = 4;
  inline ::google::protobuf::uint32 is_top() const;
  inline void set_is_top(::google::protobuf::uint32 value);

  // optional uint32 top_time = 5;
  inline bool has_top_time() const;
  inline void clear_top_time();
  static const int kTopTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 top_time() const;
  inline void set_top_time(::google::protobuf::uint32 value);

  // optional uint32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional .proto.common.user_info info = 7;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 7;
  inline const ::proto::common::user_info& info() const;
  inline ::proto::common::user_info* mutable_info();
  inline ::proto::common::user_info* release_info();
  inline void set_allocated_info(::proto::common::user_info* info);

  // optional uint32 shadow_time = 8;
  inline bool has_shadow_time() const;
  inline void clear_shadow_time();
  static const int kShadowTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 shadow_time() const;
  inline void set_shadow_time(::google::protobuf::uint32 value);

  // optional uint32 shadow_count = 9;
  inline bool has_shadow_count() const;
  inline void clear_shadow_count();
  static const int kShadowCountFieldNumber = 9;
  inline ::google::protobuf::uint32 shadow_count() const;
  inline void set_shadow_count(::google::protobuf::uint32 value);

  // optional int32 friendliness = 10;
  inline bool has_friendliness() const;
  inline void clear_friendliness();
  static const int kFriendlinessFieldNumber = 10;
  inline ::google::protobuf::int32 friendliness() const;
  inline void set_friendliness(::google::protobuf::int32 value);

  // optional uint32 friendliness_added_today = 15;
  inline bool has_friendliness_added_today() const;
  inline void clear_friendliness_added_today();
  static const int kFriendlinessAddedTodayFieldNumber = 15;
  inline ::google::protobuf::uint32 friendliness_added_today() const;
  inline void set_friendliness_added_today(::google::protobuf::uint32 value);

  // optional uint32 friendliness_refresh_time = 16;
  inline bool has_friendliness_refresh_time() const;
  inline void clear_friendliness_refresh_time();
  static const int kFriendlinessRefreshTimeFieldNumber = 16;
  inline ::google::protobuf::uint32 friendliness_refresh_time() const;
  inline void set_friendliness_refresh_time(::google::protobuf::uint32 value);

  // optional uint32 can_get_friendship_point = 11;
  inline bool has_can_get_friendship_point() const;
  inline void clear_can_get_friendship_point();
  static const int kCanGetFriendshipPointFieldNumber = 11;
  inline ::google::protobuf::uint32 can_get_friendship_point() const;
  inline void set_can_get_friendship_point(::google::protobuf::uint32 value);

  // optional uint32 last_get_fp_time = 12;
  inline bool has_last_get_fp_time() const;
  inline void clear_last_get_fp_time();
  static const int kLastGetFpTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 last_get_fp_time() const;
  inline void set_last_get_fp_time(::google::protobuf::uint32 value);

  // optional uint32 last_sent_fp_time = 13;
  inline bool has_last_sent_fp_time() const;
  inline void clear_last_sent_fp_time();
  static const int kLastSentFpTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 last_sent_fp_time() const;
  inline void set_last_sent_fp_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.friend_member)
 private:
  inline void set_has_friend_uid();
  inline void clear_has_friend_uid();
  inline void set_has_contact_time();
  inline void clear_has_contact_time();
  inline void set_has_ftype();
  inline void clear_has_ftype();
  inline void set_has_is_top();
  inline void clear_has_is_top();
  inline void set_has_top_time();
  inline void clear_has_top_time();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_shadow_time();
  inline void clear_has_shadow_time();
  inline void set_has_shadow_count();
  inline void clear_has_shadow_count();
  inline void set_has_friendliness();
  inline void clear_has_friendliness();
  inline void set_has_friendliness_added_today();
  inline void clear_has_friendliness_added_today();
  inline void set_has_friendliness_refresh_time();
  inline void clear_has_friendliness_refresh_time();
  inline void set_has_can_get_friendship_point();
  inline void clear_has_can_get_friendship_point();
  inline void set_has_last_get_fp_time();
  inline void clear_has_last_get_fp_time();
  inline void set_has_last_sent_fp_time();
  inline void clear_has_last_sent_fp_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* friend_uid_;
  ::google::protobuf::uint32 contact_time_;
  int ftype_;
  ::google::protobuf::uint32 is_top_;
  ::google::protobuf::uint32 top_time_;
  ::proto::common::user_info* info_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 shadow_time_;
  ::google::protobuf::uint32 shadow_count_;
  ::google::protobuf::int32 friendliness_;
  ::google::protobuf::uint32 friendliness_added_today_;
  ::google::protobuf::uint32 friendliness_refresh_time_;
  ::google::protobuf::uint32 can_get_friendship_point_;
  ::google::protobuf::uint32 last_get_fp_time_;
  ::google::protobuf::uint32 last_sent_fp_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static friend_member* default_instance_;
};
// -------------------------------------------------------------------

class relation_interface_data : public ::google::protobuf::Message {
 public:
  relation_interface_data();
  virtual ~relation_interface_data();

  relation_interface_data(const relation_interface_data& from);

  inline relation_interface_data& operator=(const relation_interface_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const relation_interface_data& default_instance();

  void Swap(relation_interface_data* other);

  // implements Message ----------------------------------------------

  relation_interface_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const relation_interface_data& from);
  void MergeFrom(const relation_interface_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 friends_quantity = 2;
  inline bool has_friends_quantity() const;
  inline void clear_friends_quantity();
  static const int kFriendsQuantityFieldNumber = 2;
  inline ::google::protobuf::uint32 friends_quantity() const;
  inline void set_friends_quantity(::google::protobuf::uint32 value);

  // optional bool has_got = 3;
  inline bool has_has_got() const;
  inline void clear_has_got();
  static const int kHasGotFieldNumber = 3;
  inline bool has_got() const;
  inline void set_has_got(bool value);

  // @@protoc_insertion_point(class_scope:proto.common.relation_interface_data)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_friends_quantity();
  inline void clear_has_friends_quantity();
  inline void set_has_has_got();
  inline void clear_has_has_got();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 friends_quantity_;
  bool has_got_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static relation_interface_data* default_instance_;
};
// -------------------------------------------------------------------

class recommend_member : public ::google::protobuf::Message {
 public:
  recommend_member();
  virtual ~recommend_member();

  recommend_member(const recommend_member& from);

  inline recommend_member& operator=(const recommend_member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recommend_member& default_instance();

  void Swap(recommend_member* other);

  // implements Message ----------------------------------------------

  recommend_member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recommend_member& from);
  void MergeFrom(const recommend_member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.user_info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto::common::user_info& info() const;
  inline ::proto::common::user_info* mutable_info();
  inline ::proto::common::user_info* release_info();
  inline void set_allocated_info(::proto::common::user_info* info);

  // optional uint32 src = 2;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 2;
  inline ::google::protobuf::uint32 src() const;
  inline void set_src(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.recommend_member)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_src();
  inline void clear_has_src();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::user_info* info_;
  ::google::protobuf::uint32 src_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static recommend_member* default_instance_;
};
// -------------------------------------------------------------------

class user_info : public ::google::protobuf::Message {
 public:
  user_info();
  virtual ~user_info();

  user_info(const user_info& from);

  inline user_info& operator=(const user_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_info& default_instance();

  void Swap(user_info* other);

  // implements Message ----------------------------------------------

  user_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_info& from);
  void MergeFrom(const user_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional .proto.common.country_common country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline const ::proto::common::country_common& country() const;
  inline ::proto::common::country_common* mutable_country();
  inline ::proto::common::country_common* release_country();
  inline void set_allocated_country(::proto::common::country_common* country);

  // optional string family = 5;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 5;
  inline const ::std::string& family() const;
  inline void set_family(const ::std::string& value);
  inline void set_family(const char* value);
  inline void set_family(const char* value, size_t size);
  inline ::std::string* mutable_family();
  inline ::std::string* release_family();
  inline void set_allocated_family(::std::string* family);

  // optional uint32 offline_time = 6;
  inline bool has_offline_time() const;
  inline void clear_offline_time();
  static const int kOfflineTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 offline_time() const;
  inline void set_offline_time(::google::protobuf::uint32 value);

  // optional uint32 fighting = 7;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 7;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 plugin = 8;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 8;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 charm = 9;
  inline bool has_charm() const;
  inline void clear_charm();
  static const int kCharmFieldNumber = 9;
  inline ::google::protobuf::uint32 charm() const;
  inline void set_charm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.user_info)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_offline_time();
  inline void clear_has_offline_time();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_charm();
  inline void clear_has_charm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::proto::common::country_common* country_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 offline_time_;
  ::std::string* family_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 charm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_info* default_instance_;
};
// -------------------------------------------------------------------

class luck_gift_info : public ::google::protobuf::Message {
 public:
  luck_gift_info();
  virtual ~luck_gift_info();

  luck_gift_info(const luck_gift_info& from);

  inline luck_gift_info& operator=(const luck_gift_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luck_gift_info& default_instance();

  void Swap(luck_gift_info* other);

  // implements Message ----------------------------------------------

  luck_gift_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luck_gift_info& from);
  void MergeFrom(const luck_gift_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 luck_gift_uid = 1;
  inline bool has_luck_gift_uid() const;
  inline void clear_luck_gift_uid();
  static const int kLuckGiftUidFieldNumber = 1;
  inline ::google::protobuf::uint32 luck_gift_uid() const;
  inline void set_luck_gift_uid(::google::protobuf::uint32 value);

  // optional string src_role_uid = 2;
  inline bool has_src_role_uid() const;
  inline void clear_src_role_uid();
  static const int kSrcRoleUidFieldNumber = 2;
  inline const ::std::string& src_role_uid() const;
  inline void set_src_role_uid(const ::std::string& value);
  inline void set_src_role_uid(const char* value);
  inline void set_src_role_uid(const char* value, size_t size);
  inline ::std::string* mutable_src_role_uid();
  inline ::std::string* release_src_role_uid();
  inline void set_allocated_src_role_uid(::std::string* src_role_uid);

  // optional string src_role_name = 3;
  inline bool has_src_role_name() const;
  inline void clear_src_role_name();
  static const int kSrcRoleNameFieldNumber = 3;
  inline const ::std::string& src_role_name() const;
  inline void set_src_role_name(const ::std::string& value);
  inline void set_src_role_name(const char* value);
  inline void set_src_role_name(const char* value, size_t size);
  inline ::std::string* mutable_src_role_name();
  inline ::std::string* release_src_role_name();
  inline void set_allocated_src_role_name(::std::string* src_role_name);

  // @@protoc_insertion_point(class_scope:proto.common.luck_gift_info)
 private:
  inline void set_has_luck_gift_uid();
  inline void clear_has_luck_gift_uid();
  inline void set_has_src_role_uid();
  inline void clear_has_src_role_uid();
  inline void set_has_src_role_name();
  inline void clear_has_src_role_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* src_role_uid_;
  ::std::string* src_role_name_;
  ::google::protobuf::uint32 luck_gift_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luck_gift_info* default_instance_;
};
// -------------------------------------------------------------------

class gift_single : public ::google::protobuf::Message {
 public:
  gift_single();
  virtual ~gift_single();

  gift_single(const gift_single& from);

  inline gift_single& operator=(const gift_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gift_single& default_instance();

  void Swap(gift_single* other);

  // implements Message ----------------------------------------------

  gift_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gift_single& from);
  void MergeFrom(const gift_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.gift_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gift_single* default_instance_;
};
// -------------------------------------------------------------------

class gift_data : public ::google::protobuf::Message {
 public:
  gift_data();
  virtual ~gift_data();

  gift_data(const gift_data& from);

  inline gift_data& operator=(const gift_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gift_data& default_instance();

  void Swap(gift_data* other);

  // implements Message ----------------------------------------------

  gift_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gift_data& from);
  void MergeFrom(const gift_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string src_uid = 1;
  inline bool has_src_uid() const;
  inline void clear_src_uid();
  static const int kSrcUidFieldNumber = 1;
  inline const ::std::string& src_uid() const;
  inline void set_src_uid(const ::std::string& value);
  inline void set_src_uid(const char* value);
  inline void set_src_uid(const char* value, size_t size);
  inline ::std::string* mutable_src_uid();
  inline ::std::string* release_src_uid();
  inline void set_allocated_src_uid(::std::string* src_uid);

  // optional string src_name = 2;
  inline bool has_src_name() const;
  inline void clear_src_name();
  static const int kSrcNameFieldNumber = 2;
  inline const ::std::string& src_name() const;
  inline void set_src_name(const ::std::string& value);
  inline void set_src_name(const char* value);
  inline void set_src_name(const char* value, size_t size);
  inline ::std::string* mutable_src_name();
  inline ::std::string* release_src_name();
  inline void set_allocated_src_name(::std::string* src_name);

  // optional uint32 gift_count = 3;
  inline bool has_gift_count() const;
  inline void clear_gift_count();
  static const int kGiftCountFieldNumber = 3;
  inline ::google::protobuf::uint32 gift_count() const;
  inline void set_gift_count(::google::protobuf::uint32 value);

  // optional uint32 gift_value = 4;
  inline bool has_gift_value() const;
  inline void clear_gift_value();
  static const int kGiftValueFieldNumber = 4;
  inline ::google::protobuf::uint32 gift_value() const;
  inline void set_gift_value(::google::protobuf::uint32 value);

  // optional uint32 finish_time = 5;
  inline bool has_finish_time() const;
  inline void clear_finish_time();
  static const int kFinishTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 finish_time() const;
  inline void set_finish_time(::google::protobuf::uint32 value);

  // repeated .proto.common.gift_single gift_single = 6;
  inline int gift_single_size() const;
  inline void clear_gift_single();
  static const int kGiftSingleFieldNumber = 6;
  inline const ::proto::common::gift_single& gift_single(int index) const;
  inline ::proto::common::gift_single* mutable_gift_single(int index);
  inline ::proto::common::gift_single* add_gift_single();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::gift_single >&
      gift_single() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::gift_single >*
      mutable_gift_single();

  // @@protoc_insertion_point(class_scope:proto.common.gift_data)
 private:
  inline void set_has_src_uid();
  inline void clear_has_src_uid();
  inline void set_has_src_name();
  inline void clear_has_src_name();
  inline void set_has_gift_count();
  inline void clear_has_gift_count();
  inline void set_has_gift_value();
  inline void clear_has_gift_value();
  inline void set_has_finish_time();
  inline void clear_has_finish_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* src_uid_;
  ::std::string* src_name_;
  ::google::protobuf::uint32 gift_count_;
  ::google::protobuf::uint32 gift_value_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::gift_single > gift_single_;
  ::google::protobuf::uint32 finish_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gift_data* default_instance_;
};
// -------------------------------------------------------------------

class activity_single : public ::google::protobuf::Message {
 public:
  activity_single();
  virtual ~activity_single();

  activity_single(const activity_single& from);

  inline activity_single& operator=(const activity_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_single& default_instance();

  void Swap(activity_single* other);

  // implements Message ----------------------------------------------

  activity_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_single& from);
  void MergeFrom(const activity_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 activity_id = 1;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::uint32 activity_id() const;
  inline void set_activity_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 last_reset_time = 3;
  inline bool has_last_reset_time() const;
  inline void clear_last_reset_time();
  static const int kLastResetTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 last_reset_time() const;
  inline void set_last_reset_time(::google::protobuf::uint32 value);

  // optional uint32 add_count = 4;
  inline bool has_add_count() const;
  inline void clear_add_count();
  static const int kAddCountFieldNumber = 4;
  inline ::google::protobuf::uint32 add_count() const;
  inline void set_add_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.activity_single)
 private:
  inline void set_has_activity_id();
  inline void clear_has_activity_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_last_reset_time();
  inline void clear_has_last_reset_time();
  inline void set_has_add_count();
  inline void clear_has_add_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 activity_id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 last_reset_time_;
  ::google::protobuf::uint32 add_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static activity_single* default_instance_;
};
// -------------------------------------------------------------------

class liveness_box : public ::google::protobuf::Message {
 public:
  liveness_box();
  virtual ~liveness_box();

  liveness_box(const liveness_box& from);

  inline liveness_box& operator=(const liveness_box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const liveness_box& default_instance();

  void Swap(liveness_box* other);

  // implements Message ----------------------------------------------

  liveness_box* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const liveness_box& from);
  void MergeFrom(const liveness_box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 liveness = 1;
  inline bool has_liveness() const;
  inline void clear_liveness();
  static const int kLivenessFieldNumber = 1;
  inline ::google::protobuf::uint32 liveness() const;
  inline void set_liveness(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.liveness_box)
 private:
  inline void set_has_liveness();
  inline void clear_has_liveness();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 liveness_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static liveness_box* default_instance_;
};
// -------------------------------------------------------------------

class activities_data : public ::google::protobuf::Message {
 public:
  activities_data();
  virtual ~activities_data();

  activities_data(const activities_data& from);

  inline activities_data& operator=(const activities_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activities_data& default_instance();

  void Swap(activities_data* other);

  // implements Message ----------------------------------------------

  activities_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activities_data& from);
  void MergeFrom(const activities_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 liveness = 1;
  inline bool has_liveness() const;
  inline void clear_liveness();
  static const int kLivenessFieldNumber = 1;
  inline ::google::protobuf::uint32 liveness() const;
  inline void set_liveness(::google::protobuf::uint32 value);

  // repeated .proto.common.liveness_box box_list = 2;
  inline int box_list_size() const;
  inline void clear_box_list();
  static const int kBoxListFieldNumber = 2;
  inline const ::proto::common::liveness_box& box_list(int index) const;
  inline ::proto::common::liveness_box* mutable_box_list(int index);
  inline ::proto::common::liveness_box* add_box_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
      box_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
      mutable_box_list();

  // repeated .proto.common.activity_single activity_data = 3;
  inline int activity_data_size() const;
  inline void clear_activity_data();
  static const int kActivityDataFieldNumber = 3;
  inline const ::proto::common::activity_single& activity_data(int index) const;
  inline ::proto::common::activity_single* mutable_activity_data(int index);
  inline ::proto::common::activity_single* add_activity_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::activity_single >&
      activity_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::activity_single >*
      mutable_activity_data();

  // @@protoc_insertion_point(class_scope:proto.common.activities_data)
 private:
  inline void set_has_liveness();
  inline void clear_has_liveness();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box > box_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::activity_single > activity_data_;
  ::google::protobuf::uint32 liveness_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static activities_data* default_instance_;
};
// -------------------------------------------------------------------

class arena_role_rank_info : public ::google::protobuf::Message {
 public:
  arena_role_rank_info();
  virtual ~arena_role_rank_info();

  arena_role_rank_info(const arena_role_rank_info& from);

  inline arena_role_rank_info& operator=(const arena_role_rank_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_role_rank_info& default_instance();

  void Swap(arena_role_rank_info* other);

  // implements Message ----------------------------------------------

  arena_role_rank_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_role_rank_info& from);
  void MergeFrom(const arena_role_rank_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 stage = 3;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 3;
  inline ::google::protobuf::uint32 stage() const;
  inline void set_stage(::google::protobuf::uint32 value);

  // optional uint32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 server_id = 5;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional uint32 rank = 6;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 6;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 num = 7;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 7;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional string name = 8;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 8;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .proto.common.hero_data fight_heroes = 9;
  inline bool has_fight_heroes() const;
  inline void clear_fight_heroes();
  static const int kFightHeroesFieldNumber = 9;
  inline const ::proto::common::hero_data& fight_heroes() const;
  inline ::proto::common::hero_data* mutable_fight_heroes();
  inline ::proto::common::hero_data* release_fight_heroes();
  inline void set_allocated_fight_heroes(::proto::common::hero_data* fight_heroes);

  // optional .proto.common.item_data hero_equips = 10;
  inline bool has_hero_equips() const;
  inline void clear_hero_equips();
  static const int kHeroEquipsFieldNumber = 10;
  inline const ::proto::common::item_data& hero_equips() const;
  inline ::proto::common::item_data* mutable_hero_equips();
  inline ::proto::common::item_data* release_hero_equips();
  inline void set_allocated_hero_equips(::proto::common::item_data* hero_equips);

  // optional uint32 fighting_value = 11;
  inline bool has_fighting_value() const;
  inline void clear_fighting_value();
  static const int kFightingValueFieldNumber = 11;
  inline ::google::protobuf::uint32 fighting_value() const;
  inline void set_fighting_value(::google::protobuf::uint32 value);

  // optional string server_name = 12;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 12;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // @@protoc_insertion_point(class_scope:proto.common.arena_role_rank_info)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fight_heroes();
  inline void clear_has_fight_heroes();
  inline void set_has_hero_equips();
  inline void clear_has_hero_equips();
  inline void set_has_fighting_value();
  inline void clear_has_fighting_value();
  inline void set_has_server_name();
  inline void clear_has_server_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 stage_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 server_id_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 num_;
  ::std::string* name_;
  ::proto::common::hero_data* fight_heroes_;
  ::proto::common::item_data* hero_equips_;
  ::std::string* server_name_;
  ::google::protobuf::uint32 fighting_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static arena_role_rank_info* default_instance_;
};
// -------------------------------------------------------------------

class arena_rank_info_array : public ::google::protobuf::Message {
 public:
  arena_rank_info_array();
  virtual ~arena_rank_info_array();

  arena_rank_info_array(const arena_rank_info_array& from);

  inline arena_rank_info_array& operator=(const arena_rank_info_array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_rank_info_array& default_instance();

  void Swap(arena_rank_info_array* other);

  // implements Message ----------------------------------------------

  arena_rank_info_array* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_rank_info_array& from);
  void MergeFrom(const arena_rank_info_array& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.arena_role_rank_info info_list = 1;
  inline int info_list_size() const;
  inline void clear_info_list();
  static const int kInfoListFieldNumber = 1;
  inline const ::proto::common::arena_role_rank_info& info_list(int index) const;
  inline ::proto::common::arena_role_rank_info* mutable_info_list(int index);
  inline ::proto::common::arena_role_rank_info* add_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::arena_role_rank_info >&
      info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::arena_role_rank_info >*
      mutable_info_list();

  // @@protoc_insertion_point(class_scope:proto.common.arena_rank_info_array)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::arena_role_rank_info > info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static arena_rank_info_array* default_instance_;
};
// -------------------------------------------------------------------

class arena_role_data : public ::google::protobuf::Message {
 public:
  arena_role_data();
  virtual ~arena_role_data();

  arena_role_data(const arena_role_data& from);

  inline arena_role_data& operator=(const arena_role_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_role_data& default_instance();

  void Swap(arena_role_data* other);

  // implements Message ----------------------------------------------

  arena_role_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_role_data& from);
  void MergeFrom(const arena_role_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 win_times = 1;
  inline bool has_win_times() const;
  inline void clear_win_times();
  static const int kWinTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 win_times() const;
  inline void set_win_times(::google::protobuf::uint32 value);

  // optional uint32 lose_times = 2;
  inline bool has_lose_times() const;
  inline void clear_lose_times();
  static const int kLoseTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 lose_times() const;
  inline void set_lose_times(::google::protobuf::uint32 value);

  // optional uint32 is_start = 3;
  inline bool has_is_start() const;
  inline void clear_is_start();
  static const int kIsStartFieldNumber = 3;
  inline ::google::protobuf::uint32 is_start() const;
  inline void set_is_start(::google::protobuf::uint32 value);

  // optional uint32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 arena_level = 5;
  inline bool has_arena_level() const;
  inline void clear_arena_level();
  static const int kArenaLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 arena_level() const;
  inline void set_arena_level(::google::protobuf::uint32 value);

  // optional uint32 all_fight_times = 6;
  inline bool has_all_fight_times() const;
  inline void clear_all_fight_times();
  static const int kAllFightTimesFieldNumber = 6;
  inline ::google::protobuf::uint32 all_fight_times() const;
  inline void set_all_fight_times(::google::protobuf::uint32 value);

  // optional uint32 all_win_times = 7;
  inline bool has_all_win_times() const;
  inline void clear_all_win_times();
  static const int kAllWinTimesFieldNumber = 7;
  inline ::google::protobuf::uint32 all_win_times() const;
  inline void set_all_win_times(::google::protobuf::uint32 value);

  // optional uint32 honor = 8;
  inline bool has_honor() const;
  inline void clear_honor();
  static const int kHonorFieldNumber = 8;
  inline ::google::protobuf::uint32 honor() const;
  inline void set_honor(::google::protobuf::uint32 value);

  // optional uint32 honor_limit = 9;
  inline bool has_honor_limit() const;
  inline void clear_honor_limit();
  static const int kHonorLimitFieldNumber = 9;
  inline ::google::protobuf::uint32 honor_limit() const;
  inline void set_honor_limit(::google::protobuf::uint32 value);

  // optional uint32 rank = 10;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 10;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // optional uint32 best_win_times = 11;
  inline bool has_best_win_times() const;
  inline void clear_best_win_times();
  static const int kBestWinTimesFieldNumber = 11;
  inline ::google::protobuf::uint32 best_win_times() const;
  inline void set_best_win_times(::google::protobuf::uint32 value);

  // optional uint32 last_reset_time = 12;
  inline bool has_last_reset_time() const;
  inline void clear_last_reset_time();
  static const int kLastResetTimeFieldNumber = 12;
  inline ::google::protobuf::uint32 last_reset_time() const;
  inline void set_last_reset_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.arena_role_data)
 private:
  inline void set_has_win_times();
  inline void clear_has_win_times();
  inline void set_has_lose_times();
  inline void clear_has_lose_times();
  inline void set_has_is_start();
  inline void clear_has_is_start();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_arena_level();
  inline void clear_has_arena_level();
  inline void set_has_all_fight_times();
  inline void clear_has_all_fight_times();
  inline void set_has_all_win_times();
  inline void clear_has_all_win_times();
  inline void set_has_honor();
  inline void clear_has_honor();
  inline void set_has_honor_limit();
  inline void clear_has_honor_limit();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_best_win_times();
  inline void clear_has_best_win_times();
  inline void set_has_last_reset_time();
  inline void clear_has_last_reset_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 win_times_;
  ::google::protobuf::uint32 lose_times_;
  ::google::protobuf::uint32 is_start_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 arena_level_;
  ::google::protobuf::uint32 all_fight_times_;
  ::google::protobuf::uint32 all_win_times_;
  ::google::protobuf::uint32 honor_;
  ::google::protobuf::uint32 honor_limit_;
  ::google::protobuf::uint32 rank_;
  ::google::protobuf::uint32 best_win_times_;
  ::google::protobuf::uint32 last_reset_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static arena_role_data* default_instance_;
};
// -------------------------------------------------------------------

class treasure_single : public ::google::protobuf::Message {
 public:
  treasure_single();
  virtual ~treasure_single();

  treasure_single(const treasure_single& from);

  inline treasure_single& operator=(const treasure_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const treasure_single& default_instance();

  void Swap(treasure_single* other);

  // implements Message ----------------------------------------------

  treasure_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const treasure_single& from);
  void MergeFrom(const treasure_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 item_tid = 2;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 2;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.treasure_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_item_tid();
  inline void clear_has_item_tid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 item_tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static treasure_single* default_instance_;
};
// -------------------------------------------------------------------

class treasure_data : public ::google::protobuf::Message {
 public:
  treasure_data();
  virtual ~treasure_data();

  treasure_data(const treasure_data& from);

  inline treasure_data& operator=(const treasure_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const treasure_data& default_instance();

  void Swap(treasure_data* other);

  // implements Message ----------------------------------------------

  treasure_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const treasure_data& from);
  void MergeFrom(const treasure_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.treasure_single treasure_list = 1;
  inline int treasure_list_size() const;
  inline void clear_treasure_list();
  static const int kTreasureListFieldNumber = 1;
  inline const ::proto::common::treasure_single& treasure_list(int index) const;
  inline ::proto::common::treasure_single* mutable_treasure_list(int index);
  inline ::proto::common::treasure_single* add_treasure_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::treasure_single >&
      treasure_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::treasure_single >*
      mutable_treasure_list();

  // optional uint32 treasure_id = 2;
  inline bool has_treasure_id() const;
  inline void clear_treasure_id();
  static const int kTreasureIdFieldNumber = 2;
  inline ::google::protobuf::uint32 treasure_id() const;
  inline void set_treasure_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.treasure_data)
 private:
  inline void set_has_treasure_id();
  inline void clear_has_treasure_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::treasure_single > treasure_list_;
  ::google::protobuf::uint32 treasure_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static treasure_data* default_instance_;
};
// -------------------------------------------------------------------

class sys_notice_data : public ::google::protobuf::Message {
 public:
  sys_notice_data();
  virtual ~sys_notice_data();

  sys_notice_data(const sys_notice_data& from);

  inline sys_notice_data& operator=(const sys_notice_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_notice_data& default_instance();

  void Swap(sys_notice_data* other);

  // implements Message ----------------------------------------------

  sys_notice_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_notice_data& from);
  void MergeFrom(const sys_notice_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.system_notice_type type = 1 [default = SYS_NOTICE_DEFAULT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::proto::common::system_notice_type type() const;
  inline void set_type(::proto::common::system_notice_type value);

  // optional uint32 priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline ::google::protobuf::uint32 priority() const;
  inline void set_priority(::google::protobuf::uint32 value);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string role_id = 4;
  inline bool has_role_id() const;
  inline void clear_role_id();
  static const int kRoleIdFieldNumber = 4;
  inline const ::std::string& role_id() const;
  inline void set_role_id(const ::std::string& value);
  inline void set_role_id(const char* value);
  inline void set_role_id(const char* value, size_t size);
  inline ::std::string* mutable_role_id();
  inline ::std::string* release_role_id();
  inline void set_allocated_role_id(::std::string* role_id);

  // optional string family_id = 5;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 5;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional string country_id = 6;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 6;
  inline const ::std::string& country_id() const;
  inline void set_country_id(const ::std::string& value);
  inline void set_country_id(const char* value);
  inline void set_country_id(const char* value, size_t size);
  inline ::std::string* mutable_country_id();
  inline ::std::string* release_country_id();
  inline void set_allocated_country_id(::std::string* country_id);

  // optional uint32 label = 7;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 7;
  inline ::google::protobuf::uint32 label() const;
  inline void set_label(::google::protobuf::uint32 value);

  // optional string default_text = 8;
  inline bool has_default_text() const;
  inline void clear_default_text();
  static const int kDefaultTextFieldNumber = 8;
  inline const ::std::string& default_text() const;
  inline void set_default_text(const ::std::string& value);
  inline void set_default_text(const char* value);
  inline void set_default_text(const char* value, size_t size);
  inline ::std::string* mutable_default_text();
  inline ::std::string* release_default_text();
  inline void set_allocated_default_text(::std::string* default_text);

  // optional uint32 table_type_id = 9;
  inline bool has_table_type_id() const;
  inline void clear_table_type_id();
  static const int kTableTypeIdFieldNumber = 9;
  inline ::google::protobuf::uint32 table_type_id() const;
  inline void set_table_type_id(::google::protobuf::uint32 value);

  // optional uint32 param = 10;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 10;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // repeated string param_str_list = 11;
  inline int param_str_list_size() const;
  inline void clear_param_str_list();
  static const int kParamStrListFieldNumber = 11;
  inline const ::std::string& param_str_list(int index) const;
  inline ::std::string* mutable_param_str_list(int index);
  inline void set_param_str_list(int index, const ::std::string& value);
  inline void set_param_str_list(int index, const char* value);
  inline void set_param_str_list(int index, const char* value, size_t size);
  inline ::std::string* add_param_str_list();
  inline void add_param_str_list(const ::std::string& value);
  inline void add_param_str_list(const char* value);
  inline void add_param_str_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& param_str_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_param_str_list();

  // @@protoc_insertion_point(class_scope:proto.common.sys_notice_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_role_id();
  inline void clear_has_role_id();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_default_text();
  inline void clear_has_default_text();
  inline void set_has_table_type_id();
  inline void clear_has_table_type_id();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 priority_;
  ::std::string* text_;
  ::std::string* role_id_;
  ::std::string* family_id_;
  ::std::string* country_id_;
  ::std::string* default_text_;
  ::google::protobuf::uint32 label_;
  ::google::protobuf::uint32 table_type_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> param_str_list_;
  ::google::protobuf::uint32 param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sys_notice_data* default_instance_;
};
// -------------------------------------------------------------------

class shop_goods : public ::google::protobuf::Message {
 public:
  shop_goods();
  virtual ~shop_goods();

  shop_goods(const shop_goods& from);

  inline shop_goods& operator=(const shop_goods& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shop_goods& default_instance();

  void Swap(shop_goods* other);

  // implements Message ----------------------------------------------

  shop_goods* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shop_goods& from);
  void MergeFrom(const shop_goods& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 goods_id = 1;
  inline bool has_goods_id() const;
  inline void clear_goods_id();
  static const int kGoodsIdFieldNumber = 1;
  inline ::google::protobuf::uint32 goods_id() const;
  inline void set_goods_id(::google::protobuf::uint32 value);

  // optional uint32 buy_count = 2;
  inline bool has_buy_count() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 2;
  inline ::google::protobuf::uint32 buy_count() const;
  inline void set_buy_count(::google::protobuf::uint32 value);

  // optional uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 4;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // optional uint32 last_refresh_time = 5;
  inline bool has_last_refresh_time() const;
  inline void clear_last_refresh_time();
  static const int kLastRefreshTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 last_refresh_time() const;
  inline void set_last_refresh_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.shop_goods)
 private:
  inline void set_has_goods_id();
  inline void clear_has_goods_id();
  inline void set_has_buy_count();
  inline void clear_has_buy_count();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_last_refresh_time();
  inline void clear_has_last_refresh_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 goods_id_;
  ::google::protobuf::uint32 buy_count_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 last_refresh_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static shop_goods* default_instance_;
};
// -------------------------------------------------------------------

class shop_goods_list : public ::google::protobuf::Message {
 public:
  shop_goods_list();
  virtual ~shop_goods_list();

  shop_goods_list(const shop_goods_list& from);

  inline shop_goods_list& operator=(const shop_goods_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const shop_goods_list& default_instance();

  void Swap(shop_goods_list* other);

  // implements Message ----------------------------------------------

  shop_goods_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const shop_goods_list& from);
  void MergeFrom(const shop_goods_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.shop_goods goods_list = 1;
  inline int goods_list_size() const;
  inline void clear_goods_list();
  static const int kGoodsListFieldNumber = 1;
  inline const ::proto::common::shop_goods& goods_list(int index) const;
  inline ::proto::common::shop_goods* mutable_goods_list(int index);
  inline ::proto::common::shop_goods* add_goods_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::shop_goods >&
      goods_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::shop_goods >*
      mutable_goods_list();

  // @@protoc_insertion_point(class_scope:proto.common.shop_goods_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::shop_goods > goods_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static shop_goods_list* default_instance_;
};
// -------------------------------------------------------------------

class user_goods : public ::google::protobuf::Message {
 public:
  user_goods();
  virtual ~user_goods();

  user_goods(const user_goods& from);

  inline user_goods& operator=(const user_goods& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_goods& default_instance();

  void Swap(user_goods* other);

  // implements Message ----------------------------------------------

  user_goods* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_goods& from);
  void MergeFrom(const user_goods& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 goods_id = 1;
  inline bool has_goods_id() const;
  inline void clear_goods_id();
  static const int kGoodsIdFieldNumber = 1;
  inline ::google::protobuf::uint32 goods_id() const;
  inline void set_goods_id(::google::protobuf::uint32 value);

  // optional uint32 buy_count = 2;
  inline bool has_buy_count() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 2;
  inline ::google::protobuf::uint32 buy_count() const;
  inline void set_buy_count(::google::protobuf::uint32 value);

  // optional uint32 last_refresh_time = 3;
  inline bool has_last_refresh_time() const;
  inline void clear_last_refresh_time();
  static const int kLastRefreshTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 last_refresh_time() const;
  inline void set_last_refresh_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.user_goods)
 private:
  inline void set_has_goods_id();
  inline void clear_has_goods_id();
  inline void set_has_buy_count();
  inline void clear_has_buy_count();
  inline void set_has_last_refresh_time();
  inline void clear_has_last_refresh_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 goods_id_;
  ::google::protobuf::uint32 buy_count_;
  ::google::protobuf::uint32 last_refresh_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_goods* default_instance_;
};
// -------------------------------------------------------------------

class user_goods_list : public ::google::protobuf::Message {
 public:
  user_goods_list();
  virtual ~user_goods_list();

  user_goods_list(const user_goods_list& from);

  inline user_goods_list& operator=(const user_goods_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_goods_list& default_instance();

  void Swap(user_goods_list* other);

  // implements Message ----------------------------------------------

  user_goods_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_goods_list& from);
  void MergeFrom(const user_goods_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.user_goods goods_list = 1;
  inline int goods_list_size() const;
  inline void clear_goods_list();
  static const int kGoodsListFieldNumber = 1;
  inline const ::proto::common::user_goods& goods_list(int index) const;
  inline ::proto::common::user_goods* mutable_goods_list(int index);
  inline ::proto::common::user_goods* add_goods_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::user_goods >&
      goods_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::user_goods >*
      mutable_goods_list();

  // @@protoc_insertion_point(class_scope:proto.common.user_goods_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::user_goods > goods_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_goods_list* default_instance_;
};
// -------------------------------------------------------------------

class user_buy_goods : public ::google::protobuf::Message {
 public:
  user_buy_goods();
  virtual ~user_buy_goods();

  user_buy_goods(const user_buy_goods& from);

  inline user_buy_goods& operator=(const user_buy_goods& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_buy_goods& default_instance();

  void Swap(user_buy_goods* other);

  // implements Message ----------------------------------------------

  user_buy_goods* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_buy_goods& from);
  void MergeFrom(const user_buy_goods& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 goods_id = 1;
  inline bool has_goods_id() const;
  inline void clear_goods_id();
  static const int kGoodsIdFieldNumber = 1;
  inline ::google::protobuf::uint32 goods_id() const;
  inline void set_goods_id(::google::protobuf::uint32 value);

  // optional uint32 goods_num = 2;
  inline bool has_goods_num() const;
  inline void clear_goods_num();
  static const int kGoodsNumFieldNumber = 2;
  inline ::google::protobuf::uint32 goods_num() const;
  inline void set_goods_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.user_buy_goods)
 private:
  inline void set_has_goods_id();
  inline void clear_has_goods_id();
  inline void set_has_goods_num();
  inline void clear_has_goods_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 goods_id_;
  ::google::protobuf::uint32 goods_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static user_buy_goods* default_instance_;
};
// -------------------------------------------------------------------

class challenge_info : public ::google::protobuf::Message {
 public:
  challenge_info();
  virtual ~challenge_info();

  challenge_info(const challenge_info& from);

  inline challenge_info& operator=(const challenge_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const challenge_info& default_instance();

  void Swap(challenge_info* other);

  // implements Message ----------------------------------------------

  challenge_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const challenge_info& from);
  void MergeFrom(const challenge_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string challenge_uid = 1;
  inline bool has_challenge_uid() const;
  inline void clear_challenge_uid();
  static const int kChallengeUidFieldNumber = 1;
  inline const ::std::string& challenge_uid() const;
  inline void set_challenge_uid(const ::std::string& value);
  inline void set_challenge_uid(const char* value);
  inline void set_challenge_uid(const char* value, size_t size);
  inline ::std::string* mutable_challenge_uid();
  inline ::std::string* release_challenge_uid();
  inline void set_allocated_challenge_uid(::std::string* challenge_uid);

  // optional string challenger_name = 2;
  inline bool has_challenger_name() const;
  inline void clear_challenger_name();
  static const int kChallengerNameFieldNumber = 2;
  inline const ::std::string& challenger_name() const;
  inline void set_challenger_name(const ::std::string& value);
  inline void set_challenger_name(const char* value);
  inline void set_challenger_name(const char* value, size_t size);
  inline ::std::string* mutable_challenger_name();
  inline ::std::string* release_challenger_name();
  inline void set_allocated_challenger_name(::std::string* challenger_name);

  // optional string target_name = 3;
  inline bool has_target_name() const;
  inline void clear_target_name();
  static const int kTargetNameFieldNumber = 3;
  inline const ::std::string& target_name() const;
  inline void set_target_name(const ::std::string& value);
  inline void set_target_name(const char* value);
  inline void set_target_name(const char* value, size_t size);
  inline ::std::string* mutable_target_name();
  inline ::std::string* release_target_name();
  inline void set_allocated_target_name(::std::string* target_name);

  // optional string challenge_time = 4;
  inline bool has_challenge_time() const;
  inline void clear_challenge_time();
  static const int kChallengeTimeFieldNumber = 4;
  inline const ::std::string& challenge_time() const;
  inline void set_challenge_time(const ::std::string& value);
  inline void set_challenge_time(const char* value);
  inline void set_challenge_time(const char* value, size_t size);
  inline ::std::string* mutable_challenge_time();
  inline ::std::string* release_challenge_time();
  inline void set_allocated_challenge_time(::std::string* challenge_time);

  // optional uint32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.challenge_info)
 private:
  inline void set_has_challenge_uid();
  inline void clear_has_challenge_uid();
  inline void set_has_challenger_name();
  inline void clear_has_challenger_name();
  inline void set_has_target_name();
  inline void clear_has_target_name();
  inline void set_has_challenge_time();
  inline void clear_has_challenge_time();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* challenge_uid_;
  ::std::string* challenger_name_;
  ::std::string* target_name_;
  ::std::string* challenge_time_;
  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static challenge_info* default_instance_;
};
// -------------------------------------------------------------------

class troop_formation_pair : public ::google::protobuf::Message {
 public:
  troop_formation_pair();
  virtual ~troop_formation_pair();

  troop_formation_pair(const troop_formation_pair& from);

  inline troop_formation_pair& operator=(const troop_formation_pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const troop_formation_pair& default_instance();

  void Swap(troop_formation_pair* other);

  // implements Message ----------------------------------------------

  troop_formation_pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const troop_formation_pair& from);
  void MergeFrom(const troop_formation_pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // optional string unique_id = 2;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 2;
  inline const ::std::string& unique_id() const;
  inline void set_unique_id(const ::std::string& value);
  inline void set_unique_id(const char* value);
  inline void set_unique_id(const char* value, size_t size);
  inline ::std::string* mutable_unique_id();
  inline ::std::string* release_unique_id();
  inline void set_allocated_unique_id(::std::string* unique_id);

  // optional string owner_id = 3;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  inline const ::std::string& owner_id() const;
  inline void set_owner_id(const ::std::string& value);
  inline void set_owner_id(const char* value);
  inline void set_owner_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_id();
  inline ::std::string* release_owner_id();
  inline void set_allocated_owner_id(::std::string* owner_id);

  // @@protoc_insertion_point(class_scope:proto.common.troop_formation_pair)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* unique_id_;
  ::std::string* owner_id_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static troop_formation_pair* default_instance_;
};
// -------------------------------------------------------------------

class troop_formation : public ::google::protobuf::Message {
 public:
  troop_formation();
  virtual ~troop_formation();

  troop_formation(const troop_formation& from);

  inline troop_formation& operator=(const troop_formation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const troop_formation& default_instance();

  void Swap(troop_formation* other);

  // implements Message ----------------------------------------------

  troop_formation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const troop_formation& from);
  void MergeFrom(const troop_formation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tactic_id = 1;
  inline bool has_tactic_id() const;
  inline void clear_tactic_id();
  static const int kTacticIdFieldNumber = 1;
  inline ::google::protobuf::uint32 tactic_id() const;
  inline void set_tactic_id(::google::protobuf::uint32 value);

  // repeated .proto.common.troop_formation_pair formations = 2;
  inline int formations_size() const;
  inline void clear_formations();
  static const int kFormationsFieldNumber = 2;
  inline const ::proto::common::troop_formation_pair& formations(int index) const;
  inline ::proto::common::troop_formation_pair* mutable_formations(int index);
  inline ::proto::common::troop_formation_pair* add_formations();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::troop_formation_pair >&
      formations() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::troop_formation_pair >*
      mutable_formations();

  // @@protoc_insertion_point(class_scope:proto.common.troop_formation)
 private:
  inline void set_has_tactic_id();
  inline void clear_has_tactic_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::troop_formation_pair > formations_;
  ::google::protobuf::uint32 tactic_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static troop_formation* default_instance_;
};
// -------------------------------------------------------------------

class king_war_country_sign_up_single : public ::google::protobuf::Message {
 public:
  king_war_country_sign_up_single();
  virtual ~king_war_country_sign_up_single();

  king_war_country_sign_up_single(const king_war_country_sign_up_single& from);

  inline king_war_country_sign_up_single& operator=(const king_war_country_sign_up_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_country_sign_up_single& default_instance();

  void Swap(king_war_country_sign_up_single* other);

  // implements Message ----------------------------------------------

  king_war_country_sign_up_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_country_sign_up_single& from);
  void MergeFrom(const king_war_country_sign_up_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.country_base_data country_base = 1;
  inline bool has_country_base() const;
  inline void clear_country_base();
  static const int kCountryBaseFieldNumber = 1;
  inline const ::proto::common::country_base_data& country_base() const;
  inline ::proto::common::country_base_data* mutable_country_base();
  inline ::proto::common::country_base_data* release_country_base();
  inline void set_allocated_country_base(::proto::common::country_base_data* country_base);

  // optional uint32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::uint32 power() const;
  inline void set_power(::google::protobuf::uint32 value);

  // optional uint32 family_number = 4;
  inline bool has_family_number() const;
  inline void clear_family_number();
  static const int kFamilyNumberFieldNumber = 4;
  inline ::google::protobuf::uint32 family_number() const;
  inline void set_family_number(::google::protobuf::uint32 value);

  // optional uint32 sign_up_number = 5;
  inline bool has_sign_up_number() const;
  inline void clear_sign_up_number();
  static const int kSignUpNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 sign_up_number() const;
  inline void set_sign_up_number(::google::protobuf::uint32 value);

  // optional bool is_sign_up = 6;
  inline bool has_is_sign_up() const;
  inline void clear_is_sign_up();
  static const int kIsSignUpFieldNumber = 6;
  inline bool is_sign_up() const;
  inline void set_is_sign_up(bool value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_country_sign_up_single)
 private:
  inline void set_has_country_base();
  inline void clear_has_country_base();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_family_number();
  inline void clear_has_family_number();
  inline void set_has_sign_up_number();
  inline void clear_has_sign_up_number();
  inline void set_has_is_sign_up();
  inline void clear_has_is_sign_up();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::country_base_data* country_base_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 power_;
  ::google::protobuf::uint32 family_number_;
  ::google::protobuf::uint32 sign_up_number_;
  bool is_sign_up_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_country_sign_up_single* default_instance_;
};
// -------------------------------------------------------------------

class king_war_country_sign_up_info : public ::google::protobuf::Message {
 public:
  king_war_country_sign_up_info();
  virtual ~king_war_country_sign_up_info();

  king_war_country_sign_up_info(const king_war_country_sign_up_info& from);

  inline king_war_country_sign_up_info& operator=(const king_war_country_sign_up_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_country_sign_up_info& default_instance();

  void Swap(king_war_country_sign_up_info* other);

  // implements Message ----------------------------------------------

  king_war_country_sign_up_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_country_sign_up_info& from);
  void MergeFrom(const king_war_country_sign_up_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 end_time = 1;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // repeated .proto.common.king_war_country_sign_up_single countries = 2;
  inline int countries_size() const;
  inline void clear_countries();
  static const int kCountriesFieldNumber = 2;
  inline const ::proto::common::king_war_country_sign_up_single& countries(int index) const;
  inline ::proto::common::king_war_country_sign_up_single* mutable_countries(int index);
  inline ::proto::common::king_war_country_sign_up_single* add_countries();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_sign_up_single >&
      countries() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_sign_up_single >*
      mutable_countries();

  // @@protoc_insertion_point(class_scope:proto.common.king_war_country_sign_up_info)
 private:
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_sign_up_single > countries_;
  ::google::protobuf::uint32 end_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_country_sign_up_info* default_instance_;
};
// -------------------------------------------------------------------

class king_war_family_info : public ::google::protobuf::Message {
 public:
  king_war_family_info();
  virtual ~king_war_family_info();

  king_war_family_info(const king_war_family_info& from);

  inline king_war_family_info& operator=(const king_war_family_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_family_info& default_instance();

  void Swap(king_war_family_info* other);

  // implements Message ----------------------------------------------

  king_war_family_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_family_info& from);
  void MergeFrom(const king_war_family_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string family_id = 1;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 1;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional bool is_king_family = 3;
  inline bool has_is_king_family() const;
  inline void clear_is_king_family();
  static const int kIsKingFamilyFieldNumber = 3;
  inline bool is_king_family() const;
  inline void set_is_king_family(bool value);

  // optional string friend_family_id = 4;
  inline bool has_friend_family_id() const;
  inline void clear_friend_family_id();
  static const int kFriendFamilyIdFieldNumber = 4;
  inline const ::std::string& friend_family_id() const;
  inline void set_friend_family_id(const ::std::string& value);
  inline void set_friend_family_id(const char* value);
  inline void set_friend_family_id(const char* value, size_t size);
  inline ::std::string* mutable_friend_family_id();
  inline ::std::string* release_friend_family_id();
  inline void set_allocated_friend_family_id(::std::string* friend_family_id);

  // optional string friend_family_name = 5;
  inline bool has_friend_family_name() const;
  inline void clear_friend_family_name();
  static const int kFriendFamilyNameFieldNumber = 5;
  inline const ::std::string& friend_family_name() const;
  inline void set_friend_family_name(const ::std::string& value);
  inline void set_friend_family_name(const char* value);
  inline void set_friend_family_name(const char* value, size_t size);
  inline ::std::string* mutable_friend_family_name();
  inline ::std::string* release_friend_family_name();
  inline void set_allocated_friend_family_name(::std::string* friend_family_name);

  // optional string notice_user = 6;
  inline bool has_notice_user() const;
  inline void clear_notice_user();
  static const int kNoticeUserFieldNumber = 6;
  inline const ::std::string& notice_user() const;
  inline void set_notice_user(const ::std::string& value);
  inline void set_notice_user(const char* value);
  inline void set_notice_user(const char* value, size_t size);
  inline ::std::string* mutable_notice_user();
  inline ::std::string* release_notice_user();
  inline void set_allocated_notice_user(::std::string* notice_user);

  // optional uint32 family_officer = 7;
  inline bool has_family_officer() const;
  inline void clear_family_officer();
  static const int kFamilyOfficerFieldNumber = 7;
  inline ::google::protobuf::uint32 family_officer() const;
  inline void set_family_officer(::google::protobuf::uint32 value);

  // optional string notice = 8;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 8;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional uint32 like_num = 9;
  inline bool has_like_num() const;
  inline void clear_like_num();
  static const int kLikeNumFieldNumber = 9;
  inline ::google::protobuf::uint32 like_num() const;
  inline void set_like_num(::google::protobuf::uint32 value);

  // optional uint32 dislike_num = 10;
  inline bool has_dislike_num() const;
  inline void clear_dislike_num();
  static const int kDislikeNumFieldNumber = 10;
  inline ::google::protobuf::uint32 dislike_num() const;
  inline void set_dislike_num(::google::protobuf::uint32 value);

  // optional bool is_like = 11;
  inline bool has_is_like() const;
  inline void clear_is_like();
  static const int kIsLikeFieldNumber = 11;
  inline bool is_like() const;
  inline void set_is_like(bool value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_family_info)
 private:
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_is_king_family();
  inline void clear_has_is_king_family();
  inline void set_has_friend_family_id();
  inline void clear_has_friend_family_id();
  inline void set_has_friend_family_name();
  inline void clear_has_friend_family_name();
  inline void set_has_notice_user();
  inline void clear_has_notice_user();
  inline void set_has_family_officer();
  inline void clear_has_family_officer();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_like_num();
  inline void clear_has_like_num();
  inline void set_has_dislike_num();
  inline void clear_has_dislike_num();
  inline void set_has_is_like();
  inline void clear_has_is_like();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_id_;
  ::std::string* family_name_;
  ::std::string* friend_family_id_;
  ::std::string* friend_family_name_;
  ::std::string* notice_user_;
  ::google::protobuf::uint32 family_officer_;
  bool is_king_family_;
  bool is_like_;
  ::std::string* notice_;
  ::google::protobuf::uint32 like_num_;
  ::google::protobuf::uint32 dislike_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_family_info* default_instance_;
};
// -------------------------------------------------------------------

class king_war_country_pre_single : public ::google::protobuf::Message {
 public:
  king_war_country_pre_single();
  virtual ~king_war_country_pre_single();

  king_war_country_pre_single(const king_war_country_pre_single& from);

  inline king_war_country_pre_single& operator=(const king_war_country_pre_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_country_pre_single& default_instance();

  void Swap(king_war_country_pre_single* other);

  // implements Message ----------------------------------------------

  king_war_country_pre_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_country_pre_single& from);
  void MergeFrom(const king_war_country_pre_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 country_id = 1;
  inline bool has_country_id() const;
  inline void clear_country_id();
  static const int kCountryIdFieldNumber = 1;
  inline ::google::protobuf::uint32 country_id() const;
  inline void set_country_id(::google::protobuf::uint32 value);

  // optional .proto.common.king_war_family_info left_family = 2;
  inline bool has_left_family() const;
  inline void clear_left_family();
  static const int kLeftFamilyFieldNumber = 2;
  inline const ::proto::common::king_war_family_info& left_family() const;
  inline ::proto::common::king_war_family_info* mutable_left_family();
  inline ::proto::common::king_war_family_info* release_left_family();
  inline void set_allocated_left_family(::proto::common::king_war_family_info* left_family);

  // optional .proto.common.king_war_family_info right_family = 3;
  inline bool has_right_family() const;
  inline void clear_right_family();
  static const int kRightFamilyFieldNumber = 3;
  inline const ::proto::common::king_war_family_info& right_family() const;
  inline ::proto::common::king_war_family_info* mutable_right_family();
  inline ::proto::common::king_war_family_info* release_right_family();
  inline void set_allocated_right_family(::proto::common::king_war_family_info* right_family);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_country_pre_single)
 private:
  inline void set_has_country_id();
  inline void clear_has_country_id();
  inline void set_has_left_family();
  inline void clear_has_left_family();
  inline void set_has_right_family();
  inline void clear_has_right_family();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::king_war_family_info* left_family_;
  ::proto::common::king_war_family_info* right_family_;
  ::google::protobuf::uint32 country_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_country_pre_single* default_instance_;
};
// -------------------------------------------------------------------

class king_war_country_pre_info : public ::google::protobuf::Message {
 public:
  king_war_country_pre_info();
  virtual ~king_war_country_pre_info();

  king_war_country_pre_info(const king_war_country_pre_info& from);

  inline king_war_country_pre_info& operator=(const king_war_country_pre_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_country_pre_info& default_instance();

  void Swap(king_war_country_pre_info* other);

  // implements Message ----------------------------------------------

  king_war_country_pre_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_country_pre_info& from);
  void MergeFrom(const king_war_country_pre_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 fight_time = 1;
  inline bool has_fight_time() const;
  inline void clear_fight_time();
  static const int kFightTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 fight_time() const;
  inline void set_fight_time(::google::protobuf::uint32 value);

  // repeated .proto.common.king_war_country_pre_single countries = 2;
  inline int countries_size() const;
  inline void clear_countries();
  static const int kCountriesFieldNumber = 2;
  inline const ::proto::common::king_war_country_pre_single& countries(int index) const;
  inline ::proto::common::king_war_country_pre_single* mutable_countries(int index);
  inline ::proto::common::king_war_country_pre_single* add_countries();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_pre_single >&
      countries() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_pre_single >*
      mutable_countries();

  // @@protoc_insertion_point(class_scope:proto.common.king_war_country_pre_info)
 private:
  inline void set_has_fight_time();
  inline void clear_has_fight_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_pre_single > countries_;
  ::google::protobuf::uint32 fight_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_country_pre_info* default_instance_;
};
// -------------------------------------------------------------------

class country_king_war_info : public ::google::protobuf::Message {
 public:
  country_king_war_info();
  virtual ~country_king_war_info();

  country_king_war_info(const country_king_war_info& from);

  inline country_king_war_info& operator=(const country_king_war_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const country_king_war_info& default_instance();

  void Swap(country_king_war_info* other);

  // implements Message ----------------------------------------------

  country_king_war_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const country_king_war_info& from);
  void MergeFrom(const country_king_war_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 state = 1 [default = 0];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional .proto.common.king_war_country_sign_up_info sign_up_info = 2;
  inline bool has_sign_up_info() const;
  inline void clear_sign_up_info();
  static const int kSignUpInfoFieldNumber = 2;
  inline const ::proto::common::king_war_country_sign_up_info& sign_up_info() const;
  inline ::proto::common::king_war_country_sign_up_info* mutable_sign_up_info();
  inline ::proto::common::king_war_country_sign_up_info* release_sign_up_info();
  inline void set_allocated_sign_up_info(::proto::common::king_war_country_sign_up_info* sign_up_info);

  // optional .proto.common.king_war_country_pre_info pre_info = 3;
  inline bool has_pre_info() const;
  inline void clear_pre_info();
  static const int kPreInfoFieldNumber = 3;
  inline const ::proto::common::king_war_country_pre_info& pre_info() const;
  inline ::proto::common::king_war_country_pre_info* mutable_pre_info();
  inline ::proto::common::king_war_country_pre_info* release_pre_info();
  inline void set_allocated_pre_info(::proto::common::king_war_country_pre_info* pre_info);

  // @@protoc_insertion_point(class_scope:proto.common.country_king_war_info)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_sign_up_info();
  inline void clear_has_sign_up_info();
  inline void set_has_pre_info();
  inline void clear_has_pre_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::king_war_country_sign_up_info* sign_up_info_;
  ::proto::common::king_war_country_pre_info* pre_info_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static country_king_war_info* default_instance_;
};
// -------------------------------------------------------------------

class family_war_info : public ::google::protobuf::Message {
 public:
  family_war_info();
  virtual ~family_war_info();

  family_war_info(const family_war_info& from);

  inline family_war_info& operator=(const family_war_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_war_info& default_instance();

  void Swap(family_war_info* other);

  // implements Message ----------------------------------------------

  family_war_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_war_info& from);
  void MergeFrom(const family_war_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.family_war_state state = 1 [default = family_war_state_end];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::proto::common::family_war_state state() const;
  inline void set_state(::proto::common::family_war_state value);

  // optional .proto.common.family_against_data data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::proto::common::family_against_data& data() const;
  inline ::proto::common::family_against_data* mutable_data();
  inline ::proto::common::family_against_data* release_data();
  inline void set_allocated_data(::proto::common::family_against_data* data);

  // optional uint32 war_time = 3;
  inline bool has_war_time() const;
  inline void clear_war_time();
  static const int kWarTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 war_time() const;
  inline void set_war_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_war_info)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_war_time();
  inline void clear_has_war_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::family_against_data* data_;
  int state_;
  ::google::protobuf::uint32 war_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_war_info* default_instance_;
};
// -------------------------------------------------------------------

class king_war_sign_up_data : public ::google::protobuf::Message {
 public:
  king_war_sign_up_data();
  virtual ~king_war_sign_up_data();

  king_war_sign_up_data(const king_war_sign_up_data& from);

  inline king_war_sign_up_data& operator=(const king_war_sign_up_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_sign_up_data& default_instance();

  void Swap(king_war_sign_up_data* other);

  // implements Message ----------------------------------------------

  king_war_sign_up_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_sign_up_data& from);
  void MergeFrom(const king_war_sign_up_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string family_name = 1;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 1;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional string patriarch_name = 2;
  inline bool has_patriarch_name() const;
  inline void clear_patriarch_name();
  static const int kPatriarchNameFieldNumber = 2;
  inline const ::std::string& patriarch_name() const;
  inline void set_patriarch_name(const ::std::string& value);
  inline void set_patriarch_name(const char* value);
  inline void set_patriarch_name(const char* value, size_t size);
  inline ::std::string* mutable_patriarch_name();
  inline ::std::string* release_patriarch_name();
  inline void set_allocated_patriarch_name(::std::string* patriarch_name);

  // optional uint32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_sign_up_data)
 private:
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_patriarch_name();
  inline void clear_has_patriarch_name();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_name_;
  ::std::string* patriarch_name_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_sign_up_data* default_instance_;
};
// -------------------------------------------------------------------

class king_war_help_family : public ::google::protobuf::Message {
 public:
  king_war_help_family();
  virtual ~king_war_help_family();

  king_war_help_family(const king_war_help_family& from);

  inline king_war_help_family& operator=(const king_war_help_family& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_help_family& default_instance();

  void Swap(king_war_help_family* other);

  // implements Message ----------------------------------------------

  king_war_help_family* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_help_family& from);
  void MergeFrom(const king_war_help_family& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.family_list_info info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto::common::family_list_info& info() const;
  inline ::proto::common::family_list_info* mutable_info();
  inline ::proto::common::family_list_info* release_info();
  inline void set_allocated_info(::proto::common::family_list_info* info);

  // optional .proto.common.king_war_help_state state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::proto::common::king_war_help_state state() const;
  inline void set_state(::proto::common::king_war_help_state value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_help_family)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::family_list_info* info_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_help_family* default_instance_;
};
// -------------------------------------------------------------------

class king_war_helf_info : public ::google::protobuf::Message {
 public:
  king_war_helf_info();
  virtual ~king_war_helf_info();

  king_war_helf_info(const king_war_helf_info& from);

  inline king_war_helf_info& operator=(const king_war_helf_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_helf_info& default_instance();

  void Swap(king_war_helf_info* other);

  // implements Message ----------------------------------------------

  king_war_helf_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_helf_info& from);
  void MergeFrom(const king_war_helf_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string family_uid = 1;
  inline bool has_family_uid() const;
  inline void clear_family_uid();
  static const int kFamilyUidFieldNumber = 1;
  inline const ::std::string& family_uid() const;
  inline void set_family_uid(const ::std::string& value);
  inline void set_family_uid(const char* value);
  inline void set_family_uid(const char* value, size_t size);
  inline ::std::string* mutable_family_uid();
  inline ::std::string* release_family_uid();
  inline void set_allocated_family_uid(::std::string* family_uid);

  // optional string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 country = 3;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 3;
  inline ::google::protobuf::uint32 country() const;
  inline void set_country(::google::protobuf::uint32 value);

  // optional uint32 fight_time = 4;
  inline bool has_fight_time() const;
  inline void clear_fight_time();
  static const int kFightTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 fight_time() const;
  inline void set_fight_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_helf_info)
 private:
  inline void set_has_family_uid();
  inline void clear_has_family_uid();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_fight_time();
  inline void clear_has_fight_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* family_uid_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 country_;
  ::google::protobuf::uint32 fight_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_helf_info* default_instance_;
};
// -------------------------------------------------------------------

class king_war_long_info : public ::google::protobuf::Message {
 public:
  king_war_long_info();
  virtual ~king_war_long_info();

  king_war_long_info(const king_war_long_info& from);

  inline king_war_long_info& operator=(const king_war_long_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_long_info& default_instance();

  void Swap(king_war_long_info* other);

  // implements Message ----------------------------------------------

  king_war_long_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_long_info& from);
  void MergeFrom(const king_war_long_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string object_id = 1;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  inline const ::std::string& object_id() const;
  inline void set_object_id(const ::std::string& value);
  inline void set_object_id(const char* value);
  inline void set_object_id(const char* value, size_t size);
  inline ::std::string* mutable_object_id();
  inline ::std::string* release_object_id();
  inline void set_allocated_object_id(::std::string* object_id);

  // optional uint32 monster_tid = 2;
  inline bool has_monster_tid() const;
  inline void clear_monster_tid();
  static const int kMonsterTidFieldNumber = 2;
  inline ::google::protobuf::uint32 monster_tid() const;
  inline void set_monster_tid(::google::protobuf::uint32 value);

  // optional uint32 curr_x = 3;
  inline bool has_curr_x() const;
  inline void clear_curr_x();
  static const int kCurrXFieldNumber = 3;
  inline ::google::protobuf::uint32 curr_x() const;
  inline void set_curr_x(::google::protobuf::uint32 value);

  // optional uint32 curr_y = 4;
  inline bool has_curr_y() const;
  inline void clear_curr_y();
  static const int kCurrYFieldNumber = 4;
  inline ::google::protobuf::uint32 curr_y() const;
  inline void set_curr_y(::google::protobuf::uint32 value);

  // optional uint32 curr_hp = 5;
  inline bool has_curr_hp() const;
  inline void clear_curr_hp();
  static const int kCurrHpFieldNumber = 5;
  inline ::google::protobuf::uint32 curr_hp() const;
  inline void set_curr_hp(::google::protobuf::uint32 value);

  // optional uint32 max_hp = 6;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 6;
  inline ::google::protobuf::uint32 max_hp() const;
  inline void set_max_hp(::google::protobuf::uint32 value);

  // optional uint32 long_type = 7;
  inline bool has_long_type() const;
  inline void clear_long_type();
  static const int kLongTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 long_type() const;
  inline void set_long_type(::google::protobuf::uint32 value);

  // optional string occupy_family = 8;
  inline bool has_occupy_family() const;
  inline void clear_occupy_family();
  static const int kOccupyFamilyFieldNumber = 8;
  inline const ::std::string& occupy_family() const;
  inline void set_occupy_family(const ::std::string& value);
  inline void set_occupy_family(const char* value);
  inline void set_occupy_family(const char* value, size_t size);
  inline ::std::string* mutable_occupy_family();
  inline ::std::string* release_occupy_family();
  inline void set_allocated_occupy_family(::std::string* occupy_family);

  // optional string occupy_help = 9;
  inline bool has_occupy_help() const;
  inline void clear_occupy_help();
  static const int kOccupyHelpFieldNumber = 9;
  inline const ::std::string& occupy_help() const;
  inline void set_occupy_help(const ::std::string& value);
  inline void set_occupy_help(const char* value);
  inline void set_occupy_help(const char* value, size_t size);
  inline ::std::string* mutable_occupy_help();
  inline ::std::string* release_occupy_help();
  inline void set_allocated_occupy_help(::std::string* occupy_help);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_long_info)
 private:
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_monster_tid();
  inline void clear_has_monster_tid();
  inline void set_has_curr_x();
  inline void clear_has_curr_x();
  inline void set_has_curr_y();
  inline void clear_has_curr_y();
  inline void set_has_curr_hp();
  inline void clear_has_curr_hp();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_long_type();
  inline void clear_has_long_type();
  inline void set_has_occupy_family();
  inline void clear_has_occupy_family();
  inline void set_has_occupy_help();
  inline void clear_has_occupy_help();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* object_id_;
  ::google::protobuf::uint32 monster_tid_;
  ::google::protobuf::uint32 curr_x_;
  ::google::protobuf::uint32 curr_y_;
  ::google::protobuf::uint32 curr_hp_;
  ::google::protobuf::uint32 max_hp_;
  ::google::protobuf::uint32 long_type_;
  ::std::string* occupy_family_;
  ::std::string* occupy_help_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_long_info* default_instance_;
};
// -------------------------------------------------------------------

class king_war_role_pos : public ::google::protobuf::Message {
 public:
  king_war_role_pos();
  virtual ~king_war_role_pos();

  king_war_role_pos(const king_war_role_pos& from);

  inline king_war_role_pos& operator=(const king_war_role_pos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_role_pos& default_instance();

  void Swap(king_war_role_pos* other);

  // implements Message ----------------------------------------------

  king_war_role_pos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_role_pos& from);
  void MergeFrom(const king_war_role_pos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float pos_x = 1;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 1;
  inline float pos_x() const;
  inline void set_pos_x(float value);

  // optional float pos_y = 2;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 2;
  inline float pos_y() const;
  inline void set_pos_y(float value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_role_pos)
 private:
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float pos_x_;
  float pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_role_pos* default_instance_;
};
// -------------------------------------------------------------------

class king_war_side_roles : public ::google::protobuf::Message {
 public:
  king_war_side_roles();
  virtual ~king_war_side_roles();

  king_war_side_roles(const king_war_side_roles& from);

  inline king_war_side_roles& operator=(const king_war_side_roles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_side_roles& default_instance();

  void Swap(king_war_side_roles* other);

  // implements Message ----------------------------------------------

  king_war_side_roles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_side_roles& from);
  void MergeFrom(const king_war_side_roles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.king_war_role_pos roles = 1;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 1;
  inline const ::proto::common::king_war_role_pos& roles(int index) const;
  inline ::proto::common::king_war_role_pos* mutable_roles(int index);
  inline ::proto::common::king_war_role_pos* add_roles();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_role_pos >&
      roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_role_pos >*
      mutable_roles();

  // @@protoc_insertion_point(class_scope:proto.common.king_war_side_roles)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_role_pos > roles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_side_roles* default_instance_;
};
// -------------------------------------------------------------------

class king_war_rank_single : public ::google::protobuf::Message {
 public:
  king_war_rank_single();
  virtual ~king_war_rank_single();

  king_war_rank_single(const king_war_rank_single& from);

  inline king_war_rank_single& operator=(const king_war_rank_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_rank_single& default_instance();

  void Swap(king_war_rank_single* other);

  // implements Message ----------------------------------------------

  king_war_rank_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_rank_single& from);
  void MergeFrom(const king_war_rank_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_name = 1;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional string family_name = 2;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 2;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 kill_count = 3;
  inline bool has_kill_count() const;
  inline void clear_kill_count();
  static const int kKillCountFieldNumber = 3;
  inline ::google::protobuf::uint32 kill_count() const;
  inline void set_kill_count(::google::protobuf::uint32 value);

  // optional uint32 death_count = 4;
  inline bool has_death_count() const;
  inline void clear_death_count();
  static const int kDeathCountFieldNumber = 4;
  inline ::google::protobuf::uint32 death_count() const;
  inline void set_death_count(::google::protobuf::uint32 value);

  // optional uint32 continued_kill = 5;
  inline bool has_continued_kill() const;
  inline void clear_continued_kill();
  static const int kContinuedKillFieldNumber = 5;
  inline ::google::protobuf::uint32 continued_kill() const;
  inline void set_continued_kill(::google::protobuf::uint32 value);

  // optional uint32 exploits = 6;
  inline bool has_exploits() const;
  inline void clear_exploits();
  static const int kExploitsFieldNumber = 6;
  inline ::google::protobuf::uint32 exploits() const;
  inline void set_exploits(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.king_war_rank_single)
 private:
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_kill_count();
  inline void clear_has_kill_count();
  inline void set_has_death_count();
  inline void clear_has_death_count();
  inline void set_has_continued_kill();
  inline void clear_has_continued_kill();
  inline void set_has_exploits();
  inline void clear_has_exploits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 kill_count_;
  ::google::protobuf::uint32 death_count_;
  ::google::protobuf::uint32 continued_kill_;
  ::google::protobuf::uint32 exploits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_rank_single* default_instance_;
};
// -------------------------------------------------------------------

class king_war_rank_list : public ::google::protobuf::Message {
 public:
  king_war_rank_list();
  virtual ~king_war_rank_list();

  king_war_rank_list(const king_war_rank_list& from);

  inline king_war_rank_list& operator=(const king_war_rank_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const king_war_rank_list& default_instance();

  void Swap(king_war_rank_list* other);

  // implements Message ----------------------------------------------

  king_war_rank_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const king_war_rank_list& from);
  void MergeFrom(const king_war_rank_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.king_war_rank_single ranks = 1;
  inline int ranks_size() const;
  inline void clear_ranks();
  static const int kRanksFieldNumber = 1;
  inline const ::proto::common::king_war_rank_single& ranks(int index) const;
  inline ::proto::common::king_war_rank_single* mutable_ranks(int index);
  inline ::proto::common::king_war_rank_single* add_ranks();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_rank_single >&
      ranks() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_rank_single >*
      mutable_ranks();

  // @@protoc_insertion_point(class_scope:proto.common.king_war_rank_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_rank_single > ranks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static king_war_rank_list* default_instance_;
};
// -------------------------------------------------------------------

class equip_single : public ::google::protobuf::Message {
 public:
  equip_single();
  virtual ~equip_single();

  equip_single(const equip_single& from);

  inline equip_single& operator=(const equip_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_single& default_instance();

  void Swap(equip_single* other);

  // implements Message ----------------------------------------------

  equip_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_single& from);
  void MergeFrom(const equip_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // repeated .proto.common.equip_attr attr = 2;
  inline int attr_size() const;
  inline void clear_attr();
  static const int kAttrFieldNumber = 2;
  inline const ::proto::common::equip_attr& attr(int index) const;
  inline ::proto::common::equip_attr* mutable_attr(int index);
  inline ::proto::common::equip_attr* add_attr();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::equip_attr >&
      attr() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::equip_attr >*
      mutable_attr();

  // repeated uint32 exattr = 3;
  inline int exattr_size() const;
  inline void clear_exattr();
  static const int kExattrFieldNumber = 3;
  inline ::google::protobuf::uint32 exattr(int index) const;
  inline void set_exattr(int index, ::google::protobuf::uint32 value);
  inline void add_exattr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      exattr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_exattr();

  // repeated uint32 remake_exattr = 4;
  inline int remake_exattr_size() const;
  inline void clear_remake_exattr();
  static const int kRemakeExattrFieldNumber = 4;
  inline ::google::protobuf::uint32 remake_exattr(int index) const;
  inline void set_remake_exattr(int index, ::google::protobuf::uint32 value);
  inline void add_remake_exattr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      remake_exattr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_remake_exattr();

  // optional uint32 remake_exattr_bonus = 5;
  inline bool has_remake_exattr_bonus() const;
  inline void clear_remake_exattr_bonus();
  static const int kRemakeExattrBonusFieldNumber = 5;
  inline ::google::protobuf::uint32 remake_exattr_bonus() const;
  inline void set_remake_exattr_bonus(::google::protobuf::uint32 value);

  // optional uint32 score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional uint32 name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline ::google::protobuf::uint32 name() const;
  inline void set_name(::google::protobuf::uint32 value);

  // optional uint32 special = 8;
  inline bool has_special() const;
  inline void clear_special();
  static const int kSpecialFieldNumber = 8;
  inline ::google::protobuf::uint32 special() const;
  inline void set_special(::google::protobuf::uint32 value);

  // optional uint32 strengthen_level = 9;
  inline bool has_strengthen_level() const;
  inline void clear_strengthen_level();
  static const int kStrengthenLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 strengthen_level() const;
  inline void set_strengthen_level(::google::protobuf::uint32 value);

  // optional uint32 strmaster_level = 10;
  inline bool has_strmaster_level() const;
  inline void clear_strmaster_level();
  static const int kStrmasterLevelFieldNumber = 10;
  inline ::google::protobuf::uint32 strmaster_level() const;
  inline void set_strmaster_level(::google::protobuf::uint32 value);

  // optional uint32 remake_material = 11;
  inline bool has_remake_material() const;
  inline void clear_remake_material();
  static const int kRemakeMaterialFieldNumber = 11;
  inline ::google::protobuf::uint32 remake_material() const;
  inline void set_remake_material(::google::protobuf::uint32 value);

  // optional uint32 lock_material = 12;
  inline bool has_lock_material() const;
  inline void clear_lock_material();
  static const int kLockMaterialFieldNumber = 12;
  inline ::google::protobuf::uint32 lock_material() const;
  inline void set_lock_material(::google::protobuf::uint32 value);

  // optional uint32 strengthen_material = 13;
  inline bool has_strengthen_material() const;
  inline void clear_strengthen_material();
  static const int kStrengthenMaterialFieldNumber = 13;
  inline ::google::protobuf::uint32 strengthen_material() const;
  inline void set_strengthen_material(::google::protobuf::uint32 value);

  // optional uint32 strengthen_material_ex = 14;
  inline bool has_strengthen_material_ex() const;
  inline void clear_strengthen_material_ex();
  static const int kStrengthenMaterialExFieldNumber = 14;
  inline ::google::protobuf::uint32 strengthen_material_ex() const;
  inline void set_strengthen_material_ex(::google::protobuf::uint32 value);

  // optional uint32 strengthen_money = 15;
  inline bool has_strengthen_money() const;
  inline void clear_strengthen_money();
  static const int kStrengthenMoneyFieldNumber = 15;
  inline ::google::protobuf::uint32 strengthen_money() const;
  inline void set_strengthen_money(::google::protobuf::uint32 value);

  // optional uint32 remake_score = 16;
  inline bool has_remake_score() const;
  inline void clear_remake_score();
  static const int kRemakeScoreFieldNumber = 16;
  inline ::google::protobuf::uint32 remake_score() const;
  inline void set_remake_score(::google::protobuf::uint32 value);

  // optional uint32 remain_remake_count = 17;
  inline bool has_remain_remake_count() const;
  inline void clear_remain_remake_count();
  static const int kRemainRemakeCountFieldNumber = 17;
  inline ::google::protobuf::uint32 remain_remake_count() const;
  inline void set_remain_remake_count(::google::protobuf::uint32 value);

  // optional uint32 add_remake_count = 18;
  inline bool has_add_remake_count() const;
  inline void clear_add_remake_count();
  static const int kAddRemakeCountFieldNumber = 18;
  inline ::google::protobuf::uint32 add_remake_count() const;
  inline void set_add_remake_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.equip_single)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_remake_exattr_bonus();
  inline void clear_has_remake_exattr_bonus();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_special();
  inline void clear_has_special();
  inline void set_has_strengthen_level();
  inline void clear_has_strengthen_level();
  inline void set_has_strmaster_level();
  inline void clear_has_strmaster_level();
  inline void set_has_remake_material();
  inline void clear_has_remake_material();
  inline void set_has_lock_material();
  inline void clear_has_lock_material();
  inline void set_has_strengthen_material();
  inline void clear_has_strengthen_material();
  inline void set_has_strengthen_material_ex();
  inline void clear_has_strengthen_material_ex();
  inline void set_has_strengthen_money();
  inline void clear_has_strengthen_money();
  inline void set_has_remake_score();
  inline void clear_has_remake_score();
  inline void set_has_remain_remake_count();
  inline void clear_has_remain_remake_count();
  inline void set_has_add_remake_count();
  inline void clear_has_add_remake_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hero_uid_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::equip_attr > attr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > exattr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remake_exattr_;
  ::google::protobuf::uint32 remake_exattr_bonus_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 name_;
  ::google::protobuf::uint32 special_;
  ::google::protobuf::uint32 strengthen_level_;
  ::google::protobuf::uint32 strmaster_level_;
  ::google::protobuf::uint32 remake_material_;
  ::google::protobuf::uint32 lock_material_;
  ::google::protobuf::uint32 strengthen_material_;
  ::google::protobuf::uint32 strengthen_material_ex_;
  ::google::protobuf::uint32 strengthen_money_;
  ::google::protobuf::uint32 remake_score_;
  ::google::protobuf::uint32 remain_remake_count_;
  ::google::protobuf::uint32 add_remake_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static equip_single* default_instance_;
};
// -------------------------------------------------------------------

class equip_attr : public ::google::protobuf::Message {
 public:
  equip_attr();
  virtual ~equip_attr();

  equip_attr(const equip_attr& from);

  inline equip_attr& operator=(const equip_attr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_attr& default_instance();

  void Swap(equip_attr* other);

  // implements Message ----------------------------------------------

  equip_attr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_attr& from);
  void MergeFrom(const equip_attr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.equip_attr)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static equip_attr* default_instance_;
};
// -------------------------------------------------------------------

class equip_smelt_box : public ::google::protobuf::Message {
 public:
  equip_smelt_box();
  virtual ~equip_smelt_box();

  equip_smelt_box(const equip_smelt_box& from);

  inline equip_smelt_box& operator=(const equip_smelt_box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_smelt_box& default_instance();

  void Swap(equip_smelt_box* other);

  // implements Message ----------------------------------------------

  equip_smelt_box* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_smelt_box& from);
  void MergeFrom(const equip_smelt_box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 equip_smelt_value = 1;
  inline bool has_equip_smelt_value() const;
  inline void clear_equip_smelt_value();
  static const int kEquipSmeltValueFieldNumber = 1;
  inline ::google::protobuf::uint32 equip_smelt_value() const;
  inline void set_equip_smelt_value(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.equip_smelt_box)
 private:
  inline void set_has_equip_smelt_value();
  inline void clear_has_equip_smelt_value();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 equip_smelt_value_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static equip_smelt_box* default_instance_;
};
// -------------------------------------------------------------------

class world_cup_player : public ::google::protobuf::Message {
 public:
  world_cup_player();
  virtual ~world_cup_player();

  world_cup_player(const world_cup_player& from);

  inline world_cup_player& operator=(const world_cup_player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const world_cup_player& default_instance();

  void Swap(world_cup_player* other);

  // implements Message ----------------------------------------------

  world_cup_player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const world_cup_player& from);
  void MergeFrom(const world_cup_player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string family_id = 3;
  inline bool has_family_id() const;
  inline void clear_family_id();
  static const int kFamilyIdFieldNumber = 3;
  inline const ::std::string& family_id() const;
  inline void set_family_id(const ::std::string& value);
  inline void set_family_id(const char* value);
  inline void set_family_id(const char* value, size_t size);
  inline ::std::string* mutable_family_id();
  inline ::std::string* release_family_id();
  inline void set_allocated_family_id(::std::string* family_id);

  // optional string family_name = 4;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 4;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // @@protoc_insertion_point(class_scope:proto.common.world_cup_player)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_family_id();
  inline void clear_has_family_id();
  inline void set_has_family_name();
  inline void clear_has_family_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* family_id_;
  ::std::string* family_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static world_cup_player* default_instance_;
};
// -------------------------------------------------------------------

class world_cup_battle : public ::google::protobuf::Message {
 public:
  world_cup_battle();
  virtual ~world_cup_battle();

  world_cup_battle(const world_cup_battle& from);

  inline world_cup_battle& operator=(const world_cup_battle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const world_cup_battle& default_instance();

  void Swap(world_cup_battle* other);

  // implements Message ----------------------------------------------

  world_cup_battle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const world_cup_battle& from);
  void MergeFrom(const world_cup_battle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 round = 2;
  inline bool has_round() const;
  inline void clear_round();
  static const int kRoundFieldNumber = 2;
  inline ::google::protobuf::uint32 round() const;
  inline void set_round(::google::protobuf::uint32 value);

  // optional uint32 battle_id = 3;
  inline bool has_battle_id() const;
  inline void clear_battle_id();
  static const int kBattleIdFieldNumber = 3;
  inline ::google::protobuf::uint32 battle_id() const;
  inline void set_battle_id(::google::protobuf::uint32 value);

  // optional .proto.common.world_cup_player player_a = 4;
  inline bool has_player_a() const;
  inline void clear_player_a();
  static const int kPlayerAFieldNumber = 4;
  inline const ::proto::common::world_cup_player& player_a() const;
  inline ::proto::common::world_cup_player* mutable_player_a();
  inline ::proto::common::world_cup_player* release_player_a();
  inline void set_allocated_player_a(::proto::common::world_cup_player* player_a);

  // optional uint32 score_a = 5;
  inline bool has_score_a() const;
  inline void clear_score_a();
  static const int kScoreAFieldNumber = 5;
  inline ::google::protobuf::uint32 score_a() const;
  inline void set_score_a(::google::protobuf::uint32 value);

  // optional .proto.common.world_cup_player player_b = 6;
  inline bool has_player_b() const;
  inline void clear_player_b();
  static const int kPlayerBFieldNumber = 6;
  inline const ::proto::common::world_cup_player& player_b() const;
  inline ::proto::common::world_cup_player* mutable_player_b();
  inline ::proto::common::world_cup_player* release_player_b();
  inline void set_allocated_player_b(::proto::common::world_cup_player* player_b);

  // optional uint32 score_b = 7;
  inline bool has_score_b() const;
  inline void clear_score_b();
  static const int kScoreBFieldNumber = 7;
  inline ::google::protobuf::uint32 score_b() const;
  inline void set_score_b(::google::protobuf::uint32 value);

  // optional string winner = 8;
  inline bool has_winner() const;
  inline void clear_winner();
  static const int kWinnerFieldNumber = 8;
  inline const ::std::string& winner() const;
  inline void set_winner(const ::std::string& value);
  inline void set_winner(const char* value);
  inline void set_winner(const char* value, size_t size);
  inline ::std::string* mutable_winner();
  inline ::std::string* release_winner();
  inline void set_allocated_winner(::std::string* winner);

  // optional uint32 state = 9;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 9;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional .proto.common.world_cup_bet self_bet = 12;
  inline bool has_self_bet() const;
  inline void clear_self_bet();
  static const int kSelfBetFieldNumber = 12;
  inline const ::proto::common::world_cup_bet& self_bet() const;
  inline ::proto::common::world_cup_bet* mutable_self_bet();
  inline ::proto::common::world_cup_bet* release_self_bet();
  inline void set_allocated_self_bet(::proto::common::world_cup_bet* self_bet);

  // @@protoc_insertion_point(class_scope:proto.common.world_cup_battle)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_round();
  inline void clear_has_round();
  inline void set_has_battle_id();
  inline void clear_has_battle_id();
  inline void set_has_player_a();
  inline void clear_has_player_a();
  inline void set_has_score_a();
  inline void clear_has_score_a();
  inline void set_has_player_b();
  inline void clear_has_player_b();
  inline void set_has_score_b();
  inline void clear_has_score_b();
  inline void set_has_winner();
  inline void clear_has_winner();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_self_bet();
  inline void clear_has_self_bet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 round_;
  ::google::protobuf::uint32 battle_id_;
  ::proto::common::world_cup_player* player_a_;
  ::proto::common::world_cup_player* player_b_;
  ::google::protobuf::uint32 score_a_;
  ::google::protobuf::uint32 score_b_;
  ::std::string* winner_;
  ::proto::common::world_cup_bet* self_bet_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static world_cup_battle* default_instance_;
};
// -------------------------------------------------------------------

class world_cup_data : public ::google::protobuf::Message {
 public:
  world_cup_data();
  virtual ~world_cup_data();

  world_cup_data(const world_cup_data& from);

  inline world_cup_data& operator=(const world_cup_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const world_cup_data& default_instance();

  void Swap(world_cup_data* other);

  // implements Message ----------------------------------------------

  world_cup_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const world_cup_data& from);
  void MergeFrom(const world_cup_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 season = 1;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 1;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // repeated .proto.common.world_cup_battle battle_list = 2;
  inline int battle_list_size() const;
  inline void clear_battle_list();
  static const int kBattleListFieldNumber = 2;
  inline const ::proto::common::world_cup_battle& battle_list(int index) const;
  inline ::proto::common::world_cup_battle* mutable_battle_list(int index);
  inline ::proto::common::world_cup_battle* add_battle_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::world_cup_battle >&
      battle_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::world_cup_battle >*
      mutable_battle_list();

  // @@protoc_insertion_point(class_scope:proto.common.world_cup_data)
 private:
  inline void set_has_season();
  inline void clear_has_season();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::world_cup_battle > battle_list_;
  ::google::protobuf::uint32 season_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static world_cup_data* default_instance_;
};
// -------------------------------------------------------------------

class world_cup_bet : public ::google::protobuf::Message {
 public:
  world_cup_bet();
  virtual ~world_cup_bet();

  world_cup_bet(const world_cup_bet& from);

  inline world_cup_bet& operator=(const world_cup_bet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const world_cup_bet& default_instance();

  void Swap(world_cup_bet* other);

  // implements Message ----------------------------------------------

  world_cup_bet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const world_cup_bet& from);
  void MergeFrom(const world_cup_bet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string battle_uid = 2;
  inline bool has_battle_uid() const;
  inline void clear_battle_uid();
  static const int kBattleUidFieldNumber = 2;
  inline const ::std::string& battle_uid() const;
  inline void set_battle_uid(const ::std::string& value);
  inline void set_battle_uid(const char* value);
  inline void set_battle_uid(const char* value, size_t size);
  inline ::std::string* mutable_battle_uid();
  inline ::std::string* release_battle_uid();
  inline void set_allocated_battle_uid(::std::string* battle_uid);

  // optional string player_uid = 3;
  inline bool has_player_uid() const;
  inline void clear_player_uid();
  static const int kPlayerUidFieldNumber = 3;
  inline const ::std::string& player_uid() const;
  inline void set_player_uid(const ::std::string& value);
  inline void set_player_uid(const char* value);
  inline void set_player_uid(const char* value, size_t size);
  inline ::std::string* mutable_player_uid();
  inline ::std::string* release_player_uid();
  inline void set_allocated_player_uid(::std::string* player_uid);

  // optional string winner = 4;
  inline bool has_winner() const;
  inline void clear_winner();
  static const int kWinnerFieldNumber = 4;
  inline const ::std::string& winner() const;
  inline void set_winner(const ::std::string& value);
  inline void set_winner(const char* value);
  inline void set_winner(const char* value, size_t size);
  inline ::std::string* mutable_winner();
  inline ::std::string* release_winner();
  inline void set_allocated_winner(::std::string* winner);

  // optional uint32 odds = 5;
  inline bool has_odds() const;
  inline void clear_odds();
  static const int kOddsFieldNumber = 5;
  inline ::google::protobuf::uint32 odds() const;
  inline void set_odds(::google::protobuf::uint32 value);

  // optional uint32 bet = 6;
  inline bool has_bet() const;
  inline void clear_bet();
  static const int kBetFieldNumber = 6;
  inline ::google::protobuf::uint32 bet() const;
  inline void set_bet(::google::protobuf::uint32 value);

  // optional uint32 result = 7;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 7;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // optional uint32 state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.world_cup_bet)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_battle_uid();
  inline void clear_has_battle_uid();
  inline void set_has_player_uid();
  inline void clear_has_player_uid();
  inline void set_has_winner();
  inline void clear_has_winner();
  inline void set_has_odds();
  inline void clear_has_odds();
  inline void set_has_bet();
  inline void clear_has_bet();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* battle_uid_;
  ::std::string* player_uid_;
  ::std::string* winner_;
  ::google::protobuf::uint32 odds_;
  ::google::protobuf::uint32 bet_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static world_cup_bet* default_instance_;
};
// -------------------------------------------------------------------

class world_cup_odds : public ::google::protobuf::Message {
 public:
  world_cup_odds();
  virtual ~world_cup_odds();

  world_cup_odds(const world_cup_odds& from);

  inline world_cup_odds& operator=(const world_cup_odds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const world_cup_odds& default_instance();

  void Swap(world_cup_odds* other);

  // implements Message ----------------------------------------------

  world_cup_odds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const world_cup_odds& from);
  void MergeFrom(const world_cup_odds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 odds_a = 1;
  inline bool has_odds_a() const;
  inline void clear_odds_a();
  static const int kOddsAFieldNumber = 1;
  inline ::google::protobuf::uint32 odds_a() const;
  inline void set_odds_a(::google::protobuf::uint32 value);

  // optional uint32 odds_b = 2;
  inline bool has_odds_b() const;
  inline void clear_odds_b();
  static const int kOddsBFieldNumber = 2;
  inline ::google::protobuf::uint32 odds_b() const;
  inline void set_odds_b(::google::protobuf::uint32 value);

  // optional uint32 bet_a = 3;
  inline bool has_bet_a() const;
  inline void clear_bet_a();
  static const int kBetAFieldNumber = 3;
  inline ::google::protobuf::uint32 bet_a() const;
  inline void set_bet_a(::google::protobuf::uint32 value);

  // optional uint32 bet_b = 4;
  inline bool has_bet_b() const;
  inline void clear_bet_b();
  static const int kBetBFieldNumber = 4;
  inline ::google::protobuf::uint32 bet_b() const;
  inline void set_bet_b(::google::protobuf::uint32 value);

  // optional uint32 vote_a = 5;
  inline bool has_vote_a() const;
  inline void clear_vote_a();
  static const int kVoteAFieldNumber = 5;
  inline ::google::protobuf::uint32 vote_a() const;
  inline void set_vote_a(::google::protobuf::uint32 value);

  // optional uint32 vote_b = 6;
  inline bool has_vote_b() const;
  inline void clear_vote_b();
  static const int kVoteBFieldNumber = 6;
  inline ::google::protobuf::uint32 vote_b() const;
  inline void set_vote_b(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.world_cup_odds)
 private:
  inline void set_has_odds_a();
  inline void clear_has_odds_a();
  inline void set_has_odds_b();
  inline void clear_has_odds_b();
  inline void set_has_bet_a();
  inline void clear_has_bet_a();
  inline void set_has_bet_b();
  inline void clear_has_bet_b();
  inline void set_has_vote_a();
  inline void clear_has_vote_a();
  inline void set_has_vote_b();
  inline void clear_has_vote_b();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 odds_a_;
  ::google::protobuf::uint32 odds_b_;
  ::google::protobuf::uint32 bet_a_;
  ::google::protobuf::uint32 bet_b_;
  ::google::protobuf::uint32 vote_a_;
  ::google::protobuf::uint32 vote_b_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static world_cup_odds* default_instance_;
};
// -------------------------------------------------------------------

class achieve_finish_info_single : public ::google::protobuf::Message {
 public:
  achieve_finish_info_single();
  virtual ~achieve_finish_info_single();

  achieve_finish_info_single(const achieve_finish_info_single& from);

  inline achieve_finish_info_single& operator=(const achieve_finish_info_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_finish_info_single& default_instance();

  void Swap(achieve_finish_info_single* other);

  // implements Message ----------------------------------------------

  achieve_finish_info_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_finish_info_single& from);
  void MergeFrom(const achieve_finish_info_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.achieve_finish_info_single)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_finish_info_single* default_instance_;
};
// -------------------------------------------------------------------

class achieve_finish_info : public ::google::protobuf::Message {
 public:
  achieve_finish_info();
  virtual ~achieve_finish_info();

  achieve_finish_info(const achieve_finish_info& from);

  inline achieve_finish_info& operator=(const achieve_finish_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_finish_info& default_instance();

  void Swap(achieve_finish_info* other);

  // implements Message ----------------------------------------------

  achieve_finish_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_finish_info& from);
  void MergeFrom(const achieve_finish_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.achieve_finish_info_single achieve_finish_info_list = 1;
  inline int achieve_finish_info_list_size() const;
  inline void clear_achieve_finish_info_list();
  static const int kAchieveFinishInfoListFieldNumber = 1;
  inline const ::proto::common::achieve_finish_info_single& achieve_finish_info_list(int index) const;
  inline ::proto::common::achieve_finish_info_single* mutable_achieve_finish_info_list(int index);
  inline ::proto::common::achieve_finish_info_single* add_achieve_finish_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_finish_info_single >&
      achieve_finish_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_finish_info_single >*
      mutable_achieve_finish_info_list();

  // @@protoc_insertion_point(class_scope:proto.common.achieve_finish_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_finish_info_single > achieve_finish_info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_finish_info* default_instance_;
};
// -------------------------------------------------------------------

class achieve_record_single : public ::google::protobuf::Message {
 public:
  achieve_record_single();
  virtual ~achieve_record_single();

  achieve_record_single(const achieve_record_single& from);

  inline achieve_record_single& operator=(const achieve_record_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_record_single& default_instance();

  void Swap(achieve_record_single* other);

  // implements Message ----------------------------------------------

  achieve_record_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_record_single& from);
  void MergeFrom(const achieve_record_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional string achieve_person_record = 2;
  inline bool has_achieve_person_record() const;
  inline void clear_achieve_person_record();
  static const int kAchievePersonRecordFieldNumber = 2;
  inline const ::std::string& achieve_person_record() const;
  inline void set_achieve_person_record(const ::std::string& value);
  inline void set_achieve_person_record(const char* value);
  inline void set_achieve_person_record(const char* value, size_t size);
  inline ::std::string* mutable_achieve_person_record();
  inline ::std::string* release_achieve_person_record();
  inline void set_allocated_achieve_person_record(::std::string* achieve_person_record);

  // @@protoc_insertion_point(class_scope:proto.common.achieve_record_single)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_achieve_person_record();
  inline void clear_has_achieve_person_record();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* achieve_person_record_;
  ::google::protobuf::uint32 tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_record_single* default_instance_;
};
// -------------------------------------------------------------------

class achieve_record : public ::google::protobuf::Message {
 public:
  achieve_record();
  virtual ~achieve_record();

  achieve_record(const achieve_record& from);

  inline achieve_record& operator=(const achieve_record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_record& default_instance();

  void Swap(achieve_record* other);

  // implements Message ----------------------------------------------

  achieve_record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_record& from);
  void MergeFrom(const achieve_record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.achieve_record_single achieve_record_list = 1;
  inline int achieve_record_list_size() const;
  inline void clear_achieve_record_list();
  static const int kAchieveRecordListFieldNumber = 1;
  inline const ::proto::common::achieve_record_single& achieve_record_list(int index) const;
  inline ::proto::common::achieve_record_single* mutable_achieve_record_list(int index);
  inline ::proto::common::achieve_record_single* add_achieve_record_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_record_single >&
      achieve_record_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_record_single >*
      mutable_achieve_record_list();

  // @@protoc_insertion_point(class_scope:proto.common.achieve_record)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_record_single > achieve_record_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_record* default_instance_;
};
// -------------------------------------------------------------------

class achieve_data_single : public ::google::protobuf::Message {
 public:
  achieve_data_single();
  virtual ~achieve_data_single();

  achieve_data_single(const achieve_data_single& from);

  inline achieve_data_single& operator=(const achieve_data_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_data_single& default_instance();

  void Swap(achieve_data_single* other);

  // implements Message ----------------------------------------------

  achieve_data_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_data_single& from);
  void MergeFrom(const achieve_data_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional string finish_info_list = 5;
  inline bool has_finish_info_list() const;
  inline void clear_finish_info_list();
  static const int kFinishInfoListFieldNumber = 5;
  inline const ::std::string& finish_info_list() const;
  inline void set_finish_info_list(const ::std::string& value);
  inline void set_finish_info_list(const char* value);
  inline void set_finish_info_list(const char* value, size_t size);
  inline ::std::string* mutable_finish_info_list();
  inline ::std::string* release_finish_info_list();
  inline void set_allocated_finish_info_list(::std::string* finish_info_list);

  // optional .proto.common.achieve_finish_info finish_list = 6;
  inline bool has_finish_list() const;
  inline void clear_finish_list();
  static const int kFinishListFieldNumber = 6;
  inline const ::proto::common::achieve_finish_info& finish_list() const;
  inline ::proto::common::achieve_finish_info* mutable_finish_list();
  inline ::proto::common::achieve_finish_info* release_finish_list();
  inline void set_allocated_finish_list(::proto::common::achieve_finish_info* finish_list);

  // @@protoc_insertion_point(class_scope:proto.common.achieve_data_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_finish_info_list();
  inline void clear_has_finish_info_list();
  inline void set_has_finish_list();
  inline void clear_has_finish_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 level_;
  ::std::string* finish_info_list_;
  ::proto::common::achieve_finish_info* finish_list_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_data_single* default_instance_;
};
// -------------------------------------------------------------------

class achieve_data : public ::google::protobuf::Message {
 public:
  achieve_data();
  virtual ~achieve_data();

  achieve_data(const achieve_data& from);

  inline achieve_data& operator=(const achieve_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const achieve_data& default_instance();

  void Swap(achieve_data* other);

  // implements Message ----------------------------------------------

  achieve_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const achieve_data& from);
  void MergeFrom(const achieve_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.achieve_data_single achieve_data_list = 1;
  inline int achieve_data_list_size() const;
  inline void clear_achieve_data_list();
  static const int kAchieveDataListFieldNumber = 1;
  inline const ::proto::common::achieve_data_single& achieve_data_list(int index) const;
  inline ::proto::common::achieve_data_single* mutable_achieve_data_list(int index);
  inline ::proto::common::achieve_data_single* add_achieve_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_data_single >&
      achieve_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_data_single >*
      mutable_achieve_data_list();

  // @@protoc_insertion_point(class_scope:proto.common.achieve_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_data_single > achieve_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static achieve_data* default_instance_;
};
// -------------------------------------------------------------------

class tower_trigger : public ::google::protobuf::Message {
 public:
  tower_trigger();
  virtual ~tower_trigger();

  tower_trigger(const tower_trigger& from);

  inline tower_trigger& operator=(const tower_trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tower_trigger& default_instance();

  void Swap(tower_trigger* other);

  // implements Message ----------------------------------------------

  tower_trigger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tower_trigger& from);
  void MergeFrom(const tower_trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional string finder_name = 3;
  inline bool has_finder_name() const;
  inline void clear_finder_name();
  static const int kFinderNameFieldNumber = 3;
  inline const ::std::string& finder_name() const;
  inline void set_finder_name(const ::std::string& value);
  inline void set_finder_name(const char* value);
  inline void set_finder_name(const char* value, size_t size);
  inline ::std::string* mutable_finder_name();
  inline ::std::string* release_finder_name();
  inline void set_allocated_finder_name(::std::string* finder_name);

  // optional uint32 expired_time = 4;
  inline bool has_expired_time() const;
  inline void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 expired_time() const;
  inline void set_expired_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.tower_trigger)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_finder_name();
  inline void clear_has_finder_name();
  inline void set_has_expired_time();
  inline void clear_has_expired_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* finder_name_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 expired_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static tower_trigger* default_instance_;
};
// -------------------------------------------------------------------

class tower_trigger_data : public ::google::protobuf::Message {
 public:
  tower_trigger_data();
  virtual ~tower_trigger_data();

  tower_trigger_data(const tower_trigger_data& from);

  inline tower_trigger_data& operator=(const tower_trigger_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tower_trigger_data& default_instance();

  void Swap(tower_trigger_data* other);

  // implements Message ----------------------------------------------

  tower_trigger_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tower_trigger_data& from);
  void MergeFrom(const tower_trigger_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.tower_trigger self_trigger = 1;
  inline int self_trigger_size() const;
  inline void clear_self_trigger();
  static const int kSelfTriggerFieldNumber = 1;
  inline const ::proto::common::tower_trigger& self_trigger(int index) const;
  inline ::proto::common::tower_trigger* mutable_self_trigger(int index);
  inline ::proto::common::tower_trigger* add_self_trigger();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >&
      self_trigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >*
      mutable_self_trigger();

  // repeated .proto.common.tower_trigger other_trigger = 2;
  inline int other_trigger_size() const;
  inline void clear_other_trigger();
  static const int kOtherTriggerFieldNumber = 2;
  inline const ::proto::common::tower_trigger& other_trigger(int index) const;
  inline ::proto::common::tower_trigger* mutable_other_trigger(int index);
  inline ::proto::common::tower_trigger* add_other_trigger();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >&
      other_trigger() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >*
      mutable_other_trigger();

  // @@protoc_insertion_point(class_scope:proto.common.tower_trigger_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger > self_trigger_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger > other_trigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static tower_trigger_data* default_instance_;
};
// -------------------------------------------------------------------

class tower_data : public ::google::protobuf::Message {
 public:
  tower_data();
  virtual ~tower_data();

  tower_data(const tower_data& from);

  inline tower_data& operator=(const tower_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tower_data& default_instance();

  void Swap(tower_data* other);

  // implements Message ----------------------------------------------

  tower_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tower_data& from);
  void MergeFrom(const tower_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 record_tower = 1;
  inline bool has_record_tower() const;
  inline void clear_record_tower();
  static const int kRecordTowerFieldNumber = 1;
  inline ::google::protobuf::uint32 record_tower() const;
  inline void set_record_tower(::google::protobuf::uint32 value);

  // optional uint32 current_tower = 2;
  inline bool has_current_tower() const;
  inline void clear_current_tower();
  static const int kCurrentTowerFieldNumber = 2;
  inline ::google::protobuf::uint32 current_tower() const;
  inline void set_current_tower(::google::protobuf::uint32 value);

  // optional uint32 reset_count = 3;
  inline bool has_reset_count() const;
  inline void clear_reset_count();
  static const int kResetCountFieldNumber = 3;
  inline ::google::protobuf::uint32 reset_count() const;
  inline void set_reset_count(::google::protobuf::uint32 value);

  // optional uint32 max_reset_count = 4;
  inline bool has_max_reset_count() const;
  inline void clear_max_reset_count();
  static const int kMaxResetCountFieldNumber = 4;
  inline ::google::protobuf::uint32 max_reset_count() const;
  inline void set_max_reset_count(::google::protobuf::uint32 value);

  // optional uint32 auto_fight_time = 5;
  inline bool has_auto_fight_time() const;
  inline void clear_auto_fight_time();
  static const int kAutoFightTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 auto_fight_time() const;
  inline void set_auto_fight_time(::google::protobuf::uint32 value);

  // optional uint32 current_achieve = 6;
  inline bool has_current_achieve() const;
  inline void clear_current_achieve();
  static const int kCurrentAchieveFieldNumber = 6;
  inline ::google::protobuf::uint32 current_achieve() const;
  inline void set_current_achieve(::google::protobuf::uint32 value);

  // optional uint32 first_day = 7;
  inline bool has_first_day() const;
  inline void clear_first_day();
  static const int kFirstDayFieldNumber = 7;
  inline ::google::protobuf::uint32 first_day() const;
  inline void set_first_day(::google::protobuf::uint32 value);

  // optional .proto.common.tower_trigger_data tower_trigger = 8;
  inline bool has_tower_trigger() const;
  inline void clear_tower_trigger();
  static const int kTowerTriggerFieldNumber = 8;
  inline const ::proto::common::tower_trigger_data& tower_trigger() const;
  inline ::proto::common::tower_trigger_data* mutable_tower_trigger();
  inline ::proto::common::tower_trigger_data* release_tower_trigger();
  inline void set_allocated_tower_trigger(::proto::common::tower_trigger_data* tower_trigger);

  // optional uint32 trigger_count = 9;
  inline bool has_trigger_count() const;
  inline void clear_trigger_count();
  static const int kTriggerCountFieldNumber = 9;
  inline ::google::protobuf::uint32 trigger_count() const;
  inline void set_trigger_count(::google::protobuf::uint32 value);

  // optional uint32 trigger_fight_count = 10;
  inline bool has_trigger_fight_count() const;
  inline void clear_trigger_fight_count();
  static const int kTriggerFightCountFieldNumber = 10;
  inline ::google::protobuf::uint32 trigger_fight_count() const;
  inline void set_trigger_fight_count(::google::protobuf::uint32 value);

  // optional uint32 send_mail_flag = 11;
  inline bool has_send_mail_flag() const;
  inline void clear_send_mail_flag();
  static const int kSendMailFlagFieldNumber = 11;
  inline ::google::protobuf::uint32 send_mail_flag() const;
  inline void set_send_mail_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.tower_data)
 private:
  inline void set_has_record_tower();
  inline void clear_has_record_tower();
  inline void set_has_current_tower();
  inline void clear_has_current_tower();
  inline void set_has_reset_count();
  inline void clear_has_reset_count();
  inline void set_has_max_reset_count();
  inline void clear_has_max_reset_count();
  inline void set_has_auto_fight_time();
  inline void clear_has_auto_fight_time();
  inline void set_has_current_achieve();
  inline void clear_has_current_achieve();
  inline void set_has_first_day();
  inline void clear_has_first_day();
  inline void set_has_tower_trigger();
  inline void clear_has_tower_trigger();
  inline void set_has_trigger_count();
  inline void clear_has_trigger_count();
  inline void set_has_trigger_fight_count();
  inline void clear_has_trigger_fight_count();
  inline void set_has_send_mail_flag();
  inline void clear_has_send_mail_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 record_tower_;
  ::google::protobuf::uint32 current_tower_;
  ::google::protobuf::uint32 reset_count_;
  ::google::protobuf::uint32 max_reset_count_;
  ::google::protobuf::uint32 auto_fight_time_;
  ::google::protobuf::uint32 current_achieve_;
  ::proto::common::tower_trigger_data* tower_trigger_;
  ::google::protobuf::uint32 first_day_;
  ::google::protobuf::uint32 trigger_count_;
  ::google::protobuf::uint32 trigger_fight_count_;
  ::google::protobuf::uint32 send_mail_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static tower_data* default_instance_;
};
// -------------------------------------------------------------------

class red_point_single : public ::google::protobuf::Message {
 public:
  red_point_single();
  virtual ~red_point_single();

  red_point_single(const red_point_single& from);

  inline red_point_single& operator=(const red_point_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const red_point_single& default_instance();

  void Swap(red_point_single* other);

  // implements Message ----------------------------------------------

  red_point_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const red_point_single& from);
  void MergeFrom(const red_point_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.RED_POINT_TYPE red_type = 1;
  inline bool has_red_type() const;
  inline void clear_red_type();
  static const int kRedTypeFieldNumber = 1;
  inline ::proto::common::RED_POINT_TYPE red_type() const;
  inline void set_red_type(::proto::common::RED_POINT_TYPE value);

  // optional uint32 red_point_state = 2;
  inline bool has_red_point_state() const;
  inline void clear_red_point_state();
  static const int kRedPointStateFieldNumber = 2;
  inline ::google::protobuf::uint32 red_point_state() const;
  inline void set_red_point_state(::google::protobuf::uint32 value);

  // optional string red_point_send_list = 3;
  inline bool has_red_point_send_list() const;
  inline void clear_red_point_send_list();
  static const int kRedPointSendListFieldNumber = 3;
  inline const ::std::string& red_point_send_list() const;
  inline void set_red_point_send_list(const ::std::string& value);
  inline void set_red_point_send_list(const char* value);
  inline void set_red_point_send_list(const char* value, size_t size);
  inline ::std::string* mutable_red_point_send_list();
  inline ::std::string* release_red_point_send_list();
  inline void set_allocated_red_point_send_list(::std::string* red_point_send_list);

  // @@protoc_insertion_point(class_scope:proto.common.red_point_single)
 private:
  inline void set_has_red_type();
  inline void clear_has_red_type();
  inline void set_has_red_point_state();
  inline void clear_has_red_point_state();
  inline void set_has_red_point_send_list();
  inline void clear_has_red_point_send_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int red_type_;
  ::google::protobuf::uint32 red_point_state_;
  ::std::string* red_point_send_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static red_point_single* default_instance_;
};
// -------------------------------------------------------------------

class red_point_data : public ::google::protobuf::Message {
 public:
  red_point_data();
  virtual ~red_point_data();

  red_point_data(const red_point_data& from);

  inline red_point_data& operator=(const red_point_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const red_point_data& default_instance();

  void Swap(red_point_data* other);

  // implements Message ----------------------------------------------

  red_point_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const red_point_data& from);
  void MergeFrom(const red_point_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.red_point_single red_info_list = 1;
  inline int red_info_list_size() const;
  inline void clear_red_info_list();
  static const int kRedInfoListFieldNumber = 1;
  inline const ::proto::common::red_point_single& red_info_list(int index) const;
  inline ::proto::common::red_point_single* mutable_red_info_list(int index);
  inline ::proto::common::red_point_single* add_red_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::red_point_single >&
      red_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::red_point_single >*
      mutable_red_info_list();

  // @@protoc_insertion_point(class_scope:proto.common.red_point_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::red_point_single > red_info_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static red_point_data* default_instance_;
};
// -------------------------------------------------------------------

class new_role_guide_single : public ::google::protobuf::Message {
 public:
  new_role_guide_single();
  virtual ~new_role_guide_single();

  new_role_guide_single(const new_role_guide_single& from);

  inline new_role_guide_single& operator=(const new_role_guide_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_role_guide_single& default_instance();

  void Swap(new_role_guide_single* other);

  // implements Message ----------------------------------------------

  new_role_guide_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_role_guide_single& from);
  void MergeFrom(const new_role_guide_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 event_type = 3;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 event_type() const;
  inline void set_event_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.new_role_guide_single)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_event_type();
  inline void clear_has_event_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static new_role_guide_single* default_instance_;
};
// -------------------------------------------------------------------

class new_role_guide_data : public ::google::protobuf::Message {
 public:
  new_role_guide_data();
  virtual ~new_role_guide_data();

  new_role_guide_data(const new_role_guide_data& from);

  inline new_role_guide_data& operator=(const new_role_guide_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const new_role_guide_data& default_instance();

  void Swap(new_role_guide_data* other);

  // implements Message ----------------------------------------------

  new_role_guide_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const new_role_guide_data& from);
  void MergeFrom(const new_role_guide_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.new_role_guide_single guide_list = 1;
  inline int guide_list_size() const;
  inline void clear_guide_list();
  static const int kGuideListFieldNumber = 1;
  inline const ::proto::common::new_role_guide_single& guide_list(int index) const;
  inline ::proto::common::new_role_guide_single* mutable_guide_list(int index);
  inline ::proto::common::new_role_guide_single* add_guide_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::new_role_guide_single >&
      guide_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::new_role_guide_single >*
      mutable_guide_list();

  // @@protoc_insertion_point(class_scope:proto.common.new_role_guide_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::new_role_guide_single > guide_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static new_role_guide_data* default_instance_;
};
// -------------------------------------------------------------------

class luckydraw_data : public ::google::protobuf::Message {
 public:
  luckydraw_data();
  virtual ~luckydraw_data();

  luckydraw_data(const luckydraw_data& from);

  inline luckydraw_data& operator=(const luckydraw_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luckydraw_data& default_instance();

  void Swap(luckydraw_data* other);

  // implements Message ----------------------------------------------

  luckydraw_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luckydraw_data& from);
  void MergeFrom(const luckydraw_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.luckydraw_info lucky_draw_list = 1;
  inline int lucky_draw_list_size() const;
  inline void clear_lucky_draw_list();
  static const int kLuckyDrawListFieldNumber = 1;
  inline const ::proto::common::luckydraw_info& lucky_draw_list(int index) const;
  inline ::proto::common::luckydraw_info* mutable_lucky_draw_list(int index);
  inline ::proto::common::luckydraw_info* add_lucky_draw_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_info >&
      lucky_draw_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_info >*
      mutable_lucky_draw_list();

  // optional uint32 lucky = 2;
  inline bool has_lucky() const;
  inline void clear_lucky();
  static const int kLuckyFieldNumber = 2;
  inline ::google::protobuf::uint32 lucky() const;
  inline void set_lucky(::google::protobuf::uint32 value);

  // optional uint32 lucky_ex = 3;
  inline bool has_lucky_ex() const;
  inline void clear_lucky_ex();
  static const int kLuckyExFieldNumber = 3;
  inline ::google::protobuf::uint32 lucky_ex() const;
  inline void set_lucky_ex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.luckydraw_data)
 private:
  inline void set_has_lucky();
  inline void clear_has_lucky();
  inline void set_has_lucky_ex();
  inline void clear_has_lucky_ex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_info > lucky_draw_list_;
  ::google::protobuf::uint32 lucky_;
  ::google::protobuf::uint32 lucky_ex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luckydraw_data* default_instance_;
};
// -------------------------------------------------------------------

class luckydraw_info : public ::google::protobuf::Message {
 public:
  luckydraw_info();
  virtual ~luckydraw_info();

  luckydraw_info(const luckydraw_info& from);

  inline luckydraw_info& operator=(const luckydraw_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luckydraw_info& default_instance();

  void Swap(luckydraw_info* other);

  // implements Message ----------------------------------------------

  luckydraw_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luckydraw_info& from);
  void MergeFrom(const luckydraw_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 senior_count = 2;
  inline bool has_senior_count() const;
  inline void clear_senior_count();
  static const int kSeniorCountFieldNumber = 2;
  inline ::google::protobuf::uint32 senior_count() const;
  inline void set_senior_count(::google::protobuf::uint32 value);

  // repeated uint32 senior_seq = 3;
  inline int senior_seq_size() const;
  inline void clear_senior_seq();
  static const int kSeniorSeqFieldNumber = 3;
  inline ::google::protobuf::uint32 senior_seq(int index) const;
  inline void set_senior_seq(int index, ::google::protobuf::uint32 value);
  inline void add_senior_seq(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      senior_seq() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_senior_seq();

  // optional uint32 today_count = 4;
  inline bool has_today_count() const;
  inline void clear_today_count();
  static const int kTodayCountFieldNumber = 4;
  inline ::google::protobuf::uint32 today_count() const;
  inline void set_today_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.luckydraw_info)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_senior_count();
  inline void clear_has_senior_count();
  inline void set_has_today_count();
  inline void clear_has_today_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 senior_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > senior_seq_;
  ::google::protobuf::uint32 today_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luckydraw_info* default_instance_;
};
// -------------------------------------------------------------------

class luckydraw_client_single : public ::google::protobuf::Message {
 public:
  luckydraw_client_single();
  virtual ~luckydraw_client_single();

  luckydraw_client_single(const luckydraw_client_single& from);

  inline luckydraw_client_single& operator=(const luckydraw_client_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luckydraw_client_single& default_instance();

  void Swap(luckydraw_client_single* other);

  // implements Message ----------------------------------------------

  luckydraw_client_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luckydraw_client_single& from);
  void MergeFrom(const luckydraw_client_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 today_count = 2;
  inline bool has_today_count() const;
  inline void clear_today_count();
  static const int kTodayCountFieldNumber = 2;
  inline ::google::protobuf::uint32 today_count() const;
  inline void set_today_count(::google::protobuf::uint32 value);

  // optional uint32 card_id = 3;
  inline bool has_card_id() const;
  inline void clear_card_id();
  static const int kCardIdFieldNumber = 3;
  inline ::google::protobuf::uint32 card_id() const;
  inline void set_card_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.luckydraw_client_single)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_today_count();
  inline void clear_has_today_count();
  inline void set_has_card_id();
  inline void clear_has_card_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 today_count_;
  ::google::protobuf::uint32 card_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luckydraw_client_single* default_instance_;
};
// -------------------------------------------------------------------

class luckydraw_client_data : public ::google::protobuf::Message {
 public:
  luckydraw_client_data();
  virtual ~luckydraw_client_data();

  luckydraw_client_data(const luckydraw_client_data& from);

  inline luckydraw_client_data& operator=(const luckydraw_client_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const luckydraw_client_data& default_instance();

  void Swap(luckydraw_client_data* other);

  // implements Message ----------------------------------------------

  luckydraw_client_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const luckydraw_client_data& from);
  void MergeFrom(const luckydraw_client_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.luckydraw_client_single client_data = 1;
  inline int client_data_size() const;
  inline void clear_client_data();
  static const int kClientDataFieldNumber = 1;
  inline const ::proto::common::luckydraw_client_single& client_data(int index) const;
  inline ::proto::common::luckydraw_client_single* mutable_client_data(int index);
  inline ::proto::common::luckydraw_client_single* add_client_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_client_single >&
      client_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_client_single >*
      mutable_client_data();

  // optional uint32 remain_time = 2;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // optional uint32 lucky = 3;
  inline bool has_lucky() const;
  inline void clear_lucky();
  static const int kLuckyFieldNumber = 3;
  inline ::google::protobuf::uint32 lucky() const;
  inline void set_lucky(::google::protobuf::uint32 value);

  // optional uint32 lucky_ex = 4;
  inline bool has_lucky_ex() const;
  inline void clear_lucky_ex();
  static const int kLuckyExFieldNumber = 4;
  inline ::google::protobuf::uint32 lucky_ex() const;
  inline void set_lucky_ex(::google::protobuf::uint32 value);

  // optional uint32 gold_luckydraw_expired_time = 5;
  inline bool has_gold_luckydraw_expired_time() const;
  inline void clear_gold_luckydraw_expired_time();
  static const int kGoldLuckydrawExpiredTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 gold_luckydraw_expired_time() const;
  inline void set_gold_luckydraw_expired_time(::google::protobuf::uint32 value);

  // optional uint32 today_count = 6;
  inline bool has_today_count() const;
  inline void clear_today_count();
  static const int kTodayCountFieldNumber = 6;
  inline ::google::protobuf::uint32 today_count() const;
  inline void set_today_count(::google::protobuf::uint32 value);

  // optional uint32 today_count_limit = 7;
  inline bool has_today_count_limit() const;
  inline void clear_today_count_limit();
  static const int kTodayCountLimitFieldNumber = 7;
  inline ::google::protobuf::uint32 today_count_limit() const;
  inline void set_today_count_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.luckydraw_client_data)
 private:
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_lucky();
  inline void clear_has_lucky();
  inline void set_has_lucky_ex();
  inline void clear_has_lucky_ex();
  inline void set_has_gold_luckydraw_expired_time();
  inline void clear_has_gold_luckydraw_expired_time();
  inline void set_has_today_count();
  inline void clear_has_today_count();
  inline void set_has_today_count_limit();
  inline void clear_has_today_count_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_client_single > client_data_;
  ::google::protobuf::uint32 remain_time_;
  ::google::protobuf::uint32 lucky_;
  ::google::protobuf::uint32 lucky_ex_;
  ::google::protobuf::uint32 gold_luckydraw_expired_time_;
  ::google::protobuf::uint32 today_count_;
  ::google::protobuf::uint32 today_count_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static luckydraw_client_data* default_instance_;
};
// -------------------------------------------------------------------

class role_dungeon_monster : public ::google::protobuf::Message {
 public:
  role_dungeon_monster();
  virtual ~role_dungeon_monster();

  role_dungeon_monster(const role_dungeon_monster& from);

  inline role_dungeon_monster& operator=(const role_dungeon_monster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_dungeon_monster& default_instance();

  void Swap(role_dungeon_monster* other);

  // implements Message ----------------------------------------------

  role_dungeon_monster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_dungeon_monster& from);
  void MergeFrom(const role_dungeon_monster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monster_tid = 1;
  inline bool has_monster_tid() const;
  inline void clear_monster_tid();
  static const int kMonsterTidFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_tid() const;
  inline void set_monster_tid(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_dungeon_monster)
 private:
  inline void set_has_monster_tid();
  inline void clear_has_monster_tid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 monster_tid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_dungeon_monster* default_instance_;
};
// -------------------------------------------------------------------

class role_dungeon_data : public ::google::protobuf::Message {
 public:
  role_dungeon_data();
  virtual ~role_dungeon_data();

  role_dungeon_data(const role_dungeon_data& from);

  inline role_dungeon_data& operator=(const role_dungeon_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_dungeon_data& default_instance();

  void Swap(role_dungeon_data* other);

  // implements Message ----------------------------------------------

  role_dungeon_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_dungeon_data& from);
  void MergeFrom(const role_dungeon_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dungeon_id = 1;
  inline bool has_dungeon_id() const;
  inline void clear_dungeon_id();
  static const int kDungeonIdFieldNumber = 1;
  inline ::google::protobuf::uint32 dungeon_id() const;
  inline void set_dungeon_id(::google::protobuf::uint32 value);

  // optional uint32 total_pass_time = 2;
  inline bool has_total_pass_time() const;
  inline void clear_total_pass_time();
  static const int kTotalPassTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 total_pass_time() const;
  inline void set_total_pass_time(::google::protobuf::uint32 value);

  // repeated .proto.common.role_dungeon_monster monsters = 3;
  inline int monsters_size() const;
  inline void clear_monsters();
  static const int kMonstersFieldNumber = 3;
  inline const ::proto::common::role_dungeon_monster& monsters(int index) const;
  inline ::proto::common::role_dungeon_monster* mutable_monsters(int index);
  inline ::proto::common::role_dungeon_monster* add_monsters();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_monster >&
      monsters() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_monster >*
      mutable_monsters();

  // optional uint32 refresh_time = 4;
  inline bool has_refresh_time() const;
  inline void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 refresh_time() const;
  inline void set_refresh_time(::google::protobuf::uint32 value);

  // optional uint32 best_score = 5;
  inline bool has_best_score() const;
  inline void clear_best_score();
  static const int kBestScoreFieldNumber = 5;
  inline ::google::protobuf::uint32 best_score() const;
  inline void set_best_score(::google::protobuf::uint32 value);

  // optional uint32 best_pass_time = 6;
  inline bool has_best_pass_time() const;
  inline void clear_best_pass_time();
  static const int kBestPassTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 best_pass_time() const;
  inline void set_best_pass_time(::google::protobuf::uint32 value);

  // optional uint32 best_death_value = 7;
  inline bool has_best_death_value() const;
  inline void clear_best_death_value();
  static const int kBestDeathValueFieldNumber = 7;
  inline ::google::protobuf::uint32 best_death_value() const;
  inline void set_best_death_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_dungeon_data)
 private:
  inline void set_has_dungeon_id();
  inline void clear_has_dungeon_id();
  inline void set_has_total_pass_time();
  inline void clear_has_total_pass_time();
  inline void set_has_refresh_time();
  inline void clear_has_refresh_time();
  inline void set_has_best_score();
  inline void clear_has_best_score();
  inline void set_has_best_pass_time();
  inline void clear_has_best_pass_time();
  inline void set_has_best_death_value();
  inline void clear_has_best_death_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 dungeon_id_;
  ::google::protobuf::uint32 total_pass_time_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_monster > monsters_;
  ::google::protobuf::uint32 refresh_time_;
  ::google::protobuf::uint32 best_score_;
  ::google::protobuf::uint32 best_pass_time_;
  ::google::protobuf::uint32 best_death_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_dungeon_data* default_instance_;
};
// -------------------------------------------------------------------

class role_dungeon_times_data : public ::google::protobuf::Message {
 public:
  role_dungeon_times_data();
  virtual ~role_dungeon_times_data();

  role_dungeon_times_data(const role_dungeon_times_data& from);

  inline role_dungeon_times_data& operator=(const role_dungeon_times_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_dungeon_times_data& default_instance();

  void Swap(role_dungeon_times_data* other);

  // implements Message ----------------------------------------------

  role_dungeon_times_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_dungeon_times_data& from);
  void MergeFrom(const role_dungeon_times_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dungeon_type = 1;
  inline bool has_dungeon_type() const;
  inline void clear_dungeon_type();
  static const int kDungeonTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 dungeon_type() const;
  inline void set_dungeon_type(::google::protobuf::uint32 value);

  // optional uint32 remain_fight_time = 2;
  inline bool has_remain_fight_time() const;
  inline void clear_remain_fight_time();
  static const int kRemainFightTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_fight_time() const;
  inline void set_remain_fight_time(::google::protobuf::uint32 value);

  // optional uint32 today_buy_time = 3;
  inline bool has_today_buy_time() const;
  inline void clear_today_buy_time();
  static const int kTodayBuyTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 today_buy_time() const;
  inline void set_today_buy_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_dungeon_times_data)
 private:
  inline void set_has_dungeon_type();
  inline void clear_has_dungeon_type();
  inline void set_has_remain_fight_time();
  inline void clear_has_remain_fight_time();
  inline void set_has_today_buy_time();
  inline void clear_has_today_buy_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 dungeon_type_;
  ::google::protobuf::uint32 remain_fight_time_;
  ::google::protobuf::uint32 today_buy_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_dungeon_times_data* default_instance_;
};
// -------------------------------------------------------------------

class role_all_dungeon_data : public ::google::protobuf::Message {
 public:
  role_all_dungeon_data();
  virtual ~role_all_dungeon_data();

  role_all_dungeon_data(const role_all_dungeon_data& from);

  inline role_all_dungeon_data& operator=(const role_all_dungeon_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_all_dungeon_data& default_instance();

  void Swap(role_all_dungeon_data* other);

  // implements Message ----------------------------------------------

  role_all_dungeon_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_all_dungeon_data& from);
  void MergeFrom(const role_all_dungeon_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.role_dungeon_data datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::proto::common::role_dungeon_data& datas(int index) const;
  inline ::proto::common::role_dungeon_data* mutable_datas(int index);
  inline ::proto::common::role_dungeon_data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_data >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:proto.common.role_all_dungeon_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_data > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_all_dungeon_data* default_instance_;
};
// -------------------------------------------------------------------

class role_all_dungeon_times_data : public ::google::protobuf::Message {
 public:
  role_all_dungeon_times_data();
  virtual ~role_all_dungeon_times_data();

  role_all_dungeon_times_data(const role_all_dungeon_times_data& from);

  inline role_all_dungeon_times_data& operator=(const role_all_dungeon_times_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_all_dungeon_times_data& default_instance();

  void Swap(role_all_dungeon_times_data* other);

  // implements Message ----------------------------------------------

  role_all_dungeon_times_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_all_dungeon_times_data& from);
  void MergeFrom(const role_all_dungeon_times_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.role_dungeon_times_data datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::proto::common::role_dungeon_times_data& datas(int index) const;
  inline ::proto::common::role_dungeon_times_data* mutable_datas(int index);
  inline ::proto::common::role_dungeon_times_data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:proto.common.role_all_dungeon_times_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_all_dungeon_times_data* default_instance_;
};
// -------------------------------------------------------------------

class role_dungeon_condition : public ::google::protobuf::Message {
 public:
  role_dungeon_condition();
  virtual ~role_dungeon_condition();

  role_dungeon_condition(const role_dungeon_condition& from);

  inline role_dungeon_condition& operator=(const role_dungeon_condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_dungeon_condition& default_instance();

  void Swap(role_dungeon_condition* other);

  // implements Message ----------------------------------------------

  role_dungeon_condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_dungeon_condition& from);
  void MergeFrom(const role_dungeon_condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional bool is_pass = 3;
  inline bool has_is_pass() const;
  inline void clear_is_pass();
  static const int kIsPassFieldNumber = 3;
  inline bool is_pass() const;
  inline void set_is_pass(bool value);

  // @@protoc_insertion_point(class_scope:proto.common.role_dungeon_condition)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_is_pass();
  inline void clear_has_is_pass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 param_;
  bool is_pass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_dungeon_condition* default_instance_;
};
// -------------------------------------------------------------------

class role_client_dungeon_data : public ::google::protobuf::Message {
 public:
  role_client_dungeon_data();
  virtual ~role_client_dungeon_data();

  role_client_dungeon_data(const role_client_dungeon_data& from);

  inline role_client_dungeon_data& operator=(const role_client_dungeon_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_client_dungeon_data& default_instance();

  void Swap(role_client_dungeon_data* other);

  // implements Message ----------------------------------------------

  role_client_dungeon_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_client_dungeon_data& from);
  void MergeFrom(const role_client_dungeon_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dungeon_id = 1;
  inline bool has_dungeon_id() const;
  inline void clear_dungeon_id();
  static const int kDungeonIdFieldNumber = 1;
  inline ::google::protobuf::uint32 dungeon_id() const;
  inline void set_dungeon_id(::google::protobuf::uint32 value);

  // repeated .proto.common.role_dungeon_condition cond = 2;
  inline int cond_size() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 2;
  inline const ::proto::common::role_dungeon_condition& cond(int index) const;
  inline ::proto::common::role_dungeon_condition* mutable_cond(int index);
  inline ::proto::common::role_dungeon_condition* add_cond();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_condition >&
      cond() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_condition >*
      mutable_cond();

  // optional .proto.common.role_dungeon_data data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::proto::common::role_dungeon_data& data() const;
  inline ::proto::common::role_dungeon_data* mutable_data();
  inline ::proto::common::role_dungeon_data* release_data();
  inline void set_allocated_data(::proto::common::role_dungeon_data* data);

  // @@protoc_insertion_point(class_scope:proto.common.role_client_dungeon_data)
 private:
  inline void set_has_dungeon_id();
  inline void clear_has_dungeon_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_condition > cond_;
  ::proto::common::role_dungeon_data* data_;
  ::google::protobuf::uint32 dungeon_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_client_dungeon_data* default_instance_;
};
// -------------------------------------------------------------------

class role_all_client_dungeon_data : public ::google::protobuf::Message {
 public:
  role_all_client_dungeon_data();
  virtual ~role_all_client_dungeon_data();

  role_all_client_dungeon_data(const role_all_client_dungeon_data& from);

  inline role_all_client_dungeon_data& operator=(const role_all_client_dungeon_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_all_client_dungeon_data& default_instance();

  void Swap(role_all_client_dungeon_data* other);

  // implements Message ----------------------------------------------

  role_all_client_dungeon_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_all_client_dungeon_data& from);
  void MergeFrom(const role_all_client_dungeon_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.role_client_dungeon_data datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::proto::common::role_client_dungeon_data& datas(int index) const;
  inline ::proto::common::role_client_dungeon_data* mutable_datas(int index);
  inline ::proto::common::role_client_dungeon_data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_client_dungeon_data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_client_dungeon_data >*
      mutable_datas();

  // repeated .proto.common.role_dungeon_times_data times_datas = 2;
  inline int times_datas_size() const;
  inline void clear_times_datas();
  static const int kTimesDatasFieldNumber = 2;
  inline const ::proto::common::role_dungeon_times_data& times_datas(int index) const;
  inline ::proto::common::role_dungeon_times_data* mutable_times_datas(int index);
  inline ::proto::common::role_dungeon_times_data* add_times_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >&
      times_datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >*
      mutable_times_datas();

  // @@protoc_insertion_point(class_scope:proto.common.role_all_client_dungeon_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_client_dungeon_data > datas_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data > times_datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_all_client_dungeon_data* default_instance_;
};
// -------------------------------------------------------------------

class teamcheck_data : public ::google::protobuf::Message {
 public:
  teamcheck_data();
  virtual ~teamcheck_data();

  teamcheck_data(const teamcheck_data& from);

  inline teamcheck_data& operator=(const teamcheck_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const teamcheck_data& default_instance();

  void Swap(teamcheck_data* other);

  // implements Message ----------------------------------------------

  teamcheck_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const teamcheck_data& from);
  void MergeFrom(const teamcheck_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional .proto.common.team_check_type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::proto::common::team_check_type type() const;
  inline void set_type(::proto::common::team_check_type value);

  // @@protoc_insertion_point(class_scope:proto.common.teamcheck_data)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static teamcheck_data* default_instance_;
};
// -------------------------------------------------------------------

class dungeon_schedule_data : public ::google::protobuf::Message {
 public:
  dungeon_schedule_data();
  virtual ~dungeon_schedule_data();

  dungeon_schedule_data(const dungeon_schedule_data& from);

  inline dungeon_schedule_data& operator=(const dungeon_schedule_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dungeon_schedule_data& default_instance();

  void Swap(dungeon_schedule_data* other);

  // implements Message ----------------------------------------------

  dungeon_schedule_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dungeon_schedule_data& from);
  void MergeFrom(const dungeon_schedule_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monster_tid = 1;
  inline bool has_monster_tid() const;
  inline void clear_monster_tid();
  static const int kMonsterTidFieldNumber = 1;
  inline ::google::protobuf::uint32 monster_tid() const;
  inline void set_monster_tid(::google::protobuf::uint32 value);

  // optional uint32 curr_num = 2;
  inline bool has_curr_num() const;
  inline void clear_curr_num();
  static const int kCurrNumFieldNumber = 2;
  inline ::google::protobuf::uint32 curr_num() const;
  inline void set_curr_num(::google::protobuf::uint32 value);

  // optional uint32 max_num = 3;
  inline bool has_max_num() const;
  inline void clear_max_num();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::uint32 max_num() const;
  inline void set_max_num(::google::protobuf::uint32 value);

  // optional uint32 pos_x = 4;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 4;
  inline ::google::protobuf::uint32 pos_x() const;
  inline void set_pos_x(::google::protobuf::uint32 value);

  // optional uint32 pos_y = 5;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 5;
  inline ::google::protobuf::uint32 pos_y() const;
  inline void set_pos_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.dungeon_schedule_data)
 private:
  inline void set_has_monster_tid();
  inline void clear_has_monster_tid();
  inline void set_has_curr_num();
  inline void clear_has_curr_num();
  inline void set_has_max_num();
  inline void clear_has_max_num();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 monster_tid_;
  ::google::protobuf::uint32 curr_num_;
  ::google::protobuf::uint32 max_num_;
  ::google::protobuf::uint32 pos_x_;
  ::google::protobuf::uint32 pos_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static dungeon_schedule_data* default_instance_;
};
// -------------------------------------------------------------------

class tactic_single : public ::google::protobuf::Message {
 public:
  tactic_single();
  virtual ~tactic_single();

  tactic_single(const tactic_single& from);

  inline tactic_single& operator=(const tactic_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tactic_single& default_instance();

  void Swap(tactic_single* other);

  // implements Message ----------------------------------------------

  tactic_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tactic_single& from);
  void MergeFrom(const tactic_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tactic_id = 1;
  inline bool has_tactic_id() const;
  inline void clear_tactic_id();
  static const int kTacticIdFieldNumber = 1;
  inline ::google::protobuf::uint32 tactic_id() const;
  inline void set_tactic_id(::google::protobuf::uint32 value);

  // optional uint32 tactic_level = 2;
  inline bool has_tactic_level() const;
  inline void clear_tactic_level();
  static const int kTacticLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 tactic_level() const;
  inline void set_tactic_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.tactic_single)
 private:
  inline void set_has_tactic_id();
  inline void clear_has_tactic_id();
  inline void set_has_tactic_level();
  inline void clear_has_tactic_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tactic_id_;
  ::google::protobuf::uint32 tactic_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static tactic_single* default_instance_;
};
// -------------------------------------------------------------------

class tactic_data : public ::google::protobuf::Message {
 public:
  tactic_data();
  virtual ~tactic_data();

  tactic_data(const tactic_data& from);

  inline tactic_data& operator=(const tactic_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tactic_data& default_instance();

  void Swap(tactic_data* other);

  // implements Message ----------------------------------------------

  tactic_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tactic_data& from);
  void MergeFrom(const tactic_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.tactic_single tactics = 1;
  inline int tactics_size() const;
  inline void clear_tactics();
  static const int kTacticsFieldNumber = 1;
  inline const ::proto::common::tactic_single& tactics(int index) const;
  inline ::proto::common::tactic_single* mutable_tactics(int index);
  inline ::proto::common::tactic_single* add_tactics();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tactic_single >&
      tactics() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::tactic_single >*
      mutable_tactics();

  // @@protoc_insertion_point(class_scope:proto.common.tactic_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::tactic_single > tactics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static tactic_data* default_instance_;
};
// -------------------------------------------------------------------

class role_buff_single : public ::google::protobuf::Message {
 public:
  role_buff_single();
  virtual ~role_buff_single();

  role_buff_single(const role_buff_single& from);

  inline role_buff_single& operator=(const role_buff_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_buff_single& default_instance();

  void Swap(role_buff_single* other);

  // implements Message ----------------------------------------------

  role_buff_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_buff_single& from);
  void MergeFrom(const role_buff_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 buff_id = 1;
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 1;
  inline ::google::protobuf::uint32 buff_id() const;
  inline void set_buff_id(::google::protobuf::uint32 value);

  // optional uint32 remain_time = 2;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 remain_time() const;
  inline void set_remain_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_buff_single)
 private:
  inline void set_has_buff_id();
  inline void clear_has_buff_id();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 buff_id_;
  ::google::protobuf::uint32 remain_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_buff_single* default_instance_;
};
// -------------------------------------------------------------------

class role_buff_data : public ::google::protobuf::Message {
 public:
  role_buff_data();
  virtual ~role_buff_data();

  role_buff_data(const role_buff_data& from);

  inline role_buff_data& operator=(const role_buff_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_buff_data& default_instance();

  void Swap(role_buff_data* other);

  // implements Message ----------------------------------------------

  role_buff_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_buff_data& from);
  void MergeFrom(const role_buff_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.role_buff_single role_buffs = 1;
  inline int role_buffs_size() const;
  inline void clear_role_buffs();
  static const int kRoleBuffsFieldNumber = 1;
  inline const ::proto::common::role_buff_single& role_buffs(int index) const;
  inline ::proto::common::role_buff_single* mutable_role_buffs(int index);
  inline ::proto::common::role_buff_single* add_role_buffs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_buff_single >&
      role_buffs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_buff_single >*
      mutable_role_buffs();

  // @@protoc_insertion_point(class_scope:proto.common.role_buff_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::role_buff_single > role_buffs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_buff_data* default_instance_;
};
// -------------------------------------------------------------------

class goods_single : public ::google::protobuf::Message {
 public:
  goods_single();
  virtual ~goods_single();

  goods_single(const goods_single& from);

  inline goods_single& operator=(const goods_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const goods_single& default_instance();

  void Swap(goods_single* other);

  // implements Message ----------------------------------------------

  goods_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const goods_single& from);
  void MergeFrom(const goods_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string seller_uid = 2;
  inline bool has_seller_uid() const;
  inline void clear_seller_uid();
  static const int kSellerUidFieldNumber = 2;
  inline const ::std::string& seller_uid() const;
  inline void set_seller_uid(const ::std::string& value);
  inline void set_seller_uid(const char* value);
  inline void set_seller_uid(const char* value, size_t size);
  inline ::std::string* mutable_seller_uid();
  inline ::std::string* release_seller_uid();
  inline void set_allocated_seller_uid(::std::string* seller_uid);

  // optional string seller_name = 3;
  inline bool has_seller_name() const;
  inline void clear_seller_name();
  static const int kSellerNameFieldNumber = 3;
  inline const ::std::string& seller_name() const;
  inline void set_seller_name(const ::std::string& value);
  inline void set_seller_name(const char* value);
  inline void set_seller_name(const char* value, size_t size);
  inline ::std::string* mutable_seller_name();
  inline ::std::string* release_seller_name();
  inline void set_allocated_seller_name(::std::string* seller_name);

  // optional uint32 item_tid = 4;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 4;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_num = 5;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 5;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional .proto.common.equip_single equip_info = 6;
  inline bool has_equip_info() const;
  inline void clear_equip_info();
  static const int kEquipInfoFieldNumber = 6;
  inline const ::proto::common::equip_single& equip_info() const;
  inline ::proto::common::equip_single* mutable_equip_info();
  inline ::proto::common::equip_single* release_equip_info();
  inline void set_allocated_equip_info(::proto::common::equip_single* equip_info);

  // optional uint32 item_price = 7;
  inline bool has_item_price() const;
  inline void clear_item_price();
  static const int kItemPriceFieldNumber = 7;
  inline ::google::protobuf::uint32 item_price() const;
  inline void set_item_price(::google::protobuf::uint32 value);

  // optional uint32 selled_num = 8;
  inline bool has_selled_num() const;
  inline void clear_selled_num();
  static const int kSelledNumFieldNumber = 8;
  inline ::google::protobuf::uint32 selled_num() const;
  inline void set_selled_num(::google::protobuf::uint32 value);

  // optional uint32 profit = 9;
  inline bool has_profit() const;
  inline void clear_profit();
  static const int kProfitFieldNumber = 9;
  inline ::google::protobuf::uint32 profit() const;
  inline void set_profit(::google::protobuf::uint32 value);

  // optional uint32 state = 10;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 10;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 expired_time = 11;
  inline bool has_expired_time() const;
  inline void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 11;
  inline ::google::protobuf::uint32 expired_time() const;
  inline void set_expired_time(::google::protobuf::uint32 value);

  // optional uint32 care = 12;
  inline bool has_care() const;
  inline void clear_care();
  static const int kCareFieldNumber = 12;
  inline ::google::protobuf::uint32 care() const;
  inline void set_care(::google::protobuf::uint32 value);

  // optional uint32 heat = 13;
  inline bool has_heat() const;
  inline void clear_heat();
  static const int kHeatFieldNumber = 13;
  inline ::google::protobuf::uint32 heat() const;
  inline void set_heat(::google::protobuf::uint32 value);

  // optional uint32 rarity = 14;
  inline bool has_rarity() const;
  inline void clear_rarity();
  static const int kRarityFieldNumber = 14;
  inline ::google::protobuf::uint32 rarity() const;
  inline void set_rarity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.goods_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seller_uid();
  inline void clear_has_seller_uid();
  inline void set_has_seller_name();
  inline void clear_has_seller_name();
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_equip_info();
  inline void clear_has_equip_info();
  inline void set_has_item_price();
  inline void clear_has_item_price();
  inline void set_has_selled_num();
  inline void clear_has_selled_num();
  inline void set_has_profit();
  inline void clear_has_profit();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_expired_time();
  inline void clear_has_expired_time();
  inline void set_has_care();
  inline void clear_has_care();
  inline void set_has_heat();
  inline void clear_has_heat();
  inline void set_has_rarity();
  inline void clear_has_rarity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* seller_uid_;
  ::std::string* seller_name_;
  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_num_;
  ::proto::common::equip_single* equip_info_;
  ::google::protobuf::uint32 item_price_;
  ::google::protobuf::uint32 selled_num_;
  ::google::protobuf::uint32 profit_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 expired_time_;
  ::google::protobuf::uint32 care_;
  ::google::protobuf::uint32 heat_;
  ::google::protobuf::uint32 rarity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static goods_single* default_instance_;
};
// -------------------------------------------------------------------

class rarity_price_single : public ::google::protobuf::Message {
 public:
  rarity_price_single();
  virtual ~rarity_price_single();

  rarity_price_single(const rarity_price_single& from);

  inline rarity_price_single& operator=(const rarity_price_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rarity_price_single& default_instance();

  void Swap(rarity_price_single* other);

  // implements Message ----------------------------------------------

  rarity_price_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rarity_price_single& from);
  void MergeFrom(const rarity_price_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 item_tid = 2;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 2;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // repeated uint32 deal_price = 3;
  inline int deal_price_size() const;
  inline void clear_deal_price();
  static const int kDealPriceFieldNumber = 3;
  inline ::google::protobuf::uint32 deal_price(int index) const;
  inline void set_deal_price(int index, ::google::protobuf::uint32 value);
  inline void add_deal_price(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      deal_price() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_deal_price();

  // @@protoc_insertion_point(class_scope:proto.common.rarity_price_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_item_tid();
  inline void clear_has_item_tid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > deal_price_;
  ::google::protobuf::uint32 item_tid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rarity_price_single* default_instance_;
};
// -------------------------------------------------------------------

class goods_info : public ::google::protobuf::Message {
 public:
  goods_info();
  virtual ~goods_info();

  goods_info(const goods_info& from);

  inline goods_info& operator=(const goods_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const goods_info& default_instance();

  void Swap(goods_info* other);

  // implements Message ----------------------------------------------

  goods_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const goods_info& from);
  void MergeFrom(const goods_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 selling_num = 2;
  inline bool has_selling_num() const;
  inline void clear_selling_num();
  static const int kSellingNumFieldNumber = 2;
  inline ::google::protobuf::uint32 selling_num() const;
  inline void set_selling_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.goods_info)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_selling_num();
  inline void clear_has_selling_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 selling_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static goods_info* default_instance_;
};
// -------------------------------------------------------------------

class goods_item : public ::google::protobuf::Message {
 public:
  goods_item();
  virtual ~goods_item();

  goods_item(const goods_item& from);

  inline goods_item& operator=(const goods_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const goods_item& default_instance();

  void Swap(goods_item* other);

  // implements Message ----------------------------------------------

  goods_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const goods_item& from);
  void MergeFrom(const goods_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 item_num() const;
  inline void set_item_num(::google::protobuf::uint32 value);

  // optional .proto.common.equip_single equip_info = 3;
  inline bool has_equip_info() const;
  inline void clear_equip_info();
  static const int kEquipInfoFieldNumber = 3;
  inline const ::proto::common::equip_single& equip_info() const;
  inline ::proto::common::equip_single* mutable_equip_info();
  inline ::proto::common::equip_single* release_equip_info();
  inline void set_allocated_equip_info(::proto::common::equip_single* equip_info);

  // optional uint32 rarity = 4;
  inline bool has_rarity() const;
  inline void clear_rarity();
  static const int kRarityFieldNumber = 4;
  inline ::google::protobuf::uint32 rarity() const;
  inline void set_rarity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.goods_item)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_equip_info();
  inline void clear_has_equip_info();
  inline void set_has_rarity();
  inline void clear_has_rarity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 item_num_;
  ::proto::common::equip_single* equip_info_;
  ::google::protobuf::uint32 rarity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static goods_item* default_instance_;
};
// -------------------------------------------------------------------

class trade_item_info : public ::google::protobuf::Message {
 public:
  trade_item_info();
  virtual ~trade_item_info();

  trade_item_info(const trade_item_info& from);

  inline trade_item_info& operator=(const trade_item_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trade_item_info& default_instance();

  void Swap(trade_item_info* other);

  // implements Message ----------------------------------------------

  trade_item_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trade_item_info& from);
  void MergeFrom(const trade_item_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 item_tid = 1;
  inline bool has_item_tid() const;
  inline void clear_item_tid();
  static const int kItemTidFieldNumber = 1;
  inline ::google::protobuf::uint32 item_tid() const;
  inline void set_item_tid(::google::protobuf::uint32 value);

  // optional uint32 scene_id = 2;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 2;
  inline ::google::protobuf::uint32 scene_id() const;
  inline void set_scene_id(::google::protobuf::uint32 value);

  // optional uint32 trade_id = 3;
  inline bool has_trade_id() const;
  inline void clear_trade_id();
  static const int kTradeIdFieldNumber = 3;
  inline ::google::protobuf::uint32 trade_id() const;
  inline void set_trade_id(::google::protobuf::uint32 value);

  // optional uint32 sour_trade_id = 4;
  inline bool has_sour_trade_id() const;
  inline void clear_sour_trade_id();
  static const int kSourTradeIdFieldNumber = 4;
  inline ::google::protobuf::uint32 sour_trade_id() const;
  inline void set_sour_trade_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.trade_item_info)
 private:
  inline void set_has_item_tid();
  inline void clear_has_item_tid();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_trade_id();
  inline void clear_has_trade_id();
  inline void set_has_sour_trade_id();
  inline void clear_has_sour_trade_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 item_tid_;
  ::google::protobuf::uint32 scene_id_;
  ::google::protobuf::uint32 trade_id_;
  ::google::protobuf::uint32 sour_trade_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static trade_item_info* default_instance_;
};
// -------------------------------------------------------------------

class arena_fight_data : public ::google::protobuf::Message {
 public:
  arena_fight_data();
  virtual ~arena_fight_data();

  arena_fight_data(const arena_fight_data& from);

  inline arena_fight_data& operator=(const arena_fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const arena_fight_data& default_instance();

  void Swap(arena_fight_data* other);

  // implements Message ----------------------------------------------

  arena_fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const arena_fight_data& from);
  void MergeFrom(const arena_fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 update_time = 1;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 update_time() const;
  inline void set_update_time(::google::protobuf::uint32 value);

  // optional .proto.common.mirror_fight_data fight_data = 2;
  inline bool has_fight_data() const;
  inline void clear_fight_data();
  static const int kFightDataFieldNumber = 2;
  inline const ::proto::common::mirror_fight_data& fight_data() const;
  inline ::proto::common::mirror_fight_data* mutable_fight_data();
  inline ::proto::common::mirror_fight_data* release_fight_data();
  inline void set_allocated_fight_data(::proto::common::mirror_fight_data* fight_data);

  // optional uint32 fight_value = 3;
  inline bool has_fight_value() const;
  inline void clear_fight_value();
  static const int kFightValueFieldNumber = 3;
  inline ::google::protobuf::uint32 fight_value() const;
  inline void set_fight_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.arena_fight_data)
 private:
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_fight_data();
  inline void clear_has_fight_data();
  inline void set_has_fight_value();
  inline void clear_has_fight_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::mirror_fight_data* fight_data_;
  ::google::protobuf::uint32 update_time_;
  ::google::protobuf::uint32 fight_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static arena_fight_data* default_instance_;
};
// -------------------------------------------------------------------

class expedition_stage_single : public ::google::protobuf::Message {
 public:
  expedition_stage_single();
  virtual ~expedition_stage_single();

  expedition_stage_single(const expedition_stage_single& from);

  inline expedition_stage_single& operator=(const expedition_stage_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const expedition_stage_single& default_instance();

  void Swap(expedition_stage_single* other);

  // implements Message ----------------------------------------------

  expedition_stage_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const expedition_stage_single& from);
  void MergeFrom(const expedition_stage_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 stage_id = 1;
  inline bool has_stage_id() const;
  inline void clear_stage_id();
  static const int kStageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 stage_id() const;
  inline void set_stage_id(::google::protobuf::uint32 value);

  // optional uint32 pass_num = 2;
  inline bool has_pass_num() const;
  inline void clear_pass_num();
  static const int kPassNumFieldNumber = 2;
  inline ::google::protobuf::uint32 pass_num() const;
  inline void set_pass_num(::google::protobuf::uint32 value);

  // repeated .proto.common.mirror_fight_data stage_info = 3;
  inline int stage_info_size() const;
  inline void clear_stage_info();
  static const int kStageInfoFieldNumber = 3;
  inline const ::proto::common::mirror_fight_data& stage_info(int index) const;
  inline ::proto::common::mirror_fight_data* mutable_stage_info(int index);
  inline ::proto::common::mirror_fight_data* add_stage_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::mirror_fight_data >&
      stage_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::mirror_fight_data >*
      mutable_stage_info();

  // optional uint32 award_num = 4;
  inline bool has_award_num() const;
  inline void clear_award_num();
  static const int kAwardNumFieldNumber = 4;
  inline ::google::protobuf::uint32 award_num() const;
  inline void set_award_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.expedition_stage_single)
 private:
  inline void set_has_stage_id();
  inline void clear_has_stage_id();
  inline void set_has_pass_num();
  inline void clear_has_pass_num();
  inline void set_has_award_num();
  inline void clear_has_award_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 stage_id_;
  ::google::protobuf::uint32 pass_num_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::mirror_fight_data > stage_info_;
  ::google::protobuf::uint32 award_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static expedition_stage_single* default_instance_;
};
// -------------------------------------------------------------------

class expedition_data : public ::google::protobuf::Message {
 public:
  expedition_data();
  virtual ~expedition_data();

  expedition_data(const expedition_data& from);

  inline expedition_data& operator=(const expedition_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const expedition_data& default_instance();

  void Swap(expedition_data* other);

  // implements Message ----------------------------------------------

  expedition_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const expedition_data& from);
  void MergeFrom(const expedition_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.expedition_stage_single stage_list = 1;
  inline int stage_list_size() const;
  inline void clear_stage_list();
  static const int kStageListFieldNumber = 1;
  inline const ::proto::common::expedition_stage_single& stage_list(int index) const;
  inline ::proto::common::expedition_stage_single* mutable_stage_list(int index);
  inline ::proto::common::expedition_stage_single* add_stage_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::expedition_stage_single >&
      stage_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::expedition_stage_single >*
      mutable_stage_list();

  // optional uint32 pass_num = 2;
  inline bool has_pass_num() const;
  inline void clear_pass_num();
  static const int kPassNumFieldNumber = 2;
  inline ::google::protobuf::uint32 pass_num() const;
  inline void set_pass_num(::google::protobuf::uint32 value);

  // optional uint32 refresh_count = 3;
  inline bool has_refresh_count() const;
  inline void clear_refresh_count();
  static const int kRefreshCountFieldNumber = 3;
  inline ::google::protobuf::uint32 refresh_count() const;
  inline void set_refresh_count(::google::protobuf::uint32 value);

  // optional .proto.common.fight_save_data save_data = 4;
  inline bool has_save_data() const;
  inline void clear_save_data();
  static const int kSaveDataFieldNumber = 4;
  inline const ::proto::common::fight_save_data& save_data() const;
  inline ::proto::common::fight_save_data* mutable_save_data();
  inline ::proto::common::fight_save_data* release_save_data();
  inline void set_allocated_save_data(::proto::common::fight_save_data* save_data);

  // optional uint32 call_help_count = 5;
  inline bool has_call_help_count() const;
  inline void clear_call_help_count();
  static const int kCallHelpCountFieldNumber = 5;
  inline ::google::protobuf::uint32 call_help_count() const;
  inline void set_call_help_count(::google::protobuf::uint32 value);

  // optional uint32 help_count = 6;
  inline bool has_help_count() const;
  inline void clear_help_count();
  static const int kHelpCountFieldNumber = 6;
  inline ::google::protobuf::uint32 help_count() const;
  inline void set_help_count(::google::protobuf::uint32 value);

  // optional uint32 glory = 7;
  inline bool has_glory() const;
  inline void clear_glory();
  static const int kGloryFieldNumber = 7;
  inline ::google::protobuf::uint32 glory() const;
  inline void set_glory(::google::protobuf::uint32 value);

  // repeated uint32 buy_count = 8;
  inline int buy_count_size() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 8;
  inline ::google::protobuf::uint32 buy_count(int index) const;
  inline void set_buy_count(int index, ::google::protobuf::uint32 value);
  inline void add_buy_count(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buy_count() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buy_count();

  // repeated .proto.common.liveness_box box_list = 9;
  inline int box_list_size() const;
  inline void clear_box_list();
  static const int kBoxListFieldNumber = 9;
  inline const ::proto::common::liveness_box& box_list(int index) const;
  inline ::proto::common::liveness_box* mutable_box_list(int index);
  inline ::proto::common::liveness_box* add_box_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
      box_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
      mutable_box_list();

  // optional uint32 liveness = 10;
  inline bool has_liveness() const;
  inline void clear_liveness();
  static const int kLivenessFieldNumber = 10;
  inline ::google::protobuf::uint32 liveness() const;
  inline void set_liveness(::google::protobuf::uint32 value);

  // optional uint32 shop_id = 11;
  inline bool has_shop_id() const;
  inline void clear_shop_id();
  static const int kShopIdFieldNumber = 11;
  inline ::google::protobuf::uint32 shop_id() const;
  inline void set_shop_id(::google::protobuf::uint32 value);

  // optional uint32 is_selled = 12;
  inline bool has_is_selled() const;
  inline void clear_is_selled();
  static const int kIsSelledFieldNumber = 12;
  inline ::google::protobuf::uint32 is_selled() const;
  inline void set_is_selled(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.expedition_data)
 private:
  inline void set_has_pass_num();
  inline void clear_has_pass_num();
  inline void set_has_refresh_count();
  inline void clear_has_refresh_count();
  inline void set_has_save_data();
  inline void clear_has_save_data();
  inline void set_has_call_help_count();
  inline void clear_has_call_help_count();
  inline void set_has_help_count();
  inline void clear_has_help_count();
  inline void set_has_glory();
  inline void clear_has_glory();
  inline void set_has_liveness();
  inline void clear_has_liveness();
  inline void set_has_shop_id();
  inline void clear_has_shop_id();
  inline void set_has_is_selled();
  inline void clear_has_is_selled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::expedition_stage_single > stage_list_;
  ::google::protobuf::uint32 pass_num_;
  ::google::protobuf::uint32 refresh_count_;
  ::proto::common::fight_save_data* save_data_;
  ::google::protobuf::uint32 call_help_count_;
  ::google::protobuf::uint32 help_count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buy_count_;
  ::google::protobuf::uint32 glory_;
  ::google::protobuf::uint32 liveness_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box > box_list_;
  ::google::protobuf::uint32 shop_id_;
  ::google::protobuf::uint32 is_selled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static expedition_data* default_instance_;
};
// -------------------------------------------------------------------

class fight_save_data : public ::google::protobuf::Message {
 public:
  fight_save_data();
  virtual ~fight_save_data();

  fight_save_data(const fight_save_data& from);

  inline fight_save_data& operator=(const fight_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fight_save_data& default_instance();

  void Swap(fight_save_data* other);

  // implements Message ----------------------------------------------

  fight_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fight_save_data& from);
  void MergeFrom(const fight_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.hero_save_data hero_list = 1;
  inline int hero_list_size() const;
  inline void clear_hero_list();
  static const int kHeroListFieldNumber = 1;
  inline const ::proto::common::hero_save_data& hero_list(int index) const;
  inline ::proto::common::hero_save_data* mutable_hero_list(int index);
  inline ::proto::common::hero_save_data* add_hero_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_save_data >&
      hero_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_save_data >*
      mutable_hero_list();

  // @@protoc_insertion_point(class_scope:proto.common.fight_save_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_save_data > hero_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static fight_save_data* default_instance_;
};
// -------------------------------------------------------------------

class skill_save_data : public ::google::protobuf::Message {
 public:
  skill_save_data();
  virtual ~skill_save_data();

  skill_save_data(const skill_save_data& from);

  inline skill_save_data& operator=(const skill_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const skill_save_data& default_instance();

  void Swap(skill_save_data* other);

  // implements Message ----------------------------------------------

  skill_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const skill_save_data& from);
  void MergeFrom(const skill_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 cd = 2;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 2;
  inline ::google::protobuf::uint32 cd() const;
  inline void set_cd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.skill_save_data)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_cd();
  inline void clear_has_cd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 cd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static skill_save_data* default_instance_;
};
// -------------------------------------------------------------------

class hero_save_data : public ::google::protobuf::Message {
 public:
  hero_save_data();
  virtual ~hero_save_data();

  hero_save_data(const hero_save_data& from);

  inline hero_save_data& operator=(const hero_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_save_data& default_instance();

  void Swap(hero_save_data* other);

  // implements Message ----------------------------------------------

  hero_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_save_data& from);
  void MergeFrom(const hero_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline ::google::protobuf::uint64 hero_uid() const;
  inline void set_hero_uid(::google::protobuf::uint64 value);

  // optional uint32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // repeated .proto.common.skill_save_data skill_list = 3;
  inline int skill_list_size() const;
  inline void clear_skill_list();
  static const int kSkillListFieldNumber = 3;
  inline const ::proto::common::skill_save_data& skill_list(int index) const;
  inline ::proto::common::skill_save_data* mutable_skill_list(int index);
  inline ::proto::common::skill_save_data* add_skill_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_save_data >&
      skill_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_save_data >*
      mutable_skill_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_save_data)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 hero_uid_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::skill_save_data > skill_list_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_save_data* default_instance_;
};
// -------------------------------------------------------------------

class page_task_single : public ::google::protobuf::Message {
 public:
  page_task_single();
  virtual ~page_task_single();

  page_task_single(const page_task_single& from);

  inline page_task_single& operator=(const page_task_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_task_single& default_instance();

  void Swap(page_task_single* other);

  // implements Message ----------------------------------------------

  page_task_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_task_single& from);
  void MergeFrom(const page_task_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.page_task_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_task_single* default_instance_;
};
// -------------------------------------------------------------------

class page_elite_single : public ::google::protobuf::Message {
 public:
  page_elite_single();
  virtual ~page_elite_single();

  page_elite_single(const page_elite_single& from);

  inline page_elite_single& operator=(const page_elite_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_elite_single& default_instance();

  void Swap(page_elite_single* other);

  // implements Message ----------------------------------------------

  page_elite_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_elite_single& from);
  void MergeFrom(const page_elite_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 reset = 4;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 4;
  inline ::google::protobuf::uint32 reset() const;
  inline void set_reset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.page_elite_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_elite_single* default_instance_;
};
// -------------------------------------------------------------------

class page_elite_data : public ::google::protobuf::Message {
 public:
  page_elite_data();
  virtual ~page_elite_data();

  page_elite_data(const page_elite_data& from);

  inline page_elite_data& operator=(const page_elite_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_elite_data& default_instance();

  void Swap(page_elite_data* other);

  // implements Message ----------------------------------------------

  page_elite_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_elite_data& from);
  void MergeFrom(const page_elite_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 can_fight_list = 1;
  inline int can_fight_list_size() const;
  inline void clear_can_fight_list();
  static const int kCanFightListFieldNumber = 1;
  inline ::google::protobuf::uint32 can_fight_list(int index) const;
  inline void set_can_fight_list(int index, ::google::protobuf::uint32 value);
  inline void add_can_fight_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      can_fight_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_can_fight_list();

  // repeated .proto.common.page_elite_single pass_elite_list = 2;
  inline int pass_elite_list_size() const;
  inline void clear_pass_elite_list();
  static const int kPassEliteListFieldNumber = 2;
  inline const ::proto::common::page_elite_single& pass_elite_list(int index) const;
  inline ::proto::common::page_elite_single* mutable_pass_elite_list(int index);
  inline ::proto::common::page_elite_single* add_pass_elite_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_elite_single >&
      pass_elite_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_elite_single >*
      mutable_pass_elite_list();

  // @@protoc_insertion_point(class_scope:proto.common.page_elite_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > can_fight_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::page_elite_single > pass_elite_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_elite_data* default_instance_;
};
// -------------------------------------------------------------------

class page_data : public ::google::protobuf::Message {
 public:
  page_data();
  virtual ~page_data();

  page_data(const page_data& from);

  inline page_data& operator=(const page_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_data& default_instance();

  void Swap(page_data* other);

  // implements Message ----------------------------------------------

  page_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_data& from);
  void MergeFrom(const page_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 pass_page_list = 1;
  inline int pass_page_list_size() const;
  inline void clear_pass_page_list();
  static const int kPassPageListFieldNumber = 1;
  inline ::google::protobuf::uint32 pass_page_list(int index) const;
  inline void set_pass_page_list(int index, ::google::protobuf::uint32 value);
  inline void add_pass_page_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pass_page_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pass_page_list();

  // repeated .proto.common.page_task_single task_info = 2;
  inline int task_info_size() const;
  inline void clear_task_info();
  static const int kTaskInfoFieldNumber = 2;
  inline const ::proto::common::page_task_single& task_info(int index) const;
  inline ::proto::common::page_task_single* mutable_task_info(int index);
  inline ::proto::common::page_task_single* add_task_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_task_single >&
      task_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_task_single >*
      mutable_task_info();

  // repeated .proto.common.page_quick_fight_data quick_data = 3;
  inline int quick_data_size() const;
  inline void clear_quick_data();
  static const int kQuickDataFieldNumber = 3;
  inline const ::proto::common::page_quick_fight_data& quick_data(int index) const;
  inline ::proto::common::page_quick_fight_data* mutable_quick_data(int index);
  inline ::proto::common::page_quick_fight_data* add_quick_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_quick_fight_data >&
      quick_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_quick_fight_data >*
      mutable_quick_data();

  // repeated .proto.common.page_reset_quick_fight_data reset_data = 4;
  inline int reset_data_size() const;
  inline void clear_reset_data();
  static const int kResetDataFieldNumber = 4;
  inline const ::proto::common::page_reset_quick_fight_data& reset_data(int index) const;
  inline ::proto::common::page_reset_quick_fight_data* mutable_reset_data(int index);
  inline ::proto::common::page_reset_quick_fight_data* add_reset_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_reset_quick_fight_data >&
      reset_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_reset_quick_fight_data >*
      mutable_reset_data();

  // optional .proto.common.page_elite_data elite_data = 5;
  inline bool has_elite_data() const;
  inline void clear_elite_data();
  static const int kEliteDataFieldNumber = 5;
  inline const ::proto::common::page_elite_data& elite_data() const;
  inline ::proto::common::page_elite_data* mutable_elite_data();
  inline ::proto::common::page_elite_data* release_elite_data();
  inline void set_allocated_elite_data(::proto::common::page_elite_data* elite_data);

  // @@protoc_insertion_point(class_scope:proto.common.page_data)
 private:
  inline void set_has_elite_data();
  inline void clear_has_elite_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pass_page_list_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::page_task_single > task_info_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::page_quick_fight_data > quick_data_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::page_reset_quick_fight_data > reset_data_;
  ::proto::common::page_elite_data* elite_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_data* default_instance_;
};
// -------------------------------------------------------------------

class page_quick_fight_data : public ::google::protobuf::Message {
 public:
  page_quick_fight_data();
  virtual ~page_quick_fight_data();

  page_quick_fight_data(const page_quick_fight_data& from);

  inline page_quick_fight_data& operator=(const page_quick_fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_quick_fight_data& default_instance();

  void Swap(page_quick_fight_data* other);

  // implements Message ----------------------------------------------

  page_quick_fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_quick_fight_data& from);
  void MergeFrom(const page_quick_fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.page_quick_fight_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_quick_fight_data* default_instance_;
};
// -------------------------------------------------------------------

class page_reset_quick_fight_data : public ::google::protobuf::Message {
 public:
  page_reset_quick_fight_data();
  virtual ~page_reset_quick_fight_data();

  page_reset_quick_fight_data(const page_reset_quick_fight_data& from);

  inline page_reset_quick_fight_data& operator=(const page_reset_quick_fight_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const page_reset_quick_fight_data& default_instance();

  void Swap(page_reset_quick_fight_data* other);

  // implements Message ----------------------------------------------

  page_reset_quick_fight_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const page_reset_quick_fight_data& from);
  void MergeFrom(const page_reset_quick_fight_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.page_reset_quick_fight_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static page_reset_quick_fight_data* default_instance_;
};
// -------------------------------------------------------------------

class active_reward_data_single : public ::google::protobuf::Message {
 public:
  active_reward_data_single();
  virtual ~active_reward_data_single();

  active_reward_data_single(const active_reward_data_single& from);

  inline active_reward_data_single& operator=(const active_reward_data_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_reward_data_single& default_instance();

  void Swap(active_reward_data_single* other);

  // implements Message ----------------------------------------------

  active_reward_data_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_reward_data_single& from);
  void MergeFrom(const active_reward_data_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 tid = 2;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 2;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 event_id = 4;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 4;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional bool is_finish = 6;
  inline bool has_is_finish() const;
  inline void clear_is_finish();
  static const int kIsFinishFieldNumber = 6;
  inline bool is_finish() const;
  inline void set_is_finish(bool value);

  // optional bool is_grant = 7;
  inline bool has_is_grant() const;
  inline void clear_is_grant();
  static const int kIsGrantFieldNumber = 7;
  inline bool is_grant() const;
  inline void set_is_grant(bool value);

  // @@protoc_insertion_point(class_scope:proto.common.active_reward_data_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_is_finish();
  inline void clear_has_is_finish();
  inline void set_has_is_grant();
  inline void clear_has_is_grant();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 count_;
  bool is_finish_;
  bool is_grant_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static active_reward_data_single* default_instance_;
};
// -------------------------------------------------------------------

class active_reward_data : public ::google::protobuf::Message {
 public:
  active_reward_data();
  virtual ~active_reward_data();

  active_reward_data(const active_reward_data& from);

  inline active_reward_data& operator=(const active_reward_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_reward_data& default_instance();

  void Swap(active_reward_data* other);

  // implements Message ----------------------------------------------

  active_reward_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_reward_data& from);
  void MergeFrom(const active_reward_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.active_reward_data_single active_reward = 1;
  inline int active_reward_size() const;
  inline void clear_active_reward();
  static const int kActiveRewardFieldNumber = 1;
  inline const ::proto::common::active_reward_data_single& active_reward(int index) const;
  inline ::proto::common::active_reward_data_single* mutable_active_reward(int index);
  inline ::proto::common::active_reward_data_single* add_active_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::active_reward_data_single >&
      active_reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::active_reward_data_single >*
      mutable_active_reward();

  // @@protoc_insertion_point(class_scope:proto.common.active_reward_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::active_reward_data_single > active_reward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static active_reward_data* default_instance_;
};
// -------------------------------------------------------------------

class active_reward_task_data : public ::google::protobuf::Message {
 public:
  active_reward_task_data();
  virtual ~active_reward_task_data();

  active_reward_task_data(const active_reward_task_data& from);

  inline active_reward_task_data& operator=(const active_reward_task_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const active_reward_task_data& default_instance();

  void Swap(active_reward_task_data* other);

  // implements Message ----------------------------------------------

  active_reward_task_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const active_reward_task_data& from);
  void MergeFrom(const active_reward_task_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 task_list = 1;
  inline int task_list_size() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 1;
  inline ::google::protobuf::uint32 task_list(int index) const;
  inline void set_task_list(int index, ::google::protobuf::uint32 value);
  inline void add_task_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      task_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_task_list();

  // @@protoc_insertion_point(class_scope:proto.common.active_reward_task_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > task_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static active_reward_task_data* default_instance_;
};
// -------------------------------------------------------------------

class cheap_day_single : public ::google::protobuf::Message {
 public:
  cheap_day_single();
  virtual ~cheap_day_single();

  cheap_day_single(const cheap_day_single& from);

  inline cheap_day_single& operator=(const cheap_day_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cheap_day_single& default_instance();

  void Swap(cheap_day_single* other);

  // implements Message ----------------------------------------------

  cheap_day_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cheap_day_single& from);
  void MergeFrom(const cheap_day_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.cheap_day_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static cheap_day_single* default_instance_;
};
// -------------------------------------------------------------------

class cheap_day_client_single : public ::google::protobuf::Message {
 public:
  cheap_day_client_single();
  virtual ~cheap_day_client_single();

  cheap_day_client_single(const cheap_day_client_single& from);

  inline cheap_day_client_single& operator=(const cheap_day_client_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cheap_day_client_single& default_instance();

  void Swap(cheap_day_client_single* other);

  // implements Message ----------------------------------------------

  cheap_day_client_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cheap_day_client_single& from);
  void MergeFrom(const cheap_day_client_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 pay = 2;
  inline bool has_pay() const;
  inline void clear_pay();
  static const int kPayFieldNumber = 2;
  inline ::google::protobuf::uint32 pay() const;
  inline void set_pay(::google::protobuf::uint32 value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 limit = 4;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 4;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string display = 7;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 7;
  inline const ::std::string& display() const;
  inline void set_display(const ::std::string& value);
  inline void set_display(const char* value);
  inline void set_display(const char* value, size_t size);
  inline ::std::string* mutable_display();
  inline ::std::string* release_display();
  inline void set_allocated_display(::std::string* display);

  // optional string pic = 8;
  inline bool has_pic() const;
  inline void clear_pic();
  static const int kPicFieldNumber = 8;
  inline const ::std::string& pic() const;
  inline void set_pic(const ::std::string& value);
  inline void set_pic(const char* value);
  inline void set_pic(const char* value, size_t size);
  inline ::std::string* mutable_pic();
  inline ::std::string* release_pic();
  inline void set_allocated_pic(::std::string* pic);

  // @@protoc_insertion_point(class_scope:proto.common.cheap_day_client_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pay();
  inline void clear_has_pay();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_pic();
  inline void clear_has_pic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 pay_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 limit_;
  ::std::string* name_;
  ::std::string* desc_;
  ::std::string* display_;
  ::std::string* pic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static cheap_day_client_single* default_instance_;
};
// -------------------------------------------------------------------

class recharge_data : public ::google::protobuf::Message {
 public:
  recharge_data();
  virtual ~recharge_data();

  recharge_data(const recharge_data& from);

  inline recharge_data& operator=(const recharge_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_data& default_instance();

  void Swap(recharge_data* other);

  // implements Message ----------------------------------------------

  recharge_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_data& from);
  void MergeFrom(const recharge_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 total_cny = 1;
  inline bool has_total_cny() const;
  inline void clear_total_cny();
  static const int kTotalCnyFieldNumber = 1;
  inline ::google::protobuf::uint32 total_cny() const;
  inline void set_total_cny(::google::protobuf::uint32 value);

  // optional uint32 recharge_flag = 2;
  inline bool has_recharge_flag() const;
  inline void clear_recharge_flag();
  static const int kRechargeFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 recharge_flag() const;
  inline void set_recharge_flag(::google::protobuf::uint32 value);

  // optional uint32 vip_level = 3;
  inline bool has_vip_level() const;
  inline void clear_vip_level();
  static const int kVipLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 vip_level() const;
  inline void set_vip_level(::google::protobuf::uint32 value);

  // optional uint32 recharge_reward_flag = 4;
  inline bool has_recharge_reward_flag() const;
  inline void clear_recharge_reward_flag();
  static const int kRechargeRewardFlagFieldNumber = 4;
  inline ::google::protobuf::uint32 recharge_reward_flag() const;
  inline void set_recharge_reward_flag(::google::protobuf::uint32 value);

  // repeated .proto.common.cheap_day_single cheap_day = 5;
  inline int cheap_day_size() const;
  inline void clear_cheap_day();
  static const int kCheapDayFieldNumber = 5;
  inline const ::proto::common::cheap_day_single& cheap_day(int index) const;
  inline ::proto::common::cheap_day_single* mutable_cheap_day(int index);
  inline ::proto::common::cheap_day_single* add_cheap_day();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::cheap_day_single >&
      cheap_day() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::cheap_day_single >*
      mutable_cheap_day();

  // @@protoc_insertion_point(class_scope:proto.common.recharge_data)
 private:
  inline void set_has_total_cny();
  inline void clear_has_total_cny();
  inline void set_has_recharge_flag();
  inline void clear_has_recharge_flag();
  inline void set_has_vip_level();
  inline void clear_has_vip_level();
  inline void set_has_recharge_reward_flag();
  inline void clear_has_recharge_reward_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 total_cny_;
  ::google::protobuf::uint32 recharge_flag_;
  ::google::protobuf::uint32 vip_level_;
  ::google::protobuf::uint32 recharge_reward_flag_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::cheap_day_single > cheap_day_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static recharge_data* default_instance_;
};
// -------------------------------------------------------------------

class random_shop_item : public ::google::protobuf::Message {
 public:
  random_shop_item();
  virtual ~random_shop_item();

  random_shop_item(const random_shop_item& from);

  inline random_shop_item& operator=(const random_shop_item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const random_shop_item& default_instance();

  void Swap(random_shop_item* other);

  // implements Message ----------------------------------------------

  random_shop_item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const random_shop_item& from);
  void MergeFrom(const random_shop_item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_item = 1;
  inline bool has_shop_item() const;
  inline void clear_shop_item();
  static const int kShopItemFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_item() const;
  inline void set_shop_item(::google::protobuf::uint32 value);

  // optional .proto.common.random_shop_state state = 2 [default = random_shop_state_none];
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::proto::common::random_shop_state state() const;
  inline void set_state(::proto::common::random_shop_state value);

  // @@protoc_insertion_point(class_scope:proto.common.random_shop_item)
 private:
  inline void set_has_shop_item();
  inline void clear_has_shop_item();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shop_item_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static random_shop_item* default_instance_;
};
// -------------------------------------------------------------------

class random_shop_data : public ::google::protobuf::Message {
 public:
  random_shop_data();
  virtual ~random_shop_data();

  random_shop_data(const random_shop_data& from);

  inline random_shop_data& operator=(const random_shop_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const random_shop_data& default_instance();

  void Swap(random_shop_data* other);

  // implements Message ----------------------------------------------

  random_shop_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const random_shop_data& from);
  void MergeFrom(const random_shop_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_id = 1;
  inline bool has_shop_id() const;
  inline void clear_shop_id();
  static const int kShopIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_id() const;
  inline void set_shop_id(::google::protobuf::uint32 value);

  // optional uint32 free_refresh = 2;
  inline bool has_free_refresh() const;
  inline void clear_free_refresh();
  static const int kFreeRefreshFieldNumber = 2;
  inline ::google::protobuf::uint32 free_refresh() const;
  inline void set_free_refresh(::google::protobuf::uint32 value);

  // optional uint32 pay_refresh = 3;
  inline bool has_pay_refresh() const;
  inline void clear_pay_refresh();
  static const int kPayRefreshFieldNumber = 3;
  inline ::google::protobuf::uint32 pay_refresh() const;
  inline void set_pay_refresh(::google::protobuf::uint32 value);

  // optional uint32 next_refresh_time = 4;
  inline bool has_next_refresh_time() const;
  inline void clear_next_refresh_time();
  static const int kNextRefreshTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 next_refresh_time() const;
  inline void set_next_refresh_time(::google::protobuf::uint32 value);

  // repeated .proto.common.random_shop_item items = 5;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 5;
  inline const ::proto::common::random_shop_item& items(int index) const;
  inline ::proto::common::random_shop_item* mutable_items(int index);
  inline ::proto::common::random_shop_item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:proto.common.random_shop_data)
 private:
  inline void set_has_shop_id();
  inline void clear_has_shop_id();
  inline void set_has_free_refresh();
  inline void clear_has_free_refresh();
  inline void set_has_pay_refresh();
  inline void clear_has_pay_refresh();
  inline void set_has_next_refresh_time();
  inline void clear_has_next_refresh_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shop_id_;
  ::google::protobuf::uint32 free_refresh_;
  ::google::protobuf::uint32 pay_refresh_;
  ::google::protobuf::uint32 next_refresh_time_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_item > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static random_shop_data* default_instance_;
};
// -------------------------------------------------------------------

class role_random_shop_data : public ::google::protobuf::Message {
 public:
  role_random_shop_data();
  virtual ~role_random_shop_data();

  role_random_shop_data(const role_random_shop_data& from);

  inline role_random_shop_data& operator=(const role_random_shop_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_random_shop_data& default_instance();

  void Swap(role_random_shop_data* other);

  // implements Message ----------------------------------------------

  role_random_shop_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_random_shop_data& from);
  void MergeFrom(const role_random_shop_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.random_shop_data datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::proto::common::random_shop_data& datas(int index) const;
  inline ::proto::common::random_shop_data* mutable_datas(int index);
  inline ::proto::common::random_shop_data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_data >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:proto.common.role_random_shop_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_data > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_random_shop_data* default_instance_;
};
// -------------------------------------------------------------------

class pve_hero_exp : public ::google::protobuf::Message {
 public:
  pve_hero_exp();
  virtual ~pve_hero_exp();

  pve_hero_exp(const pve_hero_exp& from);

  inline pve_hero_exp& operator=(const pve_hero_exp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pve_hero_exp& default_instance();

  void Swap(pve_hero_exp* other);

  // implements Message ----------------------------------------------

  pve_hero_exp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pve_hero_exp& from);
  void MergeFrom(const pve_hero_exp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hero_uid = 1;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 1;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // optional uint32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.pve_hero_exp)
 private:
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hero_uid_;
  ::google::protobuf::uint32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static pve_hero_exp* default_instance_;
};
// -------------------------------------------------------------------

class level_reward_recived_list : public ::google::protobuf::Message {
 public:
  level_reward_recived_list();
  virtual ~level_reward_recived_list();

  level_reward_recived_list(const level_reward_recived_list& from);

  inline level_reward_recived_list& operator=(const level_reward_recived_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const level_reward_recived_list& default_instance();

  void Swap(level_reward_recived_list* other);

  // implements Message ----------------------------------------------

  level_reward_recived_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const level_reward_recived_list& from);
  void MergeFrom(const level_reward_recived_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::uint32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::uint32 value);
  inline void add_data(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:proto.common.level_reward_recived_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static level_reward_recived_list* default_instance_;
};
// -------------------------------------------------------------------

class level_reward_mail_recived_list : public ::google::protobuf::Message {
 public:
  level_reward_mail_recived_list();
  virtual ~level_reward_mail_recived_list();

  level_reward_mail_recived_list(const level_reward_mail_recived_list& from);

  inline level_reward_mail_recived_list& operator=(const level_reward_mail_recived_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const level_reward_mail_recived_list& default_instance();

  void Swap(level_reward_mail_recived_list* other);

  // implements Message ----------------------------------------------

  level_reward_mail_recived_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const level_reward_mail_recived_list& from);
  void MergeFrom(const level_reward_mail_recived_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::uint32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::uint32 value);
  inline void add_data(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:proto.common.level_reward_mail_recived_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static level_reward_mail_recived_list* default_instance_;
};
// -------------------------------------------------------------------

class offline_role_data : public ::google::protobuf::Message {
 public:
  offline_role_data();
  virtual ~offline_role_data();

  offline_role_data(const offline_role_data& from);

  inline offline_role_data& operator=(const offline_role_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const offline_role_data& default_instance();

  void Swap(offline_role_data* other);

  // implements Message ----------------------------------------------

  offline_role_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const offline_role_data& from);
  void MergeFrom(const offline_role_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.tower_trigger_data tower_trigger = 1;
  inline bool has_tower_trigger() const;
  inline void clear_tower_trigger();
  static const int kTowerTriggerFieldNumber = 1;
  inline const ::proto::common::tower_trigger_data& tower_trigger() const;
  inline ::proto::common::tower_trigger_data* mutable_tower_trigger();
  inline ::proto::common::tower_trigger_data* release_tower_trigger();
  inline void set_allocated_tower_trigger(::proto::common::tower_trigger_data* tower_trigger);

  // @@protoc_insertion_point(class_scope:proto.common.offline_role_data)
 private:
  inline void set_has_tower_trigger();
  inline void clear_has_tower_trigger();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::tower_trigger_data* tower_trigger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static offline_role_data* default_instance_;
};
// -------------------------------------------------------------------

class sys_notity_single : public ::google::protobuf::Message {
 public:
  sys_notity_single();
  virtual ~sys_notity_single();

  sys_notity_single(const sys_notity_single& from);

  inline sys_notity_single& operator=(const sys_notity_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_notity_single& default_instance();

  void Swap(sys_notity_single* other);

  // implements Message ----------------------------------------------

  sys_notity_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_notity_single& from);
  void MergeFrom(const sys_notity_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.sys_notity_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 param_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sys_notity_single* default_instance_;
};
// -------------------------------------------------------------------

class sys_notity_data : public ::google::protobuf::Message {
 public:
  sys_notity_data();
  virtual ~sys_notity_data();

  sys_notity_data(const sys_notity_data& from);

  inline sys_notity_data& operator=(const sys_notity_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_notity_data& default_instance();

  void Swap(sys_notity_data* other);

  // implements Message ----------------------------------------------

  sys_notity_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_notity_data& from);
  void MergeFrom(const sys_notity_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.sys_notity_single sys_notity_data_list = 1;
  inline int sys_notity_data_list_size() const;
  inline void clear_sys_notity_data_list();
  static const int kSysNotityDataListFieldNumber = 1;
  inline const ::proto::common::sys_notity_single& sys_notity_data_list(int index) const;
  inline ::proto::common::sys_notity_single* mutable_sys_notity_data_list(int index);
  inline ::proto::common::sys_notity_single* add_sys_notity_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::sys_notity_single >&
      sys_notity_data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::sys_notity_single >*
      mutable_sys_notity_data_list();

  // @@protoc_insertion_point(class_scope:proto.common.sys_notity_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::sys_notity_single > sys_notity_data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sys_notity_data* default_instance_;
};
// -------------------------------------------------------------------

class public_struct : public ::google::protobuf::Message {
 public:
  public_struct();
  virtual ~public_struct();

  public_struct(const public_struct& from);

  inline public_struct& operator=(const public_struct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const public_struct& default_instance();

  void Swap(public_struct* other);

  // implements Message ----------------------------------------------

  public_struct* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const public_struct& from);
  void MergeFrom(const public_struct& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::google::protobuf::uint32 param() const;
  inline void set_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.public_struct)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static public_struct* default_instance_;
};
// -------------------------------------------------------------------

class multi_time_data : public ::google::protobuf::Message {
 public:
  multi_time_data();
  virtual ~multi_time_data();

  multi_time_data(const multi_time_data& from);

  inline multi_time_data& operator=(const multi_time_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const multi_time_data& default_instance();

  void Swap(multi_time_data* other);

  // implements Message ----------------------------------------------

  multi_time_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const multi_time_data& from);
  void MergeFrom(const multi_time_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.public_struct time_long_list = 1;
  inline int time_long_list_size() const;
  inline void clear_time_long_list();
  static const int kTimeLongListFieldNumber = 1;
  inline const ::proto::common::public_struct& time_long_list(int index) const;
  inline ::proto::common::public_struct* mutable_time_long_list(int index);
  inline ::proto::common::public_struct* add_time_long_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::public_struct >&
      time_long_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::public_struct >*
      mutable_time_long_list();

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.multi_time_data)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::public_struct > time_long_list_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static multi_time_data* default_instance_;
};
// -------------------------------------------------------------------

class draw_single : public ::google::protobuf::Message {
 public:
  draw_single();
  virtual ~draw_single();

  draw_single(const draw_single& from);

  inline draw_single& operator=(const draw_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const draw_single& default_instance();

  void Swap(draw_single* other);

  // implements Message ----------------------------------------------

  draw_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const draw_single& from);
  void MergeFrom(const draw_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_uid = 1;
  inline bool has_role_uid() const;
  inline void clear_role_uid();
  static const int kRoleUidFieldNumber = 1;
  inline const ::std::string& role_uid() const;
  inline void set_role_uid(const ::std::string& value);
  inline void set_role_uid(const char* value);
  inline void set_role_uid(const char* value, size_t size);
  inline ::std::string* mutable_role_uid();
  inline ::std::string* release_role_uid();
  inline void set_allocated_role_uid(::std::string* role_uid);

  // optional string role_name = 2;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.draw_single)
 private:
  inline void set_has_role_uid();
  inline void clear_has_role_uid();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_uid_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static draw_single* default_instance_;
};
// -------------------------------------------------------------------

class draw_data : public ::google::protobuf::Message {
 public:
  draw_data();
  virtual ~draw_data();

  draw_data(const draw_data& from);

  inline draw_data& operator=(const draw_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const draw_data& default_instance();

  void Swap(draw_data* other);

  // implements Message ----------------------------------------------

  draw_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const draw_data& from);
  void MergeFrom(const draw_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.draw_single draw_info = 1;
  inline int draw_info_size() const;
  inline void clear_draw_info();
  static const int kDrawInfoFieldNumber = 1;
  inline const ::proto::common::draw_single& draw_info(int index) const;
  inline ::proto::common::draw_single* mutable_draw_info(int index);
  inline ::proto::common::draw_single* add_draw_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::draw_single >&
      draw_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::draw_single >*
      mutable_draw_info();

  // @@protoc_insertion_point(class_scope:proto.common.draw_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::draw_single > draw_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static draw_data* default_instance_;
};
// -------------------------------------------------------------------

class redbag_data : public ::google::protobuf::Message {
 public:
  redbag_data();
  virtual ~redbag_data();

  redbag_data(const redbag_data& from);

  inline redbag_data& operator=(const redbag_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const redbag_data& default_instance();

  void Swap(redbag_data* other);

  // implements Message ----------------------------------------------

  redbag_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const redbag_data& from);
  void MergeFrom(const redbag_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string sender_uid = 2;
  inline bool has_sender_uid() const;
  inline void clear_sender_uid();
  static const int kSenderUidFieldNumber = 2;
  inline const ::std::string& sender_uid() const;
  inline void set_sender_uid(const ::std::string& value);
  inline void set_sender_uid(const char* value);
  inline void set_sender_uid(const char* value, size_t size);
  inline ::std::string* mutable_sender_uid();
  inline ::std::string* release_sender_uid();
  inline void set_allocated_sender_uid(::std::string* sender_uid);

  // optional string sender_name = 3;
  inline bool has_sender_name() const;
  inline void clear_sender_name();
  static const int kSenderNameFieldNumber = 3;
  inline const ::std::string& sender_name() const;
  inline void set_sender_name(const ::std::string& value);
  inline void set_sender_name(const char* value);
  inline void set_sender_name(const char* value, size_t size);
  inline ::std::string* mutable_sender_name();
  inline ::std::string* release_sender_name();
  inline void set_allocated_sender_name(::std::string* sender_name);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 rest_count = 6;
  inline bool has_rest_count() const;
  inline void clear_rest_count();
  static const int kRestCountFieldNumber = 6;
  inline ::google::protobuf::uint32 rest_count() const;
  inline void set_rest_count(::google::protobuf::uint32 value);

  // optional uint32 rest_money = 7;
  inline bool has_rest_money() const;
  inline void clear_rest_money();
  static const int kRestMoneyFieldNumber = 7;
  inline ::google::protobuf::uint32 rest_money() const;
  inline void set_rest_money(::google::protobuf::uint32 value);

  // optional uint32 send_time = 8;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 send_time() const;
  inline void set_send_time(::google::protobuf::uint32 value);

  // optional uint32 finish_time = 9;
  inline bool has_finish_time() const;
  inline void clear_finish_time();
  static const int kFinishTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 finish_time() const;
  inline void set_finish_time(::google::protobuf::uint32 value);

  // optional .proto.common.draw_data draw_data = 10;
  inline bool has_draw_data() const;
  inline void clear_draw_data();
  static const int kDrawDataFieldNumber = 10;
  inline const ::proto::common::draw_data& draw_data() const;
  inline ::proto::common::draw_data* mutable_draw_data();
  inline ::proto::common::draw_data* release_draw_data();
  inline void set_allocated_draw_data(::proto::common::draw_data* draw_data);

  // @@protoc_insertion_point(class_scope:proto.common.redbag_data)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_sender_uid();
  inline void clear_has_sender_uid();
  inline void set_has_sender_name();
  inline void clear_has_sender_name();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_rest_count();
  inline void clear_has_rest_count();
  inline void set_has_rest_money();
  inline void clear_has_rest_money();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_finish_time();
  inline void clear_has_finish_time();
  inline void set_has_draw_data();
  inline void clear_has_draw_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* sender_uid_;
  ::std::string* sender_name_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 rest_count_;
  ::google::protobuf::uint32 rest_money_;
  ::google::protobuf::uint32 send_time_;
  ::google::protobuf::uint32 finish_time_;
  ::proto::common::draw_data* draw_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static redbag_data* default_instance_;
};
// -------------------------------------------------------------------

class other_rank_data : public ::google::protobuf::Message {
 public:
  other_rank_data();
  virtual ~other_rank_data();

  other_rank_data(const other_rank_data& from);

  inline other_rank_data& operator=(const other_rank_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const other_rank_data& default_instance();

  void Swap(other_rank_data* other);

  // implements Message ----------------------------------------------

  other_rank_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const other_rank_data& from);
  void MergeFrom(const other_rank_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::uint32 value() const;
  inline void set_value(::google::protobuf::uint32 value);

  // optional uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.other_rank_data)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static other_rank_data* default_instance_;
};
// -------------------------------------------------------------------

class role_base_data : public ::google::protobuf::Message {
 public:
  role_base_data();
  virtual ~role_base_data();

  role_base_data(const role_base_data& from);

  inline role_base_data& operator=(const role_base_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_base_data& default_instance();

  void Swap(role_base_data* other);

  // implements Message ----------------------------------------------

  role_base_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_base_data& from);
  void MergeFrom(const role_base_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 role_level = 1;
  inline bool has_role_level() const;
  inline void clear_role_level();
  static const int kRoleLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 role_level() const;
  inline void set_role_level(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string family_name = 3;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 3;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 head_info = 4;
  inline bool has_head_info() const;
  inline void clear_head_info();
  static const int kHeadInfoFieldNumber = 4;
  inline ::google::protobuf::uint32 head_info() const;
  inline void set_head_info(::google::protobuf::uint32 value);

  // optional string country_name = 5;
  inline bool has_country_name() const;
  inline void clear_country_name();
  static const int kCountryNameFieldNumber = 5;
  inline const ::std::string& country_name() const;
  inline void set_country_name(const ::std::string& value);
  inline void set_country_name(const char* value);
  inline void set_country_name(const char* value, size_t size);
  inline ::std::string* mutable_country_name();
  inline ::std::string* release_country_name();
  inline void set_allocated_country_name(::std::string* country_name);

  // optional uint32 fighting = 6;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 6;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional string team_id = 7;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 7;
  inline const ::std::string& team_id() const;
  inline void set_team_id(const ::std::string& value);
  inline void set_team_id(const char* value);
  inline void set_team_id(const char* value, size_t size);
  inline ::std::string* mutable_team_id();
  inline ::std::string* release_team_id();
  inline void set_allocated_team_id(::std::string* team_id);

  // optional uint32 country_flag = 8;
  inline bool has_country_flag() const;
  inline void clear_country_flag();
  static const int kCountryFlagFieldNumber = 8;
  inline ::google::protobuf::uint32 country_flag() const;
  inline void set_country_flag(::google::protobuf::uint32 value);

  // optional uint32 charm = 9;
  inline bool has_charm() const;
  inline void clear_charm();
  static const int kCharmFieldNumber = 9;
  inline ::google::protobuf::uint32 charm() const;
  inline void set_charm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.role_base_data)
 private:
  inline void set_has_role_level();
  inline void clear_has_role_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_head_info();
  inline void clear_has_head_info();
  inline void set_has_country_name();
  inline void clear_has_country_name();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_country_flag();
  inline void clear_has_country_flag();
  inline void set_has_charm();
  inline void clear_has_charm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 role_level_;
  ::google::protobuf::uint32 head_info_;
  ::std::string* family_name_;
  ::std::string* country_name_;
  ::std::string* team_id_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 country_flag_;
  ::google::protobuf::uint32 charm_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_base_data* default_instance_;
};
// -------------------------------------------------------------------

class role_simple_data : public ::google::protobuf::Message {
 public:
  role_simple_data();
  virtual ~role_simple_data();

  role_simple_data(const role_simple_data& from);

  inline role_simple_data& operator=(const role_simple_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_simple_data& default_instance();

  void Swap(role_simple_data* other);

  // implements Message ----------------------------------------------

  role_simple_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_simple_data& from);
  void MergeFrom(const role_simple_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.role_base_data base = 1;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 1;
  inline const ::proto::common::role_base_data& base() const;
  inline ::proto::common::role_base_data* mutable_base();
  inline ::proto::common::role_base_data* release_base();
  inline void set_allocated_base(::proto::common::role_base_data* base);

  // optional .proto.common.hero_data hero = 2;
  inline bool has_hero() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 2;
  inline const ::proto::common::hero_data& hero() const;
  inline ::proto::common::hero_data* mutable_hero();
  inline ::proto::common::hero_data* release_hero();
  inline void set_allocated_hero(::proto::common::hero_data* hero);

  // optional .proto.common.item_data item = 3;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::proto::common::item_data& item() const;
  inline ::proto::common::item_data* mutable_item();
  inline ::proto::common::item_data* release_item();
  inline void set_allocated_item(::proto::common::item_data* item);

  // @@protoc_insertion_point(class_scope:proto.common.role_simple_data)
 private:
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_hero();
  inline void clear_has_hero();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::role_base_data* base_;
  ::proto::common::hero_data* hero_;
  ::proto::common::item_data* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_simple_data* default_instance_;
};
// -------------------------------------------------------------------

class role_blob_data : public ::google::protobuf::Message {
 public:
  role_blob_data();
  virtual ~role_blob_data();

  role_blob_data(const role_blob_data& from);

  inline role_blob_data& operator=(const role_blob_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const role_blob_data& default_instance();

  void Swap(role_blob_data* other);

  // implements Message ----------------------------------------------

  role_blob_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const role_blob_data& from);
  void MergeFrom(const role_blob_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.role_simple_data simple = 1;
  inline bool has_simple() const;
  inline void clear_simple();
  static const int kSimpleFieldNumber = 1;
  inline const ::proto::common::role_simple_data& simple() const;
  inline ::proto::common::role_simple_data* mutable_simple();
  inline ::proto::common::role_simple_data* release_simple();
  inline void set_allocated_simple(::proto::common::role_simple_data* simple);

  // @@protoc_insertion_point(class_scope:proto.common.role_blob_data)
 private:
  inline void set_has_simple();
  inline void clear_has_simple();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::role_simple_data* simple_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static role_blob_data* default_instance_;
};
// -------------------------------------------------------------------

class hero_strategy_info : public ::google::protobuf::Message {
 public:
  hero_strategy_info();
  virtual ~hero_strategy_info();

  hero_strategy_info(const hero_strategy_info& from);

  inline hero_strategy_info& operator=(const hero_strategy_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_strategy_info& default_instance();

  void Swap(hero_strategy_info* other);

  // implements Message ----------------------------------------------

  hero_strategy_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_strategy_info& from);
  void MergeFrom(const hero_strategy_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hero_tid = 1;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 1;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional uint32 hero_use_rate = 2;
  inline bool has_hero_use_rate() const;
  inline void clear_hero_use_rate();
  static const int kHeroUseRateFieldNumber = 2;
  inline ::google::protobuf::uint32 hero_use_rate() const;
  inline void set_hero_use_rate(::google::protobuf::uint32 value);

  // optional uint32 hero_use_hot = 3;
  inline bool has_hero_use_hot() const;
  inline void clear_hero_use_hot();
  static const int kHeroUseHotFieldNumber = 3;
  inline ::google::protobuf::uint32 hero_use_hot() const;
  inline void set_hero_use_hot(::google::protobuf::uint32 value);

  // repeated .proto.common.hero_strategy_single role_list = 4;
  inline int role_list_size() const;
  inline void clear_role_list();
  static const int kRoleListFieldNumber = 4;
  inline const ::proto::common::hero_strategy_single& role_list(int index) const;
  inline ::proto::common::hero_strategy_single* mutable_role_list(int index);
  inline ::proto::common::hero_strategy_single* add_role_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_strategy_single >&
      role_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_strategy_single >*
      mutable_role_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_strategy_info)
 private:
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_hero_use_rate();
  inline void clear_has_hero_use_rate();
  inline void set_has_hero_use_hot();
  inline void clear_has_hero_use_hot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 hero_use_rate_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::hero_strategy_single > role_list_;
  ::google::protobuf::uint32 hero_use_hot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_strategy_info* default_instance_;
};
// -------------------------------------------------------------------

class hero_strategy_single : public ::google::protobuf::Message {
 public:
  hero_strategy_single();
  virtual ~hero_strategy_single();

  hero_strategy_single(const hero_strategy_single& from);

  inline hero_strategy_single& operator=(const hero_strategy_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_strategy_single& default_instance();

  void Swap(hero_strategy_single* other);

  // implements Message ----------------------------------------------

  hero_strategy_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_strategy_single& from);
  void MergeFrom(const hero_strategy_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_name = 1;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 role_rank = 2;
  inline bool has_role_rank() const;
  inline void clear_role_rank();
  static const int kRoleRankFieldNumber = 2;
  inline ::google::protobuf::uint32 role_rank() const;
  inline void set_role_rank(::google::protobuf::uint32 value);

  // optional uint32 role_score = 3;
  inline bool has_role_score() const;
  inline void clear_role_score();
  static const int kRoleScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 role_score() const;
  inline void set_role_score(::google::protobuf::uint32 value);

  // optional uint32 server_id = 4;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 4;
  inline ::google::protobuf::uint32 server_id() const;
  inline void set_server_id(::google::protobuf::uint32 value);

  // optional string server_name = 5;
  inline bool has_server_name() const;
  inline void clear_server_name();
  static const int kServerNameFieldNumber = 5;
  inline const ::std::string& server_name() const;
  inline void set_server_name(const ::std::string& value);
  inline void set_server_name(const char* value);
  inline void set_server_name(const char* value, size_t size);
  inline ::std::string* mutable_server_name();
  inline ::std::string* release_server_name();
  inline void set_allocated_server_name(::std::string* server_name);

  // optional .proto.common.hero_strategy_equip_info equip_info_list = 6;
  inline bool has_equip_info_list() const;
  inline void clear_equip_info_list();
  static const int kEquipInfoListFieldNumber = 6;
  inline const ::proto::common::hero_strategy_equip_info& equip_info_list() const;
  inline ::proto::common::hero_strategy_equip_info* mutable_equip_info_list();
  inline ::proto::common::hero_strategy_equip_info* release_equip_info_list();
  inline void set_allocated_equip_info_list(::proto::common::hero_strategy_equip_info* equip_info_list);

  // optional .proto.common.hero_strategy_hero_info hero_info_list = 7;
  inline bool has_hero_info_list() const;
  inline void clear_hero_info_list();
  static const int kHeroInfoListFieldNumber = 7;
  inline const ::proto::common::hero_strategy_hero_info& hero_info_list() const;
  inline ::proto::common::hero_strategy_hero_info* mutable_hero_info_list();
  inline ::proto::common::hero_strategy_hero_info* release_hero_info_list();
  inline void set_allocated_hero_info_list(::proto::common::hero_strategy_hero_info* hero_info_list);

  // @@protoc_insertion_point(class_scope:proto.common.hero_strategy_single)
 private:
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_role_rank();
  inline void clear_has_role_rank();
  inline void set_has_role_score();
  inline void clear_has_role_score();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_server_name();
  inline void clear_has_server_name();
  inline void set_has_equip_info_list();
  inline void clear_has_equip_info_list();
  inline void set_has_hero_info_list();
  inline void clear_has_hero_info_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_name_;
  ::google::protobuf::uint32 role_rank_;
  ::google::protobuf::uint32 role_score_;
  ::std::string* server_name_;
  ::proto::common::hero_strategy_equip_info* equip_info_list_;
  ::proto::common::hero_strategy_hero_info* hero_info_list_;
  ::google::protobuf::uint32 server_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_strategy_single* default_instance_;
};
// -------------------------------------------------------------------

class hero_strategy_equip_info : public ::google::protobuf::Message {
 public:
  hero_strategy_equip_info();
  virtual ~hero_strategy_equip_info();

  hero_strategy_equip_info(const hero_strategy_equip_info& from);

  inline hero_strategy_equip_info& operator=(const hero_strategy_equip_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_strategy_equip_info& default_instance();

  void Swap(hero_strategy_equip_info* other);

  // implements Message ----------------------------------------------

  hero_strategy_equip_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_strategy_equip_info& from);
  void MergeFrom(const hero_strategy_equip_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.item_single equip_list = 1;
  inline int equip_list_size() const;
  inline void clear_equip_list();
  static const int kEquipListFieldNumber = 1;
  inline const ::proto::common::item_single& equip_list(int index) const;
  inline ::proto::common::item_single* mutable_equip_list(int index);
  inline ::proto::common::item_single* add_equip_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
      equip_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
      mutable_equip_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_strategy_equip_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::item_single > equip_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_strategy_equip_info* default_instance_;
};
// -------------------------------------------------------------------

class hero_strategy_hero_info : public ::google::protobuf::Message {
 public:
  hero_strategy_hero_info();
  virtual ~hero_strategy_hero_info();

  hero_strategy_hero_info(const hero_strategy_hero_info& from);

  inline hero_strategy_hero_info& operator=(const hero_strategy_hero_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_strategy_hero_info& default_instance();

  void Swap(hero_strategy_hero_info* other);

  // implements Message ----------------------------------------------

  hero_strategy_hero_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_strategy_hero_info& from);
  void MergeFrom(const hero_strategy_hero_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 hero_tid_list = 1;
  inline int hero_tid_list_size() const;
  inline void clear_hero_tid_list();
  static const int kHeroTidListFieldNumber = 1;
  inline ::google::protobuf::uint32 hero_tid_list(int index) const;
  inline void set_hero_tid_list(int index, ::google::protobuf::uint32 value);
  inline void add_hero_tid_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hero_tid_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hero_tid_list();

  // @@protoc_insertion_point(class_scope:proto.common.hero_strategy_hero_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hero_tid_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_strategy_hero_info* default_instance_;
};
// -------------------------------------------------------------------

class hero_strategy_comment_info : public ::google::protobuf::Message {
 public:
  hero_strategy_comment_info();
  virtual ~hero_strategy_comment_info();

  hero_strategy_comment_info(const hero_strategy_comment_info& from);

  inline hero_strategy_comment_info& operator=(const hero_strategy_comment_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_strategy_comment_info& default_instance();

  void Swap(hero_strategy_comment_info* other);

  // implements Message ----------------------------------------------

  hero_strategy_comment_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_strategy_comment_info& from);
  void MergeFrom(const hero_strategy_comment_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hero_tid = 1;
  inline bool has_hero_tid() const;
  inline void clear_hero_tid();
  static const int kHeroTidFieldNumber = 1;
  inline ::google::protobuf::uint32 hero_tid() const;
  inline void set_hero_tid(::google::protobuf::uint32 value);

  // optional string comment_info = 2;
  inline bool has_comment_info() const;
  inline void clear_comment_info();
  static const int kCommentInfoFieldNumber = 2;
  inline const ::std::string& comment_info() const;
  inline void set_comment_info(const ::std::string& value);
  inline void set_comment_info(const char* value);
  inline void set_comment_info(const char* value, size_t size);
  inline ::std::string* mutable_comment_info();
  inline ::std::string* release_comment_info();
  inline void set_allocated_comment_info(::std::string* comment_info);

  // optional string role_info = 3;
  inline bool has_role_info() const;
  inline void clear_role_info();
  static const int kRoleInfoFieldNumber = 3;
  inline const ::std::string& role_info() const;
  inline void set_role_info(const ::std::string& value);
  inline void set_role_info(const char* value);
  inline void set_role_info(const char* value, size_t size);
  inline ::std::string* mutable_role_info();
  inline ::std::string* release_role_info();
  inline void set_allocated_role_info(::std::string* role_info);

  // optional uint32 like_num = 4;
  inline bool has_like_num() const;
  inline void clear_like_num();
  static const int kLikeNumFieldNumber = 4;
  inline ::google::protobuf::uint32 like_num() const;
  inline void set_like_num(::google::protobuf::uint32 value);

  // optional uint32 dislike_num = 5;
  inline bool has_dislike_num() const;
  inline void clear_dislike_num();
  static const int kDislikeNumFieldNumber = 5;
  inline ::google::protobuf::uint32 dislike_num() const;
  inline void set_dislike_num(::google::protobuf::uint32 value);

  // optional uint32 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.hero_strategy_comment_info)
 private:
  inline void set_has_hero_tid();
  inline void clear_has_hero_tid();
  inline void set_has_comment_info();
  inline void clear_has_comment_info();
  inline void set_has_role_info();
  inline void clear_has_role_info();
  inline void set_has_like_num();
  inline void clear_has_like_num();
  inline void set_has_dislike_num();
  inline void clear_has_dislike_num();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* comment_info_;
  ::google::protobuf::uint32 hero_tid_;
  ::google::protobuf::uint32 like_num_;
  ::std::string* role_info_;
  ::google::protobuf::uint32 dislike_num_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_strategy_comment_info* default_instance_;
};
// -------------------------------------------------------------------

class offline_arena_single : public ::google::protobuf::Message {
 public:
  offline_arena_single();
  virtual ~offline_arena_single();

  offline_arena_single(const offline_arena_single& from);

  inline offline_arena_single& operator=(const offline_arena_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const offline_arena_single& default_instance();

  void Swap(offline_arena_single* other);

  // implements Message ----------------------------------------------

  offline_arena_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const offline_arena_single& from);
  void MergeFrom(const offline_arena_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string role_uid = 1;
  inline bool has_role_uid() const;
  inline void clear_role_uid();
  static const int kRoleUidFieldNumber = 1;
  inline const ::std::string& role_uid() const;
  inline void set_role_uid(const ::std::string& value);
  inline void set_role_uid(const char* value);
  inline void set_role_uid(const char* value, size_t size);
  inline ::std::string* mutable_role_uid();
  inline ::std::string* release_role_uid();
  inline void set_allocated_role_uid(::std::string* role_uid);

  // optional uint32 cur_class = 2;
  inline bool has_cur_class() const;
  inline void clear_cur_class();
  static const int kCurClassFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_class() const;
  inline void set_cur_class(::google::protobuf::uint32 value);

  // optional uint32 cur_rank = 3;
  inline bool has_cur_rank() const;
  inline void clear_cur_rank();
  static const int kCurRankFieldNumber = 3;
  inline ::google::protobuf::uint32 cur_rank() const;
  inline void set_cur_rank(::google::protobuf::uint32 value);

  // optional uint32 old_record_rank = 4;
  inline bool has_old_record_rank() const;
  inline void clear_old_record_rank();
  static const int kOldRecordRankFieldNumber = 4;
  inline ::google::protobuf::uint32 old_record_rank() const;
  inline void set_old_record_rank(::google::protobuf::uint32 value);

  // optional uint32 record_rank = 5;
  inline bool has_record_rank() const;
  inline void clear_record_rank();
  static const int kRecordRankFieldNumber = 5;
  inline ::google::protobuf::uint32 record_rank() const;
  inline void set_record_rank(::google::protobuf::uint32 value);

  // optional uint32 old_class = 6;
  inline bool has_old_class() const;
  inline void clear_old_class();
  static const int kOldClassFieldNumber = 6;
  inline ::google::protobuf::uint32 old_class() const;
  inline void set_old_class(::google::protobuf::uint32 value);

  // optional uint32 fight_count = 7;
  inline bool has_fight_count() const;
  inline void clear_fight_count();
  static const int kFightCountFieldNumber = 7;
  inline ::google::protobuf::uint32 fight_count() const;
  inline void set_fight_count(::google::protobuf::uint32 value);

  // optional uint32 buy_count = 8;
  inline bool has_buy_count() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 8;
  inline ::google::protobuf::uint32 buy_count() const;
  inline void set_buy_count(::google::protobuf::uint32 value);

  // optional .proto.common.mirror_fight_data form_data = 9;
  inline bool has_form_data() const;
  inline void clear_form_data();
  static const int kFormDataFieldNumber = 9;
  inline const ::proto::common::mirror_fight_data& form_data() const;
  inline ::proto::common::mirror_fight_data* mutable_form_data();
  inline ::proto::common::mirror_fight_data* release_form_data();
  inline void set_allocated_form_data(::proto::common::mirror_fight_data* form_data);

  // optional uint32 score = 10;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 10;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // repeated .proto.common.liveness_box score_box = 11;
  inline int score_box_size() const;
  inline void clear_score_box();
  static const int kScoreBoxFieldNumber = 11;
  inline const ::proto::common::liveness_box& score_box(int index) const;
  inline ::proto::common::liveness_box* mutable_score_box(int index);
  inline ::proto::common::liveness_box* add_score_box();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
      score_box() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
      mutable_score_box();

  // @@protoc_insertion_point(class_scope:proto.common.offline_arena_single)
 private:
  inline void set_has_role_uid();
  inline void clear_has_role_uid();
  inline void set_has_cur_class();
  inline void clear_has_cur_class();
  inline void set_has_cur_rank();
  inline void clear_has_cur_rank();
  inline void set_has_old_record_rank();
  inline void clear_has_old_record_rank();
  inline void set_has_record_rank();
  inline void clear_has_record_rank();
  inline void set_has_old_class();
  inline void clear_has_old_class();
  inline void set_has_fight_count();
  inline void clear_has_fight_count();
  inline void set_has_buy_count();
  inline void clear_has_buy_count();
  inline void set_has_form_data();
  inline void clear_has_form_data();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_uid_;
  ::google::protobuf::uint32 cur_class_;
  ::google::protobuf::uint32 cur_rank_;
  ::google::protobuf::uint32 old_record_rank_;
  ::google::protobuf::uint32 record_rank_;
  ::google::protobuf::uint32 old_class_;
  ::google::protobuf::uint32 fight_count_;
  ::proto::common::mirror_fight_data* form_data_;
  ::google::protobuf::uint32 buy_count_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box > score_box_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static offline_arena_single* default_instance_;
};
// -------------------------------------------------------------------

class offline_arena_general : public ::google::protobuf::Message {
 public:
  offline_arena_general();
  virtual ~offline_arena_general();

  offline_arena_general(const offline_arena_general& from);

  inline offline_arena_general& operator=(const offline_arena_general& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const offline_arena_general& default_instance();

  void Swap(offline_arena_general* other);

  // implements Message ----------------------------------------------

  offline_arena_general* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const offline_arena_general& from);
  void MergeFrom(const offline_arena_general& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 1 [default = SCENEOBJECT_USER];
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 1;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional string role_uid = 2;
  inline bool has_role_uid() const;
  inline void clear_role_uid();
  static const int kRoleUidFieldNumber = 2;
  inline const ::std::string& role_uid() const;
  inline void set_role_uid(const ::std::string& value);
  inline void set_role_uid(const char* value);
  inline void set_role_uid(const char* value, size_t size);
  inline ::std::string* mutable_role_uid();
  inline ::std::string* release_role_uid();
  inline void set_allocated_role_uid(::std::string* role_uid);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional string family_name = 4;
  inline bool has_family_name() const;
  inline void clear_family_name();
  static const int kFamilyNameFieldNumber = 4;
  inline const ::std::string& family_name() const;
  inline void set_family_name(const ::std::string& value);
  inline void set_family_name(const char* value);
  inline void set_family_name(const char* value, size_t size);
  inline ::std::string* mutable_family_name();
  inline ::std::string* release_family_name();
  inline void set_allocated_family_name(::std::string* family_name);

  // optional uint32 fighting = 5;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 5;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 cur_rank = 6;
  inline bool has_cur_rank() const;
  inline void clear_cur_rank();
  static const int kCurRankFieldNumber = 6;
  inline ::google::protobuf::uint32 cur_rank() const;
  inline void set_cur_rank(::google::protobuf::uint32 value);

  // optional uint32 plugin = 7;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 7;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 fight_against_id = 9;
  inline bool has_fight_against_id() const;
  inline void clear_fight_against_id();
  static const int kFightAgainstIdFieldNumber = 9;
  inline ::google::protobuf::uint32 fight_against_id() const;
  inline void set_fight_against_id(::google::protobuf::uint32 value);

  // optional uint32 headpic = 10;
  inline bool has_headpic() const;
  inline void clear_headpic();
  static const int kHeadpicFieldNumber = 10;
  inline ::google::protobuf::uint32 headpic() const;
  inline void set_headpic(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.offline_arena_general)
 private:
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_role_uid();
  inline void clear_has_role_uid();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_family_name();
  inline void clear_has_family_name();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_cur_rank();
  inline void clear_has_cur_rank();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_fight_against_id();
  inline void clear_has_fight_against_id();
  inline void set_has_headpic();
  inline void clear_has_headpic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_uid_;
  ::std::string* role_name_;
  int object_type_;
  ::google::protobuf::uint32 fighting_;
  ::std::string* family_name_;
  ::google::protobuf::uint32 cur_rank_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 fight_against_id_;
  ::google::protobuf::uint32 headpic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static offline_arena_general* default_instance_;
};
// -------------------------------------------------------------------

class offline_arena_record : public ::google::protobuf::Message {
 public:
  offline_arena_record();
  virtual ~offline_arena_record();

  offline_arena_record(const offline_arena_record& from);

  inline offline_arena_record& operator=(const offline_arena_record& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const offline_arena_record& default_instance();

  void Swap(offline_arena_record* other);

  // implements Message ----------------------------------------------

  offline_arena_record* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const offline_arena_record& from);
  void MergeFrom(const offline_arena_record& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 1 [default = SCENEOBJECT_USER];
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 1;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional string role_uid = 2;
  inline bool has_role_uid() const;
  inline void clear_role_uid();
  static const int kRoleUidFieldNumber = 2;
  inline const ::std::string& role_uid() const;
  inline void set_role_uid(const ::std::string& value);
  inline void set_role_uid(const char* value);
  inline void set_role_uid(const char* value, size_t size);
  inline ::std::string* mutable_role_uid();
  inline ::std::string* release_role_uid();
  inline void set_allocated_role_uid(::std::string* role_uid);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // optional uint32 fighting = 4;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 4;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 plugin = 5;
  inline bool has_plugin() const;
  inline void clear_plugin();
  static const int kPluginFieldNumber = 5;
  inline ::google::protobuf::uint32 plugin() const;
  inline void set_plugin(::google::protobuf::uint32 value);

  // optional uint32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 record_time = 7;
  inline bool has_record_time() const;
  inline void clear_record_time();
  static const int kRecordTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 record_time() const;
  inline void set_record_time(::google::protobuf::uint32 value);

  // optional uint32 old_rank = 8;
  inline bool has_old_rank() const;
  inline void clear_old_rank();
  static const int kOldRankFieldNumber = 8;
  inline ::google::protobuf::uint32 old_rank() const;
  inline void set_old_rank(::google::protobuf::uint32 value);

  // optional uint32 new_rank = 9;
  inline bool has_new_rank() const;
  inline void clear_new_rank();
  static const int kNewRankFieldNumber = 9;
  inline ::google::protobuf::uint32 new_rank() const;
  inline void set_new_rank(::google::protobuf::uint32 value);

  // optional uint32 is_win = 10;
  inline bool has_is_win() const;
  inline void clear_is_win();
  static const int kIsWinFieldNumber = 10;
  inline ::google::protobuf::uint32 is_win() const;
  inline void set_is_win(::google::protobuf::uint32 value);

  // optional uint32 side = 11;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 11;
  inline ::google::protobuf::uint32 side() const;
  inline void set_side(::google::protobuf::uint32 value);

  // optional uint32 headpic = 12;
  inline bool has_headpic() const;
  inline void clear_headpic();
  static const int kHeadpicFieldNumber = 12;
  inline ::google::protobuf::uint32 headpic() const;
  inline void set_headpic(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.offline_arena_record)
 private:
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_role_uid();
  inline void clear_has_role_uid();
  inline void set_has_role_name();
  inline void clear_has_role_name();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_plugin();
  inline void clear_has_plugin();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_record_time();
  inline void clear_has_record_time();
  inline void set_has_old_rank();
  inline void clear_has_old_rank();
  inline void set_has_new_rank();
  inline void clear_has_new_rank();
  inline void set_has_is_win();
  inline void clear_has_is_win();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_headpic();
  inline void clear_has_headpic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* role_uid_;
  int object_type_;
  ::google::protobuf::uint32 fighting_;
  ::std::string* role_name_;
  ::google::protobuf::uint32 plugin_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 record_time_;
  ::google::protobuf::uint32 old_rank_;
  ::google::protobuf::uint32 new_rank_;
  ::google::protobuf::uint32 is_win_;
  ::google::protobuf::uint32 side_;
  ::google::protobuf::uint32 headpic_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static offline_arena_record* default_instance_;
};
// -------------------------------------------------------------------

class offline_arena_record_data : public ::google::protobuf::Message {
 public:
  offline_arena_record_data();
  virtual ~offline_arena_record_data();

  offline_arena_record_data(const offline_arena_record_data& from);

  inline offline_arena_record_data& operator=(const offline_arena_record_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const offline_arena_record_data& default_instance();

  void Swap(offline_arena_record_data* other);

  // implements Message ----------------------------------------------

  offline_arena_record_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const offline_arena_record_data& from);
  void MergeFrom(const offline_arena_record_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.offline_arena_record record_data = 1;
  inline int record_data_size() const;
  inline void clear_record_data();
  static const int kRecordDataFieldNumber = 1;
  inline const ::proto::common::offline_arena_record& record_data(int index) const;
  inline ::proto::common::offline_arena_record* mutable_record_data(int index);
  inline ::proto::common::offline_arena_record* add_record_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::offline_arena_record >&
      record_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::offline_arena_record >*
      mutable_record_data();

  // @@protoc_insertion_point(class_scope:proto.common.offline_arena_record_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::offline_arena_record > record_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static offline_arena_record_data* default_instance_;
};
// -------------------------------------------------------------------

class wish_summon_info : public ::google::protobuf::Message {
 public:
  wish_summon_info();
  virtual ~wish_summon_info();

  wish_summon_info(const wish_summon_info& from);

  inline wish_summon_info& operator=(const wish_summon_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wish_summon_info& default_instance();

  void Swap(wish_summon_info* other);

  // implements Message ----------------------------------------------

  wish_summon_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const wish_summon_info& from);
  void MergeFrom(const wish_summon_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 wish_summon_id = 1;
  inline bool has_wish_summon_id() const;
  inline void clear_wish_summon_id();
  static const int kWishSummonIdFieldNumber = 1;
  inline ::google::protobuf::uint32 wish_summon_id() const;
  inline void set_wish_summon_id(::google::protobuf::uint32 value);

  // optional uint32 open_flag = 2;
  inline bool has_open_flag() const;
  inline void clear_open_flag();
  static const int kOpenFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 open_flag() const;
  inline void set_open_flag(::google::protobuf::uint32 value);

  // optional uint32 time_left = 3;
  inline bool has_time_left() const;
  inline void clear_time_left();
  static const int kTimeLeftFieldNumber = 3;
  inline ::google::protobuf::uint32 time_left() const;
  inline void set_time_left(::google::protobuf::uint32 value);

  // optional uint32 buy_count = 4;
  inline bool has_buy_count() const;
  inline void clear_buy_count();
  static const int kBuyCountFieldNumber = 4;
  inline ::google::protobuf::uint32 buy_count() const;
  inline void set_buy_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.wish_summon_info)
 private:
  inline void set_has_wish_summon_id();
  inline void clear_has_wish_summon_id();
  inline void set_has_open_flag();
  inline void clear_has_open_flag();
  inline void set_has_time_left();
  inline void clear_has_time_left();
  inline void set_has_buy_count();
  inline void clear_has_buy_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 wish_summon_id_;
  ::google::protobuf::uint32 open_flag_;
  ::google::protobuf::uint32 time_left_;
  ::google::protobuf::uint32 buy_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static wish_summon_info* default_instance_;
};
// -------------------------------------------------------------------

class hero_chip_info : public ::google::protobuf::Message {
 public:
  hero_chip_info();
  virtual ~hero_chip_info();

  hero_chip_info(const hero_chip_info& from);

  inline hero_chip_info& operator=(const hero_chip_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const hero_chip_info& default_instance();

  void Swap(hero_chip_info* other);

  // implements Message ----------------------------------------------

  hero_chip_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const hero_chip_info& from);
  void MergeFrom(const hero_chip_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.hero_chip_info)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static hero_chip_info* default_instance_;
};
// -------------------------------------------------------------------

class buy_summon_info : public ::google::protobuf::Message {
 public:
  buy_summon_info();
  virtual ~buy_summon_info();

  buy_summon_info(const buy_summon_info& from);

  inline buy_summon_info& operator=(const buy_summon_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const buy_summon_info& default_instance();

  void Swap(buy_summon_info* other);

  // implements Message ----------------------------------------------

  buy_summon_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const buy_summon_info& from);
  void MergeFrom(const buy_summon_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.buy_summon_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static buy_summon_info* default_instance_;
};
// -------------------------------------------------------------------

class quick_task_info : public ::google::protobuf::Message {
 public:
  quick_task_info();
  virtual ~quick_task_info();

  quick_task_info(const quick_task_info& from);

  inline quick_task_info& operator=(const quick_task_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const quick_task_info& default_instance();

  void Swap(quick_task_info* other);

  // implements Message ----------------------------------------------

  quick_task_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const quick_task_info& from);
  void MergeFrom(const quick_task_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 max_num = 3;
  inline bool has_max_num() const;
  inline void clear_max_num();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::uint32 max_num() const;
  inline void set_max_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.quick_task_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_max_num();
  inline void clear_has_max_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 max_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static quick_task_info* default_instance_;
};
// -------------------------------------------------------------------

class item_num_info : public ::google::protobuf::Message {
 public:
  item_num_info();
  virtual ~item_num_info();

  item_num_info(const item_num_info& from);

  inline item_num_info& operator=(const item_num_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const item_num_info& default_instance();

  void Swap(item_num_info* other);

  // implements Message ----------------------------------------------

  item_num_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_num_info& from);
  void MergeFrom(const item_num_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.item_num_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static item_num_info* default_instance_;
};
// -------------------------------------------------------------------

class item_num_info_list : public ::google::protobuf::Message {
 public:
  item_num_info_list();
  virtual ~item_num_info_list();

  item_num_info_list(const item_num_info_list& from);

  inline item_num_info_list& operator=(const item_num_info_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const item_num_info_list& default_instance();

  void Swap(item_num_info_list* other);

  // implements Message ----------------------------------------------

  item_num_info_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const item_num_info_list& from);
  void MergeFrom(const item_num_info_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.item_num_info item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::proto::common::item_num_info& item_list(int index) const;
  inline ::proto::common::item_num_info* mutable_item_list(int index);
  inline ::proto::common::item_num_info* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_num_info >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_num_info >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:proto.common.item_num_info_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::item_num_info > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static item_num_info_list* default_instance_;
};
// -------------------------------------------------------------------

class prize_status_info : public ::google::protobuf::Message {
 public:
  prize_status_info();
  virtual ~prize_status_info();

  prize_status_info(const prize_status_info& from);

  inline prize_status_info& operator=(const prize_status_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const prize_status_info& default_instance();

  void Swap(prize_status_info* other);

  // implements Message ----------------------------------------------

  prize_status_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const prize_status_info& from);
  void MergeFrom(const prize_status_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.prize_status_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static prize_status_info* default_instance_;
};
// -------------------------------------------------------------------

class life_info : public ::google::protobuf::Message {
 public:
  life_info();
  virtual ~life_info();

  life_info(const life_info& from);

  inline life_info& operator=(const life_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const life_info& default_instance();

  void Swap(life_info* other);

  // implements Message ----------------------------------------------

  life_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const life_info& from);
  void MergeFrom(const life_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline ::google::protobuf::uint32 label() const;
  inline void set_label(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.life_info)
 private:
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static life_info* default_instance_;
};
// -------------------------------------------------------------------

class money_tree_data : public ::google::protobuf::Message {
 public:
  money_tree_data();
  virtual ~money_tree_data();

  money_tree_data(const money_tree_data& from);

  inline money_tree_data& operator=(const money_tree_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const money_tree_data& default_instance();

  void Swap(money_tree_data* other);

  // implements Message ----------------------------------------------

  money_tree_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const money_tree_data& from);
  void MergeFrom(const money_tree_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.money_tree_data)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static money_tree_data* default_instance_;
};
// -------------------------------------------------------------------

class bussiness_act_data : public ::google::protobuf::Message {
 public:
  bussiness_act_data();
  virtual ~bussiness_act_data();

  bussiness_act_data(const bussiness_act_data& from);

  inline bussiness_act_data& operator=(const bussiness_act_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bussiness_act_data& default_instance();

  void Swap(bussiness_act_data* other);

  // implements Message ----------------------------------------------

  bussiness_act_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const bussiness_act_data& from);
  void MergeFrom(const bussiness_act_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .proto.common.money_tree_data money_tree_info = 1;
  inline bool has_money_tree_info() const;
  inline void clear_money_tree_info();
  static const int kMoneyTreeInfoFieldNumber = 1;
  inline const ::proto::common::money_tree_data& money_tree_info() const;
  inline ::proto::common::money_tree_data* mutable_money_tree_info();
  inline ::proto::common::money_tree_data* release_money_tree_info();
  inline void set_allocated_money_tree_info(::proto::common::money_tree_data* money_tree_info);

  // optional .proto.common.sevenday_login_save_data sevenday_data = 2;
  inline bool has_sevenday_data() const;
  inline void clear_sevenday_data();
  static const int kSevendayDataFieldNumber = 2;
  inline const ::proto::common::sevenday_login_save_data& sevenday_data() const;
  inline ::proto::common::sevenday_login_save_data* mutable_sevenday_data();
  inline ::proto::common::sevenday_login_save_data* release_sevenday_data();
  inline void set_allocated_sevenday_data(::proto::common::sevenday_login_save_data* sevenday_data);

  // optional .proto.common.month_card_save_data month_card_data = 3;
  inline bool has_month_card_data() const;
  inline void clear_month_card_data();
  static const int kMonthCardDataFieldNumber = 3;
  inline const ::proto::common::month_card_save_data& month_card_data() const;
  inline ::proto::common::month_card_save_data* mutable_month_card_data();
  inline ::proto::common::month_card_save_data* release_month_card_data();
  inline void set_allocated_month_card_data(::proto::common::month_card_save_data* month_card_data);

  // optional .proto.common.level_fund_save_info level_fund_data = 4;
  inline bool has_level_fund_data() const;
  inline void clear_level_fund_data();
  static const int kLevelFundDataFieldNumber = 4;
  inline const ::proto::common::level_fund_save_info& level_fund_data() const;
  inline ::proto::common::level_fund_save_info* mutable_level_fund_data();
  inline ::proto::common::level_fund_save_info* release_level_fund_data();
  inline void set_allocated_level_fund_data(::proto::common::level_fund_save_info* level_fund_data);

  // optional .proto.common.limit_buy_save_data limit_buy_data = 5;
  inline bool has_limit_buy_data() const;
  inline void clear_limit_buy_data();
  static const int kLimitBuyDataFieldNumber = 5;
  inline const ::proto::common::limit_buy_save_data& limit_buy_data() const;
  inline ::proto::common::limit_buy_save_data* mutable_limit_buy_data();
  inline ::proto::common::limit_buy_save_data* release_limit_buy_data();
  inline void set_allocated_limit_buy_data(::proto::common::limit_buy_save_data* limit_buy_data);

  // optional .proto.common.exchange_item_save_data exchange_data = 6;
  inline bool has_exchange_data() const;
  inline void clear_exchange_data();
  static const int kExchangeDataFieldNumber = 6;
  inline const ::proto::common::exchange_item_save_data& exchange_data() const;
  inline ::proto::common::exchange_item_save_data* mutable_exchange_data();
  inline ::proto::common::exchange_item_save_data* release_exchange_data();
  inline void set_allocated_exchange_data(::proto::common::exchange_item_save_data* exchange_data);

  // optional .proto.common.statistical_save_data statistical_data = 7;
  inline bool has_statistical_data() const;
  inline void clear_statistical_data();
  static const int kStatisticalDataFieldNumber = 7;
  inline const ::proto::common::statistical_save_data& statistical_data() const;
  inline ::proto::common::statistical_save_data* mutable_statistical_data();
  inline ::proto::common::statistical_save_data* release_statistical_data();
  inline void set_allocated_statistical_data(::proto::common::statistical_save_data* statistical_data);

  // optional .proto.common.sd_target_save_data sevenday_target_data = 8;
  inline bool has_sevenday_target_data() const;
  inline void clear_sevenday_target_data();
  static const int kSevendayTargetDataFieldNumber = 8;
  inline const ::proto::common::sd_target_save_data& sevenday_target_data() const;
  inline ::proto::common::sd_target_save_data* mutable_sevenday_target_data();
  inline ::proto::common::sd_target_save_data* release_sevenday_target_data();
  inline void set_allocated_sevenday_target_data(::proto::common::sd_target_save_data* sevenday_target_data);

  // optional .proto.common.recharge_total_data recharge_total = 9;
  inline bool has_recharge_total() const;
  inline void clear_recharge_total();
  static const int kRechargeTotalFieldNumber = 9;
  inline const ::proto::common::recharge_total_data& recharge_total() const;
  inline ::proto::common::recharge_total_data* mutable_recharge_total();
  inline ::proto::common::recharge_total_data* release_recharge_total();
  inline void set_allocated_recharge_total(::proto::common::recharge_total_data* recharge_total);

  // optional .proto.common.gold_luckydraw_data gold_luckydraw = 10;
  inline bool has_gold_luckydraw() const;
  inline void clear_gold_luckydraw();
  static const int kGoldLuckydrawFieldNumber = 10;
  inline const ::proto::common::gold_luckydraw_data& gold_luckydraw() const;
  inline ::proto::common::gold_luckydraw_data* mutable_gold_luckydraw();
  inline ::proto::common::gold_luckydraw_data* release_gold_luckydraw();
  inline void set_allocated_gold_luckydraw(::proto::common::gold_luckydraw_data* gold_luckydraw);

  // @@protoc_insertion_point(class_scope:proto.common.bussiness_act_data)
 private:
  inline void set_has_money_tree_info();
  inline void clear_has_money_tree_info();
  inline void set_has_sevenday_data();
  inline void clear_has_sevenday_data();
  inline void set_has_month_card_data();
  inline void clear_has_month_card_data();
  inline void set_has_level_fund_data();
  inline void clear_has_level_fund_data();
  inline void set_has_limit_buy_data();
  inline void clear_has_limit_buy_data();
  inline void set_has_exchange_data();
  inline void clear_has_exchange_data();
  inline void set_has_statistical_data();
  inline void clear_has_statistical_data();
  inline void set_has_sevenday_target_data();
  inline void clear_has_sevenday_target_data();
  inline void set_has_recharge_total();
  inline void clear_has_recharge_total();
  inline void set_has_gold_luckydraw();
  inline void clear_has_gold_luckydraw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::proto::common::money_tree_data* money_tree_info_;
  ::proto::common::sevenday_login_save_data* sevenday_data_;
  ::proto::common::month_card_save_data* month_card_data_;
  ::proto::common::level_fund_save_info* level_fund_data_;
  ::proto::common::limit_buy_save_data* limit_buy_data_;
  ::proto::common::exchange_item_save_data* exchange_data_;
  ::proto::common::statistical_save_data* statistical_data_;
  ::proto::common::sd_target_save_data* sevenday_target_data_;
  ::proto::common::recharge_total_data* recharge_total_;
  ::proto::common::gold_luckydraw_data* gold_luckydraw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static bussiness_act_data* default_instance_;
};
// -------------------------------------------------------------------

class sevenday_login_data_info : public ::google::protobuf::Message {
 public:
  sevenday_login_data_info();
  virtual ~sevenday_login_data_info();

  sevenday_login_data_info(const sevenday_login_data_info& from);

  inline sevenday_login_data_info& operator=(const sevenday_login_data_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sevenday_login_data_info& default_instance();

  void Swap(sevenday_login_data_info* other);

  // implements Message ----------------------------------------------

  sevenday_login_data_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sevenday_login_data_info& from);
  void MergeFrom(const sevenday_login_data_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 day_show_id = 3;
  inline bool has_day_show_id() const;
  inline void clear_day_show_id();
  static const int kDayShowIdFieldNumber = 3;
  inline ::google::protobuf::uint32 day_show_id() const;
  inline void set_day_show_id(::google::protobuf::uint32 value);

  // optional string show_id_list = 4;
  inline bool has_show_id_list() const;
  inline void clear_show_id_list();
  static const int kShowIdListFieldNumber = 4;
  inline const ::std::string& show_id_list() const;
  inline void set_show_id_list(const ::std::string& value);
  inline void set_show_id_list(const char* value);
  inline void set_show_id_list(const char* value, size_t size);
  inline ::std::string* mutable_show_id_list();
  inline ::std::string* release_show_id_list();
  inline void set_allocated_show_id_list(::std::string* show_id_list);

  // @@protoc_insertion_point(class_scope:proto.common.sevenday_login_data_info)
 private:
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_day_show_id();
  inline void clear_has_day_show_id();
  inline void set_has_show_id_list();
  inline void clear_has_show_id_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 status_;
  ::std::string* show_id_list_;
  ::google::protobuf::uint32 day_show_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sevenday_login_data_info* default_instance_;
};
// -------------------------------------------------------------------

class sevenday_login_save_data : public ::google::protobuf::Message {
 public:
  sevenday_login_save_data();
  virtual ~sevenday_login_save_data();

  sevenday_login_save_data(const sevenday_login_save_data& from);

  inline sevenday_login_save_data& operator=(const sevenday_login_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sevenday_login_save_data& default_instance();

  void Swap(sevenday_login_save_data* other);

  // implements Message ----------------------------------------------

  sevenday_login_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sevenday_login_save_data& from);
  void MergeFrom(const sevenday_login_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 login_flag = 1;
  inline bool has_login_flag() const;
  inline void clear_login_flag();
  static const int kLoginFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 login_flag() const;
  inline void set_login_flag(::google::protobuf::uint32 value);

  // optional uint32 day = 2;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 2;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // repeated uint32 days = 3;
  inline int days_size() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 3;
  inline ::google::protobuf::uint32 days(int index) const;
  inline void set_days(int index, ::google::protobuf::uint32 value);
  inline void add_days(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      days() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_days();

  // @@protoc_insertion_point(class_scope:proto.common.sevenday_login_save_data)
 private:
  inline void set_has_login_flag();
  inline void clear_has_login_flag();
  inline void set_has_day();
  inline void clear_has_day();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 login_flag_;
  ::google::protobuf::uint32 day_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > days_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sevenday_login_save_data* default_instance_;
};
// -------------------------------------------------------------------

class recharge_total_data : public ::google::protobuf::Message {
 public:
  recharge_total_data();
  virtual ~recharge_total_data();

  recharge_total_data(const recharge_total_data& from);

  inline recharge_total_data& operator=(const recharge_total_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_total_data& default_instance();

  void Swap(recharge_total_data* other);

  // implements Message ----------------------------------------------

  recharge_total_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_total_data& from);
  void MergeFrom(const recharge_total_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 recharge_total_id = 1;
  inline int recharge_total_id_size() const;
  inline void clear_recharge_total_id();
  static const int kRechargeTotalIdFieldNumber = 1;
  inline ::google::protobuf::uint32 recharge_total_id(int index) const;
  inline void set_recharge_total_id(int index, ::google::protobuf::uint32 value);
  inline void add_recharge_total_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      recharge_total_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_recharge_total_id();

  // @@protoc_insertion_point(class_scope:proto.common.recharge_total_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > recharge_total_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static recharge_total_data* default_instance_;
};
// -------------------------------------------------------------------

class recharge_total_client_data : public ::google::protobuf::Message {
 public:
  recharge_total_client_data();
  virtual ~recharge_total_client_data();

  recharge_total_client_data(const recharge_total_client_data& from);

  inline recharge_total_client_data& operator=(const recharge_total_client_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_total_client_data& default_instance();

  void Swap(recharge_total_client_data* other);

  // implements Message ----------------------------------------------

  recharge_total_client_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_total_client_data& from);
  void MergeFrom(const recharge_total_client_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.recharge_total_client_single info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto::common::recharge_total_client_single& info(int index) const;
  inline ::proto::common::recharge_total_client_single* mutable_info(int index);
  inline ::proto::common::recharge_total_client_single* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::recharge_total_client_single >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::recharge_total_client_single >*
      mutable_info();

  // optional uint32 recharge_total = 2;
  inline bool has_recharge_total() const;
  inline void clear_recharge_total();
  static const int kRechargeTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 recharge_total() const;
  inline void set_recharge_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.recharge_total_client_data)
 private:
  inline void set_has_recharge_total();
  inline void clear_has_recharge_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::recharge_total_client_single > info_;
  ::google::protobuf::uint32 recharge_total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static recharge_total_client_data* default_instance_;
};
// -------------------------------------------------------------------

class recharge_total_client_single : public ::google::protobuf::Message {
 public:
  recharge_total_client_single();
  virtual ~recharge_total_client_single();

  recharge_total_client_single(const recharge_total_client_single& from);

  inline recharge_total_client_single& operator=(const recharge_total_client_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const recharge_total_client_single& default_instance();

  void Swap(recharge_total_client_single* other);

  // implements Message ----------------------------------------------

  recharge_total_client_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const recharge_total_client_single& from);
  void MergeFrom(const recharge_total_client_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 recharge_total_id = 1;
  inline bool has_recharge_total_id() const;
  inline void clear_recharge_total_id();
  static const int kRechargeTotalIdFieldNumber = 1;
  inline ::google::protobuf::uint32 recharge_total_id() const;
  inline void set_recharge_total_id(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional string display = 3;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 3;
  inline const ::std::string& display() const;
  inline void set_display(const ::std::string& value);
  inline void set_display(const char* value);
  inline void set_display(const char* value, size_t size);
  inline ::std::string* mutable_display();
  inline ::std::string* release_display();
  inline void set_allocated_display(::std::string* display);

  // @@protoc_insertion_point(class_scope:proto.common.recharge_total_client_single)
 private:
  inline void set_has_recharge_total_id();
  inline void clear_has_recharge_total_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_display();
  inline void clear_has_display();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 recharge_total_id_;
  ::google::protobuf::uint32 state_;
  ::std::string* display_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static recharge_total_client_single* default_instance_;
};
// -------------------------------------------------------------------

class gold_luckydraw_data : public ::google::protobuf::Message {
 public:
  gold_luckydraw_data();
  virtual ~gold_luckydraw_data();

  gold_luckydraw_data(const gold_luckydraw_data& from);

  inline gold_luckydraw_data& operator=(const gold_luckydraw_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gold_luckydraw_data& default_instance();

  void Swap(gold_luckydraw_data* other);

  // implements Message ----------------------------------------------

  gold_luckydraw_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gold_luckydraw_data& from);
  void MergeFrom(const gold_luckydraw_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 gold_luckydraw_id = 1;
  inline int gold_luckydraw_id_size() const;
  inline void clear_gold_luckydraw_id();
  static const int kGoldLuckydrawIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gold_luckydraw_id(int index) const;
  inline void set_gold_luckydraw_id(int index, ::google::protobuf::uint32 value);
  inline void add_gold_luckydraw_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gold_luckydraw_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gold_luckydraw_id();

  // @@protoc_insertion_point(class_scope:proto.common.gold_luckydraw_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gold_luckydraw_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gold_luckydraw_data* default_instance_;
};
// -------------------------------------------------------------------

class gold_luckydraw_client_single : public ::google::protobuf::Message {
 public:
  gold_luckydraw_client_single();
  virtual ~gold_luckydraw_client_single();

  gold_luckydraw_client_single(const gold_luckydraw_client_single& from);

  inline gold_luckydraw_client_single& operator=(const gold_luckydraw_client_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gold_luckydraw_client_single& default_instance();

  void Swap(gold_luckydraw_client_single* other);

  // implements Message ----------------------------------------------

  gold_luckydraw_client_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gold_luckydraw_client_single& from);
  void MergeFrom(const gold_luckydraw_client_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gold_luckydraw_id = 1;
  inline bool has_gold_luckydraw_id() const;
  inline void clear_gold_luckydraw_id();
  static const int kGoldLuckydrawIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gold_luckydraw_id() const;
  inline void set_gold_luckydraw_id(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string display = 4;
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 4;
  inline const ::std::string& display() const;
  inline void set_display(const ::std::string& value);
  inline void set_display(const char* value);
  inline void set_display(const char* value, size_t size);
  inline ::std::string* mutable_display();
  inline ::std::string* release_display();
  inline void set_allocated_display(::std::string* display);

  // optional uint32 day = 5;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 5;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.gold_luckydraw_client_single)
 private:
  inline void set_has_gold_luckydraw_id();
  inline void clear_has_gold_luckydraw_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_day();
  inline void clear_has_day();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gold_luckydraw_id_;
  ::google::protobuf::uint32 state_;
  ::std::string* desc_;
  ::std::string* display_;
  ::google::protobuf::uint32 day_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gold_luckydraw_client_single* default_instance_;
};
// -------------------------------------------------------------------

class gold_luckydraw_client_data : public ::google::protobuf::Message {
 public:
  gold_luckydraw_client_data();
  virtual ~gold_luckydraw_client_data();

  gold_luckydraw_client_data(const gold_luckydraw_client_data& from);

  inline gold_luckydraw_client_data& operator=(const gold_luckydraw_client_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gold_luckydraw_client_data& default_instance();

  void Swap(gold_luckydraw_client_data* other);

  // implements Message ----------------------------------------------

  gold_luckydraw_client_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gold_luckydraw_client_data& from);
  void MergeFrom(const gold_luckydraw_client_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.gold_luckydraw_client_single gold_luckydraw_data = 1;
  inline int gold_luckydraw_data_size() const;
  inline void clear_gold_luckydraw_data();
  static const int kGoldLuckydrawDataFieldNumber = 1;
  inline const ::proto::common::gold_luckydraw_client_single& gold_luckydraw_data(int index) const;
  inline ::proto::common::gold_luckydraw_client_single* mutable_gold_luckydraw_data(int index);
  inline ::proto::common::gold_luckydraw_client_single* add_gold_luckydraw_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::gold_luckydraw_client_single >&
      gold_luckydraw_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::gold_luckydraw_client_single >*
      mutable_gold_luckydraw_data();

  // @@protoc_insertion_point(class_scope:proto.common.gold_luckydraw_client_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::gold_luckydraw_client_single > gold_luckydraw_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gold_luckydraw_client_data* default_instance_;
};
// -------------------------------------------------------------------

class cur_task_date : public ::google::protobuf::Message {
 public:
  cur_task_date();
  virtual ~cur_task_date();

  cur_task_date(const cur_task_date& from);

  inline cur_task_date& operator=(const cur_task_date& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cur_task_date& default_instance();

  void Swap(cur_task_date* other);

  // implements Message ----------------------------------------------

  cur_task_date* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const cur_task_date& from);
  void MergeFrom(const cur_task_date& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.task_state tasks = 1;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 1;
  inline const ::proto::common::task_state& tasks(int index) const;
  inline ::proto::common::task_state* mutable_tasks(int index);
  inline ::proto::common::task_state* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:proto.common.cur_task_date)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::task_state > tasks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static cur_task_date* default_instance_;
};
// -------------------------------------------------------------------

class comp_task_date : public ::google::protobuf::Message {
 public:
  comp_task_date();
  virtual ~comp_task_date();

  comp_task_date(const comp_task_date& from);

  inline comp_task_date& operator=(const comp_task_date& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const comp_task_date& default_instance();

  void Swap(comp_task_date* other);

  // implements Message ----------------------------------------------

  comp_task_date* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const comp_task_date& from);
  void MergeFrom(const comp_task_date& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 task_list = 1;
  inline int task_list_size() const;
  inline void clear_task_list();
  static const int kTaskListFieldNumber = 1;
  inline ::google::protobuf::uint32 task_list(int index) const;
  inline void set_task_list(int index, ::google::protobuf::uint32 value);
  inline void add_task_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      task_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_task_list();

  // @@protoc_insertion_point(class_scope:proto.common.comp_task_date)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > task_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static comp_task_date* default_instance_;
};
// -------------------------------------------------------------------

class task_event_single : public ::google::protobuf::Message {
 public:
  task_event_single();
  virtual ~task_event_single();

  task_event_single(const task_event_single& from);

  inline task_event_single& operator=(const task_event_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_event_single& default_instance();

  void Swap(task_event_single* other);

  // implements Message ----------------------------------------------

  task_event_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_event_single& from);
  void MergeFrom(const task_event_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint32 event_id() const;
  inline void set_event_id(::google::protobuf::uint32 value);

  // optional uint32 expired_time = 2;
  inline bool has_expired_time() const;
  inline void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 expired_time() const;
  inline void set_expired_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.task_event_single)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_expired_time();
  inline void clear_has_expired_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 event_id_;
  ::google::protobuf::uint32 expired_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_event_single* default_instance_;
};
// -------------------------------------------------------------------

class task_event : public ::google::protobuf::Message {
 public:
  task_event();
  virtual ~task_event();

  task_event(const task_event& from);

  inline task_event& operator=(const task_event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const task_event& default_instance();

  void Swap(task_event* other);

  // implements Message ----------------------------------------------

  task_event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const task_event& from);
  void MergeFrom(const task_event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.task_event_single event_data = 1;
  inline int event_data_size() const;
  inline void clear_event_data();
  static const int kEventDataFieldNumber = 1;
  inline const ::proto::common::task_event_single& event_data(int index) const;
  inline ::proto::common::task_event_single* mutable_event_data(int index);
  inline ::proto::common::task_event_single* add_event_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_event_single >&
      event_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_event_single >*
      mutable_event_data();

  // @@protoc_insertion_point(class_scope:proto.common.task_event)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::task_event_single > event_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static task_event* default_instance_;
};
// -------------------------------------------------------------------

class head_data : public ::google::protobuf::Message {
 public:
  head_data();
  virtual ~head_data();

  head_data(const head_data& from);

  inline head_data& operator=(const head_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const head_data& default_instance();

  void Swap(head_data* other);

  // implements Message ----------------------------------------------

  head_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const head_data& from);
  void MergeFrom(const head_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 head_list = 1;
  inline int head_list_size() const;
  inline void clear_head_list();
  static const int kHeadListFieldNumber = 1;
  inline ::google::protobuf::uint32 head_list(int index) const;
  inline void set_head_list(int index, ::google::protobuf::uint32 value);
  inline void add_head_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      head_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_head_list();

  // repeated uint32 frame_list = 2;
  inline int frame_list_size() const;
  inline void clear_frame_list();
  static const int kFrameListFieldNumber = 2;
  inline ::google::protobuf::uint32 frame_list(int index) const;
  inline void set_frame_list(int index, ::google::protobuf::uint32 value);
  inline void add_frame_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      frame_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_frame_list();

  // @@protoc_insertion_point(class_scope:proto.common.head_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > head_list_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > frame_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static head_data* default_instance_;
};
// -------------------------------------------------------------------

class month_card_info : public ::google::protobuf::Message {
 public:
  month_card_info();
  virtual ~month_card_info();

  month_card_info(const month_card_info& from);

  inline month_card_info& operator=(const month_card_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_card_info& default_instance();

  void Swap(month_card_info* other);

  // implements Message ----------------------------------------------

  month_card_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_card_info& from);
  void MergeFrom(const month_card_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 month_card_id = 1;
  inline bool has_month_card_id() const;
  inline void clear_month_card_id();
  static const int kMonthCardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 month_card_id() const;
  inline void set_month_card_id(::google::protobuf::uint32 value);

  // optional uint32 end_time = 2;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // optional uint32 buy_prize = 3;
  inline bool has_buy_prize() const;
  inline void clear_buy_prize();
  static const int kBuyPrizeFieldNumber = 3;
  inline ::google::protobuf::uint32 buy_prize() const;
  inline void set_buy_prize(::google::protobuf::uint32 value);

  // optional uint32 ed_prize = 4;
  inline bool has_ed_prize() const;
  inline void clear_ed_prize();
  static const int kEdPrizeFieldNumber = 4;
  inline ::google::protobuf::uint32 ed_prize() const;
  inline void set_ed_prize(::google::protobuf::uint32 value);

  // optional .proto.common.month_card_show_info show_info = 5;
  inline bool has_show_info() const;
  inline void clear_show_info();
  static const int kShowInfoFieldNumber = 5;
  inline const ::proto::common::month_card_show_info& show_info() const;
  inline ::proto::common::month_card_show_info* mutable_show_info();
  inline ::proto::common::month_card_show_info* release_show_info();
  inline void set_allocated_show_info(::proto::common::month_card_show_info* show_info);

  // optional uint32 day_left = 6;
  inline bool has_day_left() const;
  inline void clear_day_left();
  static const int kDayLeftFieldNumber = 6;
  inline ::google::protobuf::uint32 day_left() const;
  inline void set_day_left(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.month_card_info)
 private:
  inline void set_has_month_card_id();
  inline void clear_has_month_card_id();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_buy_prize();
  inline void clear_has_buy_prize();
  inline void set_has_ed_prize();
  inline void clear_has_ed_prize();
  inline void set_has_show_info();
  inline void clear_has_show_info();
  inline void set_has_day_left();
  inline void clear_has_day_left();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 month_card_id_;
  ::google::protobuf::uint32 end_time_;
  ::google::protobuf::uint32 buy_prize_;
  ::google::protobuf::uint32 ed_prize_;
  ::proto::common::month_card_show_info* show_info_;
  ::google::protobuf::uint32 day_left_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static month_card_info* default_instance_;
};
// -------------------------------------------------------------------

class month_card_show_info : public ::google::protobuf::Message {
 public:
  month_card_show_info();
  virtual ~month_card_show_info();

  month_card_show_info(const month_card_show_info& from);

  inline month_card_show_info& operator=(const month_card_show_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_card_show_info& default_instance();

  void Swap(month_card_show_info* other);

  // implements Message ----------------------------------------------

  month_card_show_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_card_show_info& from);
  void MergeFrom(const month_card_show_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 max_day = 1;
  inline bool has_max_day() const;
  inline void clear_max_day();
  static const int kMaxDayFieldNumber = 1;
  inline ::google::protobuf::uint32 max_day() const;
  inline void set_max_day(::google::protobuf::uint32 value);

  // optional string mingshi = 2;
  inline bool has_mingshi() const;
  inline void clear_mingshi();
  static const int kMingshiFieldNumber = 2;
  inline const ::std::string& mingshi() const;
  inline void set_mingshi(const ::std::string& value);
  inline void set_mingshi(const char* value);
  inline void set_mingshi(const char* value, size_t size);
  inline ::std::string* mutable_mingshi();
  inline ::std::string* release_mingshi();
  inline void set_allocated_mingshi(::std::string* mingshi);

  // optional string ed_yuanbao = 3;
  inline bool has_ed_yuanbao() const;
  inline void clear_ed_yuanbao();
  static const int kEdYuanbaoFieldNumber = 3;
  inline const ::std::string& ed_yuanbao() const;
  inline void set_ed_yuanbao(const ::std::string& value);
  inline void set_ed_yuanbao(const char* value);
  inline void set_ed_yuanbao(const char* value, size_t size);
  inline ::std::string* mutable_ed_yuanbao();
  inline ::std::string* release_ed_yuanbao();
  inline void set_allocated_ed_yuanbao(::std::string* ed_yuanbao);

  // optional string show_gift = 4;
  inline bool has_show_gift() const;
  inline void clear_show_gift();
  static const int kShowGiftFieldNumber = 4;
  inline const ::std::string& show_gift() const;
  inline void set_show_gift(const ::std::string& value);
  inline void set_show_gift(const char* value);
  inline void set_show_gift(const char* value, size_t size);
  inline ::std::string* mutable_show_gift();
  inline ::std::string* release_show_gift();
  inline void set_allocated_show_gift(::std::string* show_gift);

  // optional uint32 can_buy_day = 5;
  inline bool has_can_buy_day() const;
  inline void clear_can_buy_day();
  static const int kCanBuyDayFieldNumber = 5;
  inline ::google::protobuf::uint32 can_buy_day() const;
  inline void set_can_buy_day(::google::protobuf::uint32 value);

  // optional uint32 cz_id = 6;
  inline bool has_cz_id() const;
  inline void clear_cz_id();
  static const int kCzIdFieldNumber = 6;
  inline ::google::protobuf::uint32 cz_id() const;
  inline void set_cz_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.month_card_show_info)
 private:
  inline void set_has_max_day();
  inline void clear_has_max_day();
  inline void set_has_mingshi();
  inline void clear_has_mingshi();
  inline void set_has_ed_yuanbao();
  inline void clear_has_ed_yuanbao();
  inline void set_has_show_gift();
  inline void clear_has_show_gift();
  inline void set_has_can_buy_day();
  inline void clear_has_can_buy_day();
  inline void set_has_cz_id();
  inline void clear_has_cz_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mingshi_;
  ::std::string* ed_yuanbao_;
  ::google::protobuf::uint32 max_day_;
  ::google::protobuf::uint32 can_buy_day_;
  ::std::string* show_gift_;
  ::google::protobuf::uint32 cz_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static month_card_show_info* default_instance_;
};
// -------------------------------------------------------------------

class month_card_save_data : public ::google::protobuf::Message {
 public:
  month_card_save_data();
  virtual ~month_card_save_data();

  month_card_save_data(const month_card_save_data& from);

  inline month_card_save_data& operator=(const month_card_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const month_card_save_data& default_instance();

  void Swap(month_card_save_data* other);

  // implements Message ----------------------------------------------

  month_card_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const month_card_save_data& from);
  void MergeFrom(const month_card_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.month_card_info card_info = 1;
  inline int card_info_size() const;
  inline void clear_card_info();
  static const int kCardInfoFieldNumber = 1;
  inline const ::proto::common::month_card_info& card_info(int index) const;
  inline ::proto::common::month_card_info* mutable_card_info(int index);
  inline ::proto::common::month_card_info* add_card_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::month_card_info >&
      card_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::month_card_info >*
      mutable_card_info();

  // @@protoc_insertion_point(class_scope:proto.common.month_card_save_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::month_card_info > card_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static month_card_save_data* default_instance_;
};
// -------------------------------------------------------------------

class ex_reason : public ::google::protobuf::Message {
 public:
  ex_reason();
  virtual ~ex_reason();

  ex_reason(const ex_reason& from);

  inline ex_reason& operator=(const ex_reason& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ex_reason& default_instance();

  void Swap(ex_reason* other);

  // implements Message ----------------------------------------------

  ex_reason* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ex_reason& from);
  void MergeFrom(const ex_reason& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 ex_id = 2;
  inline bool has_ex_id() const;
  inline void clear_ex_id();
  static const int kExIdFieldNumber = 2;
  inline ::google::protobuf::uint32 ex_id() const;
  inline void set_ex_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.ex_reason)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ex_id();
  inline void clear_has_ex_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 ex_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ex_reason* default_instance_;
};
// -------------------------------------------------------------------

class liandan_single : public ::google::protobuf::Message {
 public:
  liandan_single();
  virtual ~liandan_single();

  liandan_single(const liandan_single& from);

  inline liandan_single& operator=(const liandan_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const liandan_single& default_instance();

  void Swap(liandan_single* other);

  // implements Message ----------------------------------------------

  liandan_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const liandan_single& from);
  void MergeFrom(const liandan_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 free_time = 2;
  inline bool has_free_time() const;
  inline void clear_free_time();
  static const int kFreeTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 free_time() const;
  inline void set_free_time(::google::protobuf::uint32 value);

  // optional uint32 liandan_tid = 3;
  inline bool has_liandan_tid() const;
  inline void clear_liandan_tid();
  static const int kLiandanTidFieldNumber = 3;
  inline ::google::protobuf::uint32 liandan_tid() const;
  inline void set_liandan_tid(::google::protobuf::uint32 value);

  // optional uint32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.liandan_single)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_free_time();
  inline void clear_has_free_time();
  inline void set_has_liandan_tid();
  inline void clear_has_liandan_tid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 free_time_;
  ::google::protobuf::uint32 liandan_tid_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static liandan_single* default_instance_;
};
// -------------------------------------------------------------------

class liandan_data : public ::google::protobuf::Message {
 public:
  liandan_data();
  virtual ~liandan_data();

  liandan_data(const liandan_data& from);

  inline liandan_data& operator=(const liandan_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const liandan_data& default_instance();

  void Swap(liandan_data* other);

  // implements Message ----------------------------------------------

  liandan_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const liandan_data& from);
  void MergeFrom(const liandan_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.liandan_single liandan_info = 1;
  inline int liandan_info_size() const;
  inline void clear_liandan_info();
  static const int kLiandanInfoFieldNumber = 1;
  inline const ::proto::common::liandan_single& liandan_info(int index) const;
  inline ::proto::common::liandan_single* mutable_liandan_info(int index);
  inline ::proto::common::liandan_single* add_liandan_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liandan_single >&
      liandan_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::liandan_single >*
      mutable_liandan_info();

  // @@protoc_insertion_point(class_scope:proto.common.liandan_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::liandan_single > liandan_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static liandan_data* default_instance_;
};
// -------------------------------------------------------------------

class activity_shop_item_info_single : public ::google::protobuf::Message {
 public:
  activity_shop_item_info_single();
  virtual ~activity_shop_item_info_single();

  activity_shop_item_info_single(const activity_shop_item_info_single& from);

  inline activity_shop_item_info_single& operator=(const activity_shop_item_info_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_shop_item_info_single& default_instance();

  void Swap(activity_shop_item_info_single* other);

  // implements Message ----------------------------------------------

  activity_shop_item_info_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_shop_item_info_single& from);
  void MergeFrom(const activity_shop_item_info_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shop_item_id = 1;
  inline bool has_shop_item_id() const;
  inline void clear_shop_item_id();
  static const int kShopItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 shop_item_id() const;
  inline void set_shop_item_id(::google::protobuf::uint32 value);

  // optional uint32 shop_item_price = 2;
  inline bool has_shop_item_price() const;
  inline void clear_shop_item_price();
  static const int kShopItemPriceFieldNumber = 2;
  inline ::google::protobuf::uint32 shop_item_price() const;
  inline void set_shop_item_price(::google::protobuf::uint32 value);

  // optional uint32 shop_item_num = 3;
  inline bool has_shop_item_num() const;
  inline void clear_shop_item_num();
  static const int kShopItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 shop_item_num() const;
  inline void set_shop_item_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.activity_shop_item_info_single)
 private:
  inline void set_has_shop_item_id();
  inline void clear_has_shop_item_id();
  inline void set_has_shop_item_price();
  inline void clear_has_shop_item_price();
  inline void set_has_shop_item_num();
  inline void clear_has_shop_item_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 shop_item_id_;
  ::google::protobuf::uint32 shop_item_price_;
  ::google::protobuf::uint32 shop_item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static activity_shop_item_info_single* default_instance_;
};
// -------------------------------------------------------------------

class activity_shop_item_info : public ::google::protobuf::Message {
 public:
  activity_shop_item_info();
  virtual ~activity_shop_item_info();

  activity_shop_item_info(const activity_shop_item_info& from);

  inline activity_shop_item_info& operator=(const activity_shop_item_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const activity_shop_item_info& default_instance();

  void Swap(activity_shop_item_info* other);

  // implements Message ----------------------------------------------

  activity_shop_item_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const activity_shop_item_info& from);
  void MergeFrom(const activity_shop_item_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.activity_shop_item_info_single item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::proto::common::activity_shop_item_info_single& item_list(int index) const;
  inline ::proto::common::activity_shop_item_info_single* mutable_item_list(int index);
  inline ::proto::common::activity_shop_item_info_single* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::activity_shop_item_info_single >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::activity_shop_item_info_single >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:proto.common.activity_shop_item_info)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::activity_shop_item_info_single > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static activity_shop_item_info* default_instance_;
};
// -------------------------------------------------------------------

class business_active_info : public ::google::protobuf::Message {
 public:
  business_active_info();
  virtual ~business_active_info();

  business_active_info(const business_active_info& from);

  inline business_active_info& operator=(const business_active_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const business_active_info& default_instance();

  void Swap(business_active_info* other);

  // implements Message ----------------------------------------------

  business_active_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const business_active_info& from);
  void MergeFrom(const business_active_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 active_id = 1;
  inline bool has_active_id() const;
  inline void clear_active_id();
  static const int kActiveIdFieldNumber = 1;
  inline ::google::protobuf::uint32 active_id() const;
  inline void set_active_id(::google::protobuf::uint32 value);

  // optional uint32 red_num = 2;
  inline bool has_red_num() const;
  inline void clear_red_num();
  static const int kRedNumFieldNumber = 2;
  inline ::google::protobuf::uint32 red_num() const;
  inline void set_red_num(::google::protobuf::uint32 value);

  // optional uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 4;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.business_active_info)
 private:
  inline void set_has_active_id();
  inline void clear_has_active_id();
  inline void set_has_red_num();
  inline void clear_has_red_num();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 active_id_;
  ::google::protobuf::uint32 red_num_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static business_active_info* default_instance_;
};
// -------------------------------------------------------------------

class level_fund_info : public ::google::protobuf::Message {
 public:
  level_fund_info();
  virtual ~level_fund_info();

  level_fund_info(const level_fund_info& from);

  inline level_fund_info& operator=(const level_fund_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const level_fund_info& default_instance();

  void Swap(level_fund_info* other);

  // implements Message ----------------------------------------------

  level_fund_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const level_fund_info& from);
  void MergeFrom(const level_fund_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 prize_state = 3;
  inline bool has_prize_state() const;
  inline void clear_prize_state();
  static const int kPrizeStateFieldNumber = 3;
  inline ::google::protobuf::uint32 prize_state() const;
  inline void set_prize_state(::google::protobuf::uint32 value);

  // optional string des = 4;
  inline bool has_des() const;
  inline void clear_des();
  static const int kDesFieldNumber = 4;
  inline const ::std::string& des() const;
  inline void set_des(const ::std::string& value);
  inline void set_des(const char* value);
  inline void set_des(const char* value, size_t size);
  inline ::std::string* mutable_des();
  inline ::std::string* release_des();
  inline void set_allocated_des(::std::string* des);

  // optional string show_prize = 5;
  inline bool has_show_prize() const;
  inline void clear_show_prize();
  static const int kShowPrizeFieldNumber = 5;
  inline const ::std::string& show_prize() const;
  inline void set_show_prize(const ::std::string& value);
  inline void set_show_prize(const char* value);
  inline void set_show_prize(const char* value, size_t size);
  inline ::std::string* mutable_show_prize();
  inline ::std::string* release_show_prize();
  inline void set_allocated_show_prize(::std::string* show_prize);

  // @@protoc_insertion_point(class_scope:proto.common.level_fund_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_prize_state();
  inline void clear_has_prize_state();
  inline void set_has_des();
  inline void clear_has_des();
  inline void set_has_show_prize();
  inline void clear_has_show_prize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 level_;
  ::std::string* des_;
  ::std::string* show_prize_;
  ::google::protobuf::uint32 prize_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static level_fund_info* default_instance_;
};
// -------------------------------------------------------------------

class level_fund_save_info : public ::google::protobuf::Message {
 public:
  level_fund_save_info();
  virtual ~level_fund_save_info();

  level_fund_save_info(const level_fund_save_info& from);

  inline level_fund_save_info& operator=(const level_fund_save_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const level_fund_save_info& default_instance();

  void Swap(level_fund_save_info* other);

  // implements Message ----------------------------------------------

  level_fund_save_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const level_fund_save_info& from);
  void MergeFrom(const level_fund_save_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 buy_flag = 1;
  inline bool has_buy_flag() const;
  inline void clear_buy_flag();
  static const int kBuyFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 buy_flag() const;
  inline void set_buy_flag(::google::protobuf::uint32 value);

  // repeated uint32 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::uint32 value);
  inline void add_id(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:proto.common.level_fund_save_info)
 private:
  inline void set_has_buy_flag();
  inline void clear_has_buy_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > id_;
  ::google::protobuf::uint32 buy_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static level_fund_save_info* default_instance_;
};
// -------------------------------------------------------------------

class equip_plan_single : public ::google::protobuf::Message {
 public:
  equip_plan_single();
  virtual ~equip_plan_single();

  equip_plan_single(const equip_plan_single& from);

  inline equip_plan_single& operator=(const equip_plan_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_plan_single& default_instance();

  void Swap(equip_plan_single* other);

  // implements Message ----------------------------------------------

  equip_plan_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_plan_single& from);
  void MergeFrom(const equip_plan_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string weapon = 3;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 3;
  inline const ::std::string& weapon() const;
  inline void set_weapon(const ::std::string& value);
  inline void set_weapon(const char* value);
  inline void set_weapon(const char* value, size_t size);
  inline ::std::string* mutable_weapon();
  inline ::std::string* release_weapon();
  inline void set_allocated_weapon(::std::string* weapon);

  // optional string armor = 4;
  inline bool has_armor() const;
  inline void clear_armor();
  static const int kArmorFieldNumber = 4;
  inline const ::std::string& armor() const;
  inline void set_armor(const ::std::string& value);
  inline void set_armor(const char* value);
  inline void set_armor(const char* value, size_t size);
  inline ::std::string* mutable_armor();
  inline ::std::string* release_armor();
  inline void set_allocated_armor(::std::string* armor);

  // optional string talisman = 5;
  inline bool has_talisman() const;
  inline void clear_talisman();
  static const int kTalismanFieldNumber = 5;
  inline const ::std::string& talisman() const;
  inline void set_talisman(const ::std::string& value);
  inline void set_talisman(const char* value);
  inline void set_talisman(const char* value, size_t size);
  inline ::std::string* mutable_talisman();
  inline ::std::string* release_talisman();
  inline void set_allocated_talisman(::std::string* talisman);

  // optional string hero_uid = 6;
  inline bool has_hero_uid() const;
  inline void clear_hero_uid();
  static const int kHeroUidFieldNumber = 6;
  inline const ::std::string& hero_uid() const;
  inline void set_hero_uid(const ::std::string& value);
  inline void set_hero_uid(const char* value);
  inline void set_hero_uid(const char* value, size_t size);
  inline ::std::string* mutable_hero_uid();
  inline ::std::string* release_hero_uid();
  inline void set_allocated_hero_uid(::std::string* hero_uid);

  // @@protoc_insertion_point(class_scope:proto.common.equip_plan_single)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_talisman();
  inline void clear_has_talisman();
  inline void set_has_hero_uid();
  inline void clear_has_hero_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* weapon_;
  ::std::string* armor_;
  ::std::string* talisman_;
  ::std::string* hero_uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static equip_plan_single* default_instance_;
};
// -------------------------------------------------------------------

class patrol_hire_data : public ::google::protobuf::Message {
 public:
  patrol_hire_data();
  virtual ~patrol_hire_data();

  patrol_hire_data(const patrol_hire_data& from);

  inline patrol_hire_data& operator=(const patrol_hire_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const patrol_hire_data& default_instance();

  void Swap(patrol_hire_data* other);

  // implements Message ----------------------------------------------

  patrol_hire_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const patrol_hire_data& from);
  void MergeFrom(const patrol_hire_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 map_id() const;
  inline void set_map_id(::google::protobuf::uint32 value);

  // optional uint32 begin_time = 2;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 begin_time() const;
  inline void set_begin_time(::google::protobuf::uint32 value);

  // optional uint32 fast_patrol_count = 3;
  inline bool has_fast_patrol_count() const;
  inline void clear_fast_patrol_count();
  static const int kFastPatrolCountFieldNumber = 3;
  inline ::google::protobuf::uint32 fast_patrol_count() const;
  inline void set_fast_patrol_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.patrol_hire_data)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_fast_patrol_count();
  inline void clear_has_fast_patrol_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 map_id_;
  ::google::protobuf::uint32 begin_time_;
  ::google::protobuf::uint32 fast_patrol_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static patrol_hire_data* default_instance_;
};
// -------------------------------------------------------------------

class equip_plan_data : public ::google::protobuf::Message {
 public:
  equip_plan_data();
  virtual ~equip_plan_data();

  equip_plan_data(const equip_plan_data& from);

  inline equip_plan_data& operator=(const equip_plan_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const equip_plan_data& default_instance();

  void Swap(equip_plan_data* other);

  // implements Message ----------------------------------------------

  equip_plan_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const equip_plan_data& from);
  void MergeFrom(const equip_plan_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.equip_plan_single equip_plan_info = 1;
  inline int equip_plan_info_size() const;
  inline void clear_equip_plan_info();
  static const int kEquipPlanInfoFieldNumber = 1;
  inline const ::proto::common::equip_plan_single& equip_plan_info(int index) const;
  inline ::proto::common::equip_plan_single* mutable_equip_plan_info(int index);
  inline ::proto::common::equip_plan_single* add_equip_plan_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::equip_plan_single >&
      equip_plan_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::equip_plan_single >*
      mutable_equip_plan_info();

  // @@protoc_insertion_point(class_scope:proto.common.equip_plan_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::equip_plan_single > equip_plan_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static equip_plan_data* default_instance_;
};
// -------------------------------------------------------------------

class exchange_item_data : public ::google::protobuf::Message {
 public:
  exchange_item_data();
  virtual ~exchange_item_data();

  exchange_item_data(const exchange_item_data& from);

  inline exchange_item_data& operator=(const exchange_item_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exchange_item_data& default_instance();

  void Swap(exchange_item_data* other);

  // implements Message ----------------------------------------------

  exchange_item_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exchange_item_data& from);
  void MergeFrom(const exchange_item_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 cur_num = 2;
  inline bool has_cur_num() const;
  inline void clear_cur_num();
  static const int kCurNumFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_num() const;
  inline void set_cur_num(::google::protobuf::uint32 value);

  // optional uint32 max_num = 3;
  inline bool has_max_num() const;
  inline void clear_max_num();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::uint32 max_num() const;
  inline void set_max_num(::google::protobuf::uint32 value);

  // optional string need_item = 4;
  inline bool has_need_item() const;
  inline void clear_need_item();
  static const int kNeedItemFieldNumber = 4;
  inline const ::std::string& need_item() const;
  inline void set_need_item(const ::std::string& value);
  inline void set_need_item(const char* value);
  inline void set_need_item(const char* value, size_t size);
  inline ::std::string* mutable_need_item();
  inline ::std::string* release_need_item();
  inline void set_allocated_need_item(::std::string* need_item);

  // optional string make_item = 5;
  inline bool has_make_item() const;
  inline void clear_make_item();
  static const int kMakeItemFieldNumber = 5;
  inline const ::std::string& make_item() const;
  inline void set_make_item(const ::std::string& value);
  inline void set_make_item(const char* value);
  inline void set_make_item(const char* value, size_t size);
  inline ::std::string* mutable_make_item();
  inline ::std::string* release_make_item();
  inline void set_allocated_make_item(::std::string* make_item);

  // @@protoc_insertion_point(class_scope:proto.common.exchange_item_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cur_num();
  inline void clear_has_cur_num();
  inline void set_has_max_num();
  inline void clear_has_max_num();
  inline void set_has_need_item();
  inline void clear_has_need_item();
  inline void set_has_make_item();
  inline void clear_has_make_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cur_num_;
  ::std::string* need_item_;
  ::std::string* make_item_;
  ::google::protobuf::uint32 max_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static exchange_item_data* default_instance_;
};
// -------------------------------------------------------------------

class exchange_item_save_info : public ::google::protobuf::Message {
 public:
  exchange_item_save_info();
  virtual ~exchange_item_save_info();

  exchange_item_save_info(const exchange_item_save_info& from);

  inline exchange_item_save_info& operator=(const exchange_item_save_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exchange_item_save_info& default_instance();

  void Swap(exchange_item_save_info* other);

  // implements Message ----------------------------------------------

  exchange_item_save_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exchange_item_save_info& from);
  void MergeFrom(const exchange_item_save_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 cur_num = 2;
  inline bool has_cur_num() const;
  inline void clear_cur_num();
  static const int kCurNumFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_num() const;
  inline void set_cur_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.exchange_item_save_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cur_num();
  inline void clear_has_cur_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cur_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static exchange_item_save_info* default_instance_;
};
// -------------------------------------------------------------------

class exchange_item_save_data : public ::google::protobuf::Message {
 public:
  exchange_item_save_data();
  virtual ~exchange_item_save_data();

  exchange_item_save_data(const exchange_item_save_data& from);

  inline exchange_item_save_data& operator=(const exchange_item_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exchange_item_save_data& default_instance();

  void Swap(exchange_item_save_data* other);

  // implements Message ----------------------------------------------

  exchange_item_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exchange_item_save_data& from);
  void MergeFrom(const exchange_item_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start_time = 1;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // repeated .proto.common.exchange_item_save_info info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::proto::common::exchange_item_save_info& info(int index) const;
  inline ::proto::common::exchange_item_save_info* mutable_info(int index);
  inline ::proto::common::exchange_item_save_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::exchange_item_save_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::exchange_item_save_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:proto.common.exchange_item_save_data)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::exchange_item_save_info > info_;
  ::google::protobuf::uint32 start_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static exchange_item_save_data* default_instance_;
};
// -------------------------------------------------------------------

class limit_buy_client_data : public ::google::protobuf::Message {
 public:
  limit_buy_client_data();
  virtual ~limit_buy_client_data();

  limit_buy_client_data(const limit_buy_client_data& from);

  inline limit_buy_client_data& operator=(const limit_buy_client_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const limit_buy_client_data& default_instance();

  void Swap(limit_buy_client_data* other);

  // implements Message ----------------------------------------------

  limit_buy_client_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const limit_buy_client_data& from);
  void MergeFrom(const limit_buy_client_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 show_item_id = 2;
  inline bool has_show_item_id() const;
  inline void clear_show_item_id();
  static const int kShowItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 show_item_id() const;
  inline void set_show_item_id(::google::protobuf::uint32 value);

  // optional uint32 show_item_num = 3;
  inline bool has_show_item_num() const;
  inline void clear_show_item_num();
  static const int kShowItemNumFieldNumber = 3;
  inline ::google::protobuf::uint32 show_item_num() const;
  inline void set_show_item_num(::google::protobuf::uint32 value);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional uint32 buy_money_type = 5;
  inline bool has_buy_money_type() const;
  inline void clear_buy_money_type();
  static const int kBuyMoneyTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 buy_money_type() const;
  inline void set_buy_money_type(::google::protobuf::uint32 value);

  // optional uint32 buy_money = 6;
  inline bool has_buy_money() const;
  inline void clear_buy_money();
  static const int kBuyMoneyFieldNumber = 6;
  inline ::google::protobuf::uint32 buy_money() const;
  inline void set_buy_money(::google::protobuf::uint32 value);

  // optional uint32 buy_num = 7;
  inline bool has_buy_num() const;
  inline void clear_buy_num();
  static const int kBuyNumFieldNumber = 7;
  inline ::google::protobuf::uint32 buy_num() const;
  inline void set_buy_num(::google::protobuf::uint32 value);

  // optional uint32 src_buy_money = 8;
  inline bool has_src_buy_money() const;
  inline void clear_src_buy_money();
  static const int kSrcBuyMoneyFieldNumber = 8;
  inline ::google::protobuf::uint32 src_buy_money() const;
  inline void set_src_buy_money(::google::protobuf::uint32 value);

  // optional uint32 is_buy_num = 9;
  inline bool has_is_buy_num() const;
  inline void clear_is_buy_num();
  static const int kIsBuyNumFieldNumber = 9;
  inline ::google::protobuf::uint32 is_buy_num() const;
  inline void set_is_buy_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.limit_buy_client_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_show_item_id();
  inline void clear_has_show_item_id();
  inline void set_has_show_item_num();
  inline void clear_has_show_item_num();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_buy_money_type();
  inline void clear_has_buy_money_type();
  inline void set_has_buy_money();
  inline void clear_has_buy_money();
  inline void set_has_buy_num();
  inline void clear_has_buy_num();
  inline void set_has_src_buy_money();
  inline void clear_has_src_buy_money();
  inline void set_has_is_buy_num();
  inline void clear_has_is_buy_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 show_item_id_;
  ::std::string* desc_;
  ::google::protobuf::uint32 show_item_num_;
  ::google::protobuf::uint32 buy_money_type_;
  ::google::protobuf::uint32 buy_money_;
  ::google::protobuf::uint32 buy_num_;
  ::google::protobuf::uint32 src_buy_money_;
  ::google::protobuf::uint32 is_buy_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static limit_buy_client_data* default_instance_;
};
// -------------------------------------------------------------------

class limit_buy_save_info : public ::google::protobuf::Message {
 public:
  limit_buy_save_info();
  virtual ~limit_buy_save_info();

  limit_buy_save_info(const limit_buy_save_info& from);

  inline limit_buy_save_info& operator=(const limit_buy_save_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const limit_buy_save_info& default_instance();

  void Swap(limit_buy_save_info* other);

  // implements Message ----------------------------------------------

  limit_buy_save_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const limit_buy_save_info& from);
  void MergeFrom(const limit_buy_save_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.limit_buy_save_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static limit_buy_save_info* default_instance_;
};
// -------------------------------------------------------------------

class limit_buy_save_data : public ::google::protobuf::Message {
 public:
  limit_buy_save_data();
  virtual ~limit_buy_save_data();

  limit_buy_save_data(const limit_buy_save_data& from);

  inline limit_buy_save_data& operator=(const limit_buy_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const limit_buy_save_data& default_instance();

  void Swap(limit_buy_save_data* other);

  // implements Message ----------------------------------------------

  limit_buy_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const limit_buy_save_data& from);
  void MergeFrom(const limit_buy_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 red = 2;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 2;
  inline ::google::protobuf::uint32 red() const;
  inline void set_red(::google::protobuf::uint32 value);

  // repeated .proto.common.limit_buy_save_info info = 3;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::proto::common::limit_buy_save_info& info(int index) const;
  inline ::proto::common::limit_buy_save_info* mutable_info(int index);
  inline ::proto::common::limit_buy_save_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::limit_buy_save_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::limit_buy_save_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:proto.common.limit_buy_save_data)
 private:
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_red();
  inline void clear_has_red();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 red_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::limit_buy_save_info > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static limit_buy_save_data* default_instance_;
};
// -------------------------------------------------------------------

class sd_target_info : public ::google::protobuf::Message {
 public:
  sd_target_info();
  virtual ~sd_target_info();

  sd_target_info(const sd_target_info& from);

  inline sd_target_info& operator=(const sd_target_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sd_target_info& default_instance();

  void Swap(sd_target_info* other);

  // implements Message ----------------------------------------------

  sd_target_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sd_target_info& from);
  void MergeFrom(const sd_target_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 max_num = 3;
  inline bool has_max_num() const;
  inline void clear_max_num();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::uint32 max_num() const;
  inline void set_max_num(::google::protobuf::uint32 value);

  // optional uint32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 target_id = 5;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 5;
  inline ::google::protobuf::uint32 target_id() const;
  inline void set_target_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.sd_target_info)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_max_num();
  inline void clear_has_max_num();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 max_num_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 target_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sd_target_info* default_instance_;
};
// -------------------------------------------------------------------

class sd_target_save_data : public ::google::protobuf::Message {
 public:
  sd_target_save_data();
  virtual ~sd_target_save_data();

  sd_target_save_data(const sd_target_save_data& from);

  inline sd_target_save_data& operator=(const sd_target_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sd_target_save_data& default_instance();

  void Swap(sd_target_save_data* other);

  // implements Message ----------------------------------------------

  sd_target_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sd_target_save_data& from);
  void MergeFrom(const sd_target_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // repeated uint32 info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline ::google::protobuf::uint32 info(int index) const;
  inline void set_info(int index, ::google::protobuf::uint32 value);
  inline void add_info(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      info() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:proto.common.sd_target_save_data)
 private:
  inline void set_has_day();
  inline void clear_has_day();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > info_;
  ::google::protobuf::uint32 day_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sd_target_save_data* default_instance_;
};
// -------------------------------------------------------------------

class sd_target_red_info : public ::google::protobuf::Message {
 public:
  sd_target_red_info();
  virtual ~sd_target_red_info();

  sd_target_red_info(const sd_target_red_info& from);

  inline sd_target_red_info& operator=(const sd_target_red_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sd_target_red_info& default_instance();

  void Swap(sd_target_red_info* other);

  // implements Message ----------------------------------------------

  sd_target_red_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sd_target_red_info& from);
  void MergeFrom(const sd_target_red_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 day = 1;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 1;
  inline ::google::protobuf::uint32 day() const;
  inline void set_day(::google::protobuf::uint32 value);

  // optional uint32 red = 2;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 2;
  inline ::google::protobuf::uint32 red() const;
  inline void set_red(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.sd_target_red_info)
 private:
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_red();
  inline void clear_has_red();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 day_;
  ::google::protobuf::uint32 red_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static sd_target_red_info* default_instance_;
};
// -------------------------------------------------------------------

class statistical_save_info : public ::google::protobuf::Message {
 public:
  statistical_save_info();
  virtual ~statistical_save_info();

  statistical_save_info(const statistical_save_info& from);

  inline statistical_save_info& operator=(const statistical_save_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statistical_save_info& default_instance();

  void Swap(statistical_save_info* other);

  // implements Message ----------------------------------------------

  statistical_save_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statistical_save_info& from);
  void MergeFrom(const statistical_save_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.statistical_save_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static statistical_save_info* default_instance_;
};
// -------------------------------------------------------------------

class statistical_save_data : public ::google::protobuf::Message {
 public:
  statistical_save_data();
  virtual ~statistical_save_data();

  statistical_save_data(const statistical_save_data& from);

  inline statistical_save_data& operator=(const statistical_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statistical_save_data& default_instance();

  void Swap(statistical_save_data* other);

  // implements Message ----------------------------------------------

  statistical_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statistical_save_data& from);
  void MergeFrom(const statistical_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.statistical_save_info info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::proto::common::statistical_save_info& info(int index) const;
  inline ::proto::common::statistical_save_info* mutable_info(int index);
  inline ::proto::common::statistical_save_info* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::statistical_save_info >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::statistical_save_info >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:proto.common.statistical_save_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::statistical_save_info > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static statistical_save_data* default_instance_;
};
// -------------------------------------------------------------------

class general_event_info : public ::google::protobuf::Message {
 public:
  general_event_info();
  virtual ~general_event_info();

  general_event_info(const general_event_info& from);

  inline general_event_info& operator=(const general_event_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_event_info& default_instance();

  void Swap(general_event_info* other);

  // implements Message ----------------------------------------------

  general_event_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_event_info& from);
  void MergeFrom(const general_event_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 process = 2;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 2;
  inline ::google::protobuf::uint32 process() const;
  inline void set_process(::google::protobuf::uint32 value);

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 time_left = 4;
  inline bool has_time_left() const;
  inline void clear_time_left();
  static const int kTimeLeftFieldNumber = 4;
  inline ::google::protobuf::uint32 time_left() const;
  inline void set_time_left(::google::protobuf::uint32 value);

  // optional string first_name = 5;
  inline bool has_first_name() const;
  inline void clear_first_name();
  static const int kFirstNameFieldNumber = 5;
  inline const ::std::string& first_name() const;
  inline void set_first_name(const ::std::string& value);
  inline void set_first_name(const char* value);
  inline void set_first_name(const char* value, size_t size);
  inline ::std::string* mutable_first_name();
  inline ::std::string* release_first_name();
  inline void set_allocated_first_name(::std::string* first_name);

  // optional uint32 red_num = 6;
  inline bool has_red_num() const;
  inline void clear_red_num();
  static const int kRedNumFieldNumber = 6;
  inline ::google::protobuf::uint32 red_num() const;
  inline void set_red_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.general_event_info)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_time_left();
  inline void clear_has_time_left();
  inline void set_has_first_name();
  inline void clear_has_first_name();
  inline void set_has_red_num();
  inline void clear_has_red_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 process_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 time_left_;
  ::std::string* first_name_;
  ::google::protobuf::uint32 red_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_event_info* default_instance_;
};
// -------------------------------------------------------------------

class general_event_detail : public ::google::protobuf::Message {
 public:
  general_event_detail();
  virtual ~general_event_detail();

  general_event_detail(const general_event_detail& from);

  inline general_event_detail& operator=(const general_event_detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_event_detail& default_instance();

  void Swap(general_event_detail* other);

  // implements Message ----------------------------------------------

  general_event_detail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_event_detail& from);
  void MergeFrom(const general_event_detail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 process = 2;
  inline bool has_process() const;
  inline void clear_process();
  static const int kProcessFieldNumber = 2;
  inline ::google::protobuf::uint32 process() const;
  inline void set_process(::google::protobuf::uint32 value);

  // optional uint32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.general_event_detail)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_process();
  inline void clear_has_process();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 process_;
  ::google::protobuf::uint32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_event_detail* default_instance_;
};
// -------------------------------------------------------------------

class general_event_count_data : public ::google::protobuf::Message {
 public:
  general_event_count_data();
  virtual ~general_event_count_data();

  general_event_count_data(const general_event_count_data& from);

  inline general_event_count_data& operator=(const general_event_count_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_event_count_data& default_instance();

  void Swap(general_event_count_data* other);

  // implements Message ----------------------------------------------

  general_event_count_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_event_count_data& from);
  void MergeFrom(const general_event_count_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.general_event_count_data)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_event_count_data* default_instance_;
};
// -------------------------------------------------------------------

class general_event_data : public ::google::protobuf::Message {
 public:
  general_event_data();
  virtual ~general_event_data();

  general_event_data(const general_event_data& from);

  inline general_event_data& operator=(const general_event_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_event_data& default_instance();

  void Swap(general_event_data* other);

  // implements Message ----------------------------------------------

  general_event_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_event_data& from);
  void MergeFrom(const general_event_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 start_time = 3;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional uint32 is_speed_time = 5;
  inline bool has_is_speed_time() const;
  inline void clear_is_speed_time();
  static const int kIsSpeedTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 is_speed_time() const;
  inline void set_is_speed_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.general_event_data)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_is_speed_time();
  inline void clear_has_is_speed_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 is_speed_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_event_data* default_instance_;
};
// -------------------------------------------------------------------

class general_event_save_data : public ::google::protobuf::Message {
 public:
  general_event_save_data();
  virtual ~general_event_save_data();

  general_event_save_data(const general_event_save_data& from);

  inline general_event_save_data& operator=(const general_event_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_event_save_data& default_instance();

  void Swap(general_event_save_data* other);

  // implements Message ----------------------------------------------

  general_event_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_event_save_data& from);
  void MergeFrom(const general_event_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 red = 1;
  inline int red_size() const;
  inline void clear_red();
  static const int kRedFieldNumber = 1;
  inline ::google::protobuf::uint32 red(int index) const;
  inline void set_red(int index, ::google::protobuf::uint32 value);
  inline void add_red(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      red() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_red();

  // repeated uint32 data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline ::google::protobuf::uint32 data(int index) const;
  inline void set_data(int index, ::google::protobuf::uint32 value);
  inline void add_data(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      data() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:proto.common.general_event_save_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > red_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_event_save_data* default_instance_;
};
// -------------------------------------------------------------------

class general_info_single : public ::google::protobuf::Message {
 public:
  general_info_single();
  virtual ~general_info_single();

  general_info_single(const general_info_single& from);

  inline general_info_single& operator=(const general_info_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_info_single& default_instance();

  void Swap(general_info_single* other);

  // implements Message ----------------------------------------------

  general_info_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_info_single& from);
  void MergeFrom(const general_info_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.general_info_single)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_info_single* default_instance_;
};
// -------------------------------------------------------------------

class general_info_data : public ::google::protobuf::Message {
 public:
  general_info_data();
  virtual ~general_info_data();

  general_info_data(const general_info_data& from);

  inline general_info_data& operator=(const general_info_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_info_data& default_instance();

  void Swap(general_info_data* other);

  // implements Message ----------------------------------------------

  general_info_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_info_data& from);
  void MergeFrom(const general_info_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.general_info_single general_info = 1;
  inline int general_info_size() const;
  inline void clear_general_info();
  static const int kGeneralInfoFieldNumber = 1;
  inline const ::proto::common::general_info_single& general_info(int index) const;
  inline ::proto::common::general_info_single* mutable_general_info(int index);
  inline ::proto::common::general_info_single* add_general_info();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::general_info_single >&
      general_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::general_info_single >*
      mutable_general_info();

  // @@protoc_insertion_point(class_scope:proto.common.general_info_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::general_info_single > general_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_info_data* default_instance_;
};
// -------------------------------------------------------------------

class family_skill_single : public ::google::protobuf::Message {
 public:
  family_skill_single();
  virtual ~family_skill_single();

  family_skill_single(const family_skill_single& from);

  inline family_skill_single& operator=(const family_skill_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_skill_single& default_instance();

  void Swap(family_skill_single* other);

  // implements Message ----------------------------------------------

  family_skill_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_skill_single& from);
  void MergeFrom(const family_skill_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::uint32 skill_id() const;
  inline void set_skill_id(::google::protobuf::uint32 value);

  // optional uint32 skill_level = 2;
  inline bool has_skill_level() const;
  inline void clear_skill_level();
  static const int kSkillLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 skill_level() const;
  inline void set_skill_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.family_skill_single)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_level();
  inline void clear_has_skill_level();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 skill_id_;
  ::google::protobuf::uint32 skill_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_skill_single* default_instance_;
};
// -------------------------------------------------------------------

class family_skill_data : public ::google::protobuf::Message {
 public:
  family_skill_data();
  virtual ~family_skill_data();

  family_skill_data(const family_skill_data& from);

  inline family_skill_data& operator=(const family_skill_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const family_skill_data& default_instance();

  void Swap(family_skill_data* other);

  // implements Message ----------------------------------------------

  family_skill_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const family_skill_data& from);
  void MergeFrom(const family_skill_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.family_skill_single skill_data = 1;
  inline int skill_data_size() const;
  inline void clear_skill_data();
  static const int kSkillDataFieldNumber = 1;
  inline const ::proto::common::family_skill_single& skill_data(int index) const;
  inline ::proto::common::family_skill_single* mutable_skill_data(int index);
  inline ::proto::common::family_skill_single* add_skill_data();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_skill_single >&
      skill_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_skill_single >*
      mutable_skill_data();

  // @@protoc_insertion_point(class_scope:proto.common.family_skill_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::family_skill_single > skill_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static family_skill_data* default_instance_;
};
// -------------------------------------------------------------------

class general_status_save_data : public ::google::protobuf::Message {
 public:
  general_status_save_data();
  virtual ~general_status_save_data();

  general_status_save_data(const general_status_save_data& from);

  inline general_status_save_data& operator=(const general_status_save_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const general_status_save_data& default_instance();

  void Swap(general_status_save_data* other);

  // implements Message ----------------------------------------------

  general_status_save_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const general_status_save_data& from);
  void MergeFrom(const general_status_save_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.common.general_event_data data_list = 1;
  inline int data_list_size() const;
  inline void clear_data_list();
  static const int kDataListFieldNumber = 1;
  inline const ::proto::common::general_event_data& data_list(int index) const;
  inline ::proto::common::general_event_data* mutable_data_list(int index);
  inline ::proto::common::general_event_data* add_data_list();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::general_event_data >&
      data_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::general_event_data >*
      mutable_data_list();

  // @@protoc_insertion_point(class_scope:proto.common.general_status_save_data)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::proto::common::general_event_data > data_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static general_status_save_data* default_instance_;
};
// -------------------------------------------------------------------

class gm_msg_to_account : public ::google::protobuf::Message {
 public:
  gm_msg_to_account();
  virtual ~gm_msg_to_account();

  gm_msg_to_account(const gm_msg_to_account& from);

  inline gm_msg_to_account& operator=(const gm_msg_to_account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const gm_msg_to_account& default_instance();

  void Swap(gm_msg_to_account* other);

  // implements Message ----------------------------------------------

  gm_msg_to_account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const gm_msg_to_account& from);
  void MergeFrom(const gm_msg_to_account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 user_create_flag = 1;
  inline bool has_user_create_flag() const;
  inline void clear_user_create_flag();
  static const int kUserCreateFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 user_create_flag() const;
  inline void set_user_create_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.gm_msg_to_account)
 private:
  inline void set_has_user_create_flag();
  inline void clear_has_user_create_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_create_flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static gm_msg_to_account* default_instance_;
};
// -------------------------------------------------------------------

class rank_time_single : public ::google::protobuf::Message {
 public:
  rank_time_single();
  virtual ~rank_time_single();

  rank_time_single(const rank_time_single& from);

  inline rank_time_single& operator=(const rank_time_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rank_time_single& default_instance();

  void Swap(rank_time_single* other);

  // implements Message ----------------------------------------------

  rank_time_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rank_time_single& from);
  void MergeFrom(const rank_time_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rank_id = 1;
  inline bool has_rank_id() const;
  inline void clear_rank_id();
  static const int kRankIdFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_id() const;
  inline void set_rank_id(::google::protobuf::uint32 value);

  // optional uint32 start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 start_time() const;
  inline void set_start_time(::google::protobuf::uint32 value);

  // optional uint32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 end_time() const;
  inline void set_end_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.rank_time_single)
 private:
  inline void set_has_rank_id();
  inline void clear_has_rank_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rank_id_;
  ::google::protobuf::uint32 start_time_;
  ::google::protobuf::uint32 end_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static rank_time_single* default_instance_;
};
// -------------------------------------------------------------------

class office_data : public ::google::protobuf::Message {
 public:
  office_data();
  virtual ~office_data();

  office_data(const office_data& from);

  inline office_data& operator=(const office_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const office_data& default_instance();

  void Swap(office_data* other);

  // implements Message ----------------------------------------------

  office_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const office_data& from);
  void MergeFrom(const office_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 award = 3;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 3;
  inline ::google::protobuf::uint32 award() const;
  inline void set_award(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.office_data)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_award();
  inline void clear_has_award();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 award_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static office_data* default_instance_;
};
// -------------------------------------------------------------------

class office_task_single : public ::google::protobuf::Message {
 public:
  office_task_single();
  virtual ~office_task_single();

  office_task_single(const office_task_single& from);

  inline office_task_single& operator=(const office_task_single& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const office_task_single& default_instance();

  void Swap(office_task_single* other);

  // implements Message ----------------------------------------------

  office_task_single* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const office_task_single& from);
  void MergeFrom(const office_task_single& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.office_task_single)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static office_task_single* default_instance_;
};
// -------------------------------------------------------------------

class office_client_data : public ::google::protobuf::Message {
 public:
  office_client_data();
  virtual ~office_client_data();

  office_client_data(const office_client_data& from);

  inline office_client_data& operator=(const office_client_data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const office_client_data& default_instance();

  void Swap(office_client_data* other);

  // implements Message ----------------------------------------------

  office_client_data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const office_client_data& from);
  void MergeFrom(const office_client_data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // optional uint32 award = 3;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 3;
  inline ::google::protobuf::uint32 award() const;
  inline void set_award(::google::protobuf::uint32 value);

  // repeated .proto.common.office_task_single tasks = 4;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 4;
  inline const ::proto::common::office_task_single& tasks(int index) const;
  inline ::proto::common::office_task_single* mutable_tasks(int index);
  inline ::proto::common::office_task_single* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::office_task_single >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::office_task_single >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:proto.common.office_client_data)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_award();
  inline void clear_has_award();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::office_task_single > tasks_;
  ::google::protobuf::uint32 award_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static office_client_data* default_instance_;
};
// -------------------------------------------------------------------

class video_hero_base : public ::google::protobuf::Message {
 public:
  video_hero_base();
  virtual ~video_hero_base();

  video_hero_base(const video_hero_base& from);

  inline video_hero_base& operator=(const video_hero_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const video_hero_base& default_instance();

  void Swap(video_hero_base* other);

  // implements Message ----------------------------------------------

  video_hero_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const video_hero_base& from);
  void MergeFrom(const video_hero_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tid = 1;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 1;
  inline ::google::protobuf::uint32 tid() const;
  inline void set_tid(::google::protobuf::uint32 value);

  // optional uint32 resource_id = 2;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 resource_id() const;
  inline void set_resource_id(::google::protobuf::uint32 value);

  // optional uint32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional uint32 start = 4;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 4;
  inline ::google::protobuf::uint32 start() const;
  inline void set_start(::google::protobuf::uint32 value);

  // optional uint32 grade = 5;
  inline bool has_grade() const;
  inline void clear_grade();
  static const int kGradeFieldNumber = 5;
  inline ::google::protobuf::uint32 grade() const;
  inline void set_grade(::google::protobuf::uint32 value);

  // optional uint32 quality = 6;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 6;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // optional uint32 terry = 7;
  inline bool has_terry() const;
  inline void clear_terry();
  static const int kTerryFieldNumber = 7;
  inline ::google::protobuf::uint32 terry() const;
  inline void set_terry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.video_hero_base)
 private:
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_grade();
  inline void clear_has_grade();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_terry();
  inline void clear_has_terry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tid_;
  ::google::protobuf::uint32 resource_id_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 start_;
  ::google::protobuf::uint32 grade_;
  ::google::protobuf::uint32 quality_;
  ::google::protobuf::uint32 terry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static video_hero_base* default_instance_;
};
// -------------------------------------------------------------------

class video_arena_ex : public ::google::protobuf::Message {
 public:
  video_arena_ex();
  virtual ~video_arena_ex();

  video_arena_ex(const video_arena_ex& from);

  inline video_arena_ex& operator=(const video_arena_ex& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const video_arena_ex& default_instance();

  void Swap(video_arena_ex* other);

  // implements Message ----------------------------------------------

  video_arena_ex* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const video_arena_ex& from);
  void MergeFrom(const video_arena_ex& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rank_lv = 1;
  inline bool has_rank_lv() const;
  inline void clear_rank_lv();
  static const int kRankLvFieldNumber = 1;
  inline ::google::protobuf::uint32 rank_lv() const;
  inline void set_rank_lv(::google::protobuf::uint32 value);

  // optional uint32 score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.common.video_arena_ex)
 private:
  inline void set_has_rank_lv();
  inline void clear_has_rank_lv();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rank_lv_;
  ::google::protobuf::uint32 score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static video_arena_ex* default_instance_;
};
// -------------------------------------------------------------------

class video_obj_base : public ::google::protobuf::Message {
 public:
  video_obj_base();
  virtual ~video_obj_base();

  video_obj_base(const video_obj_base& from);

  inline video_obj_base& operator=(const video_obj_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const video_obj_base& default_instance();

  void Swap(video_obj_base* other);

  // implements Message ----------------------------------------------

  video_obj_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const video_obj_base& from);
  void MergeFrom(const video_obj_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2 [default = SCENEOBJECT_USER];
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 2;
  inline ::proto::common::EM_SCENEOBJECT_TYPE object_type() const;
  inline void set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline ::google::protobuf::uint32 head() const;
  inline void set_head(::google::protobuf::uint32 value);

  // optional uint32 fighting = 5;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 5;
  inline ::google::protobuf::uint32 fighting() const;
  inline void set_fighting(::google::protobuf::uint32 value);

  // optional uint32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional .proto.common.video_arena_ex cross_arena = 7;
  inline bool has_cross_arena() const;
  inline void clear_cross_arena();
  static const int kCrossArenaFieldNumber = 7;
  inline const ::proto::common::video_arena_ex& cross_arena() const;
  inline ::proto::common::video_arena_ex* mutable_cross_arena();
  inline ::proto::common::video_arena_ex* release_cross_arena();
  inline void set_allocated_cross_arena(::proto::common::video_arena_ex* cross_arena);

  // repeated .proto.common.video_hero_base heros = 8;
  inline int heros_size() const;
  inline void clear_heros();
  static const int kHerosFieldNumber = 8;
  inline const ::proto::common::video_hero_base& heros(int index) const;
  inline ::proto::common::video_hero_base* mutable_heros(int index);
  inline ::proto::common::video_hero_base* add_heros();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::video_hero_base >&
      heros() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::video_hero_base >*
      mutable_heros();

  // @@protoc_insertion_point(class_scope:proto.common.video_obj_base)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_cross_arena();
  inline void clear_has_cross_arena();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  int object_type_;
  ::google::protobuf::uint32 head_;
  ::google::protobuf::uint32 fighting_;
  ::google::protobuf::uint32 level_;
  ::proto::common::video_arena_ex* cross_arena_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::video_hero_base > heros_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static video_obj_base* default_instance_;
};
// -------------------------------------------------------------------

class video_single_base : public ::google::protobuf::Message {
 public:
  video_single_base();
  virtual ~video_single_base();

  video_single_base(const video_single_base& from);

  inline video_single_base& operator=(const video_single_base& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const video_single_base& default_instance();

  void Swap(video_single_base* other);

  // implements Message ----------------------------------------------

  video_single_base* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const video_single_base& from);
  void MergeFrom(const video_single_base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string video_uid = 1;
  inline bool has_video_uid() const;
  inline void clear_video_uid();
  static const int kVideoUidFieldNumber = 1;
  inline const ::std::string& video_uid() const;
  inline void set_video_uid(const ::std::string& value);
  inline void set_video_uid(const char* value);
  inline void set_video_uid(const char* value, size_t size);
  inline ::std::string* mutable_video_uid();
  inline ::std::string* release_video_uid();
  inline void set_allocated_video_uid(::std::string* video_uid);

  // optional uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // optional uint32 fight_times = 3;
  inline bool has_fight_times() const;
  inline void clear_fight_times();
  static const int kFightTimesFieldNumber = 3;
  inline ::google::protobuf::uint32 fight_times() const;
  inline void set_fight_times(::google::protobuf::uint32 value);

  // optional uint32 win_camp = 4;
  inline bool has_win_camp() const;
  inline void clear_win_camp();
  static const int kWinCampFieldNumber = 4;
  inline ::google::protobuf::uint32 win_camp() const;
  inline void set_win_camp(::google::protobuf::uint32 value);

  // optional uint32 layer_id = 5;
  inline bool has_layer_id() const;
  inline void clear_layer_id();
  static const int kLayerIdFieldNumber = 5;
  inline ::google::protobuf::uint32 layer_id() const;
  inline void set_layer_id(::google::protobuf::uint32 value);

  // optional uint32 cost_time = 6;
  inline bool has_cost_time() const;
  inline void clear_cost_time();
  static const int kCostTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 cost_time() const;
  inline void set_cost_time(::google::protobuf::uint32 value);

  // repeated .proto.common.video_obj_base objs = 10;
  inline int objs_size() const;
  inline void clear_objs();
  static const int kObjsFieldNumber = 10;
  inline const ::proto::common::video_obj_base& objs(int index) const;
  inline ::proto::common::video_obj_base* mutable_objs(int index);
  inline ::proto::common::video_obj_base* add_objs();
  inline const ::google::protobuf::RepeatedPtrField< ::proto::common::video_obj_base >&
      objs() const;
  inline ::google::protobuf::RepeatedPtrField< ::proto::common::video_obj_base >*
      mutable_objs();

  // @@protoc_insertion_point(class_scope:proto.common.video_single_base)
 private:
  inline void set_has_video_uid();
  inline void clear_has_video_uid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_fight_times();
  inline void clear_has_fight_times();
  inline void set_has_win_camp();
  inline void clear_has_win_camp();
  inline void set_has_layer_id();
  inline void clear_has_layer_id();
  inline void set_has_cost_time();
  inline void clear_has_cost_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* video_uid_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 fight_times_;
  ::google::protobuf::uint32 win_camp_;
  ::google::protobuf::uint32 layer_id_;
  ::google::protobuf::RepeatedPtrField< ::proto::common::video_obj_base > objs_;
  ::google::protobuf::uint32 cost_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static video_single_base* default_instance_;
};
// ===================================================================


// ===================================================================

// object_state_info

// optional .proto.common.object_state_type obj_state = 1 [default = object_state_none];
inline bool object_state_info::has_obj_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void object_state_info::set_has_obj_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void object_state_info::clear_has_obj_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void object_state_info::clear_obj_state() {
  obj_state_ = 0;
  clear_has_obj_state();
}
inline ::proto::common::object_state_type object_state_info::obj_state() const {
  return static_cast< ::proto::common::object_state_type >(obj_state_);
}
inline void object_state_info::set_obj_state(::proto::common::object_state_type value) {
  assert(::proto::common::object_state_type_IsValid(value));
  set_has_obj_state();
  obj_state_ = value;
}

// optional .proto.common.role_mode_state mode_state = 2 [default = role_mode_state_normal];
inline bool object_state_info::has_mode_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void object_state_info::set_has_mode_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void object_state_info::clear_has_mode_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void object_state_info::clear_mode_state() {
  mode_state_ = 1;
  clear_has_mode_state();
}
inline ::proto::common::role_mode_state object_state_info::mode_state() const {
  return static_cast< ::proto::common::role_mode_state >(mode_state_);
}
inline void object_state_info::set_mode_state(::proto::common::role_mode_state value) {
  assert(::proto::common::role_mode_state_IsValid(value));
  set_has_mode_state();
  mode_state_ = value;
}

// optional string obj_state_param = 3;
inline bool object_state_info::has_obj_state_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void object_state_info::set_has_obj_state_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void object_state_info::clear_has_obj_state_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void object_state_info::clear_obj_state_param() {
  if (obj_state_param_ != &::google::protobuf::internal::kEmptyString) {
    obj_state_param_->clear();
  }
  clear_has_obj_state_param();
}
inline const ::std::string& object_state_info::obj_state_param() const {
  return *obj_state_param_;
}
inline void object_state_info::set_obj_state_param(const ::std::string& value) {
  set_has_obj_state_param();
  if (obj_state_param_ == &::google::protobuf::internal::kEmptyString) {
    obj_state_param_ = new ::std::string;
  }
  obj_state_param_->assign(value);
}
inline void object_state_info::set_obj_state_param(const char* value) {
  set_has_obj_state_param();
  if (obj_state_param_ == &::google::protobuf::internal::kEmptyString) {
    obj_state_param_ = new ::std::string;
  }
  obj_state_param_->assign(value);
}
inline void object_state_info::set_obj_state_param(const char* value, size_t size) {
  set_has_obj_state_param();
  if (obj_state_param_ == &::google::protobuf::internal::kEmptyString) {
    obj_state_param_ = new ::std::string;
  }
  obj_state_param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_state_info::mutable_obj_state_param() {
  set_has_obj_state_param();
  if (obj_state_param_ == &::google::protobuf::internal::kEmptyString) {
    obj_state_param_ = new ::std::string;
  }
  return obj_state_param_;
}
inline ::std::string* object_state_info::release_obj_state_param() {
  clear_has_obj_state_param();
  if (obj_state_param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = obj_state_param_;
    obj_state_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_state_info::set_allocated_obj_state_param(::std::string* obj_state_param) {
  if (obj_state_param_ != &::google::protobuf::internal::kEmptyString) {
    delete obj_state_param_;
  }
  if (obj_state_param) {
    set_has_obj_state_param();
    obj_state_param_ = obj_state_param;
  } else {
    clear_has_obj_state_param();
    obj_state_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 alert_time = 4;
inline bool object_state_info::has_alert_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void object_state_info::set_has_alert_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void object_state_info::clear_has_alert_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void object_state_info::clear_alert_time() {
  alert_time_ = 0u;
  clear_has_alert_time();
}
inline ::google::protobuf::uint32 object_state_info::alert_time() const {
  return alert_time_;
}
inline void object_state_info::set_alert_time(::google::protobuf::uint32 value) {
  set_has_alert_time();
  alert_time_ = value;
}

// -------------------------------------------------------------------

// mobile_info

// optional string uuid = 1;
inline bool mobile_info::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mobile_info::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mobile_info::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mobile_info::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& mobile_info::uuid() const {
  return *uuid_;
}
inline void mobile_info::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mobile_info::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mobile_info::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mobile_info::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* mobile_info::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mobile_info::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_model = 2;
inline bool mobile_info::has_device_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mobile_info::set_has_device_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mobile_info::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mobile_info::clear_device_model() {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    device_model_->clear();
  }
  clear_has_device_model();
}
inline const ::std::string& mobile_info::device_model() const {
  return *device_model_;
}
inline void mobile_info::set_device_model(const ::std::string& value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void mobile_info::set_device_model(const char* value) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(value);
}
inline void mobile_info::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  device_model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mobile_info::mutable_device_model() {
  set_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    device_model_ = new ::std::string;
  }
  return device_model_;
}
inline ::std::string* mobile_info::release_device_model() {
  clear_has_device_model();
  if (device_model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_model_;
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mobile_info::set_allocated_device_model(::std::string* device_model) {
  if (device_model_ != &::google::protobuf::internal::kEmptyString) {
    delete device_model_;
  }
  if (device_model) {
    set_has_device_model();
    device_model_ = device_model;
  } else {
    clear_has_device_model();
    device_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_sys_version = 3;
inline bool mobile_info::has_device_sys_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mobile_info::set_has_device_sys_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mobile_info::clear_has_device_sys_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mobile_info::clear_device_sys_version() {
  if (device_sys_version_ != &::google::protobuf::internal::kEmptyString) {
    device_sys_version_->clear();
  }
  clear_has_device_sys_version();
}
inline const ::std::string& mobile_info::device_sys_version() const {
  return *device_sys_version_;
}
inline void mobile_info::set_device_sys_version(const ::std::string& value) {
  set_has_device_sys_version();
  if (device_sys_version_ == &::google::protobuf::internal::kEmptyString) {
    device_sys_version_ = new ::std::string;
  }
  device_sys_version_->assign(value);
}
inline void mobile_info::set_device_sys_version(const char* value) {
  set_has_device_sys_version();
  if (device_sys_version_ == &::google::protobuf::internal::kEmptyString) {
    device_sys_version_ = new ::std::string;
  }
  device_sys_version_->assign(value);
}
inline void mobile_info::set_device_sys_version(const char* value, size_t size) {
  set_has_device_sys_version();
  if (device_sys_version_ == &::google::protobuf::internal::kEmptyString) {
    device_sys_version_ = new ::std::string;
  }
  device_sys_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mobile_info::mutable_device_sys_version() {
  set_has_device_sys_version();
  if (device_sys_version_ == &::google::protobuf::internal::kEmptyString) {
    device_sys_version_ = new ::std::string;
  }
  return device_sys_version_;
}
inline ::std::string* mobile_info::release_device_sys_version() {
  clear_has_device_sys_version();
  if (device_sys_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_sys_version_;
    device_sys_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mobile_info::set_allocated_device_sys_version(::std::string* device_sys_version) {
  if (device_sys_version_ != &::google::protobuf::internal::kEmptyString) {
    delete device_sys_version_;
  }
  if (device_sys_version) {
    set_has_device_sys_version();
    device_sys_version_ = device_sys_version;
  } else {
    clear_has_device_sys_version();
    device_sys_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cpu_type = 4;
inline bool mobile_info::has_cpu_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mobile_info::set_has_cpu_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mobile_info::clear_has_cpu_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mobile_info::clear_cpu_type() {
  if (cpu_type_ != &::google::protobuf::internal::kEmptyString) {
    cpu_type_->clear();
  }
  clear_has_cpu_type();
}
inline const ::std::string& mobile_info::cpu_type() const {
  return *cpu_type_;
}
inline void mobile_info::set_cpu_type(const ::std::string& value) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(value);
}
inline void mobile_info::set_cpu_type(const char* value) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(value);
}
inline void mobile_info::set_cpu_type(const char* value, size_t size) {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  cpu_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mobile_info::mutable_cpu_type() {
  set_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    cpu_type_ = new ::std::string;
  }
  return cpu_type_;
}
inline ::std::string* mobile_info::release_cpu_type() {
  clear_has_cpu_type();
  if (cpu_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpu_type_;
    cpu_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mobile_info::set_allocated_cpu_type(::std::string* cpu_type) {
  if (cpu_type_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_type_;
  }
  if (cpu_type) {
    set_has_cpu_type();
    cpu_type_ = cpu_type;
  } else {
    clear_has_cpu_type();
    cpu_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cpu_count = 5;
inline bool mobile_info::has_cpu_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mobile_info::set_has_cpu_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mobile_info::clear_has_cpu_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mobile_info::clear_cpu_count() {
  cpu_count_ = 0;
  clear_has_cpu_count();
}
inline ::google::protobuf::int32 mobile_info::cpu_count() const {
  return cpu_count_;
}
inline void mobile_info::set_cpu_count(::google::protobuf::int32 value) {
  set_has_cpu_count();
  cpu_count_ = value;
}

// optional int32 memory_size = 6;
inline bool mobile_info::has_memory_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mobile_info::set_has_memory_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mobile_info::clear_has_memory_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mobile_info::clear_memory_size() {
  memory_size_ = 0;
  clear_has_memory_size();
}
inline ::google::protobuf::int32 mobile_info::memory_size() const {
  return memory_size_;
}
inline void mobile_info::set_memory_size(::google::protobuf::int32 value) {
  set_has_memory_size();
  memory_size_ = value;
}

// optional string grph_device_name = 7;
inline bool mobile_info::has_grph_device_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mobile_info::set_has_grph_device_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mobile_info::clear_has_grph_device_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mobile_info::clear_grph_device_name() {
  if (grph_device_name_ != &::google::protobuf::internal::kEmptyString) {
    grph_device_name_->clear();
  }
  clear_has_grph_device_name();
}
inline const ::std::string& mobile_info::grph_device_name() const {
  return *grph_device_name_;
}
inline void mobile_info::set_grph_device_name(const ::std::string& value) {
  set_has_grph_device_name();
  if (grph_device_name_ == &::google::protobuf::internal::kEmptyString) {
    grph_device_name_ = new ::std::string;
  }
  grph_device_name_->assign(value);
}
inline void mobile_info::set_grph_device_name(const char* value) {
  set_has_grph_device_name();
  if (grph_device_name_ == &::google::protobuf::internal::kEmptyString) {
    grph_device_name_ = new ::std::string;
  }
  grph_device_name_->assign(value);
}
inline void mobile_info::set_grph_device_name(const char* value, size_t size) {
  set_has_grph_device_name();
  if (grph_device_name_ == &::google::protobuf::internal::kEmptyString) {
    grph_device_name_ = new ::std::string;
  }
  grph_device_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mobile_info::mutable_grph_device_name() {
  set_has_grph_device_name();
  if (grph_device_name_ == &::google::protobuf::internal::kEmptyString) {
    grph_device_name_ = new ::std::string;
  }
  return grph_device_name_;
}
inline ::std::string* mobile_info::release_grph_device_name() {
  clear_has_grph_device_name();
  if (grph_device_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grph_device_name_;
    grph_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mobile_info::set_allocated_grph_device_name(::std::string* grph_device_name) {
  if (grph_device_name_ != &::google::protobuf::internal::kEmptyString) {
    delete grph_device_name_;
  }
  if (grph_device_name) {
    set_has_grph_device_name();
    grph_device_name_ = grph_device_name;
  } else {
    clear_has_grph_device_name();
    grph_device_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// chat_param

// optional .proto.common.chat_type type = 1 [default = chat_item];
inline bool chat_param::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_param::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_param::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_param::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::proto::common::chat_type chat_param::type() const {
  return static_cast< ::proto::common::chat_type >(type_);
}
inline void chat_param::set_type(::proto::common::chat_type value) {
  assert(::proto::common::chat_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string value = 2;
inline bool chat_param::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_param::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_param::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_param::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& chat_param::value() const {
  return *value_;
}
inline void chat_param::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void chat_param::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void chat_param::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_param::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* chat_param::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_param::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// server_info

// optional uint32 server_id = 1;
inline bool server_info::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void server_info::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void server_info::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void server_info::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 server_info::server_id() const {
  return server_id_;
}
inline void server_info::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional string server_name = 2;
inline bool server_info::has_server_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void server_info::set_has_server_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void server_info::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void server_info::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& server_info::server_name() const {
  return *server_name_;
}
inline void server_info::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void server_info::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void server_info::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* server_info::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* server_info::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void server_info::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string login_ip = 3;
inline bool server_info::has_login_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void server_info::set_has_login_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void server_info::clear_has_login_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void server_info::clear_login_ip() {
  if (login_ip_ != &::google::protobuf::internal::kEmptyString) {
    login_ip_->clear();
  }
  clear_has_login_ip();
}
inline const ::std::string& server_info::login_ip() const {
  return *login_ip_;
}
inline void server_info::set_login_ip(const ::std::string& value) {
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(value);
}
inline void server_info::set_login_ip(const char* value) {
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(value);
}
inline void server_info::set_login_ip(const char* value, size_t size) {
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  login_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* server_info::mutable_login_ip() {
  set_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    login_ip_ = new ::std::string;
  }
  return login_ip_;
}
inline ::std::string* server_info::release_login_ip() {
  clear_has_login_ip();
  if (login_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = login_ip_;
    login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void server_info::set_allocated_login_ip(::std::string* login_ip) {
  if (login_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete login_ip_;
  }
  if (login_ip) {
    set_has_login_ip();
    login_ip_ = login_ip;
  } else {
    clear_has_login_ip();
    login_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 login_port = 4;
inline bool server_info::has_login_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void server_info::set_has_login_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void server_info::clear_has_login_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void server_info::clear_login_port() {
  login_port_ = 0u;
  clear_has_login_port();
}
inline ::google::protobuf::uint32 server_info::login_port() const {
  return login_port_;
}
inline void server_info::set_login_port(::google::protobuf::uint32 value) {
  set_has_login_port();
  login_port_ = value;
}

// optional .proto.common.SERVER_STATE server_state = 5 [default = SERVER_STATE_CLOSE];
inline bool server_info::has_server_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void server_info::set_has_server_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void server_info::clear_has_server_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void server_info::clear_server_state() {
  server_state_ = 4;
  clear_has_server_state();
}
inline ::proto::common::SERVER_STATE server_info::server_state() const {
  return static_cast< ::proto::common::SERVER_STATE >(server_state_);
}
inline void server_info::set_server_state(::proto::common::SERVER_STATE value) {
  assert(::proto::common::SERVER_STATE_IsValid(value));
  set_has_server_state();
  server_state_ = value;
}

// optional uint32 label = 6;
inline bool server_info::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void server_info::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void server_info::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void server_info::clear_label() {
  label_ = 0u;
  clear_has_label();
}
inline ::google::protobuf::uint32 server_info::label() const {
  return label_;
}
inline void server_info::set_label(::google::protobuf::uint32 value) {
  set_has_label();
  label_ = value;
}

// repeated .proto.common.account_role_data role_list = 7;
inline int server_info::role_list_size() const {
  return role_list_.size();
}
inline void server_info::clear_role_list() {
  role_list_.Clear();
}
inline const ::proto::common::account_role_data& server_info::role_list(int index) const {
  return role_list_.Get(index);
}
inline ::proto::common::account_role_data* server_info::mutable_role_list(int index) {
  return role_list_.Mutable(index);
}
inline ::proto::common::account_role_data* server_info::add_role_list() {
  return role_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::account_role_data >&
server_info::role_list() const {
  return role_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::account_role_data >*
server_info::mutable_role_list() {
  return &role_list_;
}

// optional string new_role_id = 8;
inline bool server_info::has_new_role_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void server_info::set_has_new_role_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void server_info::clear_has_new_role_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void server_info::clear_new_role_id() {
  if (new_role_id_ != &::google::protobuf::internal::kEmptyString) {
    new_role_id_->clear();
  }
  clear_has_new_role_id();
}
inline const ::std::string& server_info::new_role_id() const {
  return *new_role_id_;
}
inline void server_info::set_new_role_id(const ::std::string& value) {
  set_has_new_role_id();
  if (new_role_id_ == &::google::protobuf::internal::kEmptyString) {
    new_role_id_ = new ::std::string;
  }
  new_role_id_->assign(value);
}
inline void server_info::set_new_role_id(const char* value) {
  set_has_new_role_id();
  if (new_role_id_ == &::google::protobuf::internal::kEmptyString) {
    new_role_id_ = new ::std::string;
  }
  new_role_id_->assign(value);
}
inline void server_info::set_new_role_id(const char* value, size_t size) {
  set_has_new_role_id();
  if (new_role_id_ == &::google::protobuf::internal::kEmptyString) {
    new_role_id_ = new ::std::string;
  }
  new_role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* server_info::mutable_new_role_id() {
  set_has_new_role_id();
  if (new_role_id_ == &::google::protobuf::internal::kEmptyString) {
    new_role_id_ = new ::std::string;
  }
  return new_role_id_;
}
inline ::std::string* server_info::release_new_role_id() {
  clear_has_new_role_id();
  if (new_role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_role_id_;
    new_role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void server_info::set_allocated_new_role_id(::std::string* new_role_id) {
  if (new_role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete new_role_id_;
  }
  if (new_role_id) {
    set_has_new_role_id();
    new_role_id_ = new_role_id;
  } else {
    clear_has_new_role_id();
    new_role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 can_create_new_role = 9;
inline bool server_info::has_can_create_new_role() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void server_info::set_has_can_create_new_role() {
  _has_bits_[0] |= 0x00000100u;
}
inline void server_info::clear_has_can_create_new_role() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void server_info::clear_can_create_new_role() {
  can_create_new_role_ = 0u;
  clear_has_can_create_new_role();
}
inline ::google::protobuf::uint32 server_info::can_create_new_role() const {
  return can_create_new_role_;
}
inline void server_info::set_can_create_new_role(::google::protobuf::uint32 value) {
  set_has_can_create_new_role();
  can_create_new_role_ = value;
}

// -------------------------------------------------------------------

// account_role_data

// optional string uid = 1;
inline bool account_role_data::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void account_role_data::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void account_role_data::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void account_role_data::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& account_role_data::uid() const {
  return *uid_;
}
inline void account_role_data::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void account_role_data::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void account_role_data::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* account_role_data::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* account_role_data::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void account_role_data::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 species = 2;
inline bool account_role_data::has_species() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void account_role_data::set_has_species() {
  _has_bits_[0] |= 0x00000002u;
}
inline void account_role_data::clear_has_species() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void account_role_data::clear_species() {
  species_ = 0u;
  clear_has_species();
}
inline ::google::protobuf::uint32 account_role_data::species() const {
  return species_;
}
inline void account_role_data::set_species(::google::protobuf::uint32 value) {
  set_has_species();
  species_ = value;
}

// optional string name = 3;
inline bool account_role_data::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void account_role_data::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void account_role_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void account_role_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& account_role_data::name() const {
  return *name_;
}
inline void account_role_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void account_role_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void account_role_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* account_role_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* account_role_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void account_role_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 create_time = 4;
inline bool account_role_data::has_create_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void account_role_data::set_has_create_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void account_role_data::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void account_role_data::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 account_role_data::create_time() const {
  return create_time_;
}
inline void account_role_data::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional uint32 level = 5;
inline bool account_role_data::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void account_role_data::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void account_role_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void account_role_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 account_role_data::level() const {
  return level_;
}
inline void account_role_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 plugin = 6;
inline bool account_role_data::has_plugin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void account_role_data::set_has_plugin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void account_role_data::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void account_role_data::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 account_role_data::plugin() const {
  return plugin_;
}
inline void account_role_data::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 channel_id = 7;
inline bool account_role_data::has_channel_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void account_role_data::set_has_channel_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void account_role_data::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void account_role_data::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 account_role_data::channel_id() const {
  return channel_id_;
}
inline void account_role_data::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// -------------------------------------------------------------------

// channel_general

// optional string uid = 1;
inline bool channel_general::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void channel_general::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void channel_general::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void channel_general::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& channel_general::uid() const {
  return *uid_;
}
inline void channel_general::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void channel_general::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void channel_general::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* channel_general::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* channel_general::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void channel_general::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string session_id = 2;
inline bool channel_general::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void channel_general::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void channel_general::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void channel_general::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& channel_general::session_id() const {
  return *session_id_;
}
inline void channel_general::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void channel_general::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void channel_general::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* channel_general::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* channel_general::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void channel_general::set_allocated_session_id(::std::string* session_id) {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete session_id_;
  }
  if (session_id) {
    set_has_session_id();
    session_id_ = session_id;
  } else {
    clear_has_session_id();
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string guid = 3;
inline bool channel_general::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void channel_general::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void channel_general::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void channel_general::clear_guid() {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& channel_general::guid() const {
  return *guid_;
}
inline void channel_general::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void channel_general::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
}
inline void channel_general::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* channel_general::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    guid_ = new ::std::string;
  }
  return guid_;
}
inline ::std::string* channel_general::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void channel_general::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::kEmptyString) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// task_type_count

// optional uint32 type = 1;
inline bool task_type_count::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_type_count::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_type_count::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_type_count::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 task_type_count::type() const {
  return type_;
}
inline void task_type_count::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 count = 2;
inline bool task_type_count::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_type_count::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_type_count::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_type_count::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 task_type_count::count() const {
  return count_;
}
inline void task_type_count::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// task_type_data

// repeated .proto.common.task_type_count type_count = 1;
inline int task_type_data::type_count_size() const {
  return type_count_.size();
}
inline void task_type_data::clear_type_count() {
  type_count_.Clear();
}
inline const ::proto::common::task_type_count& task_type_data::type_count(int index) const {
  return type_count_.Get(index);
}
inline ::proto::common::task_type_count* task_type_data::mutable_type_count(int index) {
  return type_count_.Mutable(index);
}
inline ::proto::common::task_type_count* task_type_data::add_type_count() {
  return type_count_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_type_count >&
task_type_data::type_count() const {
  return type_count_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_type_count >*
task_type_data::mutable_type_count() {
  return &type_count_;
}

// -------------------------------------------------------------------

// fight_study_data

// optional uint32 step = 1;
inline bool fight_study_data::has_step() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_study_data::set_has_step() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_study_data::clear_has_step() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_study_data::clear_step() {
  step_ = 0u;
  clear_has_step();
}
inline ::google::protobuf::uint32 fight_study_data::step() const {
  return step_;
}
inline void fight_study_data::set_step(::google::protobuf::uint32 value) {
  set_has_step();
  step_ = value;
}

// optional uint32 step_time = 2;
inline bool fight_study_data::has_step_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_study_data::set_has_step_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_study_data::clear_has_step_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_study_data::clear_step_time() {
  step_time_ = 0u;
  clear_has_step_time();
}
inline ::google::protobuf::uint32 fight_study_data::step_time() const {
  return step_time_;
}
inline void fight_study_data::set_step_time(::google::protobuf::uint32 value) {
  set_has_step_time();
  step_time_ = value;
}

// optional uint64 target = 3;
inline bool fight_study_data::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_study_data::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_study_data::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_study_data::clear_target() {
  target_ = GOOGLE_ULONGLONG(0);
  clear_has_target();
}
inline ::google::protobuf::uint64 fight_study_data::target() const {
  return target_;
}
inline void fight_study_data::set_target(::google::protobuf::uint64 value) {
  set_has_target();
  target_ = value;
}

// optional uint64 attacker = 4;
inline bool fight_study_data::has_attacker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_study_data::set_has_attacker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_study_data::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_study_data::clear_attacker() {
  attacker_ = GOOGLE_ULONGLONG(0);
  clear_has_attacker();
}
inline ::google::protobuf::uint64 fight_study_data::attacker() const {
  return attacker_;
}
inline void fight_study_data::set_attacker(::google::protobuf::uint64 value) {
  set_has_attacker();
  attacker_ = value;
}

// optional uint32 study_time = 5;
inline bool fight_study_data::has_study_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_study_data::set_has_study_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_study_data::clear_has_study_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_study_data::clear_study_time() {
  study_time_ = 0u;
  clear_has_study_time();
}
inline ::google::protobuf::uint32 fight_study_data::study_time() const {
  return study_time_;
}
inline void fight_study_data::set_study_time(::google::protobuf::uint32 value) {
  set_has_study_time();
  study_time_ = value;
}

// -------------------------------------------------------------------

// role_fight_data

// optional uint64 fight_uid = 1;
inline bool role_fight_data::has_fight_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_fight_data::set_has_fight_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_fight_data::clear_has_fight_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_fight_data::clear_fight_uid() {
  fight_uid_ = GOOGLE_ULONGLONG(0);
  clear_has_fight_uid();
}
inline ::google::protobuf::uint64 role_fight_data::fight_uid() const {
  return fight_uid_;
}
inline void role_fight_data::set_fight_uid(::google::protobuf::uint64 value) {
  set_has_fight_uid();
  fight_uid_ = value;
}

// optional .proto.common.fight_study_data study = 2;
inline bool role_fight_data::has_study() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_fight_data::set_has_study() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_fight_data::clear_has_study() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_fight_data::clear_study() {
  if (study_ != NULL) study_->::proto::common::fight_study_data::Clear();
  clear_has_study();
}
inline const ::proto::common::fight_study_data& role_fight_data::study() const {
  return study_ != NULL ? *study_ : *default_instance_->study_;
}
inline ::proto::common::fight_study_data* role_fight_data::mutable_study() {
  set_has_study();
  if (study_ == NULL) study_ = new ::proto::common::fight_study_data;
  return study_;
}
inline ::proto::common::fight_study_data* role_fight_data::release_study() {
  clear_has_study();
  ::proto::common::fight_study_data* temp = study_;
  study_ = NULL;
  return temp;
}
inline void role_fight_data::set_allocated_study(::proto::common::fight_study_data* study) {
  delete study_;
  study_ = study;
  if (study) {
    set_has_study();
  } else {
    clear_has_study();
  }
}

// optional uint32 auto_fight_flag = 3;
inline bool role_fight_data::has_auto_fight_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_fight_data::set_has_auto_fight_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_fight_data::clear_has_auto_fight_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_fight_data::clear_auto_fight_flag() {
  auto_fight_flag_ = 0u;
  clear_has_auto_fight_flag();
}
inline ::google::protobuf::uint32 role_fight_data::auto_fight_flag() const {
  return auto_fight_flag_;
}
inline void role_fight_data::set_auto_fight_flag(::google::protobuf::uint32 value) {
  set_has_auto_fight_flag();
  auto_fight_flag_ = value;
}

// optional uint64 watching_fight_uid = 4;
inline bool role_fight_data::has_watching_fight_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_fight_data::set_has_watching_fight_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_fight_data::clear_has_watching_fight_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_fight_data::clear_watching_fight_uid() {
  watching_fight_uid_ = GOOGLE_ULONGLONG(0);
  clear_has_watching_fight_uid();
}
inline ::google::protobuf::uint64 role_fight_data::watching_fight_uid() const {
  return watching_fight_uid_;
}
inline void role_fight_data::set_watching_fight_uid(::google::protobuf::uint64 value) {
  set_has_watching_fight_uid();
  watching_fight_uid_ = value;
}

// optional uint32 ignore_lineup_flag = 5;
inline bool role_fight_data::has_ignore_lineup_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_fight_data::set_has_ignore_lineup_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_fight_data::clear_has_ignore_lineup_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_fight_data::clear_ignore_lineup_flag() {
  ignore_lineup_flag_ = 0u;
  clear_has_ignore_lineup_flag();
}
inline ::google::protobuf::uint32 role_fight_data::ignore_lineup_flag() const {
  return ignore_lineup_flag_;
}
inline void role_fight_data::set_ignore_lineup_flag(::google::protobuf::uint32 value) {
  set_has_ignore_lineup_flag();
  ignore_lineup_flag_ = value;
}

// -------------------------------------------------------------------

// role_server_data

// optional uint32 server_id = 1;
inline bool role_server_data::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_server_data::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_server_data::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_server_data::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 role_server_data::server_id() const {
  return server_id_;
}
inline void role_server_data::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 gate = 2;
inline bool role_server_data::has_gate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_server_data::set_has_gate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_server_data::clear_has_gate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_server_data::clear_gate() {
  gate_ = 0u;
  clear_has_gate();
}
inline ::google::protobuf::uint32 role_server_data::gate() const {
  return gate_;
}
inline void role_server_data::set_gate(::google::protobuf::uint32 value) {
  set_has_gate();
  gate_ = value;
}

// optional string server_name = 3;
inline bool role_server_data::has_server_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_server_data::set_has_server_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_server_data::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_server_data::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& role_server_data::server_name() const {
  return *server_name_;
}
inline void role_server_data::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void role_server_data::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void role_server_data::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_server_data::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* role_server_data::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_server_data::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// last_static_map

// optional uint32 last_map_tid = 1;
inline bool last_static_map::has_last_map_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void last_static_map::set_has_last_map_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void last_static_map::clear_has_last_map_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void last_static_map::clear_last_map_tid() {
  last_map_tid_ = 0u;
  clear_has_last_map_tid();
}
inline ::google::protobuf::uint32 last_static_map::last_map_tid() const {
  return last_map_tid_;
}
inline void last_static_map::set_last_map_tid(::google::protobuf::uint32 value) {
  set_has_last_map_tid();
  last_map_tid_ = value;
}

// optional float last_pos_x = 2;
inline bool last_static_map::has_last_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void last_static_map::set_has_last_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void last_static_map::clear_has_last_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void last_static_map::clear_last_pos_x() {
  last_pos_x_ = 0;
  clear_has_last_pos_x();
}
inline float last_static_map::last_pos_x() const {
  return last_pos_x_;
}
inline void last_static_map::set_last_pos_x(float value) {
  set_has_last_pos_x();
  last_pos_x_ = value;
}

// optional float last_pos_y = 3;
inline bool last_static_map::has_last_pos_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void last_static_map::set_has_last_pos_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void last_static_map::clear_has_last_pos_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void last_static_map::clear_last_pos_y() {
  last_pos_y_ = 0;
  clear_has_last_pos_y();
}
inline float last_static_map::last_pos_y() const {
  return last_pos_y_;
}
inline void last_static_map::set_last_pos_y(float value) {
  set_has_last_pos_y();
  last_pos_y_ = value;
}

// optional float last_dir = 4;
inline bool last_static_map::has_last_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void last_static_map::set_has_last_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void last_static_map::clear_has_last_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void last_static_map::clear_last_dir() {
  last_dir_ = 0;
  clear_has_last_dir();
}
inline float last_static_map::last_dir() const {
  return last_dir_;
}
inline void last_static_map::set_last_dir(float value) {
  set_has_last_dir();
  last_dir_ = value;
}

// -------------------------------------------------------------------

// role_data

// optional string uid = 1;
inline bool role_data::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_data::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_data::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_data::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& role_data::uid() const {
  return *uid_;
}
inline void role_data::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void role_data::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void role_data::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_data::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* role_data::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_data::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string did = 2;
inline bool role_data::has_did() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_data::set_has_did() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_data::clear_has_did() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_data::clear_did() {
  if (did_ != &::google::protobuf::internal::kEmptyString) {
    did_->clear();
  }
  clear_has_did();
}
inline const ::std::string& role_data::did() const {
  return *did_;
}
inline void role_data::set_did(const ::std::string& value) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(value);
}
inline void role_data::set_did(const char* value) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(value);
}
inline void role_data::set_did(const char* value, size_t size) {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  did_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_data::mutable_did() {
  set_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    did_ = new ::std::string;
  }
  return did_;
}
inline ::std::string* role_data::release_did() {
  clear_has_did();
  if (did_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = did_;
    did_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_data::set_allocated_did(::std::string* did) {
  if (did_ != &::google::protobuf::internal::kEmptyString) {
    delete did_;
  }
  if (did) {
    set_has_did();
    did_ = did;
  } else {
    clear_has_did();
    did_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool role_data::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_data::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& role_data::name() const {
  return *name_;
}
inline void role_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* role_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gm = 4;
inline bool role_data::has_gm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_data::set_has_gm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_data::clear_has_gm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_data::clear_gm() {
  gm_ = 0;
  clear_has_gm();
}
inline ::google::protobuf::int32 role_data::gm() const {
  return gm_;
}
inline void role_data::set_gm(::google::protobuf::int32 value) {
  set_has_gm();
  gm_ = value;
}

// optional uint32 create_time = 5;
inline bool role_data::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_data::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_data::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_data::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 role_data::create_time() const {
  return create_time_;
}
inline void role_data::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional uint32 last_login_time = 6;
inline bool role_data::has_last_login_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_data::set_has_last_login_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_data::clear_has_last_login_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_data::clear_last_login_time() {
  last_login_time_ = 0u;
  clear_has_last_login_time();
}
inline ::google::protobuf::uint32 role_data::last_login_time() const {
  return last_login_time_;
}
inline void role_data::set_last_login_time(::google::protobuf::uint32 value) {
  set_has_last_login_time();
  last_login_time_ = value;
}

// optional uint32 last_logout_time = 7;
inline bool role_data::has_last_logout_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_data::set_has_last_logout_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_data::clear_has_last_logout_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_data::clear_last_logout_time() {
  last_logout_time_ = 0u;
  clear_has_last_logout_time();
}
inline ::google::protobuf::uint32 role_data::last_logout_time() const {
  return last_logout_time_;
}
inline void role_data::set_last_logout_time(::google::protobuf::uint32 value) {
  set_has_last_logout_time();
  last_logout_time_ = value;
}

// optional uint32 level = 8;
inline bool role_data::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_data::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 role_data::level() const {
  return level_;
}
inline void role_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 map_tid = 9;
inline bool role_data::has_map_tid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void role_data::set_has_map_tid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void role_data::clear_has_map_tid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void role_data::clear_map_tid() {
  map_tid_ = 0u;
  clear_has_map_tid();
}
inline ::google::protobuf::uint32 role_data::map_tid() const {
  return map_tid_;
}
inline void role_data::set_map_tid(::google::protobuf::uint32 value) {
  set_has_map_tid();
  map_tid_ = value;
}

// optional .proto.common.object_common_info obj_info = 10;
inline bool role_data::has_obj_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void role_data::set_has_obj_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void role_data::clear_has_obj_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void role_data::clear_obj_info() {
  if (obj_info_ != NULL) obj_info_->::proto::common::object_common_info::Clear();
  clear_has_obj_info();
}
inline const ::proto::common::object_common_info& role_data::obj_info() const {
  return obj_info_ != NULL ? *obj_info_ : *default_instance_->obj_info_;
}
inline ::proto::common::object_common_info* role_data::mutable_obj_info() {
  set_has_obj_info();
  if (obj_info_ == NULL) obj_info_ = new ::proto::common::object_common_info;
  return obj_info_;
}
inline ::proto::common::object_common_info* role_data::release_obj_info() {
  clear_has_obj_info();
  ::proto::common::object_common_info* temp = obj_info_;
  obj_info_ = NULL;
  return temp;
}
inline void role_data::set_allocated_obj_info(::proto::common::object_common_info* obj_info) {
  delete obj_info_;
  obj_info_ = obj_info;
  if (obj_info) {
    set_has_obj_info();
  } else {
    clear_has_obj_info();
  }
}

// optional .proto.common.personal_info per_info = 11;
inline bool role_data::has_per_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void role_data::set_has_per_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void role_data::clear_has_per_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void role_data::clear_per_info() {
  if (per_info_ != NULL) per_info_->::proto::common::personal_info::Clear();
  clear_has_per_info();
}
inline const ::proto::common::personal_info& role_data::per_info() const {
  return per_info_ != NULL ? *per_info_ : *default_instance_->per_info_;
}
inline ::proto::common::personal_info* role_data::mutable_per_info() {
  set_has_per_info();
  if (per_info_ == NULL) per_info_ = new ::proto::common::personal_info;
  return per_info_;
}
inline ::proto::common::personal_info* role_data::release_per_info() {
  clear_has_per_info();
  ::proto::common::personal_info* temp = per_info_;
  per_info_ = NULL;
  return temp;
}
inline void role_data::set_allocated_per_info(::proto::common::personal_info* per_info) {
  delete per_info_;
  per_info_ = per_info;
  if (per_info) {
    set_has_per_info();
  } else {
    clear_has_per_info();
  }
}

// optional .proto.common.interior_info interior = 12;
inline bool role_data::has_interior() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void role_data::set_has_interior() {
  _has_bits_[0] |= 0x00000800u;
}
inline void role_data::clear_has_interior() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void role_data::clear_interior() {
  if (interior_ != NULL) interior_->::proto::common::interior_info::Clear();
  clear_has_interior();
}
inline const ::proto::common::interior_info& role_data::interior() const {
  return interior_ != NULL ? *interior_ : *default_instance_->interior_;
}
inline ::proto::common::interior_info* role_data::mutable_interior() {
  set_has_interior();
  if (interior_ == NULL) interior_ = new ::proto::common::interior_info;
  return interior_;
}
inline ::proto::common::interior_info* role_data::release_interior() {
  clear_has_interior();
  ::proto::common::interior_info* temp = interior_;
  interior_ = NULL;
  return temp;
}
inline void role_data::set_allocated_interior(::proto::common::interior_info* interior) {
  delete interior_;
  interior_ = interior;
  if (interior) {
    set_has_interior();
  } else {
    clear_has_interior();
  }
}

// optional uint32 fighting = 13;
inline bool role_data::has_fighting() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void role_data::set_has_fighting() {
  _has_bits_[0] |= 0x00001000u;
}
inline void role_data::clear_has_fighting() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void role_data::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 role_data::fighting() const {
  return fighting_;
}
inline void role_data::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 channel_id = 14;
inline bool role_data::has_channel_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void role_data::set_has_channel_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void role_data::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void role_data::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 role_data::channel_id() const {
  return channel_id_;
}
inline void role_data::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// optional uint32 role_type = 15;
inline bool role_data::has_role_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void role_data::set_has_role_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void role_data::clear_has_role_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void role_data::clear_role_type() {
  role_type_ = 0u;
  clear_has_role_type();
}
inline ::google::protobuf::uint32 role_data::role_type() const {
  return role_type_;
}
inline void role_data::set_role_type(::google::protobuf::uint32 value) {
  set_has_role_type();
  role_type_ = value;
}

// optional .proto.common.role_trade_info trade_info = 16;
inline bool role_data::has_trade_info() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void role_data::set_has_trade_info() {
  _has_bits_[0] |= 0x00008000u;
}
inline void role_data::clear_has_trade_info() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void role_data::clear_trade_info() {
  if (trade_info_ != NULL) trade_info_->::proto::common::role_trade_info::Clear();
  clear_has_trade_info();
}
inline const ::proto::common::role_trade_info& role_data::trade_info() const {
  return trade_info_ != NULL ? *trade_info_ : *default_instance_->trade_info_;
}
inline ::proto::common::role_trade_info* role_data::mutable_trade_info() {
  set_has_trade_info();
  if (trade_info_ == NULL) trade_info_ = new ::proto::common::role_trade_info;
  return trade_info_;
}
inline ::proto::common::role_trade_info* role_data::release_trade_info() {
  clear_has_trade_info();
  ::proto::common::role_trade_info* temp = trade_info_;
  trade_info_ = NULL;
  return temp;
}
inline void role_data::set_allocated_trade_info(::proto::common::role_trade_info* trade_info) {
  delete trade_info_;
  trade_info_ = trade_info;
  if (trade_info) {
    set_has_trade_info();
  } else {
    clear_has_trade_info();
  }
}

// optional .proto.common.task_type_data ttd = 17;
inline bool role_data::has_ttd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void role_data::set_has_ttd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void role_data::clear_has_ttd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void role_data::clear_ttd() {
  if (ttd_ != NULL) ttd_->::proto::common::task_type_data::Clear();
  clear_has_ttd();
}
inline const ::proto::common::task_type_data& role_data::ttd() const {
  return ttd_ != NULL ? *ttd_ : *default_instance_->ttd_;
}
inline ::proto::common::task_type_data* role_data::mutable_ttd() {
  set_has_ttd();
  if (ttd_ == NULL) ttd_ = new ::proto::common::task_type_data;
  return ttd_;
}
inline ::proto::common::task_type_data* role_data::release_ttd() {
  clear_has_ttd();
  ::proto::common::task_type_data* temp = ttd_;
  ttd_ = NULL;
  return temp;
}
inline void role_data::set_allocated_ttd(::proto::common::task_type_data* ttd) {
  delete ttd_;
  ttd_ = ttd;
  if (ttd) {
    set_has_ttd();
  } else {
    clear_has_ttd();
  }
}

// optional .proto.common.formation_data formation = 18;
inline bool role_data::has_formation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void role_data::set_has_formation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void role_data::clear_has_formation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void role_data::clear_formation() {
  if (formation_ != NULL) formation_->::proto::common::formation_data::Clear();
  clear_has_formation();
}
inline const ::proto::common::formation_data& role_data::formation() const {
  return formation_ != NULL ? *formation_ : *default_instance_->formation_;
}
inline ::proto::common::formation_data* role_data::mutable_formation() {
  set_has_formation();
  if (formation_ == NULL) formation_ = new ::proto::common::formation_data;
  return formation_;
}
inline ::proto::common::formation_data* role_data::release_formation() {
  clear_has_formation();
  ::proto::common::formation_data* temp = formation_;
  formation_ = NULL;
  return temp;
}
inline void role_data::set_allocated_formation(::proto::common::formation_data* formation) {
  delete formation_;
  formation_ = formation;
  if (formation) {
    set_has_formation();
  } else {
    clear_has_formation();
  }
}

// optional .proto.common.role_fight_data fight = 19;
inline bool role_data::has_fight() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void role_data::set_has_fight() {
  _has_bits_[0] |= 0x00040000u;
}
inline void role_data::clear_has_fight() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void role_data::clear_fight() {
  if (fight_ != NULL) fight_->::proto::common::role_fight_data::Clear();
  clear_has_fight();
}
inline const ::proto::common::role_fight_data& role_data::fight() const {
  return fight_ != NULL ? *fight_ : *default_instance_->fight_;
}
inline ::proto::common::role_fight_data* role_data::mutable_fight() {
  set_has_fight();
  if (fight_ == NULL) fight_ = new ::proto::common::role_fight_data;
  return fight_;
}
inline ::proto::common::role_fight_data* role_data::release_fight() {
  clear_has_fight();
  ::proto::common::role_fight_data* temp = fight_;
  fight_ = NULL;
  return temp;
}
inline void role_data::set_allocated_fight(::proto::common::role_fight_data* fight) {
  delete fight_;
  fight_ = fight;
  if (fight) {
    set_has_fight();
  } else {
    clear_has_fight();
  }
}

// optional uint32 exp = 20;
inline bool role_data::has_exp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void role_data::set_has_exp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void role_data::clear_has_exp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void role_data::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 role_data::exp() const {
  return exp_;
}
inline void role_data::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional .proto.common.role_server_data server = 21;
inline bool role_data::has_server() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void role_data::set_has_server() {
  _has_bits_[0] |= 0x00100000u;
}
inline void role_data::clear_has_server() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void role_data::clear_server() {
  if (server_ != NULL) server_->::proto::common::role_server_data::Clear();
  clear_has_server();
}
inline const ::proto::common::role_server_data& role_data::server() const {
  return server_ != NULL ? *server_ : *default_instance_->server_;
}
inline ::proto::common::role_server_data* role_data::mutable_server() {
  set_has_server();
  if (server_ == NULL) server_ = new ::proto::common::role_server_data;
  return server_;
}
inline ::proto::common::role_server_data* role_data::release_server() {
  clear_has_server();
  ::proto::common::role_server_data* temp = server_;
  server_ = NULL;
  return temp;
}
inline void role_data::set_allocated_server(::proto::common::role_server_data* server) {
  delete server_;
  server_ = server;
  if (server) {
    set_has_server();
  } else {
    clear_has_server();
  }
}

// optional uint32 continue_login_days = 22;
inline bool role_data::has_continue_login_days() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void role_data::set_has_continue_login_days() {
  _has_bits_[0] |= 0x00200000u;
}
inline void role_data::clear_has_continue_login_days() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void role_data::clear_continue_login_days() {
  continue_login_days_ = 0u;
  clear_has_continue_login_days();
}
inline ::google::protobuf::uint32 role_data::continue_login_days() const {
  return continue_login_days_;
}
inline void role_data::set_continue_login_days(::google::protobuf::uint32 value) {
  set_has_continue_login_days();
  continue_login_days_ = value;
}

// optional uint32 cumulative_login_days = 23;
inline bool role_data::has_cumulative_login_days() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void role_data::set_has_cumulative_login_days() {
  _has_bits_[0] |= 0x00400000u;
}
inline void role_data::clear_has_cumulative_login_days() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void role_data::clear_cumulative_login_days() {
  cumulative_login_days_ = 0u;
  clear_has_cumulative_login_days();
}
inline ::google::protobuf::uint32 role_data::cumulative_login_days() const {
  return cumulative_login_days_;
}
inline void role_data::set_cumulative_login_days(::google::protobuf::uint32 value) {
  set_has_cumulative_login_days();
  cumulative_login_days_ = value;
}

// optional bool is_new_role = 24;
inline bool role_data::has_is_new_role() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void role_data::set_has_is_new_role() {
  _has_bits_[0] |= 0x00800000u;
}
inline void role_data::clear_has_is_new_role() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void role_data::clear_is_new_role() {
  is_new_role_ = false;
  clear_has_is_new_role();
}
inline bool role_data::is_new_role() const {
  return is_new_role_;
}
inline void role_data::set_is_new_role(bool value) {
  set_has_is_new_role();
  is_new_role_ = value;
}

// optional .proto.common.new_role_guide_data guide_data = 25;
inline bool role_data::has_guide_data() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void role_data::set_has_guide_data() {
  _has_bits_[0] |= 0x01000000u;
}
inline void role_data::clear_has_guide_data() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void role_data::clear_guide_data() {
  if (guide_data_ != NULL) guide_data_->::proto::common::new_role_guide_data::Clear();
  clear_has_guide_data();
}
inline const ::proto::common::new_role_guide_data& role_data::guide_data() const {
  return guide_data_ != NULL ? *guide_data_ : *default_instance_->guide_data_;
}
inline ::proto::common::new_role_guide_data* role_data::mutable_guide_data() {
  set_has_guide_data();
  if (guide_data_ == NULL) guide_data_ = new ::proto::common::new_role_guide_data;
  return guide_data_;
}
inline ::proto::common::new_role_guide_data* role_data::release_guide_data() {
  clear_has_guide_data();
  ::proto::common::new_role_guide_data* temp = guide_data_;
  guide_data_ = NULL;
  return temp;
}
inline void role_data::set_allocated_guide_data(::proto::common::new_role_guide_data* guide_data) {
  delete guide_data_;
  guide_data_ = guide_data;
  if (guide_data) {
    set_has_guide_data();
  } else {
    clear_has_guide_data();
  }
}

// optional string function_code = 26;
inline bool role_data::has_function_code() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void role_data::set_has_function_code() {
  _has_bits_[0] |= 0x02000000u;
}
inline void role_data::clear_has_function_code() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void role_data::clear_function_code() {
  if (function_code_ != &::google::protobuf::internal::kEmptyString) {
    function_code_->clear();
  }
  clear_has_function_code();
}
inline const ::std::string& role_data::function_code() const {
  return *function_code_;
}
inline void role_data::set_function_code(const ::std::string& value) {
  set_has_function_code();
  if (function_code_ == &::google::protobuf::internal::kEmptyString) {
    function_code_ = new ::std::string;
  }
  function_code_->assign(value);
}
inline void role_data::set_function_code(const char* value) {
  set_has_function_code();
  if (function_code_ == &::google::protobuf::internal::kEmptyString) {
    function_code_ = new ::std::string;
  }
  function_code_->assign(value);
}
inline void role_data::set_function_code(const char* value, size_t size) {
  set_has_function_code();
  if (function_code_ == &::google::protobuf::internal::kEmptyString) {
    function_code_ = new ::std::string;
  }
  function_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_data::mutable_function_code() {
  set_has_function_code();
  if (function_code_ == &::google::protobuf::internal::kEmptyString) {
    function_code_ = new ::std::string;
  }
  return function_code_;
}
inline ::std::string* role_data::release_function_code() {
  clear_has_function_code();
  if (function_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = function_code_;
    function_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_data::set_allocated_function_code(::std::string* function_code) {
  if (function_code_ != &::google::protobuf::internal::kEmptyString) {
    delete function_code_;
  }
  if (function_code) {
    set_has_function_code();
    function_code_ = function_code;
  } else {
    clear_has_function_code();
    function_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.tactic_data tactic = 27;
inline bool role_data::has_tactic() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void role_data::set_has_tactic() {
  _has_bits_[0] |= 0x04000000u;
}
inline void role_data::clear_has_tactic() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void role_data::clear_tactic() {
  if (tactic_ != NULL) tactic_->::proto::common::tactic_data::Clear();
  clear_has_tactic();
}
inline const ::proto::common::tactic_data& role_data::tactic() const {
  return tactic_ != NULL ? *tactic_ : *default_instance_->tactic_;
}
inline ::proto::common::tactic_data* role_data::mutable_tactic() {
  set_has_tactic();
  if (tactic_ == NULL) tactic_ = new ::proto::common::tactic_data;
  return tactic_;
}
inline ::proto::common::tactic_data* role_data::release_tactic() {
  clear_has_tactic();
  ::proto::common::tactic_data* temp = tactic_;
  tactic_ = NULL;
  return temp;
}
inline void role_data::set_allocated_tactic(::proto::common::tactic_data* tactic) {
  delete tactic_;
  tactic_ = tactic;
  if (tactic) {
    set_has_tactic();
  } else {
    clear_has_tactic();
  }
}

// optional .proto.common.role_buff_data role_buff = 28;
inline bool role_data::has_role_buff() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void role_data::set_has_role_buff() {
  _has_bits_[0] |= 0x08000000u;
}
inline void role_data::clear_has_role_buff() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void role_data::clear_role_buff() {
  if (role_buff_ != NULL) role_buff_->::proto::common::role_buff_data::Clear();
  clear_has_role_buff();
}
inline const ::proto::common::role_buff_data& role_data::role_buff() const {
  return role_buff_ != NULL ? *role_buff_ : *default_instance_->role_buff_;
}
inline ::proto::common::role_buff_data* role_data::mutable_role_buff() {
  set_has_role_buff();
  if (role_buff_ == NULL) role_buff_ = new ::proto::common::role_buff_data;
  return role_buff_;
}
inline ::proto::common::role_buff_data* role_data::release_role_buff() {
  clear_has_role_buff();
  ::proto::common::role_buff_data* temp = role_buff_;
  role_buff_ = NULL;
  return temp;
}
inline void role_data::set_allocated_role_buff(::proto::common::role_buff_data* role_buff) {
  delete role_buff_;
  role_buff_ = role_buff;
  if (role_buff) {
    set_has_role_buff();
  } else {
    clear_has_role_buff();
  }
}

// optional .proto.common.last_static_map last_map = 29;
inline bool role_data::has_last_map() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void role_data::set_has_last_map() {
  _has_bits_[0] |= 0x10000000u;
}
inline void role_data::clear_has_last_map() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void role_data::clear_last_map() {
  if (last_map_ != NULL) last_map_->::proto::common::last_static_map::Clear();
  clear_has_last_map();
}
inline const ::proto::common::last_static_map& role_data::last_map() const {
  return last_map_ != NULL ? *last_map_ : *default_instance_->last_map_;
}
inline ::proto::common::last_static_map* role_data::mutable_last_map() {
  set_has_last_map();
  if (last_map_ == NULL) last_map_ = new ::proto::common::last_static_map;
  return last_map_;
}
inline ::proto::common::last_static_map* role_data::release_last_map() {
  clear_has_last_map();
  ::proto::common::last_static_map* temp = last_map_;
  last_map_ = NULL;
  return temp;
}
inline void role_data::set_allocated_last_map(::proto::common::last_static_map* last_map) {
  delete last_map_;
  last_map_ = last_map;
  if (last_map) {
    set_has_last_map();
  } else {
    clear_has_last_map();
  }
}

// optional uint32 npc_code = 30;
inline bool role_data::has_npc_code() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void role_data::set_has_npc_code() {
  _has_bits_[0] |= 0x20000000u;
}
inline void role_data::clear_has_npc_code() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void role_data::clear_npc_code() {
  npc_code_ = 0u;
  clear_has_npc_code();
}
inline ::google::protobuf::uint32 role_data::npc_code() const {
  return npc_code_;
}
inline void role_data::set_npc_code(::google::protobuf::uint32 value) {
  set_has_npc_code();
  npc_code_ = value;
}

// optional uint32 collect_code = 31;
inline bool role_data::has_collect_code() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void role_data::set_has_collect_code() {
  _has_bits_[0] |= 0x40000000u;
}
inline void role_data::clear_has_collect_code() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void role_data::clear_collect_code() {
  collect_code_ = 0u;
  clear_has_collect_code();
}
inline ::google::protobuf::uint32 role_data::collect_code() const {
  return collect_code_;
}
inline void role_data::set_collect_code(::google::protobuf::uint32 value) {
  set_has_collect_code();
  collect_code_ = value;
}

// optional .proto.common.page_data page_list = 32;
inline bool role_data::has_page_list() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void role_data::set_has_page_list() {
  _has_bits_[0] |= 0x80000000u;
}
inline void role_data::clear_has_page_list() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void role_data::clear_page_list() {
  if (page_list_ != NULL) page_list_->::proto::common::page_data::Clear();
  clear_has_page_list();
}
inline const ::proto::common::page_data& role_data::page_list() const {
  return page_list_ != NULL ? *page_list_ : *default_instance_->page_list_;
}
inline ::proto::common::page_data* role_data::mutable_page_list() {
  set_has_page_list();
  if (page_list_ == NULL) page_list_ = new ::proto::common::page_data;
  return page_list_;
}
inline ::proto::common::page_data* role_data::release_page_list() {
  clear_has_page_list();
  ::proto::common::page_data* temp = page_list_;
  page_list_ = NULL;
  return temp;
}
inline void role_data::set_allocated_page_list(::proto::common::page_data* page_list) {
  delete page_list_;
  page_list_ = page_list;
  if (page_list) {
    set_has_page_list();
  } else {
    clear_has_page_list();
  }
}

// optional .proto.common.active_reward_task_data task_list = 33;
inline bool role_data::has_task_list() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void role_data::set_has_task_list() {
  _has_bits_[1] |= 0x00000001u;
}
inline void role_data::clear_has_task_list() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void role_data::clear_task_list() {
  if (task_list_ != NULL) task_list_->::proto::common::active_reward_task_data::Clear();
  clear_has_task_list();
}
inline const ::proto::common::active_reward_task_data& role_data::task_list() const {
  return task_list_ != NULL ? *task_list_ : *default_instance_->task_list_;
}
inline ::proto::common::active_reward_task_data* role_data::mutable_task_list() {
  set_has_task_list();
  if (task_list_ == NULL) task_list_ = new ::proto::common::active_reward_task_data;
  return task_list_;
}
inline ::proto::common::active_reward_task_data* role_data::release_task_list() {
  clear_has_task_list();
  ::proto::common::active_reward_task_data* temp = task_list_;
  task_list_ = NULL;
  return temp;
}
inline void role_data::set_allocated_task_list(::proto::common::active_reward_task_data* task_list) {
  delete task_list_;
  task_list_ = task_list;
  if (task_list) {
    set_has_task_list();
  } else {
    clear_has_task_list();
  }
}

// optional uint32 current_tower = 35;
inline bool role_data::has_current_tower() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void role_data::set_has_current_tower() {
  _has_bits_[1] |= 0x00000002u;
}
inline void role_data::clear_has_current_tower() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void role_data::clear_current_tower() {
  current_tower_ = 0u;
  clear_has_current_tower();
}
inline ::google::protobuf::uint32 role_data::current_tower() const {
  return current_tower_;
}
inline void role_data::set_current_tower(::google::protobuf::uint32 value) {
  set_has_current_tower();
  current_tower_ = value;
}

// optional uint32 update_day_time = 36;
inline bool role_data::has_update_day_time() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void role_data::set_has_update_day_time() {
  _has_bits_[1] |= 0x00000004u;
}
inline void role_data::clear_has_update_day_time() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void role_data::clear_update_day_time() {
  update_day_time_ = 0u;
  clear_has_update_day_time();
}
inline ::google::protobuf::uint32 role_data::update_day_time() const {
  return update_day_time_;
}
inline void role_data::set_update_day_time(::google::protobuf::uint32 value) {
  set_has_update_day_time();
  update_day_time_ = value;
}

// optional uint32 update_week_time = 37;
inline bool role_data::has_update_week_time() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void role_data::set_has_update_week_time() {
  _has_bits_[1] |= 0x00000008u;
}
inline void role_data::clear_has_update_week_time() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void role_data::clear_update_week_time() {
  update_week_time_ = 0u;
  clear_has_update_week_time();
}
inline ::google::protobuf::uint32 role_data::update_week_time() const {
  return update_week_time_;
}
inline void role_data::set_update_week_time(::google::protobuf::uint32 value) {
  set_has_update_week_time();
  update_week_time_ = value;
}

// optional .proto.common.multi_time_data multi_time = 38;
inline bool role_data::has_multi_time() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void role_data::set_has_multi_time() {
  _has_bits_[1] |= 0x00000010u;
}
inline void role_data::clear_has_multi_time() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void role_data::clear_multi_time() {
  if (multi_time_ != NULL) multi_time_->::proto::common::multi_time_data::Clear();
  clear_has_multi_time();
}
inline const ::proto::common::multi_time_data& role_data::multi_time() const {
  return multi_time_ != NULL ? *multi_time_ : *default_instance_->multi_time_;
}
inline ::proto::common::multi_time_data* role_data::mutable_multi_time() {
  set_has_multi_time();
  if (multi_time_ == NULL) multi_time_ = new ::proto::common::multi_time_data;
  return multi_time_;
}
inline ::proto::common::multi_time_data* role_data::release_multi_time() {
  clear_has_multi_time();
  ::proto::common::multi_time_data* temp = multi_time_;
  multi_time_ = NULL;
  return temp;
}
inline void role_data::set_allocated_multi_time(::proto::common::multi_time_data* multi_time) {
  delete multi_time_;
  multi_time_ = multi_time;
  if (multi_time) {
    set_has_multi_time();
  } else {
    clear_has_multi_time();
  }
}

// optional uint32 mode_state = 39;
inline bool role_data::has_mode_state() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void role_data::set_has_mode_state() {
  _has_bits_[1] |= 0x00000020u;
}
inline void role_data::clear_has_mode_state() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void role_data::clear_mode_state() {
  mode_state_ = 0u;
  clear_has_mode_state();
}
inline ::google::protobuf::uint32 role_data::mode_state() const {
  return mode_state_;
}
inline void role_data::set_mode_state(::google::protobuf::uint32 value) {
  set_has_mode_state();
  mode_state_ = value;
}

// optional .proto.common.life_info life_data = 40;
inline bool role_data::has_life_data() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void role_data::set_has_life_data() {
  _has_bits_[1] |= 0x00000040u;
}
inline void role_data::clear_has_life_data() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void role_data::clear_life_data() {
  if (life_data_ != NULL) life_data_->::proto::common::life_info::Clear();
  clear_has_life_data();
}
inline const ::proto::common::life_info& role_data::life_data() const {
  return life_data_ != NULL ? *life_data_ : *default_instance_->life_data_;
}
inline ::proto::common::life_info* role_data::mutable_life_data() {
  set_has_life_data();
  if (life_data_ == NULL) life_data_ = new ::proto::common::life_info;
  return life_data_;
}
inline ::proto::common::life_info* role_data::release_life_data() {
  clear_has_life_data();
  ::proto::common::life_info* temp = life_data_;
  life_data_ = NULL;
  return temp;
}
inline void role_data::set_allocated_life_data(::proto::common::life_info* life_data) {
  delete life_data_;
  life_data_ = life_data;
  if (life_data) {
    set_has_life_data();
  } else {
    clear_has_life_data();
  }
}

// optional .proto.common.head_data head_frame_info = 41;
inline bool role_data::has_head_frame_info() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void role_data::set_has_head_frame_info() {
  _has_bits_[1] |= 0x00000080u;
}
inline void role_data::clear_has_head_frame_info() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void role_data::clear_head_frame_info() {
  if (head_frame_info_ != NULL) head_frame_info_->::proto::common::head_data::Clear();
  clear_has_head_frame_info();
}
inline const ::proto::common::head_data& role_data::head_frame_info() const {
  return head_frame_info_ != NULL ? *head_frame_info_ : *default_instance_->head_frame_info_;
}
inline ::proto::common::head_data* role_data::mutable_head_frame_info() {
  set_has_head_frame_info();
  if (head_frame_info_ == NULL) head_frame_info_ = new ::proto::common::head_data;
  return head_frame_info_;
}
inline ::proto::common::head_data* role_data::release_head_frame_info() {
  clear_has_head_frame_info();
  ::proto::common::head_data* temp = head_frame_info_;
  head_frame_info_ = NULL;
  return temp;
}
inline void role_data::set_allocated_head_frame_info(::proto::common::head_data* head_frame_info) {
  delete head_frame_info_;
  head_frame_info_ = head_frame_info;
  if (head_frame_info) {
    set_has_head_frame_info();
  } else {
    clear_has_head_frame_info();
  }
}

// optional uint32 charm = 43;
inline bool role_data::has_charm() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void role_data::set_has_charm() {
  _has_bits_[1] |= 0x00000100u;
}
inline void role_data::clear_has_charm() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void role_data::clear_charm() {
  charm_ = 0u;
  clear_has_charm();
}
inline ::google::protobuf::uint32 role_data::charm() const {
  return charm_;
}
inline void role_data::set_charm(::google::protobuf::uint32 value) {
  set_has_charm();
  charm_ = value;
}

// repeated uint32 compeleted_guide_id = 44;
inline int role_data::compeleted_guide_id_size() const {
  return compeleted_guide_id_.size();
}
inline void role_data::clear_compeleted_guide_id() {
  compeleted_guide_id_.Clear();
}
inline ::google::protobuf::uint32 role_data::compeleted_guide_id(int index) const {
  return compeleted_guide_id_.Get(index);
}
inline void role_data::set_compeleted_guide_id(int index, ::google::protobuf::uint32 value) {
  compeleted_guide_id_.Set(index, value);
}
inline void role_data::add_compeleted_guide_id(::google::protobuf::uint32 value) {
  compeleted_guide_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
role_data::compeleted_guide_id() const {
  return compeleted_guide_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
role_data::mutable_compeleted_guide_id() {
  return &compeleted_guide_id_;
}

// -------------------------------------------------------------------

// country_common

// optional uint32 country_id = 1;
inline bool country_common::has_country_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_common::set_has_country_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_common::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_common::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 country_common::country_id() const {
  return country_id_;
}
inline void country_common::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional uint32 country_flag = 2;
inline bool country_common::has_country_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_common::set_has_country_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_common::clear_has_country_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_common::clear_country_flag() {
  country_flag_ = 0u;
  clear_has_country_flag();
}
inline ::google::protobuf::uint32 country_common::country_flag() const {
  return country_flag_;
}
inline void country_common::set_country_flag(::google::protobuf::uint32 value) {
  set_has_country_flag();
  country_flag_ = value;
}

// optional string country_name = 3;
inline bool country_common::has_country_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_common::set_has_country_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_common::clear_has_country_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_common::clear_country_name() {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    country_name_->clear();
  }
  clear_has_country_name();
}
inline const ::std::string& country_common::country_name() const {
  return *country_name_;
}
inline void country_common::set_country_name(const ::std::string& value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void country_common::set_country_name(const char* value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void country_common::set_country_name(const char* value, size_t size) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_common::mutable_country_name() {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  return country_name_;
}
inline ::std::string* country_common::release_country_name() {
  clear_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_name_;
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_common::set_allocated_country_name(::std::string* country_name) {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    delete country_name_;
  }
  if (country_name) {
    set_has_country_name();
    country_name_ = country_name;
  } else {
    clear_has_country_name();
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// object_common_info

// optional string object_id = 1;
inline bool object_common_info::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void object_common_info::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void object_common_info::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void object_common_info::clear_object_id() {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    object_id_->clear();
  }
  clear_has_object_id();
}
inline const ::std::string& object_common_info::object_id() const {
  return *object_id_;
}
inline void object_common_info::set_object_id(const ::std::string& value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void object_common_info::set_object_id(const char* value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void object_common_info::set_object_id(const char* value, size_t size) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_common_info::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  return object_id_;
}
inline ::std::string* object_common_info::release_object_id() {
  clear_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_id_;
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_common_info::set_allocated_object_id(::std::string* object_id) {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    delete object_id_;
  }
  if (object_id) {
    set_has_object_id();
    object_id_ = object_id;
  } else {
    clear_has_object_id();
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2;
inline bool object_common_info::has_object_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void object_common_info::set_has_object_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void object_common_info::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void object_common_info::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE object_common_info::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void object_common_info::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional string object_name = 3;
inline bool object_common_info::has_object_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void object_common_info::set_has_object_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void object_common_info::clear_has_object_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void object_common_info::clear_object_name() {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    object_name_->clear();
  }
  clear_has_object_name();
}
inline const ::std::string& object_common_info::object_name() const {
  return *object_name_;
}
inline void object_common_info::set_object_name(const ::std::string& value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void object_common_info::set_object_name(const char* value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void object_common_info::set_object_name(const char* value, size_t size) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_common_info::mutable_object_name() {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  return object_name_;
}
inline ::std::string* object_common_info::release_object_name() {
  clear_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_name_;
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_common_info::set_allocated_object_name(::std::string* object_name) {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    delete object_name_;
  }
  if (object_name) {
    set_has_object_name();
    object_name_ = object_name;
  } else {
    clear_has_object_name();
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 speed = 4;
inline bool object_common_info::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void object_common_info::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void object_common_info::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void object_common_info::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
inline ::google::protobuf::uint32 object_common_info::speed() const {
  return speed_;
}
inline void object_common_info::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
}

// optional uint32 level = 5;
inline bool object_common_info::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void object_common_info::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void object_common_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void object_common_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 object_common_info::level() const {
  return level_;
}
inline void object_common_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional .proto.common.country_common country = 6;
inline bool object_common_info::has_country() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void object_common_info::set_has_country() {
  _has_bits_[0] |= 0x00000020u;
}
inline void object_common_info::clear_has_country() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void object_common_info::clear_country() {
  if (country_ != NULL) country_->::proto::common::country_common::Clear();
  clear_has_country();
}
inline const ::proto::common::country_common& object_common_info::country() const {
  return country_ != NULL ? *country_ : *default_instance_->country_;
}
inline ::proto::common::country_common* object_common_info::mutable_country() {
  set_has_country();
  if (country_ == NULL) country_ = new ::proto::common::country_common;
  return country_;
}
inline ::proto::common::country_common* object_common_info::release_country() {
  clear_has_country();
  ::proto::common::country_common* temp = country_;
  country_ = NULL;
  return temp;
}
inline void object_common_info::set_allocated_country(::proto::common::country_common* country) {
  delete country_;
  country_ = country;
  if (country) {
    set_has_country();
  } else {
    clear_has_country();
  }
}

// optional .proto.common.object_state_info object_state = 7;
inline bool object_common_info::has_object_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void object_common_info::set_has_object_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void object_common_info::clear_has_object_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void object_common_info::clear_object_state() {
  if (object_state_ != NULL) object_state_->::proto::common::object_state_info::Clear();
  clear_has_object_state();
}
inline const ::proto::common::object_state_info& object_common_info::object_state() const {
  return object_state_ != NULL ? *object_state_ : *default_instance_->object_state_;
}
inline ::proto::common::object_state_info* object_common_info::mutable_object_state() {
  set_has_object_state();
  if (object_state_ == NULL) object_state_ = new ::proto::common::object_state_info;
  return object_state_;
}
inline ::proto::common::object_state_info* object_common_info::release_object_state() {
  clear_has_object_state();
  ::proto::common::object_state_info* temp = object_state_;
  object_state_ = NULL;
  return temp;
}
inline void object_common_info::set_allocated_object_state(::proto::common::object_state_info* object_state) {
  delete object_state_;
  object_state_ = object_state;
  if (object_state) {
    set_has_object_state();
  } else {
    clear_has_object_state();
  }
}

// optional uint32 plugin = 8;
inline bool object_common_info::has_plugin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void object_common_info::set_has_plugin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void object_common_info::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void object_common_info::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 object_common_info::plugin() const {
  return plugin_;
}
inline void object_common_info::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 country_officer = 9;
inline bool object_common_info::has_country_officer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void object_common_info::set_has_country_officer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void object_common_info::clear_has_country_officer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void object_common_info::clear_country_officer() {
  country_officer_ = 0u;
  clear_has_country_officer();
}
inline ::google::protobuf::uint32 object_common_info::country_officer() const {
  return country_officer_;
}
inline void object_common_info::set_country_officer(::google::protobuf::uint32 value) {
  set_has_country_officer();
  country_officer_ = value;
}

// optional uint32 mode_id = 10;
inline bool object_common_info::has_mode_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void object_common_info::set_has_mode_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void object_common_info::clear_has_mode_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void object_common_info::clear_mode_id() {
  mode_id_ = 0u;
  clear_has_mode_id();
}
inline ::google::protobuf::uint32 object_common_info::mode_id() const {
  return mode_id_;
}
inline void object_common_info::set_mode_id(::google::protobuf::uint32 value) {
  set_has_mode_id();
  mode_id_ = value;
}

// optional float current_x = 11;
inline bool object_common_info::has_current_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void object_common_info::set_has_current_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void object_common_info::clear_has_current_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void object_common_info::clear_current_x() {
  current_x_ = 0;
  clear_has_current_x();
}
inline float object_common_info::current_x() const {
  return current_x_;
}
inline void object_common_info::set_current_x(float value) {
  set_has_current_x();
  current_x_ = value;
}

// optional float current_y = 12;
inline bool object_common_info::has_current_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void object_common_info::set_has_current_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void object_common_info::clear_has_current_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void object_common_info::clear_current_y() {
  current_y_ = 0;
  clear_has_current_y();
}
inline float object_common_info::current_y() const {
  return current_y_;
}
inline void object_common_info::set_current_y(float value) {
  set_has_current_y();
  current_y_ = value;
}

// optional float direction = 13;
inline bool object_common_info::has_direction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void object_common_info::set_has_direction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void object_common_info::clear_has_direction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void object_common_info::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline float object_common_info::direction() const {
  return direction_;
}
inline void object_common_info::set_direction(float value) {
  set_has_direction();
  direction_ = value;
}

// optional uint32 max_hp = 14;
inline bool object_common_info::has_max_hp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void object_common_info::set_has_max_hp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void object_common_info::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void object_common_info::clear_max_hp() {
  max_hp_ = 0u;
  clear_has_max_hp();
}
inline ::google::protobuf::uint32 object_common_info::max_hp() const {
  return max_hp_;
}
inline void object_common_info::set_max_hp(::google::protobuf::uint32 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// optional uint32 current_hp = 15;
inline bool object_common_info::has_current_hp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void object_common_info::set_has_current_hp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void object_common_info::clear_has_current_hp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void object_common_info::clear_current_hp() {
  current_hp_ = 0u;
  clear_has_current_hp();
}
inline ::google::protobuf::uint32 object_common_info::current_hp() const {
  return current_hp_;
}
inline void object_common_info::set_current_hp(::google::protobuf::uint32 value) {
  set_has_current_hp();
  current_hp_ = value;
}

// optional string family_id = 16;
inline bool object_common_info::has_family_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void object_common_info::set_has_family_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void object_common_info::clear_has_family_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void object_common_info::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& object_common_info::family_id() const {
  return *family_id_;
}
inline void object_common_info::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void object_common_info::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void object_common_info::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_common_info::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* object_common_info::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_common_info::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 17;
inline bool object_common_info::has_family_name() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void object_common_info::set_has_family_name() {
  _has_bits_[0] |= 0x00010000u;
}
inline void object_common_info::clear_has_family_name() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void object_common_info::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& object_common_info::family_name() const {
  return *family_name_;
}
inline void object_common_info::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void object_common_info::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void object_common_info::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_common_info::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* object_common_info::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_common_info::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fighting_value = 18;
inline bool object_common_info::has_fighting_value() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void object_common_info::set_has_fighting_value() {
  _has_bits_[0] |= 0x00020000u;
}
inline void object_common_info::clear_has_fighting_value() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void object_common_info::clear_fighting_value() {
  fighting_value_ = 0u;
  clear_has_fighting_value();
}
inline ::google::protobuf::uint32 object_common_info::fighting_value() const {
  return fighting_value_;
}
inline void object_common_info::set_fighting_value(::google::protobuf::uint32 value) {
  set_has_fighting_value();
  fighting_value_ = value;
}

// optional uint32 mount_tid = 19;
inline bool object_common_info::has_mount_tid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void object_common_info::set_has_mount_tid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void object_common_info::clear_has_mount_tid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void object_common_info::clear_mount_tid() {
  mount_tid_ = 0u;
  clear_has_mount_tid();
}
inline ::google::protobuf::uint32 object_common_info::mount_tid() const {
  return mount_tid_;
}
inline void object_common_info::set_mount_tid(::google::protobuf::uint32 value) {
  set_has_mount_tid();
  mount_tid_ = value;
}

// optional uint32 npc_tid = 20;
inline bool object_common_info::has_npc_tid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void object_common_info::set_has_npc_tid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void object_common_info::clear_has_npc_tid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void object_common_info::clear_npc_tid() {
  npc_tid_ = 0u;
  clear_has_npc_tid();
}
inline ::google::protobuf::uint32 object_common_info::npc_tid() const {
  return npc_tid_;
}
inline void object_common_info::set_npc_tid(::google::protobuf::uint32 value) {
  set_has_npc_tid();
  npc_tid_ = value;
}

// optional uint32 collect_tid = 21;
inline bool object_common_info::has_collect_tid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void object_common_info::set_has_collect_tid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void object_common_info::clear_has_collect_tid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void object_common_info::clear_collect_tid() {
  collect_tid_ = 0u;
  clear_has_collect_tid();
}
inline ::google::protobuf::uint32 object_common_info::collect_tid() const {
  return collect_tid_;
}
inline void object_common_info::set_collect_tid(::google::protobuf::uint32 value) {
  set_has_collect_tid();
  collect_tid_ = value;
}

// optional uint32 pk_value = 23;
inline bool object_common_info::has_pk_value() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void object_common_info::set_has_pk_value() {
  _has_bits_[0] |= 0x00200000u;
}
inline void object_common_info::clear_has_pk_value() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void object_common_info::clear_pk_value() {
  pk_value_ = 0u;
  clear_has_pk_value();
}
inline ::google::protobuf::uint32 object_common_info::pk_value() const {
  return pk_value_;
}
inline void object_common_info::set_pk_value(::google::protobuf::uint32 value) {
  set_has_pk_value();
  pk_value_ = value;
}

// optional string troop_id = 24;
inline bool object_common_info::has_troop_id() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void object_common_info::set_has_troop_id() {
  _has_bits_[0] |= 0x00400000u;
}
inline void object_common_info::clear_has_troop_id() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void object_common_info::clear_troop_id() {
  if (troop_id_ != &::google::protobuf::internal::kEmptyString) {
    troop_id_->clear();
  }
  clear_has_troop_id();
}
inline const ::std::string& object_common_info::troop_id() const {
  return *troop_id_;
}
inline void object_common_info::set_troop_id(const ::std::string& value) {
  set_has_troop_id();
  if (troop_id_ == &::google::protobuf::internal::kEmptyString) {
    troop_id_ = new ::std::string;
  }
  troop_id_->assign(value);
}
inline void object_common_info::set_troop_id(const char* value) {
  set_has_troop_id();
  if (troop_id_ == &::google::protobuf::internal::kEmptyString) {
    troop_id_ = new ::std::string;
  }
  troop_id_->assign(value);
}
inline void object_common_info::set_troop_id(const char* value, size_t size) {
  set_has_troop_id();
  if (troop_id_ == &::google::protobuf::internal::kEmptyString) {
    troop_id_ = new ::std::string;
  }
  troop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* object_common_info::mutable_troop_id() {
  set_has_troop_id();
  if (troop_id_ == &::google::protobuf::internal::kEmptyString) {
    troop_id_ = new ::std::string;
  }
  return troop_id_;
}
inline ::std::string* object_common_info::release_troop_id() {
  clear_has_troop_id();
  if (troop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = troop_id_;
    troop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void object_common_info::set_allocated_troop_id(::std::string* troop_id) {
  if (troop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete troop_id_;
  }
  if (troop_id) {
    set_has_troop_id();
    troop_id_ = troop_id;
  } else {
    clear_has_troop_id();
    troop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_leader = 25;
inline bool object_common_info::has_is_leader() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void object_common_info::set_has_is_leader() {
  _has_bits_[0] |= 0x00800000u;
}
inline void object_common_info::clear_has_is_leader() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void object_common_info::clear_is_leader() {
  is_leader_ = false;
  clear_has_is_leader();
}
inline bool object_common_info::is_leader() const {
  return is_leader_;
}
inline void object_common_info::set_is_leader(bool value) {
  set_has_is_leader();
  is_leader_ = value;
}

// optional uint32 family_officer = 26;
inline bool object_common_info::has_family_officer() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void object_common_info::set_has_family_officer() {
  _has_bits_[0] |= 0x01000000u;
}
inline void object_common_info::clear_has_family_officer() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void object_common_info::clear_family_officer() {
  family_officer_ = 0u;
  clear_has_family_officer();
}
inline ::google::protobuf::uint32 object_common_info::family_officer() const {
  return family_officer_;
}
inline void object_common_info::set_family_officer(::google::protobuf::uint32 value) {
  set_has_family_officer();
  family_officer_ = value;
}

// repeated uint32 role_buff = 27;
inline int object_common_info::role_buff_size() const {
  return role_buff_.size();
}
inline void object_common_info::clear_role_buff() {
  role_buff_.Clear();
}
inline ::google::protobuf::uint32 object_common_info::role_buff(int index) const {
  return role_buff_.Get(index);
}
inline void object_common_info::set_role_buff(int index, ::google::protobuf::uint32 value) {
  role_buff_.Set(index, value);
}
inline void object_common_info::add_role_buff(::google::protobuf::uint32 value) {
  role_buff_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
object_common_info::role_buff() const {
  return role_buff_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
object_common_info::mutable_role_buff() {
  return &role_buff_;
}

// optional uint32 state_level = 28;
inline bool object_common_info::has_state_level() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void object_common_info::set_has_state_level() {
  _has_bits_[0] |= 0x04000000u;
}
inline void object_common_info::clear_has_state_level() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void object_common_info::clear_state_level() {
  state_level_ = 0u;
  clear_has_state_level();
}
inline ::google::protobuf::uint32 object_common_info::state_level() const {
  return state_level_;
}
inline void object_common_info::set_state_level(::google::protobuf::uint32 value) {
  set_has_state_level();
  state_level_ = value;
}

// optional uint32 head = 29;
inline bool object_common_info::has_head() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void object_common_info::set_has_head() {
  _has_bits_[0] |= 0x08000000u;
}
inline void object_common_info::clear_has_head() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void object_common_info::clear_head() {
  head_ = 0u;
  clear_has_head();
}
inline ::google::protobuf::uint32 object_common_info::head() const {
  return head_;
}
inline void object_common_info::set_head(::google::protobuf::uint32 value) {
  set_has_head();
  head_ = value;
}

// optional uint32 pk_mode = 30;
inline bool object_common_info::has_pk_mode() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void object_common_info::set_has_pk_mode() {
  _has_bits_[0] |= 0x10000000u;
}
inline void object_common_info::clear_has_pk_mode() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void object_common_info::clear_pk_mode() {
  pk_mode_ = 0u;
  clear_has_pk_mode();
}
inline ::google::protobuf::uint32 object_common_info::pk_mode() const {
  return pk_mode_;
}
inline void object_common_info::set_pk_mode(::google::protobuf::uint32 value) {
  set_has_pk_mode();
  pk_mode_ = value;
}

// optional uint32 pk_ex = 31;
inline bool object_common_info::has_pk_ex() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void object_common_info::set_has_pk_ex() {
  _has_bits_[0] |= 0x20000000u;
}
inline void object_common_info::clear_has_pk_ex() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void object_common_info::clear_pk_ex() {
  pk_ex_ = 0u;
  clear_has_pk_ex();
}
inline ::google::protobuf::uint32 object_common_info::pk_ex() const {
  return pk_ex_;
}
inline void object_common_info::set_pk_ex(::google::protobuf::uint32 value) {
  set_has_pk_ex();
  pk_ex_ = value;
}

// optional uint32 cur_title = 32;
inline bool object_common_info::has_cur_title() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void object_common_info::set_has_cur_title() {
  _has_bits_[0] |= 0x40000000u;
}
inline void object_common_info::clear_has_cur_title() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void object_common_info::clear_cur_title() {
  cur_title_ = 0u;
  clear_has_cur_title();
}
inline ::google::protobuf::uint32 object_common_info::cur_title() const {
  return cur_title_;
}
inline void object_common_info::set_cur_title(::google::protobuf::uint32 value) {
  set_has_cur_title();
  cur_title_ = value;
}

// -------------------------------------------------------------------

// personal_info

// optional uint32 yuanbao = 1;
inline bool personal_info::has_yuanbao() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void personal_info::set_has_yuanbao() {
  _has_bits_[0] |= 0x00000001u;
}
inline void personal_info::clear_has_yuanbao() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void personal_info::clear_yuanbao() {
  yuanbao_ = 0u;
  clear_has_yuanbao();
}
inline ::google::protobuf::uint32 personal_info::yuanbao() const {
  return yuanbao_;
}
inline void personal_info::set_yuanbao(::google::protobuf::uint32 value) {
  set_has_yuanbao();
  yuanbao_ = value;
}

// optional uint32 silver = 2;
inline bool personal_info::has_silver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void personal_info::set_has_silver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void personal_info::clear_has_silver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void personal_info::clear_silver() {
  silver_ = 0u;
  clear_has_silver();
}
inline ::google::protobuf::uint32 personal_info::silver() const {
  return silver_;
}
inline void personal_info::set_silver(::google::protobuf::uint32 value) {
  set_has_silver();
  silver_ = value;
}

// optional uint32 copper = 3;
inline bool personal_info::has_copper() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void personal_info::set_has_copper() {
  _has_bits_[0] |= 0x00000004u;
}
inline void personal_info::clear_has_copper() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void personal_info::clear_copper() {
  copper_ = 0u;
  clear_has_copper();
}
inline ::google::protobuf::uint32 personal_info::copper() const {
  return copper_;
}
inline void personal_info::set_copper(::google::protobuf::uint32 value) {
  set_has_copper();
  copper_ = value;
}

// optional uint32 pk_mode = 7;
inline bool personal_info::has_pk_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void personal_info::set_has_pk_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void personal_info::clear_has_pk_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void personal_info::clear_pk_mode() {
  pk_mode_ = 0u;
  clear_has_pk_mode();
}
inline ::google::protobuf::uint32 personal_info::pk_mode() const {
  return pk_mode_;
}
inline void personal_info::set_pk_mode(::google::protobuf::uint32 value) {
  set_has_pk_mode();
  pk_mode_ = value;
}

// optional uint32 pk_punishment = 8;
inline bool personal_info::has_pk_punishment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void personal_info::set_has_pk_punishment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void personal_info::clear_has_pk_punishment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void personal_info::clear_pk_punishment() {
  pk_punishment_ = 0u;
  clear_has_pk_punishment();
}
inline ::google::protobuf::uint32 personal_info::pk_punishment() const {
  return pk_punishment_;
}
inline void personal_info::set_pk_punishment(::google::protobuf::uint32 value) {
  set_has_pk_punishment();
  pk_punishment_ = value;
}

// optional uint32 garrison_city = 9;
inline bool personal_info::has_garrison_city() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void personal_info::set_has_garrison_city() {
  _has_bits_[0] |= 0x00000020u;
}
inline void personal_info::clear_has_garrison_city() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void personal_info::clear_garrison_city() {
  garrison_city_ = 0u;
  clear_has_garrison_city();
}
inline ::google::protobuf::uint32 personal_info::garrison_city() const {
  return garrison_city_;
}
inline void personal_info::set_garrison_city(::google::protobuf::uint32 value) {
  set_has_garrison_city();
  garrison_city_ = value;
}

// optional uint32 offline_reward_calc_time = 10;
inline bool personal_info::has_offline_reward_calc_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void personal_info::set_has_offline_reward_calc_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void personal_info::clear_has_offline_reward_calc_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void personal_info::clear_offline_reward_calc_time() {
  offline_reward_calc_time_ = 0u;
  clear_has_offline_reward_calc_time();
}
inline ::google::protobuf::uint32 personal_info::offline_reward_calc_time() const {
  return offline_reward_calc_time_;
}
inline void personal_info::set_offline_reward_calc_time(::google::protobuf::uint32 value) {
  set_has_offline_reward_calc_time();
  offline_reward_calc_time_ = value;
}

// optional string family_id = 11;
inline bool personal_info::has_family_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void personal_info::set_has_family_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void personal_info::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void personal_info::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& personal_info::family_id() const {
  return *family_id_;
}
inline void personal_info::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void personal_info::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void personal_info::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* personal_info::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* personal_info::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void personal_info::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 city_id = 12;
inline bool personal_info::has_city_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void personal_info::set_has_city_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void personal_info::clear_has_city_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void personal_info::clear_city_id() {
  city_id_ = 0u;
  clear_has_city_id();
}
inline ::google::protobuf::uint32 personal_info::city_id() const {
  return city_id_;
}
inline void personal_info::set_city_id(::google::protobuf::uint32 value) {
  set_has_city_id();
  city_id_ = value;
}

// optional uint32 luck_gift_gold = 18;
inline bool personal_info::has_luck_gift_gold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void personal_info::set_has_luck_gift_gold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void personal_info::clear_has_luck_gift_gold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void personal_info::clear_luck_gift_gold() {
  luck_gift_gold_ = 0u;
  clear_has_luck_gift_gold();
}
inline ::google::protobuf::uint32 personal_info::luck_gift_gold() const {
  return luck_gift_gold_;
}
inline void personal_info::set_luck_gift_gold(::google::protobuf::uint32 value) {
  set_has_luck_gift_gold();
  luck_gift_gold_ = value;
}

// optional string hero_uid = 19;
inline bool personal_info::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void personal_info::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void personal_info::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void personal_info::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& personal_info::hero_uid() const {
  return *hero_uid_;
}
inline void personal_info::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void personal_info::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void personal_info::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* personal_info::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* personal_info::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void personal_info::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prestige = 20;
inline bool personal_info::has_prestige() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void personal_info::set_has_prestige() {
  _has_bits_[0] |= 0x00000800u;
}
inline void personal_info::clear_has_prestige() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void personal_info::clear_prestige() {
  prestige_ = 0u;
  clear_has_prestige();
}
inline ::google::protobuf::uint32 personal_info::prestige() const {
  return prestige_;
}
inline void personal_info::set_prestige(::google::protobuf::uint32 value) {
  set_has_prestige();
  prestige_ = value;
}

// optional uint32 prestige_total = 21;
inline bool personal_info::has_prestige_total() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void personal_info::set_has_prestige_total() {
  _has_bits_[0] |= 0x00001000u;
}
inline void personal_info::clear_has_prestige_total() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void personal_info::clear_prestige_total() {
  prestige_total_ = 0u;
  clear_has_prestige_total();
}
inline ::google::protobuf::uint32 personal_info::prestige_total() const {
  return prestige_total_;
}
inline void personal_info::set_prestige_total(::google::protobuf::uint32 value) {
  set_has_prestige_total();
  prestige_total_ = value;
}

// optional uint32 prestige_level = 22;
inline bool personal_info::has_prestige_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void personal_info::set_has_prestige_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void personal_info::clear_has_prestige_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void personal_info::clear_prestige_level() {
  prestige_level_ = 0u;
  clear_has_prestige_level();
}
inline ::google::protobuf::uint32 personal_info::prestige_level() const {
  return prestige_level_;
}
inline void personal_info::set_prestige_level(::google::protobuf::uint32 value) {
  set_has_prestige_level();
  prestige_level_ = value;
}

// optional uint32 cur_form_id = 23;
inline bool personal_info::has_cur_form_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void personal_info::set_has_cur_form_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void personal_info::clear_has_cur_form_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void personal_info::clear_cur_form_id() {
  cur_form_id_ = 0u;
  clear_has_cur_form_id();
}
inline ::google::protobuf::uint32 personal_info::cur_form_id() const {
  return cur_form_id_;
}
inline void personal_info::set_cur_form_id(::google::protobuf::uint32 value) {
  set_has_cur_form_id();
  cur_form_id_ = value;
}

// optional uint32 pk_value_reduce_time = 24;
inline bool personal_info::has_pk_value_reduce_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void personal_info::set_has_pk_value_reduce_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void personal_info::clear_has_pk_value_reduce_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void personal_info::clear_pk_value_reduce_time() {
  pk_value_reduce_time_ = 0u;
  clear_has_pk_value_reduce_time();
}
inline ::google::protobuf::uint32 personal_info::pk_value_reduce_time() const {
  return pk_value_reduce_time_;
}
inline void personal_info::set_pk_value_reduce_time(::google::protobuf::uint32 value) {
  set_has_pk_value_reduce_time();
  pk_value_reduce_time_ = value;
}

// optional uint32 pk_value = 25;
inline bool personal_info::has_pk_value() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void personal_info::set_has_pk_value() {
  _has_bits_[0] |= 0x00010000u;
}
inline void personal_info::clear_has_pk_value() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void personal_info::clear_pk_value() {
  pk_value_ = 0u;
  clear_has_pk_value();
}
inline ::google::protobuf::uint32 personal_info::pk_value() const {
  return pk_value_;
}
inline void personal_info::set_pk_value(::google::protobuf::uint32 value) {
  set_has_pk_value();
  pk_value_ = value;
}

// optional uint32 pk_count = 26;
inline bool personal_info::has_pk_count() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void personal_info::set_has_pk_count() {
  _has_bits_[0] |= 0x00020000u;
}
inline void personal_info::clear_has_pk_count() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void personal_info::clear_pk_count() {
  pk_count_ = 0u;
  clear_has_pk_count();
}
inline ::google::protobuf::uint32 personal_info::pk_count() const {
  return pk_count_;
}
inline void personal_info::set_pk_count(::google::protobuf::uint32 value) {
  set_has_pk_count();
  pk_count_ = value;
}

// optional uint32 target_count = 27;
inline bool personal_info::has_target_count() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void personal_info::set_has_target_count() {
  _has_bits_[0] |= 0x00040000u;
}
inline void personal_info::clear_has_target_count() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void personal_info::clear_target_count() {
  target_count_ = 0u;
  clear_has_target_count();
}
inline ::google::protobuf::uint32 personal_info::target_count() const {
  return target_count_;
}
inline void personal_info::set_target_count(::google::protobuf::uint32 value) {
  set_has_target_count();
  target_count_ = value;
}

// optional uint32 errantry = 28;
inline bool personal_info::has_errantry() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void personal_info::set_has_errantry() {
  _has_bits_[0] |= 0x00080000u;
}
inline void personal_info::clear_has_errantry() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void personal_info::clear_errantry() {
  errantry_ = 0u;
  clear_has_errantry();
}
inline ::google::protobuf::uint32 personal_info::errantry() const {
  return errantry_;
}
inline void personal_info::set_errantry(::google::protobuf::uint32 value) {
  set_has_errantry();
  errantry_ = value;
}

// optional uint32 energy = 29;
inline bool personal_info::has_energy() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void personal_info::set_has_energy() {
  _has_bits_[0] |= 0x00100000u;
}
inline void personal_info::clear_has_energy() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void personal_info::clear_energy() {
  energy_ = 0u;
  clear_has_energy();
}
inline ::google::protobuf::uint32 personal_info::energy() const {
  return energy_;
}
inline void personal_info::set_energy(::google::protobuf::uint32 value) {
  set_has_energy();
  energy_ = value;
}

// optional uint32 equip_smelt_value = 30;
inline bool personal_info::has_equip_smelt_value() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void personal_info::set_has_equip_smelt_value() {
  _has_bits_[0] |= 0x00200000u;
}
inline void personal_info::clear_has_equip_smelt_value() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void personal_info::clear_equip_smelt_value() {
  equip_smelt_value_ = 0u;
  clear_has_equip_smelt_value();
}
inline ::google::protobuf::uint32 personal_info::equip_smelt_value() const {
  return equip_smelt_value_;
}
inline void personal_info::set_equip_smelt_value(::google::protobuf::uint32 value) {
  set_has_equip_smelt_value();
  equip_smelt_value_ = value;
}

// repeated uint32 equip_smelt_box = 31;
inline int personal_info::equip_smelt_box_size() const {
  return equip_smelt_box_.size();
}
inline void personal_info::clear_equip_smelt_box() {
  equip_smelt_box_.Clear();
}
inline ::google::protobuf::uint32 personal_info::equip_smelt_box(int index) const {
  return equip_smelt_box_.Get(index);
}
inline void personal_info::set_equip_smelt_box(int index, ::google::protobuf::uint32 value) {
  equip_smelt_box_.Set(index, value);
}
inline void personal_info::add_equip_smelt_box(::google::protobuf::uint32 value) {
  equip_smelt_box_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
personal_info::equip_smelt_box() const {
  return equip_smelt_box_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
personal_info::mutable_equip_smelt_box() {
  return &equip_smelt_box_;
}

// optional uint32 achieve_point = 32;
inline bool personal_info::has_achieve_point() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void personal_info::set_has_achieve_point() {
  _has_bits_[0] |= 0x00800000u;
}
inline void personal_info::clear_has_achieve_point() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void personal_info::clear_achieve_point() {
  achieve_point_ = 0u;
  clear_has_achieve_point();
}
inline ::google::protobuf::uint32 personal_info::achieve_point() const {
  return achieve_point_;
}
inline void personal_info::set_achieve_point(::google::protobuf::uint32 value) {
  set_has_achieve_point();
  achieve_point_ = value;
}

// optional uint32 achieve_level = 33;
inline bool personal_info::has_achieve_level() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void personal_info::set_has_achieve_level() {
  _has_bits_[0] |= 0x01000000u;
}
inline void personal_info::clear_has_achieve_level() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void personal_info::clear_achieve_level() {
  achieve_level_ = 0u;
  clear_has_achieve_level();
}
inline ::google::protobuf::uint32 personal_info::achieve_level() const {
  return achieve_level_;
}
inline void personal_info::set_achieve_level(::google::protobuf::uint32 value) {
  set_has_achieve_level();
  achieve_level_ = value;
}

// optional uint32 achieve_recv_reward_level = 34;
inline bool personal_info::has_achieve_recv_reward_level() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void personal_info::set_has_achieve_recv_reward_level() {
  _has_bits_[0] |= 0x02000000u;
}
inline void personal_info::clear_has_achieve_recv_reward_level() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void personal_info::clear_achieve_recv_reward_level() {
  achieve_recv_reward_level_ = 0u;
  clear_has_achieve_recv_reward_level();
}
inline ::google::protobuf::uint32 personal_info::achieve_recv_reward_level() const {
  return achieve_recv_reward_level_;
}
inline void personal_info::set_achieve_recv_reward_level(::google::protobuf::uint32 value) {
  set_has_achieve_recv_reward_level();
  achieve_recv_reward_level_ = value;
}

// optional uint32 lifeforce = 35;
inline bool personal_info::has_lifeforce() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void personal_info::set_has_lifeforce() {
  _has_bits_[0] |= 0x04000000u;
}
inline void personal_info::clear_has_lifeforce() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void personal_info::clear_lifeforce() {
  lifeforce_ = 0u;
  clear_has_lifeforce();
}
inline ::google::protobuf::uint32 personal_info::lifeforce() const {
  return lifeforce_;
}
inline void personal_info::set_lifeforce(::google::protobuf::uint32 value) {
  set_has_lifeforce();
  lifeforce_ = value;
}

// optional uint32 lifestar_level = 36;
inline bool personal_info::has_lifestar_level() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void personal_info::set_has_lifestar_level() {
  _has_bits_[0] |= 0x08000000u;
}
inline void personal_info::clear_has_lifestar_level() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void personal_info::clear_lifestar_level() {
  lifestar_level_ = 0u;
  clear_has_lifestar_level();
}
inline ::google::protobuf::uint32 personal_info::lifestar_level() const {
  return lifestar_level_;
}
inline void personal_info::set_lifestar_level(::google::protobuf::uint32 value) {
  set_has_lifestar_level();
  lifestar_level_ = value;
}

// optional uint32 lifestate_level = 37;
inline bool personal_info::has_lifestate_level() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void personal_info::set_has_lifestate_level() {
  _has_bits_[0] |= 0x10000000u;
}
inline void personal_info::clear_has_lifestate_level() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void personal_info::clear_lifestate_level() {
  lifestate_level_ = 0u;
  clear_has_lifestate_level();
}
inline ::google::protobuf::uint32 personal_info::lifestate_level() const {
  return lifestate_level_;
}
inline void personal_info::set_lifestate_level(::google::protobuf::uint32 value) {
  set_has_lifestate_level();
  lifestate_level_ = value;
}

// optional uint32 plugin = 38;
inline bool personal_info::has_plugin() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void personal_info::set_has_plugin() {
  _has_bits_[0] |= 0x20000000u;
}
inline void personal_info::clear_has_plugin() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void personal_info::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 personal_info::plugin() const {
  return plugin_;
}
inline void personal_info::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 prestige_today = 39;
inline bool personal_info::has_prestige_today() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void personal_info::set_has_prestige_today() {
  _has_bits_[0] |= 0x40000000u;
}
inline void personal_info::clear_has_prestige_today() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void personal_info::clear_prestige_today() {
  prestige_today_ = 0u;
  clear_has_prestige_today();
}
inline ::google::protobuf::uint32 personal_info::prestige_today() const {
  return prestige_today_;
}
inline void personal_info::set_prestige_today(::google::protobuf::uint32 value) {
  set_has_prestige_today();
  prestige_today_ = value;
}

// optional uint32 life_stone = 40;
inline bool personal_info::has_life_stone() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void personal_info::set_has_life_stone() {
  _has_bits_[0] |= 0x80000000u;
}
inline void personal_info::clear_has_life_stone() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void personal_info::clear_life_stone() {
  life_stone_ = 0u;
  clear_has_life_stone();
}
inline ::google::protobuf::uint32 personal_info::life_stone() const {
  return life_stone_;
}
inline void personal_info::set_life_stone(::google::protobuf::uint32 value) {
  set_has_life_stone();
  life_stone_ = value;
}

// optional uint32 contribution = 43;
inline bool personal_info::has_contribution() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void personal_info::set_has_contribution() {
  _has_bits_[1] |= 0x00000001u;
}
inline void personal_info::clear_has_contribution() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void personal_info::clear_contribution() {
  contribution_ = 0u;
  clear_has_contribution();
}
inline ::google::protobuf::uint32 personal_info::contribution() const {
  return contribution_;
}
inline void personal_info::set_contribution(::google::protobuf::uint32 value) {
  set_has_contribution();
  contribution_ = value;
}

// optional uint32 herosoul = 44;
inline bool personal_info::has_herosoul() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void personal_info::set_has_herosoul() {
  _has_bits_[1] |= 0x00000002u;
}
inline void personal_info::clear_has_herosoul() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void personal_info::clear_herosoul() {
  herosoul_ = 0u;
  clear_has_herosoul();
}
inline ::google::protobuf::uint32 personal_info::herosoul() const {
  return herosoul_;
}
inline void personal_info::set_herosoul(::google::protobuf::uint32 value) {
  set_has_herosoul();
  herosoul_ = value;
}

// optional uint32 honor = 45;
inline bool personal_info::has_honor() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void personal_info::set_has_honor() {
  _has_bits_[1] |= 0x00000004u;
}
inline void personal_info::clear_has_honor() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void personal_info::clear_honor() {
  honor_ = 0u;
  clear_has_honor();
}
inline ::google::protobuf::uint32 personal_info::honor() const {
  return honor_;
}
inline void personal_info::set_honor(::google::protobuf::uint32 value) {
  set_has_honor();
  honor_ = value;
}

// optional uint32 honor_week = 46;
inline bool personal_info::has_honor_week() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void personal_info::set_has_honor_week() {
  _has_bits_[1] |= 0x00000008u;
}
inline void personal_info::clear_has_honor_week() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void personal_info::clear_honor_week() {
  honor_week_ = 0u;
  clear_has_honor_week();
}
inline ::google::protobuf::uint32 personal_info::honor_week() const {
  return honor_week_;
}
inline void personal_info::set_honor_week(::google::protobuf::uint32 value) {
  set_has_honor_week();
  honor_week_ = value;
}

// optional uint32 honor_limit = 47;
inline bool personal_info::has_honor_limit() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void personal_info::set_has_honor_limit() {
  _has_bits_[1] |= 0x00000010u;
}
inline void personal_info::clear_has_honor_limit() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void personal_info::clear_honor_limit() {
  honor_limit_ = 0u;
  clear_has_honor_limit();
}
inline ::google::protobuf::uint32 personal_info::honor_limit() const {
  return honor_limit_;
}
inline void personal_info::set_honor_limit(::google::protobuf::uint32 value) {
  set_has_honor_limit();
  honor_limit_ = value;
}

// optional uint32 patrol_count = 48;
inline bool personal_info::has_patrol_count() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void personal_info::set_has_patrol_count() {
  _has_bits_[1] |= 0x00000020u;
}
inline void personal_info::clear_has_patrol_count() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void personal_info::clear_patrol_count() {
  patrol_count_ = 0u;
  clear_has_patrol_count();
}
inline ::google::protobuf::uint32 personal_info::patrol_count() const {
  return patrol_count_;
}
inline void personal_info::set_patrol_count(::google::protobuf::uint32 value) {
  set_has_patrol_count();
  patrol_count_ = value;
}

// optional uint32 multi_point = 49;
inline bool personal_info::has_multi_point() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void personal_info::set_has_multi_point() {
  _has_bits_[1] |= 0x00000040u;
}
inline void personal_info::clear_has_multi_point() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void personal_info::clear_multi_point() {
  multi_point_ = 0u;
  clear_has_multi_point();
}
inline ::google::protobuf::uint32 personal_info::multi_point() const {
  return multi_point_;
}
inline void personal_info::set_multi_point(::google::protobuf::uint32 value) {
  set_has_multi_point();
  multi_point_ = value;
}

// optional uint32 equip_lucky = 50;
inline bool personal_info::has_equip_lucky() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void personal_info::set_has_equip_lucky() {
  _has_bits_[1] |= 0x00000080u;
}
inline void personal_info::clear_has_equip_lucky() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void personal_info::clear_equip_lucky() {
  equip_lucky_ = 0u;
  clear_has_equip_lucky();
}
inline ::google::protobuf::uint32 personal_info::equip_lucky() const {
  return equip_lucky_;
}
inline void personal_info::set_equip_lucky(::google::protobuf::uint32 value) {
  set_has_equip_lucky();
  equip_lucky_ = value;
}

// optional uint32 role_unlock = 51;
inline bool personal_info::has_role_unlock() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void personal_info::set_has_role_unlock() {
  _has_bits_[1] |= 0x00000100u;
}
inline void personal_info::clear_has_role_unlock() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void personal_info::clear_role_unlock() {
  role_unlock_ = 0u;
  clear_has_role_unlock();
}
inline ::google::protobuf::uint32 personal_info::role_unlock() const {
  return role_unlock_;
}
inline void personal_info::set_role_unlock(::google::protobuf::uint32 value) {
  set_has_role_unlock();
  role_unlock_ = value;
}

// optional uint32 vigour = 52;
inline bool personal_info::has_vigour() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void personal_info::set_has_vigour() {
  _has_bits_[1] |= 0x00000200u;
}
inline void personal_info::clear_has_vigour() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void personal_info::clear_vigour() {
  vigour_ = 0u;
  clear_has_vigour();
}
inline ::google::protobuf::uint32 personal_info::vigour() const {
  return vigour_;
}
inline void personal_info::set_vigour(::google::protobuf::uint32 value) {
  set_has_vigour();
  vigour_ = value;
}

// optional uint32 vigour_buy = 53;
inline bool personal_info::has_vigour_buy() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void personal_info::set_has_vigour_buy() {
  _has_bits_[1] |= 0x00000400u;
}
inline void personal_info::clear_has_vigour_buy() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void personal_info::clear_vigour_buy() {
  vigour_buy_ = 0u;
  clear_has_vigour_buy();
}
inline ::google::protobuf::uint32 personal_info::vigour_buy() const {
  return vigour_buy_;
}
inline void personal_info::set_vigour_buy(::google::protobuf::uint32 value) {
  set_has_vigour_buy();
  vigour_buy_ = value;
}

// optional uint32 vigour_time = 54;
inline bool personal_info::has_vigour_time() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void personal_info::set_has_vigour_time() {
  _has_bits_[1] |= 0x00000800u;
}
inline void personal_info::clear_has_vigour_time() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void personal_info::clear_vigour_time() {
  vigour_time_ = 0u;
  clear_has_vigour_time();
}
inline ::google::protobuf::uint32 personal_info::vigour_time() const {
  return vigour_time_;
}
inline void personal_info::set_vigour_time(::google::protobuf::uint32 value) {
  set_has_vigour_time();
  vigour_time_ = value;
}

// optional uint32 head_frame = 55;
inline bool personal_info::has_head_frame() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void personal_info::set_has_head_frame() {
  _has_bits_[1] |= 0x00001000u;
}
inline void personal_info::clear_has_head_frame() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void personal_info::clear_head_frame() {
  head_frame_ = 0u;
  clear_has_head_frame();
}
inline ::google::protobuf::uint32 personal_info::head_frame() const {
  return head_frame_;
}
inline void personal_info::set_head_frame(::google::protobuf::uint32 value) {
  set_has_head_frame();
  head_frame_ = value;
}

// optional uint32 month_card_id = 56;
inline bool personal_info::has_month_card_id() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void personal_info::set_has_month_card_id() {
  _has_bits_[1] |= 0x00002000u;
}
inline void personal_info::clear_has_month_card_id() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void personal_info::clear_month_card_id() {
  month_card_id_ = 0u;
  clear_has_month_card_id();
}
inline ::google::protobuf::uint32 personal_info::month_card_id() const {
  return month_card_id_;
}
inline void personal_info::set_month_card_id(::google::protobuf::uint32 value) {
  set_has_month_card_id();
  month_card_id_ = value;
}

// optional uint32 wusheng_score = 57;
inline bool personal_info::has_wusheng_score() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void personal_info::set_has_wusheng_score() {
  _has_bits_[1] |= 0x00004000u;
}
inline void personal_info::clear_has_wusheng_score() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void personal_info::clear_wusheng_score() {
  wusheng_score_ = 0u;
  clear_has_wusheng_score();
}
inline ::google::protobuf::uint32 personal_info::wusheng_score() const {
  return wusheng_score_;
}
inline void personal_info::set_wusheng_score(::google::protobuf::uint32 value) {
  set_has_wusheng_score();
  wusheng_score_ = value;
}

// optional uint32 wusheng_score_today = 58;
inline bool personal_info::has_wusheng_score_today() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void personal_info::set_has_wusheng_score_today() {
  _has_bits_[1] |= 0x00008000u;
}
inline void personal_info::clear_has_wusheng_score_today() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void personal_info::clear_wusheng_score_today() {
  wusheng_score_today_ = 0u;
  clear_has_wusheng_score_today();
}
inline ::google::protobuf::uint32 personal_info::wusheng_score_today() const {
  return wusheng_score_today_;
}
inline void personal_info::set_wusheng_score_today(::google::protobuf::uint32 value) {
  set_has_wusheng_score_today();
  wusheng_score_today_ = value;
}

// optional uint32 wusheng_lucky = 59;
inline bool personal_info::has_wusheng_lucky() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void personal_info::set_has_wusheng_lucky() {
  _has_bits_[1] |= 0x00010000u;
}
inline void personal_info::clear_has_wusheng_lucky() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void personal_info::clear_wusheng_lucky() {
  wusheng_lucky_ = 0u;
  clear_has_wusheng_lucky();
}
inline ::google::protobuf::uint32 personal_info::wusheng_lucky() const {
  return wusheng_lucky_;
}
inline void personal_info::set_wusheng_lucky(::google::protobuf::uint32 value) {
  set_has_wusheng_lucky();
  wusheng_lucky_ = value;
}

// optional uint32 patrol_point = 60;
inline bool personal_info::has_patrol_point() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void personal_info::set_has_patrol_point() {
  _has_bits_[1] |= 0x00020000u;
}
inline void personal_info::clear_has_patrol_point() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void personal_info::clear_patrol_point() {
  patrol_point_ = 0u;
  clear_has_patrol_point();
}
inline ::google::protobuf::uint32 personal_info::patrol_point() const {
  return patrol_point_;
}
inline void personal_info::set_patrol_point(::google::protobuf::uint32 value) {
  set_has_patrol_point();
  patrol_point_ = value;
}

// optional uint32 patrol_hook = 61;
inline bool personal_info::has_patrol_hook() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void personal_info::set_has_patrol_hook() {
  _has_bits_[1] |= 0x00040000u;
}
inline void personal_info::clear_has_patrol_hook() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void personal_info::clear_patrol_hook() {
  patrol_hook_ = 0u;
  clear_has_patrol_hook();
}
inline ::google::protobuf::uint32 personal_info::patrol_hook() const {
  return patrol_hook_;
}
inline void personal_info::set_patrol_hook(::google::protobuf::uint32 value) {
  set_has_patrol_hook();
  patrol_hook_ = value;
}

// optional uint32 feats = 62;
inline bool personal_info::has_feats() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void personal_info::set_has_feats() {
  _has_bits_[1] |= 0x00080000u;
}
inline void personal_info::clear_has_feats() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void personal_info::clear_feats() {
  feats_ = 0u;
  clear_has_feats();
}
inline ::google::protobuf::uint32 personal_info::feats() const {
  return feats_;
}
inline void personal_info::set_feats(::google::protobuf::uint32 value) {
  set_has_feats();
  feats_ = value;
}

// optional uint32 ignore_lineup_flag = 63;
inline bool personal_info::has_ignore_lineup_flag() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void personal_info::set_has_ignore_lineup_flag() {
  _has_bits_[1] |= 0x00100000u;
}
inline void personal_info::clear_has_ignore_lineup_flag() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void personal_info::clear_ignore_lineup_flag() {
  ignore_lineup_flag_ = 0u;
  clear_has_ignore_lineup_flag();
}
inline ::google::protobuf::uint32 personal_info::ignore_lineup_flag() const {
  return ignore_lineup_flag_;
}
inline void personal_info::set_ignore_lineup_flag(::google::protobuf::uint32 value) {
  set_has_ignore_lineup_flag();
  ignore_lineup_flag_ = value;
}

// repeated uint32 career_id = 64;
inline int personal_info::career_id_size() const {
  return career_id_.size();
}
inline void personal_info::clear_career_id() {
  career_id_.Clear();
}
inline ::google::protobuf::uint32 personal_info::career_id(int index) const {
  return career_id_.Get(index);
}
inline void personal_info::set_career_id(int index, ::google::protobuf::uint32 value) {
  career_id_.Set(index, value);
}
inline void personal_info::add_career_id(::google::protobuf::uint32 value) {
  career_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
personal_info::career_id() const {
  return career_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
personal_info::mutable_career_id() {
  return &career_id_;
}

// optional uint32 change_name = 65;
inline bool personal_info::has_change_name() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void personal_info::set_has_change_name() {
  _has_bits_[1] |= 0x00400000u;
}
inline void personal_info::clear_has_change_name() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void personal_info::clear_change_name() {
  change_name_ = 0u;
  clear_has_change_name();
}
inline ::google::protobuf::uint32 personal_info::change_name() const {
  return change_name_;
}
inline void personal_info::set_change_name(::google::protobuf::uint32 value) {
  set_has_change_name();
  change_name_ = value;
}

// repeated uint32 title_id = 66;
inline int personal_info::title_id_size() const {
  return title_id_.size();
}
inline void personal_info::clear_title_id() {
  title_id_.Clear();
}
inline ::google::protobuf::uint32 personal_info::title_id(int index) const {
  return title_id_.Get(index);
}
inline void personal_info::set_title_id(int index, ::google::protobuf::uint32 value) {
  title_id_.Set(index, value);
}
inline void personal_info::add_title_id(::google::protobuf::uint32 value) {
  title_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
personal_info::title_id() const {
  return title_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
personal_info::mutable_title_id() {
  return &title_id_;
}

// optional uint32 cur_title = 67;
inline bool personal_info::has_cur_title() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void personal_info::set_has_cur_title() {
  _has_bits_[1] |= 0x01000000u;
}
inline void personal_info::clear_has_cur_title() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void personal_info::clear_cur_title() {
  cur_title_ = 0u;
  clear_has_cur_title();
}
inline ::google::protobuf::uint32 personal_info::cur_title() const {
  return cur_title_;
}
inline void personal_info::set_cur_title(::google::protobuf::uint32 value) {
  set_has_cur_title();
  cur_title_ = value;
}

// optional uint32 friendship_point = 69;
inline bool personal_info::has_friendship_point() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void personal_info::set_has_friendship_point() {
  _has_bits_[1] |= 0x02000000u;
}
inline void personal_info::clear_has_friendship_point() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void personal_info::clear_friendship_point() {
  friendship_point_ = 0u;
  clear_has_friendship_point();
}
inline ::google::protobuf::uint32 personal_info::friendship_point() const {
  return friendship_point_;
}
inline void personal_info::set_friendship_point(::google::protobuf::uint32 value) {
  set_has_friendship_point();
  friendship_point_ = value;
}

// optional uint32 wusheng_today_buy = 70;
inline bool personal_info::has_wusheng_today_buy() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void personal_info::set_has_wusheng_today_buy() {
  _has_bits_[1] |= 0x04000000u;
}
inline void personal_info::clear_has_wusheng_today_buy() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void personal_info::clear_wusheng_today_buy() {
  wusheng_today_buy_ = 0u;
  clear_has_wusheng_today_buy();
}
inline ::google::protobuf::uint32 personal_info::wusheng_today_buy() const {
  return wusheng_today_buy_;
}
inline void personal_info::set_wusheng_today_buy(::google::protobuf::uint32 value) {
  set_has_wusheng_today_buy();
  wusheng_today_buy_ = value;
}

// repeated uint32 handbook = 71;
inline int personal_info::handbook_size() const {
  return handbook_.size();
}
inline void personal_info::clear_handbook() {
  handbook_.Clear();
}
inline ::google::protobuf::uint32 personal_info::handbook(int index) const {
  return handbook_.Get(index);
}
inline void personal_info::set_handbook(int index, ::google::protobuf::uint32 value) {
  handbook_.Set(index, value);
}
inline void personal_info::add_handbook(::google::protobuf::uint32 value) {
  handbook_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
personal_info::handbook() const {
  return handbook_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
personal_info::mutable_handbook() {
  return &handbook_;
}

// -------------------------------------------------------------------

// interior_info

// optional uint32 level = 1;
inline bool interior_info::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void interior_info::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void interior_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void interior_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 interior_info::level() const {
  return level_;
}
inline void interior_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 task_id = 2;
inline bool interior_info::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void interior_info::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void interior_info::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void interior_info::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 interior_info::task_id() const {
  return task_id_;
}
inline void interior_info::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional uint32 star_level = 3;
inline bool interior_info::has_star_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void interior_info::set_has_star_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void interior_info::clear_has_star_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void interior_info::clear_star_level() {
  star_level_ = 0u;
  clear_has_star_level();
}
inline ::google::protobuf::uint32 interior_info::star_level() const {
  return star_level_;
}
inline void interior_info::set_star_level(::google::protobuf::uint32 value) {
  set_has_star_level();
  star_level_ = value;
}

// optional uint32 start_time = 4;
inline bool interior_info::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void interior_info::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void interior_info::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void interior_info::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 interior_info::start_time() const {
  return start_time_;
}
inline void interior_info::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 span_time = 5;
inline bool interior_info::has_span_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void interior_info::set_has_span_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void interior_info::clear_has_span_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void interior_info::clear_span_time() {
  span_time_ = 0u;
  clear_has_span_time();
}
inline ::google::protobuf::uint32 interior_info::span_time() const {
  return span_time_;
}
inline void interior_info::set_span_time(::google::protobuf::uint32 value) {
  set_has_span_time();
  span_time_ = value;
}

// optional uint32 last_reward_time = 6;
inline bool interior_info::has_last_reward_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void interior_info::set_has_last_reward_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void interior_info::clear_has_last_reward_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void interior_info::clear_last_reward_time() {
  last_reward_time_ = 0u;
  clear_has_last_reward_time();
}
inline ::google::protobuf::uint32 interior_info::last_reward_time() const {
  return last_reward_time_;
}
inline void interior_info::set_last_reward_time(::google::protobuf::uint32 value) {
  set_has_last_reward_time();
  last_reward_time_ = value;
}

// repeated uint32 hero_id_list = 7;
inline int interior_info::hero_id_list_size() const {
  return hero_id_list_.size();
}
inline void interior_info::clear_hero_id_list() {
  hero_id_list_.Clear();
}
inline ::google::protobuf::uint32 interior_info::hero_id_list(int index) const {
  return hero_id_list_.Get(index);
}
inline void interior_info::set_hero_id_list(int index, ::google::protobuf::uint32 value) {
  hero_id_list_.Set(index, value);
}
inline void interior_info::add_hero_id_list(::google::protobuf::uint32 value) {
  hero_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
interior_info::hero_id_list() const {
  return hero_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
interior_info::mutable_hero_id_list() {
  return &hero_id_list_;
}

// optional uint32 left_times = 8;
inline bool interior_info::has_left_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void interior_info::set_has_left_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void interior_info::clear_has_left_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void interior_info::clear_left_times() {
  left_times_ = 0u;
  clear_has_left_times();
}
inline ::google::protobuf::uint32 interior_info::left_times() const {
  return left_times_;
}
inline void interior_info::set_left_times(::google::protobuf::uint32 value) {
  set_has_left_times();
  left_times_ = value;
}

// optional uint32 is_start = 9;
inline bool interior_info::has_is_start() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void interior_info::set_has_is_start() {
  _has_bits_[0] |= 0x00000100u;
}
inline void interior_info::clear_has_is_start() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void interior_info::clear_is_start() {
  is_start_ = 0u;
  clear_has_is_start();
}
inline ::google::protobuf::uint32 interior_info::is_start() const {
  return is_start_;
}
inline void interior_info::set_is_start(::google::protobuf::uint32 value) {
  set_has_is_start();
  is_start_ = value;
}

// optional uint32 copper_left_time = 10;
inline bool interior_info::has_copper_left_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void interior_info::set_has_copper_left_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void interior_info::clear_has_copper_left_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void interior_info::clear_copper_left_time() {
  copper_left_time_ = 0u;
  clear_has_copper_left_time();
}
inline ::google::protobuf::uint32 interior_info::copper_left_time() const {
  return copper_left_time_;
}
inline void interior_info::set_copper_left_time(::google::protobuf::uint32 value) {
  set_has_copper_left_time();
  copper_left_time_ = value;
}

// optional uint32 copper_count = 11;
inline bool interior_info::has_copper_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void interior_info::set_has_copper_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void interior_info::clear_has_copper_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void interior_info::clear_copper_count() {
  copper_count_ = 0u;
  clear_has_copper_count();
}
inline ::google::protobuf::uint32 interior_info::copper_count() const {
  return copper_count_;
}
inline void interior_info::set_copper_count(::google::protobuf::uint32 value) {
  set_has_copper_count();
  copper_count_ = value;
}

// optional uint32 task_left_time = 12;
inline bool interior_info::has_task_left_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void interior_info::set_has_task_left_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void interior_info::clear_has_task_left_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void interior_info::clear_task_left_time() {
  task_left_time_ = 0u;
  clear_has_task_left_time();
}
inline ::google::protobuf::uint32 interior_info::task_left_time() const {
  return task_left_time_;
}
inline void interior_info::set_task_left_time(::google::protobuf::uint32 value) {
  set_has_task_left_time();
  task_left_time_ = value;
}

// -------------------------------------------------------------------

// role_cross_data

// optional .proto.common.role_data rd = 1;
inline bool role_cross_data::has_rd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_cross_data::set_has_rd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_cross_data::clear_has_rd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_cross_data::clear_rd() {
  if (rd_ != NULL) rd_->::proto::common::role_data::Clear();
  clear_has_rd();
}
inline const ::proto::common::role_data& role_cross_data::rd() const {
  return rd_ != NULL ? *rd_ : *default_instance_->rd_;
}
inline ::proto::common::role_data* role_cross_data::mutable_rd() {
  set_has_rd();
  if (rd_ == NULL) rd_ = new ::proto::common::role_data;
  return rd_;
}
inline ::proto::common::role_data* role_cross_data::release_rd() {
  clear_has_rd();
  ::proto::common::role_data* temp = rd_;
  rd_ = NULL;
  return temp;
}
inline void role_cross_data::set_allocated_rd(::proto::common::role_data* rd) {
  delete rd_;
  rd_ = rd;
  if (rd) {
    set_has_rd();
  } else {
    clear_has_rd();
  }
}

// optional .proto.common.hero_data hd = 2;
inline bool role_cross_data::has_hd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_cross_data::set_has_hd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_cross_data::clear_has_hd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_cross_data::clear_hd() {
  if (hd_ != NULL) hd_->::proto::common::hero_data::Clear();
  clear_has_hd();
}
inline const ::proto::common::hero_data& role_cross_data::hd() const {
  return hd_ != NULL ? *hd_ : *default_instance_->hd_;
}
inline ::proto::common::hero_data* role_cross_data::mutable_hd() {
  set_has_hd();
  if (hd_ == NULL) hd_ = new ::proto::common::hero_data;
  return hd_;
}
inline ::proto::common::hero_data* role_cross_data::release_hd() {
  clear_has_hd();
  ::proto::common::hero_data* temp = hd_;
  hd_ = NULL;
  return temp;
}
inline void role_cross_data::set_allocated_hd(::proto::common::hero_data* hd) {
  delete hd_;
  hd_ = hd;
  if (hd) {
    set_has_hd();
  } else {
    clear_has_hd();
  }
}

// optional .proto.common.item_data item_data = 3;
inline bool role_cross_data::has_item_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_cross_data::set_has_item_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_cross_data::clear_has_item_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_cross_data::clear_item_data() {
  if (item_data_ != NULL) item_data_->::proto::common::item_data::Clear();
  clear_has_item_data();
}
inline const ::proto::common::item_data& role_cross_data::item_data() const {
  return item_data_ != NULL ? *item_data_ : *default_instance_->item_data_;
}
inline ::proto::common::item_data* role_cross_data::mutable_item_data() {
  set_has_item_data();
  if (item_data_ == NULL) item_data_ = new ::proto::common::item_data;
  return item_data_;
}
inline ::proto::common::item_data* role_cross_data::release_item_data() {
  clear_has_item_data();
  ::proto::common::item_data* temp = item_data_;
  item_data_ = NULL;
  return temp;
}
inline void role_cross_data::set_allocated_item_data(::proto::common::item_data* item_data) {
  delete item_data_;
  item_data_ = item_data;
  if (item_data) {
    set_has_item_data();
  } else {
    clear_has_item_data();
  }
}

// -------------------------------------------------------------------

// mirror_fight_data

// optional .proto.common.obj_single obj = 1;
inline bool mirror_fight_data::has_obj() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mirror_fight_data::set_has_obj() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mirror_fight_data::clear_has_obj() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mirror_fight_data::clear_obj() {
  if (obj_ != NULL) obj_->::proto::common::obj_single::Clear();
  clear_has_obj();
}
inline const ::proto::common::obj_single& mirror_fight_data::obj() const {
  return obj_ != NULL ? *obj_ : *default_instance_->obj_;
}
inline ::proto::common::obj_single* mirror_fight_data::mutable_obj() {
  set_has_obj();
  if (obj_ == NULL) obj_ = new ::proto::common::obj_single;
  return obj_;
}
inline ::proto::common::obj_single* mirror_fight_data::release_obj() {
  clear_has_obj();
  ::proto::common::obj_single* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void mirror_fight_data::set_allocated_obj(::proto::common::obj_single* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    set_has_obj();
  } else {
    clear_has_obj();
  }
}

// optional .proto.common.hero_data heros = 2;
inline bool mirror_fight_data::has_heros() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mirror_fight_data::set_has_heros() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mirror_fight_data::clear_has_heros() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mirror_fight_data::clear_heros() {
  if (heros_ != NULL) heros_->::proto::common::hero_data::Clear();
  clear_has_heros();
}
inline const ::proto::common::hero_data& mirror_fight_data::heros() const {
  return heros_ != NULL ? *heros_ : *default_instance_->heros_;
}
inline ::proto::common::hero_data* mirror_fight_data::mutable_heros() {
  set_has_heros();
  if (heros_ == NULL) heros_ = new ::proto::common::hero_data;
  return heros_;
}
inline ::proto::common::hero_data* mirror_fight_data::release_heros() {
  clear_has_heros();
  ::proto::common::hero_data* temp = heros_;
  heros_ = NULL;
  return temp;
}
inline void mirror_fight_data::set_allocated_heros(::proto::common::hero_data* heros) {
  delete heros_;
  heros_ = heros;
  if (heros) {
    set_has_heros();
  } else {
    clear_has_heros();
  }
}

// optional uint32 formation_id = 3;
inline bool mirror_fight_data::has_formation_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mirror_fight_data::set_has_formation_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mirror_fight_data::clear_has_formation_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mirror_fight_data::clear_formation_id() {
  formation_id_ = 0u;
  clear_has_formation_id();
}
inline ::google::protobuf::uint32 mirror_fight_data::formation_id() const {
  return formation_id_;
}
inline void mirror_fight_data::set_formation_id(::google::protobuf::uint32 value) {
  set_has_formation_id();
  formation_id_ = value;
}

// -------------------------------------------------------------------

// attr_single

// optional uint32 type = 1;
inline bool attr_single::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void attr_single::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void attr_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void attr_single::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 attr_single::type() const {
  return type_;
}
inline void attr_single::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 value = 2;
inline bool attr_single::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void attr_single::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void attr_single::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void attr_single::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 attr_single::value() const {
  return value_;
}
inline void attr_single::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// attr_data

// repeated .proto.common.attr_single attrs = 1;
inline int attr_data::attrs_size() const {
  return attrs_.size();
}
inline void attr_data::clear_attrs() {
  attrs_.Clear();
}
inline const ::proto::common::attr_single& attr_data::attrs(int index) const {
  return attrs_.Get(index);
}
inline ::proto::common::attr_single* attr_data::mutable_attrs(int index) {
  return attrs_.Mutable(index);
}
inline ::proto::common::attr_single* attr_data::add_attrs() {
  return attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::attr_single >&
attr_data::attrs() const {
  return attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::attr_single >*
attr_data::mutable_attrs() {
  return &attrs_;
}

// -------------------------------------------------------------------

// hero_state

// optional string hero_uid = 1;
inline bool hero_state::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_state::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_state::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_state::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& hero_state::hero_uid() const {
  return *hero_uid_;
}
inline void hero_state::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void hero_state::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void hero_state::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_state::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* hero_state::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_state::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pos = 2;
inline bool hero_state::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_state::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_state::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_state::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 hero_state::pos() const {
  return pos_;
}
inline void hero_state::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional uint32 hp = 3;
inline bool hero_state::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_state::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_state::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_state::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 hero_state::hp() const {
  return hp_;
}
inline void hero_state::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// hero_state_data

// repeated .proto.common.hero_state states = 1;
inline int hero_state_data::states_size() const {
  return states_.size();
}
inline void hero_state_data::clear_states() {
  states_.Clear();
}
inline const ::proto::common::hero_state& hero_state_data::states(int index) const {
  return states_.Get(index);
}
inline ::proto::common::hero_state* hero_state_data::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::proto::common::hero_state* hero_state_data::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_state >&
hero_state_data::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_state >*
hero_state_data::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// fight_attr

// optional .proto.common.attr_data attr = 1;
inline bool fight_attr::has_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_attr::set_has_attr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_attr::clear_has_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_attr::clear_attr() {
  if (attr_ != NULL) attr_->::proto::common::attr_data::Clear();
  clear_has_attr();
}
inline const ::proto::common::attr_data& fight_attr::attr() const {
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
}
inline ::proto::common::attr_data* fight_attr::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::proto::common::attr_data;
  return attr_;
}
inline ::proto::common::attr_data* fight_attr::release_attr() {
  clear_has_attr();
  ::proto::common::attr_data* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_attr(::proto::common::attr_data* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
}

// optional uint32 fighting = 2;
inline bool fight_attr::has_fighting() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_attr::set_has_fighting() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_attr::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_attr::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 fight_attr::fighting() const {
  return fighting_;
}
inline void fight_attr::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional string master = 3;
inline bool fight_attr::has_master() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_attr::set_has_master() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_attr::clear_has_master() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_attr::clear_master() {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    master_->clear();
  }
  clear_has_master();
}
inline const ::std::string& fight_attr::master() const {
  return *master_;
}
inline void fight_attr::set_master(const ::std::string& value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void fight_attr::set_master(const char* value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void fight_attr::set_master(const char* value, size_t size) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_attr::mutable_master() {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  return master_;
}
inline ::std::string* fight_attr::release_master() {
  clear_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_;
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_attr::set_allocated_master(::std::string* master) {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    delete master_;
  }
  if (master) {
    set_has_master();
    master_ = master;
  } else {
    clear_has_master();
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 pos = 4;
inline bool fight_attr::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_attr::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_attr::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_attr::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 fight_attr::pos() const {
  return pos_;
}
inline void fight_attr::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional uint32 camp = 5;
inline bool fight_attr::has_camp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_attr::set_has_camp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_attr::clear_has_camp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_attr::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 fight_attr::camp() const {
  return camp_;
}
inline void fight_attr::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
}

// optional .proto.common.hero_state start = 6;
inline bool fight_attr::has_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fight_attr::set_has_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fight_attr::clear_has_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fight_attr::clear_start() {
  if (start_ != NULL) start_->::proto::common::hero_state::Clear();
  clear_has_start();
}
inline const ::proto::common::hero_state& fight_attr::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::proto::common::hero_state* fight_attr::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::proto::common::hero_state;
  return start_;
}
inline ::proto::common::hero_state* fight_attr::release_start() {
  clear_has_start();
  ::proto::common::hero_state* temp = start_;
  start_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_start(::proto::common::hero_state* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional .proto.common.hero_state update = 7;
inline bool fight_attr::has_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fight_attr::set_has_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fight_attr::clear_has_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fight_attr::clear_update() {
  if (update_ != NULL) update_->::proto::common::hero_state::Clear();
  clear_has_update();
}
inline const ::proto::common::hero_state& fight_attr::update() const {
  return update_ != NULL ? *update_ : *default_instance_->update_;
}
inline ::proto::common::hero_state* fight_attr::mutable_update() {
  set_has_update();
  if (update_ == NULL) update_ = new ::proto::common::hero_state;
  return update_;
}
inline ::proto::common::hero_state* fight_attr::release_update() {
  clear_has_update();
  ::proto::common::hero_state* temp = update_;
  update_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_update(::proto::common::hero_state* update) {
  delete update_;
  update_ = update;
  if (update) {
    set_has_update();
  } else {
    clear_has_update();
  }
}

// optional .proto.common.attr_data next_level = 8;
inline bool fight_attr::has_next_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void fight_attr::set_has_next_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void fight_attr::clear_has_next_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void fight_attr::clear_next_level() {
  if (next_level_ != NULL) next_level_->::proto::common::attr_data::Clear();
  clear_has_next_level();
}
inline const ::proto::common::attr_data& fight_attr::next_level() const {
  return next_level_ != NULL ? *next_level_ : *default_instance_->next_level_;
}
inline ::proto::common::attr_data* fight_attr::mutable_next_level() {
  set_has_next_level();
  if (next_level_ == NULL) next_level_ = new ::proto::common::attr_data;
  return next_level_;
}
inline ::proto::common::attr_data* fight_attr::release_next_level() {
  clear_has_next_level();
  ::proto::common::attr_data* temp = next_level_;
  next_level_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_next_level(::proto::common::attr_data* next_level) {
  delete next_level_;
  next_level_ = next_level;
  if (next_level) {
    set_has_next_level();
  } else {
    clear_has_next_level();
  }
}

// optional .proto.common.attr_data next_grade = 9;
inline bool fight_attr::has_next_grade() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void fight_attr::set_has_next_grade() {
  _has_bits_[0] |= 0x00000100u;
}
inline void fight_attr::clear_has_next_grade() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void fight_attr::clear_next_grade() {
  if (next_grade_ != NULL) next_grade_->::proto::common::attr_data::Clear();
  clear_has_next_grade();
}
inline const ::proto::common::attr_data& fight_attr::next_grade() const {
  return next_grade_ != NULL ? *next_grade_ : *default_instance_->next_grade_;
}
inline ::proto::common::attr_data* fight_attr::mutable_next_grade() {
  set_has_next_grade();
  if (next_grade_ == NULL) next_grade_ = new ::proto::common::attr_data;
  return next_grade_;
}
inline ::proto::common::attr_data* fight_attr::release_next_grade() {
  clear_has_next_grade();
  ::proto::common::attr_data* temp = next_grade_;
  next_grade_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_next_grade(::proto::common::attr_data* next_grade) {
  delete next_grade_;
  next_grade_ = next_grade;
  if (next_grade) {
    set_has_next_grade();
  } else {
    clear_has_next_grade();
  }
}

// optional .proto.common.attr_data next_star = 10;
inline bool fight_attr::has_next_star() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void fight_attr::set_has_next_star() {
  _has_bits_[0] |= 0x00000200u;
}
inline void fight_attr::clear_has_next_star() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void fight_attr::clear_next_star() {
  if (next_star_ != NULL) next_star_->::proto::common::attr_data::Clear();
  clear_has_next_star();
}
inline const ::proto::common::attr_data& fight_attr::next_star() const {
  return next_star_ != NULL ? *next_star_ : *default_instance_->next_star_;
}
inline ::proto::common::attr_data* fight_attr::mutable_next_star() {
  set_has_next_star();
  if (next_star_ == NULL) next_star_ = new ::proto::common::attr_data;
  return next_star_;
}
inline ::proto::common::attr_data* fight_attr::release_next_star() {
  clear_has_next_star();
  ::proto::common::attr_data* temp = next_star_;
  next_star_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_next_star(::proto::common::attr_data* next_star) {
  delete next_star_;
  next_star_ = next_star;
  if (next_star) {
    set_has_next_star();
  } else {
    clear_has_next_star();
  }
}

// optional .proto.common.attr_data wakeup = 11;
inline bool fight_attr::has_wakeup() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void fight_attr::set_has_wakeup() {
  _has_bits_[0] |= 0x00000400u;
}
inline void fight_attr::clear_has_wakeup() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void fight_attr::clear_wakeup() {
  if (wakeup_ != NULL) wakeup_->::proto::common::attr_data::Clear();
  clear_has_wakeup();
}
inline const ::proto::common::attr_data& fight_attr::wakeup() const {
  return wakeup_ != NULL ? *wakeup_ : *default_instance_->wakeup_;
}
inline ::proto::common::attr_data* fight_attr::mutable_wakeup() {
  set_has_wakeup();
  if (wakeup_ == NULL) wakeup_ = new ::proto::common::attr_data;
  return wakeup_;
}
inline ::proto::common::attr_data* fight_attr::release_wakeup() {
  clear_has_wakeup();
  ::proto::common::attr_data* temp = wakeup_;
  wakeup_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_wakeup(::proto::common::attr_data* wakeup) {
  delete wakeup_;
  wakeup_ = wakeup;
  if (wakeup) {
    set_has_wakeup();
  } else {
    clear_has_wakeup();
  }
}

// optional .proto.common.attr_data base_attr = 12;
inline bool fight_attr::has_base_attr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void fight_attr::set_has_base_attr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void fight_attr::clear_has_base_attr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void fight_attr::clear_base_attr() {
  if (base_attr_ != NULL) base_attr_->::proto::common::attr_data::Clear();
  clear_has_base_attr();
}
inline const ::proto::common::attr_data& fight_attr::base_attr() const {
  return base_attr_ != NULL ? *base_attr_ : *default_instance_->base_attr_;
}
inline ::proto::common::attr_data* fight_attr::mutable_base_attr() {
  set_has_base_attr();
  if (base_attr_ == NULL) base_attr_ = new ::proto::common::attr_data;
  return base_attr_;
}
inline ::proto::common::attr_data* fight_attr::release_base_attr() {
  clear_has_base_attr();
  ::proto::common::attr_data* temp = base_attr_;
  base_attr_ = NULL;
  return temp;
}
inline void fight_attr::set_allocated_base_attr(::proto::common::attr_data* base_attr) {
  delete base_attr_;
  base_attr_ = base_attr;
  if (base_attr) {
    set_has_base_attr();
  } else {
    clear_has_base_attr();
  }
}

// optional uint32 wave_num = 13;
inline bool fight_attr::has_wave_num() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void fight_attr::set_has_wave_num() {
  _has_bits_[0] |= 0x00001000u;
}
inline void fight_attr::clear_has_wave_num() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void fight_attr::clear_wave_num() {
  wave_num_ = 0u;
  clear_has_wave_num();
}
inline ::google::protobuf::uint32 fight_attr::wave_num() const {
  return wave_num_;
}
inline void fight_attr::set_wave_num(::google::protobuf::uint32 value) {
  set_has_wave_num();
  wave_num_ = value;
}

// -------------------------------------------------------------------

// hero_equip

// optional uint32 pos = 1;
inline bool hero_equip::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_equip::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_equip::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_equip::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 hero_equip::pos() const {
  return pos_;
}
inline void hero_equip::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string equip_uid = 2;
inline bool hero_equip::has_equip_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_equip::set_has_equip_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_equip::clear_has_equip_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_equip::clear_equip_uid() {
  if (equip_uid_ != &::google::protobuf::internal::kEmptyString) {
    equip_uid_->clear();
  }
  clear_has_equip_uid();
}
inline const ::std::string& hero_equip::equip_uid() const {
  return *equip_uid_;
}
inline void hero_equip::set_equip_uid(const ::std::string& value) {
  set_has_equip_uid();
  if (equip_uid_ == &::google::protobuf::internal::kEmptyString) {
    equip_uid_ = new ::std::string;
  }
  equip_uid_->assign(value);
}
inline void hero_equip::set_equip_uid(const char* value) {
  set_has_equip_uid();
  if (equip_uid_ == &::google::protobuf::internal::kEmptyString) {
    equip_uid_ = new ::std::string;
  }
  equip_uid_->assign(value);
}
inline void hero_equip::set_equip_uid(const char* value, size_t size) {
  set_has_equip_uid();
  if (equip_uid_ == &::google::protobuf::internal::kEmptyString) {
    equip_uid_ = new ::std::string;
  }
  equip_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_equip::mutable_equip_uid() {
  set_has_equip_uid();
  if (equip_uid_ == &::google::protobuf::internal::kEmptyString) {
    equip_uid_ = new ::std::string;
  }
  return equip_uid_;
}
inline ::std::string* hero_equip::release_equip_uid() {
  clear_has_equip_uid();
  if (equip_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = equip_uid_;
    equip_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_equip::set_allocated_equip_uid(::std::string* equip_uid) {
  if (equip_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete equip_uid_;
  }
  if (equip_uid) {
    set_has_equip_uid();
    equip_uid_ = equip_uid;
  } else {
    clear_has_equip_uid();
    equip_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// hero_skill_single

// optional uint32 skill_id = 1;
inline bool hero_skill_single::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_skill_single::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_skill_single::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_skill_single::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 hero_skill_single::skill_id() const {
  return skill_id_;
}
inline void hero_skill_single::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 skill_level = 2;
inline bool hero_skill_single::has_skill_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_skill_single::set_has_skill_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_skill_single::clear_has_skill_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_skill_single::clear_skill_level() {
  skill_level_ = 0u;
  clear_has_skill_level();
}
inline ::google::protobuf::uint32 hero_skill_single::skill_level() const {
  return skill_level_;
}
inline void hero_skill_single::set_skill_level(::google::protobuf::uint32 value) {
  set_has_skill_level();
  skill_level_ = value;
}

// optional uint32 skill_pos = 3;
inline bool hero_skill_single::has_skill_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_skill_single::set_has_skill_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_skill_single::clear_has_skill_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_skill_single::clear_skill_pos() {
  skill_pos_ = 0u;
  clear_has_skill_pos();
}
inline ::google::protobuf::uint32 hero_skill_single::skill_pos() const {
  return skill_pos_;
}
inline void hero_skill_single::set_skill_pos(::google::protobuf::uint32 value) {
  set_has_skill_pos();
  skill_pos_ = value;
}

// optional uint32 skill_index = 4;
inline bool hero_skill_single::has_skill_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero_skill_single::set_has_skill_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero_skill_single::clear_has_skill_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero_skill_single::clear_skill_index() {
  skill_index_ = 0u;
  clear_has_skill_index();
}
inline ::google::protobuf::uint32 hero_skill_single::skill_index() const {
  return skill_index_;
}
inline void hero_skill_single::set_skill_index(::google::protobuf::uint32 value) {
  set_has_skill_index();
  skill_index_ = value;
}

// -------------------------------------------------------------------

// hero_skill_data

// repeated .proto.common.hero_skill_single skill_list = 1;
inline int hero_skill_data::skill_list_size() const {
  return skill_list_.size();
}
inline void hero_skill_data::clear_skill_list() {
  skill_list_.Clear();
}
inline const ::proto::common::hero_skill_single& hero_skill_data::skill_list(int index) const {
  return skill_list_.Get(index);
}
inline ::proto::common::hero_skill_single* hero_skill_data::mutable_skill_list(int index) {
  return skill_list_.Mutable(index);
}
inline ::proto::common::hero_skill_single* hero_skill_data::add_skill_list() {
  return skill_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_skill_single >&
hero_skill_data::skill_list() const {
  return skill_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_skill_single >*
hero_skill_data::mutable_skill_list() {
  return &skill_list_;
}

// -------------------------------------------------------------------

// base_attr

// optional uint32 type = 1;
inline bool base_attr::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void base_attr::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void base_attr::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void base_attr::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 base_attr::type() const {
  return type_;
}
inline void base_attr::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool base_attr::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void base_attr::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void base_attr::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void base_attr::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 base_attr::id() const {
  return id_;
}
inline void base_attr::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool base_attr::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void base_attr::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void base_attr::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void base_attr::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& base_attr::name() const {
  return *name_;
}
inline void base_attr::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void base_attr::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void base_attr::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* base_attr::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 4;
inline bool base_attr::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void base_attr::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void base_attr::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void base_attr::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 base_attr::level() const {
  return level_;
}
inline void base_attr::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 exp = 5;
inline bool base_attr::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void base_attr::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void base_attr::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void base_attr::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 base_attr::exp() const {
  return exp_;
}
inline void base_attr::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 species = 6;
inline bool base_attr::has_species() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void base_attr::set_has_species() {
  _has_bits_[0] |= 0x00000020u;
}
inline void base_attr::clear_has_species() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void base_attr::clear_species() {
  species_ = 0u;
  clear_has_species();
}
inline ::google::protobuf::uint32 base_attr::species() const {
  return species_;
}
inline void base_attr::set_species(::google::protobuf::uint32 value) {
  set_has_species();
  species_ = value;
}

// optional uint32 quality = 7;
inline bool base_attr::has_quality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void base_attr::set_has_quality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void base_attr::clear_has_quality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void base_attr::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 base_attr::quality() const {
  return quality_;
}
inline void base_attr::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
}

// optional uint32 in_form = 8;
inline bool base_attr::has_in_form() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void base_attr::set_has_in_form() {
  _has_bits_[0] |= 0x00000080u;
}
inline void base_attr::clear_has_in_form() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void base_attr::clear_in_form() {
  in_form_ = 0u;
  clear_has_in_form();
}
inline ::google::protobuf::uint32 base_attr::in_form() const {
  return in_form_;
}
inline void base_attr::set_in_form(::google::protobuf::uint32 value) {
  set_has_in_form();
  in_form_ = value;
}

// repeated .proto.common.hero_equip equips = 9;
inline int base_attr::equips_size() const {
  return equips_.size();
}
inline void base_attr::clear_equips() {
  equips_.Clear();
}
inline const ::proto::common::hero_equip& base_attr::equips(int index) const {
  return equips_.Get(index);
}
inline ::proto::common::hero_equip* base_attr::mutable_equips(int index) {
  return equips_.Mutable(index);
}
inline ::proto::common::hero_equip* base_attr::add_equips() {
  return equips_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_equip >&
base_attr::equips() const {
  return equips_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_equip >*
base_attr::mutable_equips() {
  return &equips_;
}

// optional uint32 country = 10;
inline bool base_attr::has_country() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void base_attr::set_has_country() {
  _has_bits_[0] |= 0x00000200u;
}
inline void base_attr::clear_has_country() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void base_attr::clear_country() {
  country_ = 0u;
  clear_has_country();
}
inline ::google::protobuf::uint32 base_attr::country() const {
  return country_;
}
inline void base_attr::set_country(::google::protobuf::uint32 value) {
  set_has_country();
  country_ = value;
}

// optional uint32 grade = 11;
inline bool base_attr::has_grade() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void base_attr::set_has_grade() {
  _has_bits_[0] |= 0x00000400u;
}
inline void base_attr::clear_has_grade() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void base_attr::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 base_attr::grade() const {
  return grade_;
}
inline void base_attr::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// optional uint32 talent_level = 12;
inline bool base_attr::has_talent_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void base_attr::set_has_talent_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void base_attr::clear_has_talent_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void base_attr::clear_talent_level() {
  talent_level_ = 0u;
  clear_has_talent_level();
}
inline ::google::protobuf::uint32 base_attr::talent_level() const {
  return talent_level_;
}
inline void base_attr::set_talent_level(::google::protobuf::uint32 value) {
  set_has_talent_level();
  talent_level_ = value;
}

// optional string unique_id = 13;
inline bool base_attr::has_unique_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void base_attr::set_has_unique_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void base_attr::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void base_attr::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& base_attr::unique_id() const {
  return *unique_id_;
}
inline void base_attr::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void base_attr::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void base_attr::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* base_attr::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unique_id_;
  }
  if (unique_id) {
    set_has_unique_id();
    unique_id_ = unique_id;
  } else {
    clear_has_unique_id();
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 star = 14;
inline bool base_attr::has_star() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void base_attr::set_has_star() {
  _has_bits_[0] |= 0x00002000u;
}
inline void base_attr::clear_has_star() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void base_attr::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 base_attr::star() const {
  return star_;
}
inline void base_attr::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// optional uint32 degree = 15;
inline bool base_attr::has_degree() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void base_attr::set_has_degree() {
  _has_bits_[0] |= 0x00004000u;
}
inline void base_attr::clear_has_degree() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void base_attr::clear_degree() {
  degree_ = 0u;
  clear_has_degree();
}
inline ::google::protobuf::uint32 base_attr::degree() const {
  return degree_;
}
inline void base_attr::set_degree(::google::protobuf::uint32 value) {
  set_has_degree();
  degree_ = value;
}

// optional uint32 talent_count = 16;
inline bool base_attr::has_talent_count() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void base_attr::set_has_talent_count() {
  _has_bits_[0] |= 0x00008000u;
}
inline void base_attr::clear_has_talent_count() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void base_attr::clear_talent_count() {
  talent_count_ = 0u;
  clear_has_talent_count();
}
inline ::google::protobuf::uint32 base_attr::talent_count() const {
  return talent_count_;
}
inline void base_attr::set_talent_count(::google::protobuf::uint32 value) {
  set_has_talent_count();
  talent_count_ = value;
}

// optional uint32 talent_degree = 17;
inline bool base_attr::has_talent_degree() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void base_attr::set_has_talent_degree() {
  _has_bits_[0] |= 0x00010000u;
}
inline void base_attr::clear_has_talent_degree() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void base_attr::clear_talent_degree() {
  talent_degree_ = 0u;
  clear_has_talent_degree();
}
inline ::google::protobuf::uint32 base_attr::talent_degree() const {
  return talent_degree_;
}
inline void base_attr::set_talent_degree(::google::protobuf::uint32 value) {
  set_has_talent_degree();
  talent_degree_ = value;
}

// repeated uint32 famous = 18;
inline int base_attr::famous_size() const {
  return famous_.size();
}
inline void base_attr::clear_famous() {
  famous_.Clear();
}
inline ::google::protobuf::uint32 base_attr::famous(int index) const {
  return famous_.Get(index);
}
inline void base_attr::set_famous(int index, ::google::protobuf::uint32 value) {
  famous_.Set(index, value);
}
inline void base_attr::add_famous(::google::protobuf::uint32 value) {
  famous_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
base_attr::famous() const {
  return famous_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
base_attr::mutable_famous() {
  return &famous_;
}

// optional uint32 exp_today = 20;
inline bool base_attr::has_exp_today() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void base_attr::set_has_exp_today() {
  _has_bits_[0] |= 0x00040000u;
}
inline void base_attr::clear_has_exp_today() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void base_attr::clear_exp_today() {
  exp_today_ = 0u;
  clear_has_exp_today();
}
inline ::google::protobuf::uint32 base_attr::exp_today() const {
  return exp_today_;
}
inline void base_attr::set_exp_today(::google::protobuf::uint32 value) {
  set_has_exp_today();
  exp_today_ = value;
}

// optional uint32 talent_use = 21;
inline bool base_attr::has_talent_use() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void base_attr::set_has_talent_use() {
  _has_bits_[0] |= 0x00080000u;
}
inline void base_attr::clear_has_talent_use() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void base_attr::clear_talent_use() {
  talent_use_ = 0u;
  clear_has_talent_use();
}
inline ::google::protobuf::uint32 base_attr::talent_use() const {
  return talent_use_;
}
inline void base_attr::set_talent_use(::google::protobuf::uint32 value) {
  set_has_talent_use();
  talent_use_ = value;
}

// optional .proto.common.hero_skill_data skill_data = 22;
inline bool base_attr::has_skill_data() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void base_attr::set_has_skill_data() {
  _has_bits_[0] |= 0x00100000u;
}
inline void base_attr::clear_has_skill_data() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void base_attr::clear_skill_data() {
  if (skill_data_ != NULL) skill_data_->::proto::common::hero_skill_data::Clear();
  clear_has_skill_data();
}
inline const ::proto::common::hero_skill_data& base_attr::skill_data() const {
  return skill_data_ != NULL ? *skill_data_ : *default_instance_->skill_data_;
}
inline ::proto::common::hero_skill_data* base_attr::mutable_skill_data() {
  set_has_skill_data();
  if (skill_data_ == NULL) skill_data_ = new ::proto::common::hero_skill_data;
  return skill_data_;
}
inline ::proto::common::hero_skill_data* base_attr::release_skill_data() {
  clear_has_skill_data();
  ::proto::common::hero_skill_data* temp = skill_data_;
  skill_data_ = NULL;
  return temp;
}
inline void base_attr::set_allocated_skill_data(::proto::common::hero_skill_data* skill_data) {
  delete skill_data_;
  skill_data_ = skill_data;
  if (skill_data) {
    set_has_skill_data();
  } else {
    clear_has_skill_data();
  }
}

// optional string last_equip_plan = 23;
inline bool base_attr::has_last_equip_plan() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void base_attr::set_has_last_equip_plan() {
  _has_bits_[0] |= 0x00200000u;
}
inline void base_attr::clear_has_last_equip_plan() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void base_attr::clear_last_equip_plan() {
  if (last_equip_plan_ != &::google::protobuf::internal::kEmptyString) {
    last_equip_plan_->clear();
  }
  clear_has_last_equip_plan();
}
inline const ::std::string& base_attr::last_equip_plan() const {
  return *last_equip_plan_;
}
inline void base_attr::set_last_equip_plan(const ::std::string& value) {
  set_has_last_equip_plan();
  if (last_equip_plan_ == &::google::protobuf::internal::kEmptyString) {
    last_equip_plan_ = new ::std::string;
  }
  last_equip_plan_->assign(value);
}
inline void base_attr::set_last_equip_plan(const char* value) {
  set_has_last_equip_plan();
  if (last_equip_plan_ == &::google::protobuf::internal::kEmptyString) {
    last_equip_plan_ = new ::std::string;
  }
  last_equip_plan_->assign(value);
}
inline void base_attr::set_last_equip_plan(const char* value, size_t size) {
  set_has_last_equip_plan();
  if (last_equip_plan_ == &::google::protobuf::internal::kEmptyString) {
    last_equip_plan_ = new ::std::string;
  }
  last_equip_plan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_last_equip_plan() {
  set_has_last_equip_plan();
  if (last_equip_plan_ == &::google::protobuf::internal::kEmptyString) {
    last_equip_plan_ = new ::std::string;
  }
  return last_equip_plan_;
}
inline ::std::string* base_attr::release_last_equip_plan() {
  clear_has_last_equip_plan();
  if (last_equip_plan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_equip_plan_;
    last_equip_plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_last_equip_plan(::std::string* last_equip_plan) {
  if (last_equip_plan_ != &::google::protobuf::internal::kEmptyString) {
    delete last_equip_plan_;
  }
  if (last_equip_plan) {
    set_has_last_equip_plan();
    last_equip_plan_ = last_equip_plan;
  } else {
    clear_has_last_equip_plan();
    last_equip_plan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 active_talent_use = 24;
inline bool base_attr::has_active_talent_use() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void base_attr::set_has_active_talent_use() {
  _has_bits_[0] |= 0x00400000u;
}
inline void base_attr::clear_has_active_talent_use() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void base_attr::clear_active_talent_use() {
  active_talent_use_ = 0u;
  clear_has_active_talent_use();
}
inline ::google::protobuf::uint32 base_attr::active_talent_use() const {
  return active_talent_use_;
}
inline void base_attr::set_active_talent_use(::google::protobuf::uint32 value) {
  set_has_active_talent_use();
  active_talent_use_ = value;
}

// repeated uint32 plugins = 25;
inline int base_attr::plugins_size() const {
  return plugins_.size();
}
inline void base_attr::clear_plugins() {
  plugins_.Clear();
}
inline ::google::protobuf::uint32 base_attr::plugins(int index) const {
  return plugins_.Get(index);
}
inline void base_attr::set_plugins(int index, ::google::protobuf::uint32 value) {
  plugins_.Set(index, value);
}
inline void base_attr::add_plugins(::google::protobuf::uint32 value) {
  plugins_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
base_attr::plugins() const {
  return plugins_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
base_attr::mutable_plugins() {
  return &plugins_;
}

// optional uint32 current_plugin = 26;
inline bool base_attr::has_current_plugin() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void base_attr::set_has_current_plugin() {
  _has_bits_[0] |= 0x01000000u;
}
inline void base_attr::clear_has_current_plugin() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void base_attr::clear_current_plugin() {
  current_plugin_ = 0u;
  clear_has_current_plugin();
}
inline ::google::protobuf::uint32 base_attr::current_plugin() const {
  return current_plugin_;
}
inline void base_attr::set_current_plugin(::google::protobuf::uint32 value) {
  set_has_current_plugin();
  current_plugin_ = value;
}

// optional string fight_hero_uid = 27;
inline bool base_attr::has_fight_hero_uid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void base_attr::set_has_fight_hero_uid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void base_attr::clear_has_fight_hero_uid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void base_attr::clear_fight_hero_uid() {
  if (fight_hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    fight_hero_uid_->clear();
  }
  clear_has_fight_hero_uid();
}
inline const ::std::string& base_attr::fight_hero_uid() const {
  return *fight_hero_uid_;
}
inline void base_attr::set_fight_hero_uid(const ::std::string& value) {
  set_has_fight_hero_uid();
  if (fight_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_hero_uid_ = new ::std::string;
  }
  fight_hero_uid_->assign(value);
}
inline void base_attr::set_fight_hero_uid(const char* value) {
  set_has_fight_hero_uid();
  if (fight_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_hero_uid_ = new ::std::string;
  }
  fight_hero_uid_->assign(value);
}
inline void base_attr::set_fight_hero_uid(const char* value, size_t size) {
  set_has_fight_hero_uid();
  if (fight_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_hero_uid_ = new ::std::string;
  }
  fight_hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_fight_hero_uid() {
  set_has_fight_hero_uid();
  if (fight_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_hero_uid_ = new ::std::string;
  }
  return fight_hero_uid_;
}
inline ::std::string* base_attr::release_fight_hero_uid() {
  clear_has_fight_hero_uid();
  if (fight_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_hero_uid_;
    fight_hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_fight_hero_uid(::std::string* fight_hero_uid) {
  if (fight_hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_hero_uid_;
  }
  if (fight_hero_uid) {
    set_has_fight_hero_uid();
    fight_hero_uid_ = fight_hero_uid;
  } else {
    clear_has_fight_hero_uid();
    fight_hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick_name = 28;
inline bool base_attr::has_nick_name() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void base_attr::set_has_nick_name() {
  _has_bits_[0] |= 0x04000000u;
}
inline void base_attr::clear_has_nick_name() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void base_attr::clear_nick_name() {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    nick_name_->clear();
  }
  clear_has_nick_name();
}
inline const ::std::string& base_attr::nick_name() const {
  return *nick_name_;
}
inline void base_attr::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void base_attr::set_nick_name(const char* value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void base_attr::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_nick_name() {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  return nick_name_;
}
inline ::std::string* base_attr::release_nick_name() {
  clear_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_name_;
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_nick_name(::std::string* nick_name) {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_name_;
  }
  if (nick_name) {
    set_has_nick_name();
    nick_name_ = nick_name;
  } else {
    clear_has_nick_name();
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 wakeup = 29;
inline bool base_attr::has_wakeup() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void base_attr::set_has_wakeup() {
  _has_bits_[0] |= 0x08000000u;
}
inline void base_attr::clear_has_wakeup() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void base_attr::clear_wakeup() {
  wakeup_ = 0u;
  clear_has_wakeup();
}
inline ::google::protobuf::uint32 base_attr::wakeup() const {
  return wakeup_;
}
inline void base_attr::set_wakeup(::google::protobuf::uint32 value) {
  set_has_wakeup();
  wakeup_ = value;
}

// optional uint32 delete_flag = 30;
inline bool base_attr::has_delete_flag() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void base_attr::set_has_delete_flag() {
  _has_bits_[0] |= 0x10000000u;
}
inline void base_attr::clear_has_delete_flag() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void base_attr::clear_delete_flag() {
  delete_flag_ = 0u;
  clear_has_delete_flag();
}
inline ::google::protobuf::uint32 base_attr::delete_flag() const {
  return delete_flag_;
}
inline void base_attr::set_delete_flag(::google::protobuf::uint32 value) {
  set_has_delete_flag();
  delete_flag_ = value;
}

// optional uint32 terry = 31;
inline bool base_attr::has_terry() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void base_attr::set_has_terry() {
  _has_bits_[0] |= 0x20000000u;
}
inline void base_attr::clear_has_terry() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void base_attr::clear_terry() {
  terry_ = 0u;
  clear_has_terry();
}
inline ::google::protobuf::uint32 base_attr::terry() const {
  return terry_;
}
inline void base_attr::set_terry(::google::protobuf::uint32 value) {
  set_has_terry();
  terry_ = value;
}

// optional uint32 grade_id = 32;
inline bool base_attr::has_grade_id() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void base_attr::set_has_grade_id() {
  _has_bits_[0] |= 0x40000000u;
}
inline void base_attr::clear_has_grade_id() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void base_attr::clear_grade_id() {
  grade_id_ = 0u;
  clear_has_grade_id();
}
inline ::google::protobuf::uint32 base_attr::grade_id() const {
  return grade_id_;
}
inline void base_attr::set_grade_id(::google::protobuf::uint32 value) {
  set_has_grade_id();
  grade_id_ = value;
}

// optional uint32 debut = 33;
inline bool base_attr::has_debut() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void base_attr::set_has_debut() {
  _has_bits_[0] |= 0x80000000u;
}
inline void base_attr::clear_has_debut() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void base_attr::clear_debut() {
  debut_ = 0u;
  clear_has_debut();
}
inline ::google::protobuf::uint32 base_attr::debut() const {
  return debut_;
}
inline void base_attr::set_debut(::google::protobuf::uint32 value) {
  set_has_debut();
  debut_ = value;
}

// optional uint32 resource_id = 34;
inline bool base_attr::has_resource_id() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void base_attr::set_has_resource_id() {
  _has_bits_[1] |= 0x00000001u;
}
inline void base_attr::clear_has_resource_id() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void base_attr::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
inline ::google::protobuf::uint32 base_attr::resource_id() const {
  return resource_id_;
}
inline void base_attr::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
}

// optional uint32 monster_type = 35;
inline bool base_attr::has_monster_type() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void base_attr::set_has_monster_type() {
  _has_bits_[1] |= 0x00000002u;
}
inline void base_attr::clear_has_monster_type() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void base_attr::clear_monster_type() {
  monster_type_ = 0u;
  clear_has_monster_type();
}
inline ::google::protobuf::uint32 base_attr::monster_type() const {
  return monster_type_;
}
inline void base_attr::set_monster_type(::google::protobuf::uint32 value) {
  set_has_monster_type();
  monster_type_ = value;
}

// optional uint32 scale = 36;
inline bool base_attr::has_scale() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void base_attr::set_has_scale() {
  _has_bits_[1] |= 0x00000004u;
}
inline void base_attr::clear_has_scale() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void base_attr::clear_scale() {
  scale_ = 0u;
  clear_has_scale();
}
inline ::google::protobuf::uint32 base_attr::scale() const {
  return scale_;
}
inline void base_attr::set_scale(::google::protobuf::uint32 value) {
  set_has_scale();
  scale_ = value;
}

// optional string hero_name_id = 37;
inline bool base_attr::has_hero_name_id() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void base_attr::set_has_hero_name_id() {
  _has_bits_[1] |= 0x00000008u;
}
inline void base_attr::clear_has_hero_name_id() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void base_attr::clear_hero_name_id() {
  if (hero_name_id_ != &::google::protobuf::internal::kEmptyString) {
    hero_name_id_->clear();
  }
  clear_has_hero_name_id();
}
inline const ::std::string& base_attr::hero_name_id() const {
  return *hero_name_id_;
}
inline void base_attr::set_hero_name_id(const ::std::string& value) {
  set_has_hero_name_id();
  if (hero_name_id_ == &::google::protobuf::internal::kEmptyString) {
    hero_name_id_ = new ::std::string;
  }
  hero_name_id_->assign(value);
}
inline void base_attr::set_hero_name_id(const char* value) {
  set_has_hero_name_id();
  if (hero_name_id_ == &::google::protobuf::internal::kEmptyString) {
    hero_name_id_ = new ::std::string;
  }
  hero_name_id_->assign(value);
}
inline void base_attr::set_hero_name_id(const char* value, size_t size) {
  set_has_hero_name_id();
  if (hero_name_id_ == &::google::protobuf::internal::kEmptyString) {
    hero_name_id_ = new ::std::string;
  }
  hero_name_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_hero_name_id() {
  set_has_hero_name_id();
  if (hero_name_id_ == &::google::protobuf::internal::kEmptyString) {
    hero_name_id_ = new ::std::string;
  }
  return hero_name_id_;
}
inline ::std::string* base_attr::release_hero_name_id() {
  clear_has_hero_name_id();
  if (hero_name_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_name_id_;
    hero_name_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_hero_name_id(::std::string* hero_name_id) {
  if (hero_name_id_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_name_id_;
  }
  if (hero_name_id) {
    set_has_hero_name_id();
    hero_name_id_ = hero_name_id;
  } else {
    clear_has_hero_name_id();
    hero_name_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 boss_hp_plies = 38;
inline bool base_attr::has_boss_hp_plies() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void base_attr::set_has_boss_hp_plies() {
  _has_bits_[1] |= 0x00000010u;
}
inline void base_attr::clear_has_boss_hp_plies() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void base_attr::clear_boss_hp_plies() {
  boss_hp_plies_ = 0u;
  clear_has_boss_hp_plies();
}
inline ::google::protobuf::uint32 base_attr::boss_hp_plies() const {
  return boss_hp_plies_;
}
inline void base_attr::set_boss_hp_plies(::google::protobuf::uint32 value) {
  set_has_boss_hp_plies();
  boss_hp_plies_ = value;
}

// optional uint32 event_type = 39;
inline bool base_attr::has_event_type() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void base_attr::set_has_event_type() {
  _has_bits_[1] |= 0x00000020u;
}
inline void base_attr::clear_has_event_type() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void base_attr::clear_event_type() {
  event_type_ = 0u;
  clear_has_event_type();
}
inline ::google::protobuf::uint32 base_attr::event_type() const {
  return event_type_;
}
inline void base_attr::set_event_type(::google::protobuf::uint32 value) {
  set_has_event_type();
  event_type_ = value;
}

// optional string event_param = 40;
inline bool base_attr::has_event_param() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void base_attr::set_has_event_param() {
  _has_bits_[1] |= 0x00000040u;
}
inline void base_attr::clear_has_event_param() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void base_attr::clear_event_param() {
  if (event_param_ != &::google::protobuf::internal::kEmptyString) {
    event_param_->clear();
  }
  clear_has_event_param();
}
inline const ::std::string& base_attr::event_param() const {
  return *event_param_;
}
inline void base_attr::set_event_param(const ::std::string& value) {
  set_has_event_param();
  if (event_param_ == &::google::protobuf::internal::kEmptyString) {
    event_param_ = new ::std::string;
  }
  event_param_->assign(value);
}
inline void base_attr::set_event_param(const char* value) {
  set_has_event_param();
  if (event_param_ == &::google::protobuf::internal::kEmptyString) {
    event_param_ = new ::std::string;
  }
  event_param_->assign(value);
}
inline void base_attr::set_event_param(const char* value, size_t size) {
  set_has_event_param();
  if (event_param_ == &::google::protobuf::internal::kEmptyString) {
    event_param_ = new ::std::string;
  }
  event_param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* base_attr::mutable_event_param() {
  set_has_event_param();
  if (event_param_ == &::google::protobuf::internal::kEmptyString) {
    event_param_ = new ::std::string;
  }
  return event_param_;
}
inline ::std::string* base_attr::release_event_param() {
  clear_has_event_param();
  if (event_param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_param_;
    event_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void base_attr::set_allocated_event_param(::std::string* event_param) {
  if (event_param_ != &::google::protobuf::internal::kEmptyString) {
    delete event_param_;
  }
  if (event_param) {
    set_has_event_param();
    event_param_ = event_param;
  } else {
    clear_has_event_param();
    event_param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 plot_id = 41;
inline bool base_attr::has_plot_id() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void base_attr::set_has_plot_id() {
  _has_bits_[1] |= 0x00000080u;
}
inline void base_attr::clear_has_plot_id() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void base_attr::clear_plot_id() {
  plot_id_ = 0u;
  clear_has_plot_id();
}
inline ::google::protobuf::uint32 base_attr::plot_id() const {
  return plot_id_;
}
inline void base_attr::set_plot_id(::google::protobuf::uint32 value) {
  set_has_plot_id();
  plot_id_ = value;
}

// optional uint32 would_show = 42;
inline bool base_attr::has_would_show() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void base_attr::set_has_would_show() {
  _has_bits_[1] |= 0x00000100u;
}
inline void base_attr::clear_has_would_show() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void base_attr::clear_would_show() {
  would_show_ = 0u;
  clear_has_would_show();
}
inline ::google::protobuf::uint32 base_attr::would_show() const {
  return would_show_;
}
inline void base_attr::set_would_show(::google::protobuf::uint32 value) {
  set_has_would_show();
  would_show_ = value;
}

// optional uint32 hero_state = 43;
inline bool base_attr::has_hero_state() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void base_attr::set_has_hero_state() {
  _has_bits_[1] |= 0x00000200u;
}
inline void base_attr::clear_has_hero_state() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void base_attr::clear_hero_state() {
  hero_state_ = 0u;
  clear_has_hero_state();
}
inline ::google::protobuf::uint32 base_attr::hero_state() const {
  return hero_state_;
}
inline void base_attr::set_hero_state(::google::protobuf::uint32 value) {
  set_has_hero_state();
  hero_state_ = value;
}

// -------------------------------------------------------------------

// skill_single

// optional uint32 skill_id = 1;
inline bool skill_single::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skill_single::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skill_single::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skill_single::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 skill_single::skill_id() const {
  return skill_id_;
}
inline void skill_single::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 skill_level = 2;
inline bool skill_single::has_skill_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skill_single::set_has_skill_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skill_single::clear_has_skill_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skill_single::clear_skill_level() {
  skill_level_ = 0u;
  clear_has_skill_level();
}
inline ::google::protobuf::uint32 skill_single::skill_level() const {
  return skill_level_;
}
inline void skill_single::set_skill_level(::google::protobuf::uint32 value) {
  set_has_skill_level();
  skill_level_ = value;
}

// optional uint32 skill_cd = 3;
inline bool skill_single::has_skill_cd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void skill_single::set_has_skill_cd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void skill_single::clear_has_skill_cd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void skill_single::clear_skill_cd() {
  skill_cd_ = 0u;
  clear_has_skill_cd();
}
inline ::google::protobuf::uint32 skill_single::skill_cd() const {
  return skill_cd_;
}
inline void skill_single::set_skill_cd(::google::protobuf::uint32 value) {
  set_has_skill_cd();
  skill_cd_ = value;
}

// optional string hero_uid = 4;
inline bool skill_single::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void skill_single::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void skill_single::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void skill_single::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& skill_single::hero_uid() const {
  return *hero_uid_;
}
inline void skill_single::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void skill_single::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void skill_single::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* skill_single::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* skill_single::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void skill_single::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// skill_data

// repeated .proto.common.skill_single skills = 1;
inline int skill_data::skills_size() const {
  return skills_.size();
}
inline void skill_data::clear_skills() {
  skills_.Clear();
}
inline const ::proto::common::skill_single& skill_data::skills(int index) const {
  return skills_.Get(index);
}
inline ::proto::common::skill_single* skill_data::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::proto::common::skill_single* skill_data::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >&
skill_data::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >*
skill_data::mutable_skills() {
  return &skills_;
}

// -------------------------------------------------------------------

// item_data

// repeated .proto.common.item_single item_list = 1;
inline int item_data::item_list_size() const {
  return item_list_.size();
}
inline void item_data::clear_item_list() {
  item_list_.Clear();
}
inline const ::proto::common::item_single& item_data::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::proto::common::item_single* item_data::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::proto::common::item_single* item_data::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
item_data::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
item_data::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// item_single

// optional string uid = 1;
inline bool item_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void item_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void item_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void item_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& item_single::uid() const {
  return *uid_;
}
inline void item_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void item_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void item_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* item_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void item_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool item_single::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void item_single::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void item_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void item_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 item_single::tid() const {
  return tid_;
}
inline void item_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional int32 num = 3;
inline bool item_single::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void item_single::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void item_single::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void item_single::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 item_single::num() const {
  return num_;
}
inline void item_single::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 price = 4;
inline bool item_single::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void item_single::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void item_single::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void item_single::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 item_single::price() const {
  return price_;
}
inline void item_single::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
}

// optional uint32 package = 5;
inline bool item_single::has_package() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void item_single::set_has_package() {
  _has_bits_[0] |= 0x00000010u;
}
inline void item_single::clear_has_package() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void item_single::clear_package() {
  package_ = 0u;
  clear_has_package();
}
inline ::google::protobuf::uint32 item_single::package() const {
  return package_;
}
inline void item_single::set_package(::google::protobuf::uint32 value) {
  set_has_package();
  package_ = value;
}

// optional int32 up_num = 6;
inline bool item_single::has_up_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void item_single::set_has_up_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void item_single::clear_has_up_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void item_single::clear_up_num() {
  up_num_ = 0;
  clear_has_up_num();
}
inline ::google::protobuf::int32 item_single::up_num() const {
  return up_num_;
}
inline void item_single::set_up_num(::google::protobuf::int32 value) {
  set_has_up_num();
  up_num_ = value;
}

// optional uint32 pos = 7;
inline bool item_single::has_pos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void item_single::set_has_pos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void item_single::clear_has_pos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void item_single::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 item_single::pos() const {
  return pos_;
}
inline void item_single::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional uint32 param = 8;
inline bool item_single::has_param() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void item_single::set_has_param() {
  _has_bits_[0] |= 0x00000080u;
}
inline void item_single::clear_has_param() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void item_single::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 item_single::param() const {
  return param_;
}
inline void item_single::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional uint32 param2 = 9;
inline bool item_single::has_param2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void item_single::set_has_param2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void item_single::clear_has_param2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void item_single::clear_param2() {
  param2_ = 0u;
  clear_has_param2();
}
inline ::google::protobuf::uint32 item_single::param2() const {
  return param2_;
}
inline void item_single::set_param2(::google::protobuf::uint32 value) {
  set_has_param2();
  param2_ = value;
}

// optional string find_role = 10;
inline bool item_single::has_find_role() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void item_single::set_has_find_role() {
  _has_bits_[0] |= 0x00000200u;
}
inline void item_single::clear_has_find_role() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void item_single::clear_find_role() {
  if (find_role_ != &::google::protobuf::internal::kEmptyString) {
    find_role_->clear();
  }
  clear_has_find_role();
}
inline const ::std::string& item_single::find_role() const {
  return *find_role_;
}
inline void item_single::set_find_role(const ::std::string& value) {
  set_has_find_role();
  if (find_role_ == &::google::protobuf::internal::kEmptyString) {
    find_role_ = new ::std::string;
  }
  find_role_->assign(value);
}
inline void item_single::set_find_role(const char* value) {
  set_has_find_role();
  if (find_role_ == &::google::protobuf::internal::kEmptyString) {
    find_role_ = new ::std::string;
  }
  find_role_->assign(value);
}
inline void item_single::set_find_role(const char* value, size_t size) {
  set_has_find_role();
  if (find_role_ == &::google::protobuf::internal::kEmptyString) {
    find_role_ = new ::std::string;
  }
  find_role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* item_single::mutable_find_role() {
  set_has_find_role();
  if (find_role_ == &::google::protobuf::internal::kEmptyString) {
    find_role_ = new ::std::string;
  }
  return find_role_;
}
inline ::std::string* item_single::release_find_role() {
  clear_has_find_role();
  if (find_role_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = find_role_;
    find_role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void item_single::set_allocated_find_role(::std::string* find_role) {
  if (find_role_ != &::google::protobuf::internal::kEmptyString) {
    delete find_role_;
  }
  if (find_role) {
    set_has_find_role();
    find_role_ = find_role;
  } else {
    clear_has_find_role();
    find_role_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.equip_single equip_info = 11;
inline bool item_single::has_equip_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void item_single::set_has_equip_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void item_single::clear_has_equip_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void item_single::clear_equip_info() {
  if (equip_info_ != NULL) equip_info_->::proto::common::equip_single::Clear();
  clear_has_equip_info();
}
inline const ::proto::common::equip_single& item_single::equip_info() const {
  return equip_info_ != NULL ? *equip_info_ : *default_instance_->equip_info_;
}
inline ::proto::common::equip_single* item_single::mutable_equip_info() {
  set_has_equip_info();
  if (equip_info_ == NULL) equip_info_ = new ::proto::common::equip_single;
  return equip_info_;
}
inline ::proto::common::equip_single* item_single::release_equip_info() {
  clear_has_equip_info();
  ::proto::common::equip_single* temp = equip_info_;
  equip_info_ = NULL;
  return temp;
}
inline void item_single::set_allocated_equip_info(::proto::common::equip_single* equip_info) {
  delete equip_info_;
  equip_info_ = equip_info;
  if (equip_info) {
    set_has_equip_info();
  } else {
    clear_has_equip_info();
  }
}

// optional uint32 rarity = 12;
inline bool item_single::has_rarity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void item_single::set_has_rarity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void item_single::clear_has_rarity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void item_single::clear_rarity() {
  rarity_ = 0u;
  clear_has_rarity();
}
inline ::google::protobuf::uint32 item_single::rarity() const {
  return rarity_;
}
inline void item_single::set_rarity(::google::protobuf::uint32 value) {
  set_has_rarity();
  rarity_ = value;
}

// optional uint32 state = 13;
inline bool item_single::has_state() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void item_single::set_has_state() {
  _has_bits_[0] |= 0x00001000u;
}
inline void item_single::clear_has_state() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void item_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 item_single::state() const {
  return state_;
}
inline void item_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 expired_time = 14;
inline bool item_single::has_expired_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void item_single::set_has_expired_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void item_single::clear_has_expired_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void item_single::clear_expired_time() {
  expired_time_ = 0u;
  clear_has_expired_time();
}
inline ::google::protobuf::uint32 item_single::expired_time() const {
  return expired_time_;
}
inline void item_single::set_expired_time(::google::protobuf::uint32 value) {
  set_has_expired_time();
  expired_time_ = value;
}

// -------------------------------------------------------------------

// talent_single

// optional uint32 tid = 1;
inline bool talent_single::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void talent_single::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void talent_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void talent_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 talent_single::tid() const {
  return tid_;
}
inline void talent_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 level = 2;
inline bool talent_single::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void talent_single::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void talent_single::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void talent_single::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 talent_single::level() const {
  return level_;
}
inline void talent_single::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// talent_data

// repeated .proto.common.talent_single talent_list = 1;
inline int talent_data::talent_list_size() const {
  return talent_list_.size();
}
inline void talent_data::clear_talent_list() {
  talent_list_.Clear();
}
inline const ::proto::common::talent_single& talent_data::talent_list(int index) const {
  return talent_list_.Get(index);
}
inline ::proto::common::talent_single* talent_data::mutable_talent_list(int index) {
  return talent_list_.Mutable(index);
}
inline ::proto::common::talent_single* talent_data::add_talent_list() {
  return talent_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::talent_single >&
talent_data::talent_list() const {
  return talent_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::talent_single >*
talent_data::mutable_talent_list() {
  return &talent_list_;
}

// -------------------------------------------------------------------

// formation_pair

// optional uint32 pos = 1;
inline bool formation_pair::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void formation_pair::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void formation_pair::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void formation_pair::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 formation_pair::pos() const {
  return pos_;
}
inline void formation_pair::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string unique_id = 2;
inline bool formation_pair::has_unique_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void formation_pair::set_has_unique_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void formation_pair::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void formation_pair::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& formation_pair::unique_id() const {
  return *unique_id_;
}
inline void formation_pair::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void formation_pair::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void formation_pair::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* formation_pair::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* formation_pair::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void formation_pair::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unique_id_;
  }
  if (unique_id) {
    set_has_unique_id();
    unique_id_ = unique_id;
  } else {
    clear_has_unique_id();
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 plugin = 3;
inline bool formation_pair::has_plugin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void formation_pair::set_has_plugin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void formation_pair::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void formation_pair::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 formation_pair::plugin() const {
  return plugin_;
}
inline void formation_pair::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 grade = 4;
inline bool formation_pair::has_grade() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void formation_pair::set_has_grade() {
  _has_bits_[0] |= 0x00000008u;
}
inline void formation_pair::clear_has_grade() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void formation_pair::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 formation_pair::grade() const {
  return grade_;
}
inline void formation_pair::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// optional uint32 star = 5;
inline bool formation_pair::has_star() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void formation_pair::set_has_star() {
  _has_bits_[0] |= 0x00000010u;
}
inline void formation_pair::clear_has_star() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void formation_pair::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 formation_pair::star() const {
  return star_;
}
inline void formation_pair::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// optional uint32 level = 6;
inline bool formation_pair::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void formation_pair::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void formation_pair::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void formation_pair::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 formation_pair::level() const {
  return level_;
}
inline void formation_pair::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string owner_id = 7;
inline bool formation_pair::has_owner_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void formation_pair::set_has_owner_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void formation_pair::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void formation_pair::clear_owner_id() {
  if (owner_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_id_->clear();
  }
  clear_has_owner_id();
}
inline const ::std::string& formation_pair::owner_id() const {
  return *owner_id_;
}
inline void formation_pair::set_owner_id(const ::std::string& value) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(value);
}
inline void formation_pair::set_owner_id(const char* value) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(value);
}
inline void formation_pair::set_owner_id(const char* value, size_t size) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* formation_pair::mutable_owner_id() {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  return owner_id_;
}
inline ::std::string* formation_pair::release_owner_id() {
  clear_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_id_;
    owner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void formation_pair::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_id_;
  }
  if (owner_id) {
    set_has_owner_id();
    owner_id_ = owner_id;
  } else {
    clear_has_owner_id();
    owner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// formation_single

// optional uint32 formation_index = 1;
inline bool formation_single::has_formation_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void formation_single::set_has_formation_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void formation_single::clear_has_formation_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void formation_single::clear_formation_index() {
  formation_index_ = 0u;
  clear_has_formation_index();
}
inline ::google::protobuf::uint32 formation_single::formation_index() const {
  return formation_index_;
}
inline void formation_single::set_formation_index(::google::protobuf::uint32 value) {
  set_has_formation_index();
  formation_index_ = value;
}

// optional uint32 tactic_id = 2;
inline bool formation_single::has_tactic_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void formation_single::set_has_tactic_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void formation_single::clear_has_tactic_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void formation_single::clear_tactic_id() {
  tactic_id_ = 0u;
  clear_has_tactic_id();
}
inline ::google::protobuf::uint32 formation_single::tactic_id() const {
  return tactic_id_;
}
inline void formation_single::set_tactic_id(::google::protobuf::uint32 value) {
  set_has_tactic_id();
  tactic_id_ = value;
}

// repeated .proto.common.formation_pair formations = 3;
inline int formation_single::formations_size() const {
  return formations_.size();
}
inline void formation_single::clear_formations() {
  formations_.Clear();
}
inline const ::proto::common::formation_pair& formation_single::formations(int index) const {
  return formations_.Get(index);
}
inline ::proto::common::formation_pair* formation_single::mutable_formations(int index) {
  return formations_.Mutable(index);
}
inline ::proto::common::formation_pair* formation_single::add_formations() {
  return formations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::formation_pair >&
formation_single::formations() const {
  return formations_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::formation_pair >*
formation_single::mutable_formations() {
  return &formations_;
}

// -------------------------------------------------------------------

// formation_data

// repeated .proto.common.formation_single formation_list = 1;
inline int formation_data::formation_list_size() const {
  return formation_list_.size();
}
inline void formation_data::clear_formation_list() {
  formation_list_.Clear();
}
inline const ::proto::common::formation_single& formation_data::formation_list(int index) const {
  return formation_list_.Get(index);
}
inline ::proto::common::formation_single* formation_data::mutable_formation_list(int index) {
  return formation_list_.Mutable(index);
}
inline ::proto::common::formation_single* formation_data::add_formation_list() {
  return formation_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::formation_single >&
formation_data::formation_list() const {
  return formation_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::formation_single >*
formation_data::mutable_formation_list() {
  return &formation_list_;
}

// optional uint32 cur_formation_id = 2;
inline bool formation_data::has_cur_formation_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void formation_data::set_has_cur_formation_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void formation_data::clear_has_cur_formation_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void formation_data::clear_cur_formation_id() {
  cur_formation_id_ = 0u;
  clear_has_cur_formation_id();
}
inline ::google::protobuf::uint32 formation_data::cur_formation_id() const {
  return cur_formation_id_;
}
inline void formation_data::set_cur_formation_id(::google::protobuf::uint32 value) {
  set_has_cur_formation_id();
  cur_formation_id_ = value;
}

// -------------------------------------------------------------------

// fate_pair

// optional uint32 fate_tid = 1;
inline bool fate_pair::has_fate_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fate_pair::set_has_fate_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fate_pair::clear_has_fate_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fate_pair::clear_fate_tid() {
  fate_tid_ = 0u;
  clear_has_fate_tid();
}
inline ::google::protobuf::uint32 fate_pair::fate_tid() const {
  return fate_tid_;
}
inline void fate_pair::set_fate_tid(::google::protobuf::uint32 value) {
  set_has_fate_tid();
  fate_tid_ = value;
}

// optional int32 fate_level = 2;
inline bool fate_pair::has_fate_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fate_pair::set_has_fate_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fate_pair::clear_has_fate_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fate_pair::clear_fate_level() {
  fate_level_ = 0;
  clear_has_fate_level();
}
inline ::google::protobuf::int32 fate_pair::fate_level() const {
  return fate_level_;
}
inline void fate_pair::set_fate_level(::google::protobuf::int32 value) {
  set_has_fate_level();
  fate_level_ = value;
}

// -------------------------------------------------------------------

// hero_single

// optional .proto.common.base_attr base_attr = 1;
inline bool hero_single::has_base_attr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_single::set_has_base_attr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_single::clear_has_base_attr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_single::clear_base_attr() {
  if (base_attr_ != NULL) base_attr_->::proto::common::base_attr::Clear();
  clear_has_base_attr();
}
inline const ::proto::common::base_attr& hero_single::base_attr() const {
  return base_attr_ != NULL ? *base_attr_ : *default_instance_->base_attr_;
}
inline ::proto::common::base_attr* hero_single::mutable_base_attr() {
  set_has_base_attr();
  if (base_attr_ == NULL) base_attr_ = new ::proto::common::base_attr;
  return base_attr_;
}
inline ::proto::common::base_attr* hero_single::release_base_attr() {
  clear_has_base_attr();
  ::proto::common::base_attr* temp = base_attr_;
  base_attr_ = NULL;
  return temp;
}
inline void hero_single::set_allocated_base_attr(::proto::common::base_attr* base_attr) {
  delete base_attr_;
  base_attr_ = base_attr;
  if (base_attr) {
    set_has_base_attr();
  } else {
    clear_has_base_attr();
  }
}

// optional .proto.common.fight_attr fight_attr = 2;
inline bool hero_single::has_fight_attr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_single::set_has_fight_attr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_single::clear_has_fight_attr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_single::clear_fight_attr() {
  if (fight_attr_ != NULL) fight_attr_->::proto::common::fight_attr::Clear();
  clear_has_fight_attr();
}
inline const ::proto::common::fight_attr& hero_single::fight_attr() const {
  return fight_attr_ != NULL ? *fight_attr_ : *default_instance_->fight_attr_;
}
inline ::proto::common::fight_attr* hero_single::mutable_fight_attr() {
  set_has_fight_attr();
  if (fight_attr_ == NULL) fight_attr_ = new ::proto::common::fight_attr;
  return fight_attr_;
}
inline ::proto::common::fight_attr* hero_single::release_fight_attr() {
  clear_has_fight_attr();
  ::proto::common::fight_attr* temp = fight_attr_;
  fight_attr_ = NULL;
  return temp;
}
inline void hero_single::set_allocated_fight_attr(::proto::common::fight_attr* fight_attr) {
  delete fight_attr_;
  fight_attr_ = fight_attr;
  if (fight_attr) {
    set_has_fight_attr();
  } else {
    clear_has_fight_attr();
  }
}

// optional .proto.common.talent_data talent_data = 3;
inline bool hero_single::has_talent_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_single::set_has_talent_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_single::clear_has_talent_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_single::clear_talent_data() {
  if (talent_data_ != NULL) talent_data_->::proto::common::talent_data::Clear();
  clear_has_talent_data();
}
inline const ::proto::common::talent_data& hero_single::talent_data() const {
  return talent_data_ != NULL ? *talent_data_ : *default_instance_->talent_data_;
}
inline ::proto::common::talent_data* hero_single::mutable_talent_data() {
  set_has_talent_data();
  if (talent_data_ == NULL) talent_data_ = new ::proto::common::talent_data;
  return talent_data_;
}
inline ::proto::common::talent_data* hero_single::release_talent_data() {
  clear_has_talent_data();
  ::proto::common::talent_data* temp = talent_data_;
  talent_data_ = NULL;
  return temp;
}
inline void hero_single::set_allocated_talent_data(::proto::common::talent_data* talent_data) {
  delete talent_data_;
  talent_data_ = talent_data;
  if (talent_data) {
    set_has_talent_data();
  } else {
    clear_has_talent_data();
  }
}

// optional .proto.common.skill_data skill = 4;
inline bool hero_single::has_skill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero_single::set_has_skill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero_single::clear_has_skill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero_single::clear_skill() {
  if (skill_ != NULL) skill_->::proto::common::skill_data::Clear();
  clear_has_skill();
}
inline const ::proto::common::skill_data& hero_single::skill() const {
  return skill_ != NULL ? *skill_ : *default_instance_->skill_;
}
inline ::proto::common::skill_data* hero_single::mutable_skill() {
  set_has_skill();
  if (skill_ == NULL) skill_ = new ::proto::common::skill_data;
  return skill_;
}
inline ::proto::common::skill_data* hero_single::release_skill() {
  clear_has_skill();
  ::proto::common::skill_data* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline void hero_single::set_allocated_skill(::proto::common::skill_data* skill) {
  delete skill_;
  skill_ = skill;
  if (skill) {
    set_has_skill();
  } else {
    clear_has_skill();
  }
}

// optional int32 save_hp = 5;
inline bool hero_single::has_save_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void hero_single::set_has_save_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void hero_single::clear_has_save_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void hero_single::clear_save_hp() {
  save_hp_ = 0;
  clear_has_save_hp();
}
inline ::google::protobuf::int32 hero_single::save_hp() const {
  return save_hp_;
}
inline void hero_single::set_save_hp(::google::protobuf::int32 value) {
  set_has_save_hp();
  save_hp_ = value;
}

// -------------------------------------------------------------------

// hero_data

// repeated .proto.common.hero_single hero_list = 1;
inline int hero_data::hero_list_size() const {
  return hero_list_.size();
}
inline void hero_data::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::hero_single& hero_data::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::hero_single* hero_data::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::hero_single* hero_data::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
hero_data::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
hero_data::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// fight_special_hero_single

// optional string uid = 1;
inline bool fight_special_hero_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_special_hero_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_special_hero_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_special_hero_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& fight_special_hero_single::uid() const {
  return *uid_;
}
inline void fight_special_hero_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void fight_special_hero_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void fight_special_hero_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_special_hero_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* fight_special_hero_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_special_hero_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool fight_special_hero_single::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_special_hero_single::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_special_hero_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_special_hero_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 fight_special_hero_single::tid() const {
  return tid_;
}
inline void fight_special_hero_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 save_hp = 3;
inline bool fight_special_hero_single::has_save_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_special_hero_single::set_has_save_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_special_hero_single::clear_has_save_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_special_hero_single::clear_save_hp() {
  save_hp_ = 0u;
  clear_has_save_hp();
}
inline ::google::protobuf::uint32 fight_special_hero_single::save_hp() const {
  return save_hp_;
}
inline void fight_special_hero_single::set_save_hp(::google::protobuf::uint32 value) {
  set_has_save_hp();
  save_hp_ = value;
}

// optional uint32 max_hp = 4;
inline bool fight_special_hero_single::has_max_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_special_hero_single::set_has_max_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_special_hero_single::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_special_hero_single::clear_max_hp() {
  max_hp_ = 0u;
  clear_has_max_hp();
}
inline ::google::protobuf::uint32 fight_special_hero_single::max_hp() const {
  return max_hp_;
}
inline void fight_special_hero_single::set_max_hp(::google::protobuf::uint32 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// -------------------------------------------------------------------

// fight_special_hero_data

// repeated .proto.common.fight_special_hero_single hero_list = 1;
inline int fight_special_hero_data::hero_list_size() const {
  return hero_list_.size();
}
inline void fight_special_hero_data::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::fight_special_hero_single& fight_special_hero_data::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::fight_special_hero_single* fight_special_hero_data::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::fight_special_hero_single* fight_special_hero_data::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_special_hero_single >&
fight_special_hero_data::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_special_hero_single >*
fight_special_hero_data::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// luckydraw_award

// optional uint32 hero_tid = 1;
inline bool luckydraw_award::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void luckydraw_award::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void luckydraw_award::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void luckydraw_award::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 luckydraw_award::hero_tid() const {
  return hero_tid_;
}
inline void luckydraw_award::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional uint32 item_tid = 2;
inline bool luckydraw_award::has_item_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luckydraw_award::set_has_item_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luckydraw_award::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luckydraw_award::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 luckydraw_award::item_tid() const {
  return item_tid_;
}
inline void luckydraw_award::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_count = 3;
inline bool luckydraw_award::has_item_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void luckydraw_award::set_has_item_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void luckydraw_award::clear_has_item_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void luckydraw_award::clear_item_count() {
  item_count_ = 0u;
  clear_has_item_count();
}
inline ::google::protobuf::uint32 luckydraw_award::item_count() const {
  return item_count_;
}
inline void luckydraw_award::set_item_count(::google::protobuf::uint32 value) {
  set_has_item_count();
  item_count_ = value;
}

// -------------------------------------------------------------------

// role_change_data

// optional .proto.common.personal_info per_info = 1;
inline bool role_change_data::has_per_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_change_data::set_has_per_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_change_data::clear_has_per_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_change_data::clear_per_info() {
  if (per_info_ != NULL) per_info_->::proto::common::personal_info::Clear();
  clear_has_per_info();
}
inline const ::proto::common::personal_info& role_change_data::per_info() const {
  return per_info_ != NULL ? *per_info_ : *default_instance_->per_info_;
}
inline ::proto::common::personal_info* role_change_data::mutable_per_info() {
  set_has_per_info();
  if (per_info_ == NULL) per_info_ = new ::proto::common::personal_info;
  return per_info_;
}
inline ::proto::common::personal_info* role_change_data::release_per_info() {
  clear_has_per_info();
  ::proto::common::personal_info* temp = per_info_;
  per_info_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_per_info(::proto::common::personal_info* per_info) {
  delete per_info_;
  per_info_ = per_info;
  if (per_info) {
    set_has_per_info();
  } else {
    clear_has_per_info();
  }
}

// optional .proto.common.item_data item = 2;
inline bool role_change_data::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_change_data::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_change_data::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_change_data::clear_item() {
  if (item_ != NULL) item_->::proto::common::item_data::Clear();
  clear_has_item();
}
inline const ::proto::common::item_data& role_change_data::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::proto::common::item_data* role_change_data::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::proto::common::item_data;
  return item_;
}
inline ::proto::common::item_data* role_change_data::release_item() {
  clear_has_item();
  ::proto::common::item_data* temp = item_;
  item_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_item(::proto::common::item_data* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// optional .proto.common.hero_data hero = 3;
inline bool role_change_data::has_hero() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_change_data::set_has_hero() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_change_data::clear_has_hero() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_change_data::clear_hero() {
  if (hero_ != NULL) hero_->::proto::common::hero_data::Clear();
  clear_has_hero();
}
inline const ::proto::common::hero_data& role_change_data::hero() const {
  return hero_ != NULL ? *hero_ : *default_instance_->hero_;
}
inline ::proto::common::hero_data* role_change_data::mutable_hero() {
  set_has_hero();
  if (hero_ == NULL) hero_ = new ::proto::common::hero_data;
  return hero_;
}
inline ::proto::common::hero_data* role_change_data::release_hero() {
  clear_has_hero();
  ::proto::common::hero_data* temp = hero_;
  hero_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_hero(::proto::common::hero_data* hero) {
  delete hero_;
  hero_ = hero;
  if (hero) {
    set_has_hero();
  } else {
    clear_has_hero();
  }
}

// optional .proto.common.role_trade_info trade_info = 5;
inline bool role_change_data::has_trade_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_change_data::set_has_trade_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_change_data::clear_has_trade_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_change_data::clear_trade_info() {
  if (trade_info_ != NULL) trade_info_->::proto::common::role_trade_info::Clear();
  clear_has_trade_info();
}
inline const ::proto::common::role_trade_info& role_change_data::trade_info() const {
  return trade_info_ != NULL ? *trade_info_ : *default_instance_->trade_info_;
}
inline ::proto::common::role_trade_info* role_change_data::mutable_trade_info() {
  set_has_trade_info();
  if (trade_info_ == NULL) trade_info_ = new ::proto::common::role_trade_info;
  return trade_info_;
}
inline ::proto::common::role_trade_info* role_change_data::release_trade_info() {
  clear_has_trade_info();
  ::proto::common::role_trade_info* temp = trade_info_;
  trade_info_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_trade_info(::proto::common::role_trade_info* trade_info) {
  delete trade_info_;
  trade_info_ = trade_info;
  if (trade_info) {
    set_has_trade_info();
  } else {
    clear_has_trade_info();
  }
}

// optional .proto.common.role_trade_item trade_item = 6;
inline bool role_change_data::has_trade_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_change_data::set_has_trade_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_change_data::clear_has_trade_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_change_data::clear_trade_item() {
  if (trade_item_ != NULL) trade_item_->::proto::common::role_trade_item::Clear();
  clear_has_trade_item();
}
inline const ::proto::common::role_trade_item& role_change_data::trade_item() const {
  return trade_item_ != NULL ? *trade_item_ : *default_instance_->trade_item_;
}
inline ::proto::common::role_trade_item* role_change_data::mutable_trade_item() {
  set_has_trade_item();
  if (trade_item_ == NULL) trade_item_ = new ::proto::common::role_trade_item;
  return trade_item_;
}
inline ::proto::common::role_trade_item* role_change_data::release_trade_item() {
  clear_has_trade_item();
  ::proto::common::role_trade_item* temp = trade_item_;
  trade_item_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_trade_item(::proto::common::role_trade_item* trade_item) {
  delete trade_item_;
  trade_item_ = trade_item;
  if (trade_item) {
    set_has_trade_item();
  } else {
    clear_has_trade_item();
  }
}

// optional uint32 level = 7;
inline bool role_change_data::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_change_data::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_change_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_change_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 role_change_data::level() const {
  return level_;
}
inline void role_change_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 exp = 8;
inline bool role_change_data::has_exp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_change_data::set_has_exp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_change_data::clear_has_exp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_change_data::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 role_change_data::exp() const {
  return exp_;
}
inline void role_change_data::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional .proto.common.mount_data mount = 9;
inline bool role_change_data::has_mount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_change_data::set_has_mount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_change_data::clear_has_mount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_change_data::clear_mount() {
  if (mount_ != NULL) mount_->::proto::common::mount_data::Clear();
  clear_has_mount();
}
inline const ::proto::common::mount_data& role_change_data::mount() const {
  return mount_ != NULL ? *mount_ : *default_instance_->mount_;
}
inline ::proto::common::mount_data* role_change_data::mutable_mount() {
  set_has_mount();
  if (mount_ == NULL) mount_ = new ::proto::common::mount_data;
  return mount_;
}
inline ::proto::common::mount_data* role_change_data::release_mount() {
  clear_has_mount();
  ::proto::common::mount_data* temp = mount_;
  mount_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_mount(::proto::common::mount_data* mount) {
  delete mount_;
  mount_ = mount;
  if (mount) {
    set_has_mount();
  } else {
    clear_has_mount();
  }
}

// optional .proto.common.multi_time_data multi_time = 10;
inline bool role_change_data::has_multi_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void role_change_data::set_has_multi_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void role_change_data::clear_has_multi_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void role_change_data::clear_multi_time() {
  if (multi_time_ != NULL) multi_time_->::proto::common::multi_time_data::Clear();
  clear_has_multi_time();
}
inline const ::proto::common::multi_time_data& role_change_data::multi_time() const {
  return multi_time_ != NULL ? *multi_time_ : *default_instance_->multi_time_;
}
inline ::proto::common::multi_time_data* role_change_data::mutable_multi_time() {
  set_has_multi_time();
  if (multi_time_ == NULL) multi_time_ = new ::proto::common::multi_time_data;
  return multi_time_;
}
inline ::proto::common::multi_time_data* role_change_data::release_multi_time() {
  clear_has_multi_time();
  ::proto::common::multi_time_data* temp = multi_time_;
  multi_time_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_multi_time(::proto::common::multi_time_data* multi_time) {
  delete multi_time_;
  multi_time_ = multi_time;
  if (multi_time) {
    set_has_multi_time();
  } else {
    clear_has_multi_time();
  }
}

// optional .proto.common.recharge_data recharge = 11;
inline bool role_change_data::has_recharge() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void role_change_data::set_has_recharge() {
  _has_bits_[0] |= 0x00000200u;
}
inline void role_change_data::clear_has_recharge() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void role_change_data::clear_recharge() {
  if (recharge_ != NULL) recharge_->::proto::common::recharge_data::Clear();
  clear_has_recharge();
}
inline const ::proto::common::recharge_data& role_change_data::recharge() const {
  return recharge_ != NULL ? *recharge_ : *default_instance_->recharge_;
}
inline ::proto::common::recharge_data* role_change_data::mutable_recharge() {
  set_has_recharge();
  if (recharge_ == NULL) recharge_ = new ::proto::common::recharge_data;
  return recharge_;
}
inline ::proto::common::recharge_data* role_change_data::release_recharge() {
  clear_has_recharge();
  ::proto::common::recharge_data* temp = recharge_;
  recharge_ = NULL;
  return temp;
}
inline void role_change_data::set_allocated_recharge(::proto::common::recharge_data* recharge) {
  delete recharge_;
  recharge_ = recharge;
  if (recharge) {
    set_has_recharge();
  } else {
    clear_has_recharge();
  }
}

// optional uint32 charm = 12;
inline bool role_change_data::has_charm() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void role_change_data::set_has_charm() {
  _has_bits_[0] |= 0x00000400u;
}
inline void role_change_data::clear_has_charm() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void role_change_data::clear_charm() {
  charm_ = 0u;
  clear_has_charm();
}
inline ::google::protobuf::uint32 role_change_data::charm() const {
  return charm_;
}
inline void role_change_data::set_charm(::google::protobuf::uint32 value) {
  set_has_charm();
  charm_ = value;
}

// -------------------------------------------------------------------

// task_state

// optional uint32 id = 1;
inline bool task_state::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_state::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_state::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_state::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 task_state::id() const {
  return id_;
}
inline void task_state::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string progress = 2;
inline bool task_state::has_progress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_state::set_has_progress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_state::clear_has_progress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_state::clear_progress() {
  if (progress_ != &::google::protobuf::internal::kEmptyString) {
    progress_->clear();
  }
  clear_has_progress();
}
inline const ::std::string& task_state::progress() const {
  return *progress_;
}
inline void task_state::set_progress(const ::std::string& value) {
  set_has_progress();
  if (progress_ == &::google::protobuf::internal::kEmptyString) {
    progress_ = new ::std::string;
  }
  progress_->assign(value);
}
inline void task_state::set_progress(const char* value) {
  set_has_progress();
  if (progress_ == &::google::protobuf::internal::kEmptyString) {
    progress_ = new ::std::string;
  }
  progress_->assign(value);
}
inline void task_state::set_progress(const char* value, size_t size) {
  set_has_progress();
  if (progress_ == &::google::protobuf::internal::kEmptyString) {
    progress_ = new ::std::string;
  }
  progress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* task_state::mutable_progress() {
  set_has_progress();
  if (progress_ == &::google::protobuf::internal::kEmptyString) {
    progress_ = new ::std::string;
  }
  return progress_;
}
inline ::std::string* task_state::release_progress() {
  clear_has_progress();
  if (progress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = progress_;
    progress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void task_state::set_allocated_progress(::std::string* progress) {
  if (progress_ != &::google::protobuf::internal::kEmptyString) {
    delete progress_;
  }
  if (progress) {
    set_has_progress();
    progress_ = progress;
  } else {
    clear_has_progress();
    progress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 3;
inline bool task_state::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void task_state::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void task_state::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void task_state::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 task_state::state() const {
  return state_;
}
inline void task_state::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 circle_count = 4;
inline bool task_state::has_circle_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void task_state::set_has_circle_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void task_state::clear_has_circle_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void task_state::clear_circle_count() {
  circle_count_ = 0u;
  clear_has_circle_count();
}
inline ::google::protobuf::uint32 task_state::circle_count() const {
  return circle_count_;
}
inline void task_state::set_circle_count(::google::protobuf::uint32 value) {
  set_has_circle_count();
  circle_count_ = value;
}

// optional uint32 max_circle_count = 5;
inline bool task_state::has_max_circle_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void task_state::set_has_max_circle_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void task_state::clear_has_max_circle_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void task_state::clear_max_circle_count() {
  max_circle_count_ = 0u;
  clear_has_max_circle_count();
}
inline ::google::protobuf::uint32 task_state::max_circle_count() const {
  return max_circle_count_;
}
inline void task_state::set_max_circle_count(::google::protobuf::uint32 value) {
  set_has_max_circle_count();
  max_circle_count_ = value;
}

// optional uint64 uid = 7;
inline bool task_state::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void task_state::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void task_state::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void task_state::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 task_state::uid() const {
  return uid_;
}
inline void task_state::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 type = 8;
inline bool task_state::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void task_state::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void task_state::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void task_state::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 task_state::type() const {
  return type_;
}
inline void task_state::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 circle_id = 9;
inline bool task_state::has_circle_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void task_state::set_has_circle_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void task_state::clear_has_circle_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void task_state::clear_circle_id() {
  circle_id_ = 0u;
  clear_has_circle_id();
}
inline ::google::protobuf::uint32 task_state::circle_id() const {
  return circle_id_;
}
inline void task_state::set_circle_id(::google::protobuf::uint32 value) {
  set_has_circle_id();
  circle_id_ = value;
}

// optional uint32 accept_level = 10;
inline bool task_state::has_accept_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void task_state::set_has_accept_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void task_state::clear_has_accept_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void task_state::clear_accept_level() {
  accept_level_ = 0u;
  clear_has_accept_level();
}
inline ::google::protobuf::uint32 task_state::accept_level() const {
  return accept_level_;
}
inline void task_state::set_accept_level(::google::protobuf::uint32 value) {
  set_has_accept_level();
  accept_level_ = value;
}

// optional uint32 star = 11;
inline bool task_state::has_star() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void task_state::set_has_star() {
  _has_bits_[0] |= 0x00000200u;
}
inline void task_state::clear_has_star() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void task_state::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 task_state::star() const {
  return star_;
}
inline void task_state::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// -------------------------------------------------------------------

// task_data

// repeated .proto.common.task_state tasks = 1;
inline int task_data::tasks_size() const {
  return tasks_.size();
}
inline void task_data::clear_tasks() {
  tasks_.Clear();
}
inline const ::proto::common::task_state& task_data::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::proto::common::task_state* task_data::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::proto::common::task_state* task_data::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >&
task_data::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >*
task_data::mutable_tasks() {
  return &tasks_;
}

// optional uint32 shilian_count = 2;
inline bool task_data::has_shilian_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_data::set_has_shilian_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_data::clear_has_shilian_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_data::clear_shilian_count() {
  shilian_count_ = 0u;
  clear_has_shilian_count();
}
inline ::google::protobuf::uint32 task_data::shilian_count() const {
  return shilian_count_;
}
inline void task_data::set_shilian_count(::google::protobuf::uint32 value) {
  set_has_shilian_count();
  shilian_count_ = value;
}

// repeated uint32 shilian_seq = 3;
inline int task_data::shilian_seq_size() const {
  return shilian_seq_.size();
}
inline void task_data::clear_shilian_seq() {
  shilian_seq_.Clear();
}
inline ::google::protobuf::uint32 task_data::shilian_seq(int index) const {
  return shilian_seq_.Get(index);
}
inline void task_data::set_shilian_seq(int index, ::google::protobuf::uint32 value) {
  shilian_seq_.Set(index, value);
}
inline void task_data::add_shilian_seq(::google::protobuf::uint32 value) {
  shilian_seq_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
task_data::shilian_seq() const {
  return shilian_seq_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
task_data::mutable_shilian_seq() {
  return &shilian_seq_;
}

// repeated uint32 circle_task_comp_list = 4;
inline int task_data::circle_task_comp_list_size() const {
  return circle_task_comp_list_.size();
}
inline void task_data::clear_circle_task_comp_list() {
  circle_task_comp_list_.Clear();
}
inline ::google::protobuf::uint32 task_data::circle_task_comp_list(int index) const {
  return circle_task_comp_list_.Get(index);
}
inline void task_data::set_circle_task_comp_list(int index, ::google::protobuf::uint32 value) {
  circle_task_comp_list_.Set(index, value);
}
inline void task_data::add_circle_task_comp_list(::google::protobuf::uint32 value) {
  circle_task_comp_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
task_data::circle_task_comp_list() const {
  return circle_task_comp_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
task_data::mutable_circle_task_comp_list() {
  return &circle_task_comp_list_;
}

// repeated uint32 comp_task_list = 5;
inline int task_data::comp_task_list_size() const {
  return comp_task_list_.size();
}
inline void task_data::clear_comp_task_list() {
  comp_task_list_.Clear();
}
inline ::google::protobuf::uint32 task_data::comp_task_list(int index) const {
  return comp_task_list_.Get(index);
}
inline void task_data::set_comp_task_list(int index, ::google::protobuf::uint32 value) {
  comp_task_list_.Set(index, value);
}
inline void task_data::add_comp_task_list(::google::protobuf::uint32 value) {
  comp_task_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
task_data::comp_task_list() const {
  return comp_task_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
task_data::mutable_comp_task_list() {
  return &comp_task_list_;
}

// optional .proto.common.task_event event_data = 6;
inline bool task_data::has_event_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void task_data::set_has_event_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void task_data::clear_has_event_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void task_data::clear_event_data() {
  if (event_data_ != NULL) event_data_->::proto::common::task_event::Clear();
  clear_has_event_data();
}
inline const ::proto::common::task_event& task_data::event_data() const {
  return event_data_ != NULL ? *event_data_ : *default_instance_->event_data_;
}
inline ::proto::common::task_event* task_data::mutable_event_data() {
  set_has_event_data();
  if (event_data_ == NULL) event_data_ = new ::proto::common::task_event;
  return event_data_;
}
inline ::proto::common::task_event* task_data::release_event_data() {
  clear_has_event_data();
  ::proto::common::task_event* temp = event_data_;
  event_data_ = NULL;
  return temp;
}
inline void task_data::set_allocated_event_data(::proto::common::task_event* event_data) {
  delete event_data_;
  event_data_ = event_data;
  if (event_data) {
    set_has_event_data();
  } else {
    clear_has_event_data();
  }
}

// -------------------------------------------------------------------

// family_member

// optional string role_id = 1;
inline bool family_member::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_member::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_member::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_member::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& family_member::role_id() const {
  return *role_id_;
}
inline void family_member::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_member::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_member::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_member::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* family_member::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_member::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool family_member::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_member::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_member::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_member::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& family_member::role_name() const {
  return *role_name_;
}
inline void family_member::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_member::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_member::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_member::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* family_member::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_member::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 officer = 3;
inline bool family_member::has_officer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_member::set_has_officer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_member::clear_has_officer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_member::clear_officer() {
  officer_ = 0u;
  clear_has_officer();
}
inline ::google::protobuf::uint32 family_member::officer() const {
  return officer_;
}
inline void family_member::set_officer(::google::protobuf::uint32 value) {
  set_has_officer();
  officer_ = value;
}

// optional uint32 level = 4;
inline bool family_member::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_member::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_member::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_member::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_member::level() const {
  return level_;
}
inline void family_member::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 fighting = 5;
inline bool family_member::has_fighting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_member::set_has_fighting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_member::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_member::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 family_member::fighting() const {
  return fighting_;
}
inline void family_member::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 last_offline_time = 6;
inline bool family_member::has_last_offline_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_member::set_has_last_offline_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_member::clear_has_last_offline_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_member::clear_last_offline_time() {
  last_offline_time_ = 0u;
  clear_has_last_offline_time();
}
inline ::google::protobuf::uint32 family_member::last_offline_time() const {
  return last_offline_time_;
}
inline void family_member::set_last_offline_time(::google::protobuf::uint32 value) {
  set_has_last_offline_time();
  last_offline_time_ = value;
}

// optional uint32 total_family_contribution = 7;
inline bool family_member::has_total_family_contribution() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void family_member::set_has_total_family_contribution() {
  _has_bits_[0] |= 0x00000040u;
}
inline void family_member::clear_has_total_family_contribution() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void family_member::clear_total_family_contribution() {
  total_family_contribution_ = 0u;
  clear_has_total_family_contribution();
}
inline ::google::protobuf::uint32 family_member::total_family_contribution() const {
  return total_family_contribution_;
}
inline void family_member::set_total_family_contribution(::google::protobuf::uint32 value) {
  set_has_total_family_contribution();
  total_family_contribution_ = value;
}

// optional uint32 left_family_contribution = 8;
inline bool family_member::has_left_family_contribution() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void family_member::set_has_left_family_contribution() {
  _has_bits_[0] |= 0x00000080u;
}
inline void family_member::clear_has_left_family_contribution() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void family_member::clear_left_family_contribution() {
  left_family_contribution_ = 0u;
  clear_has_left_family_contribution();
}
inline ::google::protobuf::uint32 family_member::left_family_contribution() const {
  return left_family_contribution_;
}
inline void family_member::set_left_family_contribution(::google::protobuf::uint32 value) {
  set_has_left_family_contribution();
  left_family_contribution_ = value;
}

// optional uint32 plugin = 9;
inline bool family_member::has_plugin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void family_member::set_has_plugin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void family_member::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void family_member::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 family_member::plugin() const {
  return plugin_;
}
inline void family_member::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 glory = 10;
inline bool family_member::has_glory() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void family_member::set_has_glory() {
  _has_bits_[0] |= 0x00000200u;
}
inline void family_member::clear_has_glory() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void family_member::clear_glory() {
  glory_ = 0u;
  clear_has_glory();
}
inline ::google::protobuf::uint32 family_member::glory() const {
  return glory_;
}
inline void family_member::set_glory(::google::protobuf::uint32 value) {
  set_has_glory();
  glory_ = value;
}

// optional uint32 prayer_contribution = 11;
inline bool family_member::has_prayer_contribution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void family_member::set_has_prayer_contribution() {
  _has_bits_[0] |= 0x00000400u;
}
inline void family_member::clear_has_prayer_contribution() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void family_member::clear_prayer_contribution() {
  prayer_contribution_ = 0u;
  clear_has_prayer_contribution();
}
inline ::google::protobuf::uint32 family_member::prayer_contribution() const {
  return prayer_contribution_;
}
inline void family_member::set_prayer_contribution(::google::protobuf::uint32 value) {
  set_has_prayer_contribution();
  prayer_contribution_ = value;
}

// -------------------------------------------------------------------

// family_data

// optional string id = 1;
inline bool family_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_data::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& family_data::id() const {
  return *id_;
}
inline void family_data::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void family_data::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void family_data::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* family_data::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool family_data::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_data::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& family_data::name() const {
  return *name_;
}
inline void family_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void family_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void family_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* family_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool family_data::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_data::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_data::level() const {
  return level_;
}
inline void family_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 country = 4;
inline bool family_data::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_data::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_data::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_data::clear_country() {
  country_ = 0u;
  clear_has_country();
}
inline ::google::protobuf::uint32 family_data::country() const {
  return country_;
}
inline void family_data::set_country(::google::protobuf::uint32 value) {
  set_has_country();
  country_ = value;
}

// optional string patriarch = 5;
inline bool family_data::has_patriarch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_data::set_has_patriarch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_data::clear_has_patriarch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_data::clear_patriarch() {
  if (patriarch_ != &::google::protobuf::internal::kEmptyString) {
    patriarch_->clear();
  }
  clear_has_patriarch();
}
inline const ::std::string& family_data::patriarch() const {
  return *patriarch_;
}
inline void family_data::set_patriarch(const ::std::string& value) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(value);
}
inline void family_data::set_patriarch(const char* value) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(value);
}
inline void family_data::set_patriarch(const char* value, size_t size) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_patriarch() {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  return patriarch_;
}
inline ::std::string* family_data::release_patriarch() {
  clear_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patriarch_;
    patriarch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_patriarch(::std::string* patriarch) {
  if (patriarch_ != &::google::protobuf::internal::kEmptyString) {
    delete patriarch_;
  }
  if (patriarch) {
    set_has_patriarch();
    patriarch_ = patriarch;
  } else {
    clear_has_patriarch();
    patriarch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string creator = 6;
inline bool family_data::has_creator() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_data::set_has_creator() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_data::clear_has_creator() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_data::clear_creator() {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    creator_->clear();
  }
  clear_has_creator();
}
inline const ::std::string& family_data::creator() const {
  return *creator_;
}
inline void family_data::set_creator(const ::std::string& value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void family_data::set_creator(const char* value) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(value);
}
inline void family_data::set_creator(const char* value, size_t size) {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  creator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_creator() {
  set_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    creator_ = new ::std::string;
  }
  return creator_;
}
inline ::std::string* family_data::release_creator() {
  clear_has_creator();
  if (creator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_;
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_creator(::std::string* creator) {
  if (creator_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_;
  }
  if (creator) {
    set_has_creator();
    creator_ = creator;
  } else {
    clear_has_creator();
    creator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 money = 7;
inline bool family_data::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void family_data::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void family_data::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void family_data::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 family_data::money() const {
  return money_;
}
inline void family_data::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 max_money = 8;
inline bool family_data::has_max_money() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void family_data::set_has_max_money() {
  _has_bits_[0] |= 0x00000080u;
}
inline void family_data::clear_has_max_money() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void family_data::clear_max_money() {
  max_money_ = 0u;
  clear_has_max_money();
}
inline ::google::protobuf::uint32 family_data::max_money() const {
  return max_money_;
}
inline void family_data::set_max_money(::google::protobuf::uint32 value) {
  set_has_max_money();
  max_money_ = value;
}

// optional uint32 matain_cost = 9;
inline bool family_data::has_matain_cost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void family_data::set_has_matain_cost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void family_data::clear_has_matain_cost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void family_data::clear_matain_cost() {
  matain_cost_ = 0u;
  clear_has_matain_cost();
}
inline ::google::protobuf::uint32 family_data::matain_cost() const {
  return matain_cost_;
}
inline void family_data::set_matain_cost(::google::protobuf::uint32 value) {
  set_has_matain_cost();
  matain_cost_ = value;
}

// optional string declaration = 10;
inline bool family_data::has_declaration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void family_data::set_has_declaration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void family_data::clear_has_declaration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void family_data::clear_declaration() {
  if (declaration_ != &::google::protobuf::internal::kEmptyString) {
    declaration_->clear();
  }
  clear_has_declaration();
}
inline const ::std::string& family_data::declaration() const {
  return *declaration_;
}
inline void family_data::set_declaration(const ::std::string& value) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(value);
}
inline void family_data::set_declaration(const char* value) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(value);
}
inline void family_data::set_declaration(const char* value, size_t size) {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  declaration_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_declaration() {
  set_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    declaration_ = new ::std::string;
  }
  return declaration_;
}
inline ::std::string* family_data::release_declaration() {
  clear_has_declaration();
  if (declaration_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = declaration_;
    declaration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_declaration(::std::string* declaration) {
  if (declaration_ != &::google::protobuf::internal::kEmptyString) {
    delete declaration_;
  }
  if (declaration) {
    set_has_declaration();
    declaration_ = declaration;
  } else {
    clear_has_declaration();
    declaration_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string notice = 11;
inline bool family_data::has_notice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void family_data::set_has_notice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void family_data::clear_has_notice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void family_data::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& family_data::notice() const {
  return *notice_;
}
inline void family_data::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void family_data::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void family_data::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_data::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* family_data::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_data::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 prosperity = 12;
inline bool family_data::has_prosperity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void family_data::set_has_prosperity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void family_data::clear_has_prosperity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void family_data::clear_prosperity() {
  prosperity_ = 0u;
  clear_has_prosperity();
}
inline ::google::protobuf::uint32 family_data::prosperity() const {
  return prosperity_;
}
inline void family_data::set_prosperity(::google::protobuf::uint32 value) {
  set_has_prosperity();
  prosperity_ = value;
}

// optional uint32 prestige = 13;
inline bool family_data::has_prestige() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void family_data::set_has_prestige() {
  _has_bits_[0] |= 0x00001000u;
}
inline void family_data::clear_has_prestige() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void family_data::clear_prestige() {
  prestige_ = 0u;
  clear_has_prestige();
}
inline ::google::protobuf::uint32 family_data::prestige() const {
  return prestige_;
}
inline void family_data::set_prestige(::google::protobuf::uint32 value) {
  set_has_prestige();
  prestige_ = value;
}

// optional uint32 territory = 14;
inline bool family_data::has_territory() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void family_data::set_has_territory() {
  _has_bits_[0] |= 0x00002000u;
}
inline void family_data::clear_has_territory() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void family_data::clear_territory() {
  territory_ = 0u;
  clear_has_territory();
}
inline ::google::protobuf::uint32 family_data::territory() const {
  return territory_;
}
inline void family_data::set_territory(::google::protobuf::uint32 value) {
  set_has_territory();
  territory_ = value;
}

// optional bool auto_newbie = 15;
inline bool family_data::has_auto_newbie() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void family_data::set_has_auto_newbie() {
  _has_bits_[0] |= 0x00004000u;
}
inline void family_data::clear_has_auto_newbie() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void family_data::clear_auto_newbie() {
  auto_newbie_ = false;
  clear_has_auto_newbie();
}
inline bool family_data::auto_newbie() const {
  return auto_newbie_;
}
inline void family_data::set_auto_newbie(bool value) {
  set_has_auto_newbie();
  auto_newbie_ = value;
}

// optional uint32 member_cnt_max = 16;
inline bool family_data::has_member_cnt_max() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void family_data::set_has_member_cnt_max() {
  _has_bits_[0] |= 0x00008000u;
}
inline void family_data::clear_has_member_cnt_max() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void family_data::clear_member_cnt_max() {
  member_cnt_max_ = 0u;
  clear_has_member_cnt_max();
}
inline ::google::protobuf::uint32 family_data::member_cnt_max() const {
  return member_cnt_max_;
}
inline void family_data::set_member_cnt_max(::google::protobuf::uint32 value) {
  set_has_member_cnt_max();
  member_cnt_max_ = value;
}

// optional uint32 loyalty = 17;
inline bool family_data::has_loyalty() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void family_data::set_has_loyalty() {
  _has_bits_[0] |= 0x00010000u;
}
inline void family_data::clear_has_loyalty() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void family_data::clear_loyalty() {
  loyalty_ = 0u;
  clear_has_loyalty();
}
inline ::google::protobuf::uint32 family_data::loyalty() const {
  return loyalty_;
}
inline void family_data::set_loyalty(::google::protobuf::uint32 value) {
  set_has_loyalty();
  loyalty_ = value;
}

// -------------------------------------------------------------------

// family_list_info

// optional .proto.common.family_data base = 1;
inline bool family_list_info::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_list_info::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_list_info::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_list_info::clear_base() {
  if (base_ != NULL) base_->::proto::common::family_data::Clear();
  clear_has_base();
}
inline const ::proto::common::family_data& family_list_info::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::proto::common::family_data* family_list_info::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::proto::common::family_data;
  return base_;
}
inline ::proto::common::family_data* family_list_info::release_base() {
  clear_has_base();
  ::proto::common::family_data* temp = base_;
  base_ = NULL;
  return temp;
}
inline void family_list_info::set_allocated_base(::proto::common::family_data* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional uint32 member_cnt = 2;
inline bool family_list_info::has_member_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_list_info::set_has_member_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_list_info::clear_has_member_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_list_info::clear_member_cnt() {
  member_cnt_ = 0u;
  clear_has_member_cnt();
}
inline ::google::protobuf::uint32 family_list_info::member_cnt() const {
  return member_cnt_;
}
inline void family_list_info::set_member_cnt(::google::protobuf::uint32 value) {
  set_has_member_cnt();
  member_cnt_ = value;
}

// optional string patriarch_name = 3;
inline bool family_list_info::has_patriarch_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_list_info::set_has_patriarch_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_list_info::clear_has_patriarch_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_list_info::clear_patriarch_name() {
  if (patriarch_name_ != &::google::protobuf::internal::kEmptyString) {
    patriarch_name_->clear();
  }
  clear_has_patriarch_name();
}
inline const ::std::string& family_list_info::patriarch_name() const {
  return *patriarch_name_;
}
inline void family_list_info::set_patriarch_name(const ::std::string& value) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(value);
}
inline void family_list_info::set_patriarch_name(const char* value) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(value);
}
inline void family_list_info::set_patriarch_name(const char* value, size_t size) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_list_info::mutable_patriarch_name() {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  return patriarch_name_;
}
inline ::std::string* family_list_info::release_patriarch_name() {
  clear_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patriarch_name_;
    patriarch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_list_info::set_allocated_patriarch_name(::std::string* patriarch_name) {
  if (patriarch_name_ != &::google::protobuf::internal::kEmptyString) {
    delete patriarch_name_;
  }
  if (patriarch_name) {
    set_has_patriarch_name();
    patriarch_name_ = patriarch_name;
  } else {
    clear_has_patriarch_name();
    patriarch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string patriarch_uid = 4;
inline bool family_list_info::has_patriarch_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_list_info::set_has_patriarch_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_list_info::clear_has_patriarch_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_list_info::clear_patriarch_uid() {
  if (patriarch_uid_ != &::google::protobuf::internal::kEmptyString) {
    patriarch_uid_->clear();
  }
  clear_has_patriarch_uid();
}
inline const ::std::string& family_list_info::patriarch_uid() const {
  return *patriarch_uid_;
}
inline void family_list_info::set_patriarch_uid(const ::std::string& value) {
  set_has_patriarch_uid();
  if (patriarch_uid_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_uid_ = new ::std::string;
  }
  patriarch_uid_->assign(value);
}
inline void family_list_info::set_patriarch_uid(const char* value) {
  set_has_patriarch_uid();
  if (patriarch_uid_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_uid_ = new ::std::string;
  }
  patriarch_uid_->assign(value);
}
inline void family_list_info::set_patriarch_uid(const char* value, size_t size) {
  set_has_patriarch_uid();
  if (patriarch_uid_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_uid_ = new ::std::string;
  }
  patriarch_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_list_info::mutable_patriarch_uid() {
  set_has_patriarch_uid();
  if (patriarch_uid_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_uid_ = new ::std::string;
  }
  return patriarch_uid_;
}
inline ::std::string* family_list_info::release_patriarch_uid() {
  clear_has_patriarch_uid();
  if (patriarch_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patriarch_uid_;
    patriarch_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_list_info::set_allocated_patriarch_uid(::std::string* patriarch_uid) {
  if (patriarch_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete patriarch_uid_;
  }
  if (patriarch_uid) {
    set_has_patriarch_uid();
    patriarch_uid_ = patriarch_uid;
  } else {
    clear_has_patriarch_uid();
    patriarch_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// family_build_data

// optional .proto.common.family_build_type type = 1;
inline bool family_build_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_build_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_build_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_build_data::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::proto::common::family_build_type family_build_data::type() const {
  return static_cast< ::proto::common::family_build_type >(type_);
}
inline void family_build_data::set_type(::proto::common::family_build_type value) {
  assert(::proto::common::family_build_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 level = 2;
inline bool family_build_data::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_build_data::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_build_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_build_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_build_data::level() const {
  return level_;
}
inline void family_build_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 cd_time = 3;
inline bool family_build_data::has_cd_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_build_data::set_has_cd_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_build_data::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_build_data::clear_cd_time() {
  cd_time_ = 0u;
  clear_has_cd_time();
}
inline ::google::protobuf::uint32 family_build_data::cd_time() const {
  return cd_time_;
}
inline void family_build_data::set_cd_time(::google::protobuf::uint32 value) {
  set_has_cd_time();
  cd_time_ = value;
}

// -------------------------------------------------------------------

// family_apply_member

// optional string role_id = 1;
inline bool family_apply_member::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_apply_member::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_apply_member::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_apply_member::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& family_apply_member::role_id() const {
  return *role_id_;
}
inline void family_apply_member::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_apply_member::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_apply_member::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_apply_member::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* family_apply_member::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_apply_member::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool family_apply_member::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_apply_member::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_apply_member::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_apply_member::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& family_apply_member::role_name() const {
  return *role_name_;
}
inline void family_apply_member::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_apply_member::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_apply_member::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_apply_member::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* family_apply_member::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_apply_member::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool family_apply_member::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_apply_member::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_apply_member::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_apply_member::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_apply_member::level() const {
  return level_;
}
inline void family_apply_member::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 fighting = 4;
inline bool family_apply_member::has_fighting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_apply_member::set_has_fighting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_apply_member::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_apply_member::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 family_apply_member::fighting() const {
  return fighting_;
}
inline void family_apply_member::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 plugin = 5;
inline bool family_apply_member::has_plugin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_apply_member::set_has_plugin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_apply_member::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_apply_member::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 family_apply_member::plugin() const {
  return plugin_;
}
inline void family_apply_member::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 apply_time = 6;
inline bool family_apply_member::has_apply_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_apply_member::set_has_apply_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_apply_member::clear_has_apply_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_apply_member::clear_apply_time() {
  apply_time_ = 0u;
  clear_has_apply_time();
}
inline ::google::protobuf::uint32 family_apply_member::apply_time() const {
  return apply_time_;
}
inline void family_apply_member::set_apply_time(::google::protobuf::uint32 value) {
  set_has_apply_time();
  apply_time_ = value;
}

// -------------------------------------------------------------------

// family_gift_data

// optional string role_id = 1;
inline bool family_gift_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_gift_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_gift_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_gift_data::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& family_gift_data::role_id() const {
  return *role_id_;
}
inline void family_gift_data::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_gift_data::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_gift_data::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_gift_data::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* family_gift_data::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_gift_data::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gift_times = 2;
inline bool family_gift_data::has_gift_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_gift_data::set_has_gift_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_gift_data::clear_has_gift_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_gift_data::clear_gift_times() {
  gift_times_ = 0u;
  clear_has_gift_times();
}
inline ::google::protobuf::uint32 family_gift_data::gift_times() const {
  return gift_times_;
}
inline void family_gift_data::set_gift_times(::google::protobuf::uint32 value) {
  set_has_gift_times();
  gift_times_ = value;
}

// -------------------------------------------------------------------

// family_gift_data_list

// repeated .proto.common.family_gift_data gift_datas = 1;
inline int family_gift_data_list::gift_datas_size() const {
  return gift_datas_.size();
}
inline void family_gift_data_list::clear_gift_datas() {
  gift_datas_.Clear();
}
inline const ::proto::common::family_gift_data& family_gift_data_list::gift_datas(int index) const {
  return gift_datas_.Get(index);
}
inline ::proto::common::family_gift_data* family_gift_data_list::mutable_gift_datas(int index) {
  return gift_datas_.Mutable(index);
}
inline ::proto::common::family_gift_data* family_gift_data_list::add_gift_datas() {
  return gift_datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_gift_data >&
family_gift_data_list::gift_datas() const {
  return gift_datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_gift_data >*
family_gift_data_list::mutable_gift_datas() {
  return &gift_datas_;
}

// -------------------------------------------------------------------

// family_prayer_data

// optional string role_id = 1;
inline bool family_prayer_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_prayer_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_prayer_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_prayer_data::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& family_prayer_data::role_id() const {
  return *role_id_;
}
inline void family_prayer_data::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_prayer_data::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_prayer_data::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_prayer_data::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* family_prayer_data::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_prayer_data::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool family_prayer_data::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_prayer_data::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_prayer_data::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_prayer_data::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& family_prayer_data::role_name() const {
  return *role_name_;
}
inline void family_prayer_data::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_prayer_data::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_prayer_data::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_prayer_data::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* family_prayer_data::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_prayer_data::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 officer = 3;
inline bool family_prayer_data::has_officer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_prayer_data::set_has_officer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_prayer_data::clear_has_officer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_prayer_data::clear_officer() {
  officer_ = 0u;
  clear_has_officer();
}
inline ::google::protobuf::uint32 family_prayer_data::officer() const {
  return officer_;
}
inline void family_prayer_data::set_officer(::google::protobuf::uint32 value) {
  set_has_officer();
  officer_ = value;
}

// optional uint32 plugin = 4;
inline bool family_prayer_data::has_plugin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_prayer_data::set_has_plugin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_prayer_data::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_prayer_data::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 family_prayer_data::plugin() const {
  return plugin_;
}
inline void family_prayer_data::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 level = 5;
inline bool family_prayer_data::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_prayer_data::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_prayer_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_prayer_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_prayer_data::level() const {
  return level_;
}
inline void family_prayer_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 prayer_contribution = 6;
inline bool family_prayer_data::has_prayer_contribution() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_prayer_data::set_has_prayer_contribution() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_prayer_data::clear_has_prayer_contribution() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_prayer_data::clear_prayer_contribution() {
  prayer_contribution_ = 0u;
  clear_has_prayer_contribution();
}
inline ::google::protobuf::uint32 family_prayer_data::prayer_contribution() const {
  return prayer_contribution_;
}
inline void family_prayer_data::set_prayer_contribution(::google::protobuf::uint32 value) {
  set_has_prayer_contribution();
  prayer_contribution_ = value;
}

// optional uint32 hero_tid = 7;
inline bool family_prayer_data::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void family_prayer_data::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void family_prayer_data::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void family_prayer_data::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 family_prayer_data::hero_tid() const {
  return hero_tid_;
}
inline void family_prayer_data::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional uint32 hero_curr_num = 8;
inline bool family_prayer_data::has_hero_curr_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void family_prayer_data::set_has_hero_curr_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void family_prayer_data::clear_has_hero_curr_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void family_prayer_data::clear_hero_curr_num() {
  hero_curr_num_ = 0u;
  clear_has_hero_curr_num();
}
inline ::google::protobuf::uint32 family_prayer_data::hero_curr_num() const {
  return hero_curr_num_;
}
inline void family_prayer_data::set_hero_curr_num(::google::protobuf::uint32 value) {
  set_has_hero_curr_num();
  hero_curr_num_ = value;
}

// optional uint32 hero_max_num = 9;
inline bool family_prayer_data::has_hero_max_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void family_prayer_data::set_has_hero_max_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void family_prayer_data::clear_has_hero_max_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void family_prayer_data::clear_hero_max_num() {
  hero_max_num_ = 0u;
  clear_has_hero_max_num();
}
inline ::google::protobuf::uint32 family_prayer_data::hero_max_num() const {
  return hero_max_num_;
}
inline void family_prayer_data::set_hero_max_num(::google::protobuf::uint32 value) {
  set_has_hero_max_num();
  hero_max_num_ = value;
}

// optional uint32 start_time = 10;
inline bool family_prayer_data::has_start_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void family_prayer_data::set_has_start_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void family_prayer_data::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void family_prayer_data::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 family_prayer_data::start_time() const {
  return start_time_;
}
inline void family_prayer_data::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 complete_time = 11;
inline bool family_prayer_data::has_complete_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void family_prayer_data::set_has_complete_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void family_prayer_data::clear_has_complete_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void family_prayer_data::clear_complete_time() {
  complete_time_ = 0u;
  clear_has_complete_time();
}
inline ::google::protobuf::uint32 family_prayer_data::complete_time() const {
  return complete_time_;
}
inline void family_prayer_data::set_complete_time(::google::protobuf::uint32 value) {
  set_has_complete_time();
  complete_time_ = value;
}

// optional .proto.common.family_gift_data_list list = 12;
inline bool family_prayer_data::has_list() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void family_prayer_data::set_has_list() {
  _has_bits_[0] |= 0x00000800u;
}
inline void family_prayer_data::clear_has_list() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void family_prayer_data::clear_list() {
  if (list_ != NULL) list_->::proto::common::family_gift_data_list::Clear();
  clear_has_list();
}
inline const ::proto::common::family_gift_data_list& family_prayer_data::list() const {
  return list_ != NULL ? *list_ : *default_instance_->list_;
}
inline ::proto::common::family_gift_data_list* family_prayer_data::mutable_list() {
  set_has_list();
  if (list_ == NULL) list_ = new ::proto::common::family_gift_data_list;
  return list_;
}
inline ::proto::common::family_gift_data_list* family_prayer_data::release_list() {
  clear_has_list();
  ::proto::common::family_gift_data_list* temp = list_;
  list_ = NULL;
  return temp;
}
inline void family_prayer_data::set_allocated_list(::proto::common::family_gift_data_list* list) {
  delete list_;
  list_ = list;
  if (list) {
    set_has_list();
  } else {
    clear_has_list();
  }
}

// -------------------------------------------------------------------

// family_prayer_list

// repeated .proto.common.family_prayer_data lists = 1;
inline int family_prayer_list::lists_size() const {
  return lists_.size();
}
inline void family_prayer_list::clear_lists() {
  lists_.Clear();
}
inline const ::proto::common::family_prayer_data& family_prayer_list::lists(int index) const {
  return lists_.Get(index);
}
inline ::proto::common::family_prayer_data* family_prayer_list::mutable_lists(int index) {
  return lists_.Mutable(index);
}
inline ::proto::common::family_prayer_data* family_prayer_list::add_lists() {
  return lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_data >&
family_prayer_list::lists() const {
  return lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_data >*
family_prayer_list::mutable_lists() {
  return &lists_;
}

// -------------------------------------------------------------------

// family_prayer_record_data

// optional string role_id = 1;
inline bool family_prayer_record_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_prayer_record_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_prayer_record_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_prayer_record_data::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& family_prayer_record_data::role_id() const {
  return *role_id_;
}
inline void family_prayer_record_data::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_prayer_record_data::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void family_prayer_record_data::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_prayer_record_data::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* family_prayer_record_data::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_prayer_record_data::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool family_prayer_record_data::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_prayer_record_data::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_prayer_record_data::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_prayer_record_data::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& family_prayer_record_data::role_name() const {
  return *role_name_;
}
inline void family_prayer_record_data::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_prayer_record_data::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void family_prayer_record_data::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_prayer_record_data::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* family_prayer_record_data::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_prayer_record_data::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 officer = 3;
inline bool family_prayer_record_data::has_officer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_prayer_record_data::set_has_officer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_prayer_record_data::clear_has_officer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_prayer_record_data::clear_officer() {
  officer_ = 0u;
  clear_has_officer();
}
inline ::google::protobuf::uint32 family_prayer_record_data::officer() const {
  return officer_;
}
inline void family_prayer_record_data::set_officer(::google::protobuf::uint32 value) {
  set_has_officer();
  officer_ = value;
}

// optional uint32 plugin = 4;
inline bool family_prayer_record_data::has_plugin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_prayer_record_data::set_has_plugin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_prayer_record_data::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_prayer_record_data::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 family_prayer_record_data::plugin() const {
  return plugin_;
}
inline void family_prayer_record_data::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 time = 5;
inline bool family_prayer_record_data::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_prayer_record_data::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_prayer_record_data::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_prayer_record_data::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 family_prayer_record_data::time() const {
  return time_;
}
inline void family_prayer_record_data::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 hero_tid = 6;
inline bool family_prayer_record_data::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_prayer_record_data::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_prayer_record_data::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_prayer_record_data::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 family_prayer_record_data::hero_tid() const {
  return hero_tid_;
}
inline void family_prayer_record_data::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional uint32 hero_num = 7;
inline bool family_prayer_record_data::has_hero_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void family_prayer_record_data::set_has_hero_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void family_prayer_record_data::clear_has_hero_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void family_prayer_record_data::clear_hero_num() {
  hero_num_ = 0u;
  clear_has_hero_num();
}
inline ::google::protobuf::uint32 family_prayer_record_data::hero_num() const {
  return hero_num_;
}
inline void family_prayer_record_data::set_hero_num(::google::protobuf::uint32 value) {
  set_has_hero_num();
  hero_num_ = value;
}

// optional uint32 level = 8;
inline bool family_prayer_record_data::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void family_prayer_record_data::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void family_prayer_record_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void family_prayer_record_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 family_prayer_record_data::level() const {
  return level_;
}
inline void family_prayer_record_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// family_prayer_record_list

// repeated .proto.common.family_prayer_record_data gift_list = 1;
inline int family_prayer_record_list::gift_list_size() const {
  return gift_list_.size();
}
inline void family_prayer_record_list::clear_gift_list() {
  gift_list_.Clear();
}
inline const ::proto::common::family_prayer_record_data& family_prayer_record_list::gift_list(int index) const {
  return gift_list_.Get(index);
}
inline ::proto::common::family_prayer_record_data* family_prayer_record_list::mutable_gift_list(int index) {
  return gift_list_.Mutable(index);
}
inline ::proto::common::family_prayer_record_data* family_prayer_record_list::add_gift_list() {
  return gift_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >&
family_prayer_record_list::gift_list() const {
  return gift_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >*
family_prayer_record_list::mutable_gift_list() {
  return &gift_list_;
}

// repeated .proto.common.family_prayer_record_data receive_list = 2;
inline int family_prayer_record_list::receive_list_size() const {
  return receive_list_.size();
}
inline void family_prayer_record_list::clear_receive_list() {
  receive_list_.Clear();
}
inline const ::proto::common::family_prayer_record_data& family_prayer_record_list::receive_list(int index) const {
  return receive_list_.Get(index);
}
inline ::proto::common::family_prayer_record_data* family_prayer_record_list::mutable_receive_list(int index) {
  return receive_list_.Mutable(index);
}
inline ::proto::common::family_prayer_record_data* family_prayer_record_list::add_receive_list() {
  return receive_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >&
family_prayer_record_list::receive_list() const {
  return receive_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_prayer_record_data >*
family_prayer_record_list::mutable_receive_list() {
  return &receive_list_;
}

// -------------------------------------------------------------------

// family_invite_result

// optional uint32 result = 1;
inline bool family_invite_result::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_invite_result::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_invite_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_invite_result::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 family_invite_result::result() const {
  return result_;
}
inline void family_invite_result::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional string family_uid = 2;
inline bool family_invite_result::has_family_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_invite_result::set_has_family_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_invite_result::clear_has_family_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_invite_result::clear_family_uid() {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    family_uid_->clear();
  }
  clear_has_family_uid();
}
inline const ::std::string& family_invite_result::family_uid() const {
  return *family_uid_;
}
inline void family_invite_result::set_family_uid(const ::std::string& value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void family_invite_result::set_family_uid(const char* value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void family_invite_result::set_family_uid(const char* value, size_t size) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_invite_result::mutable_family_uid() {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  return family_uid_;
}
inline ::std::string* family_invite_result::release_family_uid() {
  clear_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_uid_;
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_invite_result::set_allocated_family_uid(::std::string* family_uid) {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete family_uid_;
  }
  if (family_uid) {
    set_has_family_uid();
    family_uid_ = family_uid;
  } else {
    clear_has_family_uid();
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inviter_uid = 3;
inline bool family_invite_result::has_inviter_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_invite_result::set_has_inviter_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_invite_result::clear_has_inviter_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_invite_result::clear_inviter_uid() {
  if (inviter_uid_ != &::google::protobuf::internal::kEmptyString) {
    inviter_uid_->clear();
  }
  clear_has_inviter_uid();
}
inline const ::std::string& family_invite_result::inviter_uid() const {
  return *inviter_uid_;
}
inline void family_invite_result::set_inviter_uid(const ::std::string& value) {
  set_has_inviter_uid();
  if (inviter_uid_ == &::google::protobuf::internal::kEmptyString) {
    inviter_uid_ = new ::std::string;
  }
  inviter_uid_->assign(value);
}
inline void family_invite_result::set_inviter_uid(const char* value) {
  set_has_inviter_uid();
  if (inviter_uid_ == &::google::protobuf::internal::kEmptyString) {
    inviter_uid_ = new ::std::string;
  }
  inviter_uid_->assign(value);
}
inline void family_invite_result::set_inviter_uid(const char* value, size_t size) {
  set_has_inviter_uid();
  if (inviter_uid_ == &::google::protobuf::internal::kEmptyString) {
    inviter_uid_ = new ::std::string;
  }
  inviter_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_invite_result::mutable_inviter_uid() {
  set_has_inviter_uid();
  if (inviter_uid_ == &::google::protobuf::internal::kEmptyString) {
    inviter_uid_ = new ::std::string;
  }
  return inviter_uid_;
}
inline ::std::string* family_invite_result::release_inviter_uid() {
  clear_has_inviter_uid();
  if (inviter_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inviter_uid_;
    inviter_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_invite_result::set_allocated_inviter_uid(::std::string* inviter_uid) {
  if (inviter_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete inviter_uid_;
  }
  if (inviter_uid) {
    set_has_inviter_uid();
    inviter_uid_ = inviter_uid;
  } else {
    clear_has_inviter_uid();
    inviter_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// family_shop_item

// optional uint32 shop_item = 1;
inline bool family_shop_item::has_shop_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_shop_item::set_has_shop_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_shop_item::clear_has_shop_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_shop_item::clear_shop_item() {
  shop_item_ = 0u;
  clear_has_shop_item();
}
inline ::google::protobuf::uint32 family_shop_item::shop_item() const {
  return shop_item_;
}
inline void family_shop_item::set_shop_item(::google::protobuf::uint32 value) {
  set_has_shop_item();
  shop_item_ = value;
}

// optional uint32 sold_count = 2;
inline bool family_shop_item::has_sold_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_shop_item::set_has_sold_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_shop_item::clear_has_sold_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_shop_item::clear_sold_count() {
  sold_count_ = 0u;
  clear_has_sold_count();
}
inline ::google::protobuf::uint32 family_shop_item::sold_count() const {
  return sold_count_;
}
inline void family_shop_item::set_sold_count(::google::protobuf::uint32 value) {
  set_has_sold_count();
  sold_count_ = value;
}

// -------------------------------------------------------------------

// family_shop_data

// optional uint32 next_refresh_time = 1;
inline bool family_shop_data::has_next_refresh_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_shop_data::set_has_next_refresh_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_shop_data::clear_has_next_refresh_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_shop_data::clear_next_refresh_time() {
  next_refresh_time_ = 0u;
  clear_has_next_refresh_time();
}
inline ::google::protobuf::uint32 family_shop_data::next_refresh_time() const {
  return next_refresh_time_;
}
inline void family_shop_data::set_next_refresh_time(::google::protobuf::uint32 value) {
  set_has_next_refresh_time();
  next_refresh_time_ = value;
}

// repeated .proto.common.family_shop_item items = 2;
inline int family_shop_data::items_size() const {
  return items_.size();
}
inline void family_shop_data::clear_items() {
  items_.Clear();
}
inline const ::proto::common::family_shop_item& family_shop_data::items(int index) const {
  return items_.Get(index);
}
inline ::proto::common::family_shop_item* family_shop_data::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::proto::common::family_shop_item* family_shop_data::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_item >&
family_shop_data::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_item >*
family_shop_data::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// family_shop_personal_item

// optional uint32 shop_index = 1;
inline bool family_shop_personal_item::has_shop_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_shop_personal_item::set_has_shop_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_shop_personal_item::clear_has_shop_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_shop_personal_item::clear_shop_index() {
  shop_index_ = 0u;
  clear_has_shop_index();
}
inline ::google::protobuf::uint32 family_shop_personal_item::shop_index() const {
  return shop_index_;
}
inline void family_shop_personal_item::set_shop_index(::google::protobuf::uint32 value) {
  set_has_shop_index();
  shop_index_ = value;
}

// optional uint32 buy_count = 2;
inline bool family_shop_personal_item::has_buy_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_shop_personal_item::set_has_buy_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_shop_personal_item::clear_has_buy_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_shop_personal_item::clear_buy_count() {
  buy_count_ = 0u;
  clear_has_buy_count();
}
inline ::google::protobuf::uint32 family_shop_personal_item::buy_count() const {
  return buy_count_;
}
inline void family_shop_personal_item::set_buy_count(::google::protobuf::uint32 value) {
  set_has_buy_count();
  buy_count_ = value;
}

// -------------------------------------------------------------------

// family_shop_personal_data

// optional uint32 next_refresh_time = 1;
inline bool family_shop_personal_data::has_next_refresh_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_shop_personal_data::set_has_next_refresh_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_shop_personal_data::clear_has_next_refresh_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_shop_personal_data::clear_next_refresh_time() {
  next_refresh_time_ = 0u;
  clear_has_next_refresh_time();
}
inline ::google::protobuf::uint32 family_shop_personal_data::next_refresh_time() const {
  return next_refresh_time_;
}
inline void family_shop_personal_data::set_next_refresh_time(::google::protobuf::uint32 value) {
  set_has_next_refresh_time();
  next_refresh_time_ = value;
}

// repeated .proto.common.family_shop_personal_item items = 2;
inline int family_shop_personal_data::items_size() const {
  return items_.size();
}
inline void family_shop_personal_data::clear_items() {
  items_.Clear();
}
inline const ::proto::common::family_shop_personal_item& family_shop_personal_data::items(int index) const {
  return items_.Get(index);
}
inline ::proto::common::family_shop_personal_item* family_shop_personal_data::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::proto::common::family_shop_personal_item* family_shop_personal_data::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_personal_item >&
family_shop_personal_data::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_shop_personal_item >*
family_shop_personal_data::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// family_impeach_data

// optional string impeacher = 1;
inline bool family_impeach_data::has_impeacher() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_impeach_data::set_has_impeacher() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_impeach_data::clear_has_impeacher() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_impeach_data::clear_impeacher() {
  if (impeacher_ != &::google::protobuf::internal::kEmptyString) {
    impeacher_->clear();
  }
  clear_has_impeacher();
}
inline const ::std::string& family_impeach_data::impeacher() const {
  return *impeacher_;
}
inline void family_impeach_data::set_impeacher(const ::std::string& value) {
  set_has_impeacher();
  if (impeacher_ == &::google::protobuf::internal::kEmptyString) {
    impeacher_ = new ::std::string;
  }
  impeacher_->assign(value);
}
inline void family_impeach_data::set_impeacher(const char* value) {
  set_has_impeacher();
  if (impeacher_ == &::google::protobuf::internal::kEmptyString) {
    impeacher_ = new ::std::string;
  }
  impeacher_->assign(value);
}
inline void family_impeach_data::set_impeacher(const char* value, size_t size) {
  set_has_impeacher();
  if (impeacher_ == &::google::protobuf::internal::kEmptyString) {
    impeacher_ = new ::std::string;
  }
  impeacher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_impeach_data::mutable_impeacher() {
  set_has_impeacher();
  if (impeacher_ == &::google::protobuf::internal::kEmptyString) {
    impeacher_ = new ::std::string;
  }
  return impeacher_;
}
inline ::std::string* family_impeach_data::release_impeacher() {
  clear_has_impeacher();
  if (impeacher_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = impeacher_;
    impeacher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_impeach_data::set_allocated_impeacher(::std::string* impeacher) {
  if (impeacher_ != &::google::protobuf::internal::kEmptyString) {
    delete impeacher_;
  }
  if (impeacher) {
    set_has_impeacher();
    impeacher_ = impeacher;
  } else {
    clear_has_impeacher();
    impeacher_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 approve_impeach_cnt = 2;
inline bool family_impeach_data::has_approve_impeach_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_impeach_data::set_has_approve_impeach_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_impeach_data::clear_has_approve_impeach_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_impeach_data::clear_approve_impeach_cnt() {
  approve_impeach_cnt_ = 0u;
  clear_has_approve_impeach_cnt();
}
inline ::google::protobuf::uint32 family_impeach_data::approve_impeach_cnt() const {
  return approve_impeach_cnt_;
}
inline void family_impeach_data::set_approve_impeach_cnt(::google::protobuf::uint32 value) {
  set_has_approve_impeach_cnt();
  approve_impeach_cnt_ = value;
}

// optional uint32 time_left = 3;
inline bool family_impeach_data::has_time_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_impeach_data::set_has_time_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_impeach_data::clear_has_time_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_impeach_data::clear_time_left() {
  time_left_ = 0u;
  clear_has_time_left();
}
inline ::google::protobuf::uint32 family_impeach_data::time_left() const {
  return time_left_;
}
inline void family_impeach_data::set_time_left(::google::protobuf::uint32 value) {
  set_has_time_left();
  time_left_ = value;
}

// -------------------------------------------------------------------

// family_war_data

// optional string family_id = 1;
inline bool family_war_data::has_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_war_data::set_has_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_war_data::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_war_data::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& family_war_data::family_id() const {
  return *family_id_;
}
inline void family_war_data::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void family_war_data::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void family_war_data::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_war_data::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* family_war_data::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_war_data::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 2;
inline bool family_war_data::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_war_data::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_war_data::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_war_data::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& family_war_data::family_name() const {
  return *family_name_;
}
inline void family_war_data::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void family_war_data::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void family_war_data::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_war_data::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* family_war_data::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_war_data::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 family_prestige = 3;
inline bool family_war_data::has_family_prestige() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_war_data::set_has_family_prestige() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_war_data::clear_has_family_prestige() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_war_data::clear_family_prestige() {
  family_prestige_ = 0u;
  clear_has_family_prestige();
}
inline ::google::protobuf::uint32 family_war_data::family_prestige() const {
  return family_prestige_;
}
inline void family_war_data::set_family_prestige(::google::protobuf::uint32 value) {
  set_has_family_prestige();
  family_prestige_ = value;
}

// optional uint32 family_score = 4;
inline bool family_war_data::has_family_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void family_war_data::set_has_family_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void family_war_data::clear_has_family_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void family_war_data::clear_family_score() {
  family_score_ = 0u;
  clear_has_family_score();
}
inline ::google::protobuf::uint32 family_war_data::family_score() const {
  return family_score_;
}
inline void family_war_data::set_family_score(::google::protobuf::uint32 value) {
  set_has_family_score();
  family_score_ = value;
}

// optional uint32 family_rank = 5;
inline bool family_war_data::has_family_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void family_war_data::set_has_family_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void family_war_data::clear_has_family_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void family_war_data::clear_family_rank() {
  family_rank_ = 0u;
  clear_has_family_rank();
}
inline ::google::protobuf::uint32 family_war_data::family_rank() const {
  return family_rank_;
}
inline void family_war_data::set_family_rank(::google::protobuf::uint32 value) {
  set_has_family_rank();
  family_rank_ = value;
}

// optional .proto.common.family_war_result result = 6 [default = family_war_result_none];
inline bool family_war_data::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void family_war_data::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void family_war_data::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void family_war_data::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::common::family_war_result family_war_data::result() const {
  return static_cast< ::proto::common::family_war_result >(result_);
}
inline void family_war_data::set_result(::proto::common::family_war_result value) {
  assert(::proto::common::family_war_result_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// family_against_data

// optional .proto.common.family_war_data left_side = 1;
inline bool family_against_data::has_left_side() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_against_data::set_has_left_side() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_against_data::clear_has_left_side() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_against_data::clear_left_side() {
  if (left_side_ != NULL) left_side_->::proto::common::family_war_data::Clear();
  clear_has_left_side();
}
inline const ::proto::common::family_war_data& family_against_data::left_side() const {
  return left_side_ != NULL ? *left_side_ : *default_instance_->left_side_;
}
inline ::proto::common::family_war_data* family_against_data::mutable_left_side() {
  set_has_left_side();
  if (left_side_ == NULL) left_side_ = new ::proto::common::family_war_data;
  return left_side_;
}
inline ::proto::common::family_war_data* family_against_data::release_left_side() {
  clear_has_left_side();
  ::proto::common::family_war_data* temp = left_side_;
  left_side_ = NULL;
  return temp;
}
inline void family_against_data::set_allocated_left_side(::proto::common::family_war_data* left_side) {
  delete left_side_;
  left_side_ = left_side;
  if (left_side) {
    set_has_left_side();
  } else {
    clear_has_left_side();
  }
}

// optional .proto.common.family_war_data right_side = 2;
inline bool family_against_data::has_right_side() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_against_data::set_has_right_side() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_against_data::clear_has_right_side() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_against_data::clear_right_side() {
  if (right_side_ != NULL) right_side_->::proto::common::family_war_data::Clear();
  clear_has_right_side();
}
inline const ::proto::common::family_war_data& family_against_data::right_side() const {
  return right_side_ != NULL ? *right_side_ : *default_instance_->right_side_;
}
inline ::proto::common::family_war_data* family_against_data::mutable_right_side() {
  set_has_right_side();
  if (right_side_ == NULL) right_side_ = new ::proto::common::family_war_data;
  return right_side_;
}
inline ::proto::common::family_war_data* family_against_data::release_right_side() {
  clear_has_right_side();
  ::proto::common::family_war_data* temp = right_side_;
  right_side_ = NULL;
  return temp;
}
inline void family_against_data::set_allocated_right_side(::proto::common::family_war_data* right_side) {
  delete right_side_;
  right_side_ = right_side;
  if (right_side) {
    set_has_right_side();
  } else {
    clear_has_right_side();
  }
}

// -------------------------------------------------------------------

// family_object_pos

// optional uint32 pos_x = 1;
inline bool family_object_pos::has_pos_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_object_pos::set_has_pos_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_object_pos::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_object_pos::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 family_object_pos::pos_x() const {
  return pos_x_;
}
inline void family_object_pos::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional uint32 pos_y = 2;
inline bool family_object_pos::has_pos_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_object_pos::set_has_pos_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_object_pos::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_object_pos::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 family_object_pos::pos_y() const {
  return pos_y_;
}
inline void family_object_pos::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// family_against_list

// repeated .proto.common.family_against_data data_list = 1;
inline int family_against_list::data_list_size() const {
  return data_list_.size();
}
inline void family_against_list::clear_data_list() {
  data_list_.Clear();
}
inline const ::proto::common::family_against_data& family_against_list::data_list(int index) const {
  return data_list_.Get(index);
}
inline ::proto::common::family_against_data* family_against_list::mutable_data_list(int index) {
  return data_list_.Mutable(index);
}
inline ::proto::common::family_against_data* family_against_list::add_data_list() {
  return data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_against_data >&
family_against_list::data_list() const {
  return data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_against_data >*
family_against_list::mutable_data_list() {
  return &data_list_;
}

// -------------------------------------------------------------------

// family_war_history_data

// repeated .proto.common.family_war_data data = 1;
inline int family_war_history_data::data_size() const {
  return data_.size();
}
inline void family_war_history_data::clear_data() {
  data_.Clear();
}
inline const ::proto::common::family_war_data& family_war_history_data::data(int index) const {
  return data_.Get(index);
}
inline ::proto::common::family_war_data* family_war_history_data::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::proto::common::family_war_data* family_war_history_data::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_war_data >&
family_war_history_data::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_war_data >*
family_war_history_data::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// family_war_hero_data

// optional string hero_uid = 1;
inline bool family_war_hero_data::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_war_hero_data::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_war_hero_data::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_war_hero_data::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& family_war_hero_data::hero_uid() const {
  return *hero_uid_;
}
inline void family_war_hero_data::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void family_war_hero_data::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void family_war_hero_data::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* family_war_hero_data::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* family_war_hero_data::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void family_war_hero_data::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.family_war_hero_type type = 2;
inline bool family_war_hero_data::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_war_hero_data::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_war_hero_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_war_hero_data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::common::family_war_hero_type family_war_hero_data::type() const {
  return static_cast< ::proto::common::family_war_hero_type >(type_);
}
inline void family_war_hero_data::set_type(::proto::common::family_war_hero_type value) {
  assert(::proto::common::family_war_hero_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// country_base_data

// optional uint32 id = 1;
inline bool country_base_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_base_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_base_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_base_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 country_base_data::id() const {
  return id_;
}
inline void country_base_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string king_name = 2;
inline bool country_base_data::has_king_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_base_data::set_has_king_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_base_data::clear_has_king_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_base_data::clear_king_name() {
  if (king_name_ != &::google::protobuf::internal::kEmptyString) {
    king_name_->clear();
  }
  clear_has_king_name();
}
inline const ::std::string& country_base_data::king_name() const {
  return *king_name_;
}
inline void country_base_data::set_king_name(const ::std::string& value) {
  set_has_king_name();
  if (king_name_ == &::google::protobuf::internal::kEmptyString) {
    king_name_ = new ::std::string;
  }
  king_name_->assign(value);
}
inline void country_base_data::set_king_name(const char* value) {
  set_has_king_name();
  if (king_name_ == &::google::protobuf::internal::kEmptyString) {
    king_name_ = new ::std::string;
  }
  king_name_->assign(value);
}
inline void country_base_data::set_king_name(const char* value, size_t size) {
  set_has_king_name();
  if (king_name_ == &::google::protobuf::internal::kEmptyString) {
    king_name_ = new ::std::string;
  }
  king_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_base_data::mutable_king_name() {
  set_has_king_name();
  if (king_name_ == &::google::protobuf::internal::kEmptyString) {
    king_name_ = new ::std::string;
  }
  return king_name_;
}
inline ::std::string* country_base_data::release_king_name() {
  clear_has_king_name();
  if (king_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = king_name_;
    king_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_base_data::set_allocated_king_name(::std::string* king_name) {
  if (king_name_ != &::google::protobuf::internal::kEmptyString) {
    delete king_name_;
  }
  if (king_name) {
    set_has_king_name();
    king_name_ = king_name;
  } else {
    clear_has_king_name();
    king_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string king_family = 3;
inline bool country_base_data::has_king_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_base_data::set_has_king_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_base_data::clear_has_king_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_base_data::clear_king_family() {
  if (king_family_ != &::google::protobuf::internal::kEmptyString) {
    king_family_->clear();
  }
  clear_has_king_family();
}
inline const ::std::string& country_base_data::king_family() const {
  return *king_family_;
}
inline void country_base_data::set_king_family(const ::std::string& value) {
  set_has_king_family();
  if (king_family_ == &::google::protobuf::internal::kEmptyString) {
    king_family_ = new ::std::string;
  }
  king_family_->assign(value);
}
inline void country_base_data::set_king_family(const char* value) {
  set_has_king_family();
  if (king_family_ == &::google::protobuf::internal::kEmptyString) {
    king_family_ = new ::std::string;
  }
  king_family_->assign(value);
}
inline void country_base_data::set_king_family(const char* value, size_t size) {
  set_has_king_family();
  if (king_family_ == &::google::protobuf::internal::kEmptyString) {
    king_family_ = new ::std::string;
  }
  king_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_base_data::mutable_king_family() {
  set_has_king_family();
  if (king_family_ == &::google::protobuf::internal::kEmptyString) {
    king_family_ = new ::std::string;
  }
  return king_family_;
}
inline ::std::string* country_base_data::release_king_family() {
  clear_has_king_family();
  if (king_family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = king_family_;
    king_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_base_data::set_allocated_king_family(::std::string* king_family) {
  if (king_family_ != &::google::protobuf::internal::kEmptyString) {
    delete king_family_;
  }
  if (king_family) {
    set_has_king_family();
    king_family_ = king_family;
  } else {
    clear_has_king_family();
    king_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string notice = 4;
inline bool country_base_data::has_notice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void country_base_data::set_has_notice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void country_base_data::clear_has_notice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void country_base_data::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& country_base_data::notice() const {
  return *notice_;
}
inline void country_base_data::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void country_base_data::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void country_base_data::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_base_data::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* country_base_data::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_base_data::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 5;
inline bool country_base_data::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void country_base_data::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void country_base_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void country_base_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& country_base_data::name() const {
  return *name_;
}
inline void country_base_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void country_base_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void country_base_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_base_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* country_base_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_base_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 flag = 6;
inline bool country_base_data::has_flag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void country_base_data::set_has_flag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void country_base_data::clear_has_flag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void country_base_data::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 country_base_data::flag() const {
  return flag_;
}
inline void country_base_data::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// optional string year_name = 7;
inline bool country_base_data::has_year_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void country_base_data::set_has_year_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void country_base_data::clear_has_year_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void country_base_data::clear_year_name() {
  if (year_name_ != &::google::protobuf::internal::kEmptyString) {
    year_name_->clear();
  }
  clear_has_year_name();
}
inline const ::std::string& country_base_data::year_name() const {
  return *year_name_;
}
inline void country_base_data::set_year_name(const ::std::string& value) {
  set_has_year_name();
  if (year_name_ == &::google::protobuf::internal::kEmptyString) {
    year_name_ = new ::std::string;
  }
  year_name_->assign(value);
}
inline void country_base_data::set_year_name(const char* value) {
  set_has_year_name();
  if (year_name_ == &::google::protobuf::internal::kEmptyString) {
    year_name_ = new ::std::string;
  }
  year_name_->assign(value);
}
inline void country_base_data::set_year_name(const char* value, size_t size) {
  set_has_year_name();
  if (year_name_ == &::google::protobuf::internal::kEmptyString) {
    year_name_ = new ::std::string;
  }
  year_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_base_data::mutable_year_name() {
  set_has_year_name();
  if (year_name_ == &::google::protobuf::internal::kEmptyString) {
    year_name_ = new ::std::string;
  }
  return year_name_;
}
inline ::std::string* country_base_data::release_year_name() {
  clear_has_year_name();
  if (year_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = year_name_;
    year_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_base_data::set_allocated_year_name(::std::string* year_name) {
  if (year_name_ != &::google::protobuf::internal::kEmptyString) {
    delete year_name_;
  }
  if (year_name) {
    set_has_year_name();
    year_name_ = year_name;
  } else {
    clear_has_year_name();
    year_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// country_officer_data

// optional string uid = 1;
inline bool country_officer_data::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_officer_data::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_officer_data::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_officer_data::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& country_officer_data::uid() const {
  return *uid_;
}
inline void country_officer_data::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void country_officer_data::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void country_officer_data::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_officer_data::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* country_officer_data::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_officer_data::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool country_officer_data::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_officer_data::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_officer_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_officer_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& country_officer_data::name() const {
  return *name_;
}
inline void country_officer_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void country_officer_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void country_officer_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_officer_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* country_officer_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_officer_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 3;
inline bool country_officer_data::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_officer_data::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_officer_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_officer_data::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 country_officer_data::type() const {
  return type_;
}
inline void country_officer_data::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 plugin = 4;
inline bool country_officer_data::has_plugin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void country_officer_data::set_has_plugin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void country_officer_data::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void country_officer_data::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 country_officer_data::plugin() const {
  return plugin_;
}
inline void country_officer_data::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 refresh = 5;
inline bool country_officer_data::has_refresh() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void country_officer_data::set_has_refresh() {
  _has_bits_[0] |= 0x00000010u;
}
inline void country_officer_data::clear_has_refresh() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void country_officer_data::clear_refresh() {
  refresh_ = 0u;
  clear_has_refresh();
}
inline ::google::protobuf::uint32 country_officer_data::refresh() const {
  return refresh_;
}
inline void country_officer_data::set_refresh(::google::protobuf::uint32 value) {
  set_has_refresh();
  refresh_ = value;
}

// optional uint32 level = 6;
inline bool country_officer_data::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void country_officer_data::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void country_officer_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void country_officer_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 country_officer_data::level() const {
  return level_;
}
inline void country_officer_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 fighting = 7;
inline bool country_officer_data::has_fighting() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void country_officer_data::set_has_fighting() {
  _has_bits_[0] |= 0x00000040u;
}
inline void country_officer_data::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void country_officer_data::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 country_officer_data::fighting() const {
  return fighting_;
}
inline void country_officer_data::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 hero_plugin = 8;
inline bool country_officer_data::has_hero_plugin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void country_officer_data::set_has_hero_plugin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void country_officer_data::clear_has_hero_plugin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void country_officer_data::clear_hero_plugin() {
  hero_plugin_ = 0u;
  clear_has_hero_plugin();
}
inline ::google::protobuf::uint32 country_officer_data::hero_plugin() const {
  return hero_plugin_;
}
inline void country_officer_data::set_hero_plugin(::google::protobuf::uint32 value) {
  set_has_hero_plugin();
  hero_plugin_ = value;
}

// -------------------------------------------------------------------

// country_info_data

// optional .proto.common.country_base_data base = 1;
inline bool country_info_data::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_info_data::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_info_data::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_info_data::clear_base() {
  if (base_ != NULL) base_->::proto::common::country_base_data::Clear();
  clear_has_base();
}
inline const ::proto::common::country_base_data& country_info_data::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::proto::common::country_base_data* country_info_data::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::proto::common::country_base_data;
  return base_;
}
inline ::proto::common::country_base_data* country_info_data::release_base() {
  clear_has_base();
  ::proto::common::country_base_data* temp = base_;
  base_ = NULL;
  return temp;
}
inline void country_info_data::set_allocated_base(::proto::common::country_base_data* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional uint32 money = 2;
inline bool country_info_data::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_info_data::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_info_data::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_info_data::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 country_info_data::money() const {
  return money_;
}
inline void country_info_data::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 power = 3;
inline bool country_info_data::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_info_data::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_info_data::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_info_data::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 country_info_data::power() const {
  return power_;
}
inline void country_info_data::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
}

// optional uint32 level_type = 4;
inline bool country_info_data::has_level_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void country_info_data::set_has_level_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void country_info_data::clear_has_level_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void country_info_data::clear_level_type() {
  level_type_ = 0u;
  clear_has_level_type();
}
inline ::google::protobuf::uint32 country_info_data::level_type() const {
  return level_type_;
}
inline void country_info_data::set_level_type(::google::protobuf::uint32 value) {
  set_has_level_type();
  level_type_ = value;
}

// optional uint32 free_times = 5;
inline bool country_info_data::has_free_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void country_info_data::set_has_free_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void country_info_data::clear_has_free_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void country_info_data::clear_free_times() {
  free_times_ = 0u;
  clear_has_free_times();
}
inline ::google::protobuf::uint32 country_info_data::free_times() const {
  return free_times_;
}
inline void country_info_data::set_free_times(::google::protobuf::uint32 value) {
  set_has_free_times();
  free_times_ = value;
}

// optional uint32 free_times2 = 6;
inline bool country_info_data::has_free_times2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void country_info_data::set_has_free_times2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void country_info_data::clear_has_free_times2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void country_info_data::clear_free_times2() {
  free_times2_ = 0u;
  clear_has_free_times2();
}
inline ::google::protobuf::uint32 country_info_data::free_times2() const {
  return free_times2_;
}
inline void country_info_data::set_free_times2(::google::protobuf::uint32 value) {
  set_has_free_times2();
  free_times2_ = value;
}

// -------------------------------------------------------------------

// country_family_data

// optional string family_uid = 1;
inline bool country_family_data::has_family_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_family_data::set_has_family_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_family_data::clear_has_family_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_family_data::clear_family_uid() {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    family_uid_->clear();
  }
  clear_has_family_uid();
}
inline const ::std::string& country_family_data::family_uid() const {
  return *family_uid_;
}
inline void country_family_data::set_family_uid(const ::std::string& value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void country_family_data::set_family_uid(const char* value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void country_family_data::set_family_uid(const char* value, size_t size) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_family_data::mutable_family_uid() {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  return family_uid_;
}
inline ::std::string* country_family_data::release_family_uid() {
  clear_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_uid_;
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_family_data::set_allocated_family_uid(::std::string* family_uid) {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete family_uid_;
  }
  if (family_uid) {
    set_has_family_uid();
    family_uid_ = family_uid;
  } else {
    clear_has_family_uid();
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 2;
inline bool country_family_data::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_family_data::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_family_data::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_family_data::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& country_family_data::family_name() const {
  return *family_name_;
}
inline void country_family_data::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void country_family_data::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void country_family_data::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_family_data::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* country_family_data::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_family_data::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string patriarch = 3;
inline bool country_family_data::has_patriarch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_family_data::set_has_patriarch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_family_data::clear_has_patriarch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_family_data::clear_patriarch() {
  if (patriarch_ != &::google::protobuf::internal::kEmptyString) {
    patriarch_->clear();
  }
  clear_has_patriarch();
}
inline const ::std::string& country_family_data::patriarch() const {
  return *patriarch_;
}
inline void country_family_data::set_patriarch(const ::std::string& value) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(value);
}
inline void country_family_data::set_patriarch(const char* value) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(value);
}
inline void country_family_data::set_patriarch(const char* value, size_t size) {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  patriarch_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* country_family_data::mutable_patriarch() {
  set_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_ = new ::std::string;
  }
  return patriarch_;
}
inline ::std::string* country_family_data::release_patriarch() {
  clear_has_patriarch();
  if (patriarch_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patriarch_;
    patriarch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void country_family_data::set_allocated_patriarch(::std::string* patriarch) {
  if (patriarch_ != &::google::protobuf::internal::kEmptyString) {
    delete patriarch_;
  }
  if (patriarch) {
    set_has_patriarch();
    patriarch_ = patriarch;
  } else {
    clear_has_patriarch();
    patriarch_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 4;
inline bool country_family_data::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void country_family_data::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void country_family_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void country_family_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 country_family_data::level() const {
  return level_;
}
inline void country_family_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 prestige = 5;
inline bool country_family_data::has_prestige() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void country_family_data::set_has_prestige() {
  _has_bits_[0] |= 0x00000010u;
}
inline void country_family_data::clear_has_prestige() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void country_family_data::clear_prestige() {
  prestige_ = 0u;
  clear_has_prestige();
}
inline ::google::protobuf::uint32 country_family_data::prestige() const {
  return prestige_;
}
inline void country_family_data::set_prestige(::google::protobuf::uint32 value) {
  set_has_prestige();
  prestige_ = value;
}

// optional uint32 loyalty = 6;
inline bool country_family_data::has_loyalty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void country_family_data::set_has_loyalty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void country_family_data::clear_has_loyalty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void country_family_data::clear_loyalty() {
  loyalty_ = 0u;
  clear_has_loyalty();
}
inline ::google::protobuf::uint32 country_family_data::loyalty() const {
  return loyalty_;
}
inline void country_family_data::set_loyalty(::google::protobuf::uint32 value) {
  set_has_loyalty();
  loyalty_ = value;
}

// -------------------------------------------------------------------

// country_family_list

// repeated .proto.common.country_family_data datas = 1;
inline int country_family_list::datas_size() const {
  return datas_.size();
}
inline void country_family_list::clear_datas() {
  datas_.Clear();
}
inline const ::proto::common::country_family_data& country_family_list::datas(int index) const {
  return datas_.Get(index);
}
inline ::proto::common::country_family_data* country_family_list::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::proto::common::country_family_data* country_family_list::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::country_family_data >&
country_family_list::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::country_family_data >*
country_family_list::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// server_channel_single

// optional uint32 uid = 1;
inline bool server_channel_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void server_channel_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void server_channel_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void server_channel_single::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 server_channel_single::uid() const {
  return uid_;
}
inline void server_channel_single::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// optional string name = 2;
inline bool server_channel_single::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void server_channel_single::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void server_channel_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void server_channel_single::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& server_channel_single::name() const {
  return *name_;
}
inline void server_channel_single::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void server_channel_single::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void server_channel_single::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* server_channel_single::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* server_channel_single::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void server_channel_single::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.channel_type type = 3;
inline bool server_channel_single::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void server_channel_single::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void server_channel_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void server_channel_single::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::proto::common::channel_type server_channel_single::type() const {
  return static_cast< ::proto::common::channel_type >(type_);
}
inline void server_channel_single::set_type(::proto::common::channel_type value) {
  assert(::proto::common::channel_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .proto.common.channel_state state = 4 [default = channel_free];
inline bool server_channel_single::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void server_channel_single::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void server_channel_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void server_channel_single::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::proto::common::channel_state server_channel_single::state() const {
  return static_cast< ::proto::common::channel_state >(state_);
}
inline void server_channel_single::set_state(::proto::common::channel_state value) {
  assert(::proto::common::channel_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// fh_channel_role_list

// repeated uint64 notify_role_arrary = 1;
inline int fh_channel_role_list::notify_role_arrary_size() const {
  return notify_role_arrary_.size();
}
inline void fh_channel_role_list::clear_notify_role_arrary() {
  notify_role_arrary_.Clear();
}
inline ::google::protobuf::uint64 fh_channel_role_list::notify_role_arrary(int index) const {
  return notify_role_arrary_.Get(index);
}
inline void fh_channel_role_list::set_notify_role_arrary(int index, ::google::protobuf::uint64 value) {
  notify_role_arrary_.Set(index, value);
}
inline void fh_channel_role_list::add_notify_role_arrary(::google::protobuf::uint64 value) {
  notify_role_arrary_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
fh_channel_role_list::notify_role_arrary() const {
  return notify_role_arrary_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
fh_channel_role_list::mutable_notify_role_arrary() {
  return &notify_role_arrary_;
}

// -------------------------------------------------------------------

// server_channel_data

// repeated .proto.common.server_channel_single server_channel_single = 1;
inline int server_channel_data::server_channel_single_size() const {
  return server_channel_single_.size();
}
inline void server_channel_data::clear_server_channel_single() {
  server_channel_single_.Clear();
}
inline const ::proto::common::server_channel_single& server_channel_data::server_channel_single(int index) const {
  return server_channel_single_.Get(index);
}
inline ::proto::common::server_channel_single* server_channel_data::mutable_server_channel_single(int index) {
  return server_channel_single_.Mutable(index);
}
inline ::proto::common::server_channel_single* server_channel_data::add_server_channel_single() {
  return server_channel_single_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::server_channel_single >&
server_channel_data::server_channel_single() const {
  return server_channel_single_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::server_channel_single >*
server_channel_data::mutable_server_channel_single() {
  return &server_channel_single_;
}

// -------------------------------------------------------------------

// chat_syn_user_info

// optional uint64 uid = 1;
inline bool chat_syn_user_info::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_syn_user_info::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_syn_user_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_syn_user_info::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 chat_syn_user_info::uid() const {
  return uid_;
}
inline void chat_syn_user_info::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 gate_id = 2;
inline bool chat_syn_user_info::has_gate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_syn_user_info::set_has_gate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_syn_user_info::clear_has_gate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_syn_user_info::clear_gate_id() {
  gate_id_ = 0u;
  clear_has_gate_id();
}
inline ::google::protobuf::uint32 chat_syn_user_info::gate_id() const {
  return gate_id_;
}
inline void chat_syn_user_info::set_gate_id(::google::protobuf::uint32 value) {
  set_has_gate_id();
  gate_id_ = value;
}

// optional string nickname = 3;
inline bool chat_syn_user_info::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_syn_user_info::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_syn_user_info::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_syn_user_info::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& chat_syn_user_info::nickname() const {
  return *nickname_;
}
inline void chat_syn_user_info::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void chat_syn_user_info::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void chat_syn_user_info::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_syn_user_info::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* chat_syn_user_info::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_syn_user_info::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 country_id = 4;
inline bool chat_syn_user_info::has_country_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat_syn_user_info::set_has_country_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat_syn_user_info::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat_syn_user_info::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 chat_syn_user_info::country_id() const {
  return country_id_;
}
inline void chat_syn_user_info::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional uint64 family_id = 5;
inline bool chat_syn_user_info::has_family_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat_syn_user_info::set_has_family_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat_syn_user_info::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat_syn_user_info::clear_family_id() {
  family_id_ = GOOGLE_ULONGLONG(0);
  clear_has_family_id();
}
inline ::google::protobuf::uint64 chat_syn_user_info::family_id() const {
  return family_id_;
}
inline void chat_syn_user_info::set_family_id(::google::protobuf::uint64 value) {
  set_has_family_id();
  family_id_ = value;
}

// optional uint32 channel_id = 6;
inline bool chat_syn_user_info::has_channel_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void chat_syn_user_info::set_has_channel_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void chat_syn_user_info::clear_has_channel_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void chat_syn_user_info::clear_channel_id() {
  channel_id_ = 0u;
  clear_has_channel_id();
}
inline ::google::protobuf::uint32 chat_syn_user_info::channel_id() const {
  return channel_id_;
}
inline void chat_syn_user_info::set_channel_id(::google::protobuf::uint32 value) {
  set_has_channel_id();
  channel_id_ = value;
}

// -------------------------------------------------------------------

// chat_common_data

// optional .proto.common.chat_channel chat_channel = 1 [default = chat_channel_vicinity];
inline bool chat_common_data::has_chat_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void chat_common_data::set_has_chat_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void chat_common_data::clear_has_chat_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void chat_common_data::clear_chat_channel() {
  chat_channel_ = 2;
  clear_has_chat_channel();
}
inline ::proto::common::chat_channel chat_common_data::chat_channel() const {
  return static_cast< ::proto::common::chat_channel >(chat_channel_);
}
inline void chat_common_data::set_chat_channel(::proto::common::chat_channel value) {
  assert(::proto::common::chat_channel_IsValid(value));
  set_has_chat_channel();
  chat_channel_ = value;
}

// required string src_uid = 2;
inline bool chat_common_data::has_src_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void chat_common_data::set_has_src_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void chat_common_data::clear_has_src_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void chat_common_data::clear_src_uid() {
  if (src_uid_ != &::google::protobuf::internal::kEmptyString) {
    src_uid_->clear();
  }
  clear_has_src_uid();
}
inline const ::std::string& chat_common_data::src_uid() const {
  return *src_uid_;
}
inline void chat_common_data::set_src_uid(const ::std::string& value) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(value);
}
inline void chat_common_data::set_src_uid(const char* value) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(value);
}
inline void chat_common_data::set_src_uid(const char* value, size_t size) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_common_data::mutable_src_uid() {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  return src_uid_;
}
inline ::std::string* chat_common_data::release_src_uid() {
  clear_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_uid_;
    src_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_common_data::set_allocated_src_uid(::std::string* src_uid) {
  if (src_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete src_uid_;
  }
  if (src_uid) {
    set_has_src_uid();
    src_uid_ = src_uid;
  } else {
    clear_has_src_uid();
    src_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string src_name = 3;
inline bool chat_common_data::has_src_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void chat_common_data::set_has_src_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void chat_common_data::clear_has_src_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void chat_common_data::clear_src_name() {
  if (src_name_ != &::google::protobuf::internal::kEmptyString) {
    src_name_->clear();
  }
  clear_has_src_name();
}
inline const ::std::string& chat_common_data::src_name() const {
  return *src_name_;
}
inline void chat_common_data::set_src_name(const ::std::string& value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
}
inline void chat_common_data::set_src_name(const char* value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
}
inline void chat_common_data::set_src_name(const char* value, size_t size) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_common_data::mutable_src_name() {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  return src_name_;
}
inline ::std::string* chat_common_data::release_src_name() {
  clear_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_name_;
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_common_data::set_allocated_src_name(::std::string* src_name) {
  if (src_name_ != &::google::protobuf::internal::kEmptyString) {
    delete src_name_;
  }
  if (src_name) {
    set_has_src_name();
    src_name_ = src_name;
  } else {
    clear_has_src_name();
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string chat_info = 4;
inline bool chat_common_data::has_chat_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void chat_common_data::set_has_chat_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void chat_common_data::clear_has_chat_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void chat_common_data::clear_chat_info() {
  if (chat_info_ != &::google::protobuf::internal::kEmptyString) {
    chat_info_->clear();
  }
  clear_has_chat_info();
}
inline const ::std::string& chat_common_data::chat_info() const {
  return *chat_info_;
}
inline void chat_common_data::set_chat_info(const ::std::string& value) {
  set_has_chat_info();
  if (chat_info_ == &::google::protobuf::internal::kEmptyString) {
    chat_info_ = new ::std::string;
  }
  chat_info_->assign(value);
}
inline void chat_common_data::set_chat_info(const char* value) {
  set_has_chat_info();
  if (chat_info_ == &::google::protobuf::internal::kEmptyString) {
    chat_info_ = new ::std::string;
  }
  chat_info_->assign(value);
}
inline void chat_common_data::set_chat_info(const char* value, size_t size) {
  set_has_chat_info();
  if (chat_info_ == &::google::protobuf::internal::kEmptyString) {
    chat_info_ = new ::std::string;
  }
  chat_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_common_data::mutable_chat_info() {
  set_has_chat_info();
  if (chat_info_ == &::google::protobuf::internal::kEmptyString) {
    chat_info_ = new ::std::string;
  }
  return chat_info_;
}
inline ::std::string* chat_common_data::release_chat_info() {
  clear_has_chat_info();
  if (chat_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chat_info_;
    chat_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_common_data::set_allocated_chat_info(::std::string* chat_info) {
  if (chat_info_ != &::google::protobuf::internal::kEmptyString) {
    delete chat_info_;
  }
  if (chat_info) {
    set_has_chat_info();
    chat_info_ = chat_info;
  } else {
    clear_has_chat_info();
    chat_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 head_icon_id = 5;
inline bool chat_common_data::has_head_icon_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void chat_common_data::set_has_head_icon_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void chat_common_data::clear_has_head_icon_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void chat_common_data::clear_head_icon_id() {
  head_icon_id_ = 0u;
  clear_has_head_icon_id();
}
inline ::google::protobuf::uint32 chat_common_data::head_icon_id() const {
  return head_icon_id_;
}
inline void chat_common_data::set_head_icon_id(::google::protobuf::uint32 value) {
  set_has_head_icon_id();
  head_icon_id_ = value;
}

// required uint32 role_level = 6;
inline bool chat_common_data::has_role_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void chat_common_data::set_has_role_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void chat_common_data::clear_has_role_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void chat_common_data::clear_role_level() {
  role_level_ = 0u;
  clear_has_role_level();
}
inline ::google::protobuf::uint32 chat_common_data::role_level() const {
  return role_level_;
}
inline void chat_common_data::set_role_level(::google::protobuf::uint32 value) {
  set_has_role_level();
  role_level_ = value;
}

// optional string param = 7;
inline bool chat_common_data::has_param() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void chat_common_data::set_has_param() {
  _has_bits_[0] |= 0x00000040u;
}
inline void chat_common_data::clear_has_param() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void chat_common_data::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& chat_common_data::param() const {
  return *param_;
}
inline void chat_common_data::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void chat_common_data::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void chat_common_data::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_common_data::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* chat_common_data::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_common_data::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tar_role_id = 8;
inline bool chat_common_data::has_tar_role_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void chat_common_data::set_has_tar_role_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void chat_common_data::clear_has_tar_role_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void chat_common_data::clear_tar_role_id() {
  if (tar_role_id_ != &::google::protobuf::internal::kEmptyString) {
    tar_role_id_->clear();
  }
  clear_has_tar_role_id();
}
inline const ::std::string& chat_common_data::tar_role_id() const {
  return *tar_role_id_;
}
inline void chat_common_data::set_tar_role_id(const ::std::string& value) {
  set_has_tar_role_id();
  if (tar_role_id_ == &::google::protobuf::internal::kEmptyString) {
    tar_role_id_ = new ::std::string;
  }
  tar_role_id_->assign(value);
}
inline void chat_common_data::set_tar_role_id(const char* value) {
  set_has_tar_role_id();
  if (tar_role_id_ == &::google::protobuf::internal::kEmptyString) {
    tar_role_id_ = new ::std::string;
  }
  tar_role_id_->assign(value);
}
inline void chat_common_data::set_tar_role_id(const char* value, size_t size) {
  set_has_tar_role_id();
  if (tar_role_id_ == &::google::protobuf::internal::kEmptyString) {
    tar_role_id_ = new ::std::string;
  }
  tar_role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* chat_common_data::mutable_tar_role_id() {
  set_has_tar_role_id();
  if (tar_role_id_ == &::google::protobuf::internal::kEmptyString) {
    tar_role_id_ = new ::std::string;
  }
  return tar_role_id_;
}
inline ::std::string* chat_common_data::release_tar_role_id() {
  clear_has_tar_role_id();
  if (tar_role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tar_role_id_;
    tar_role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void chat_common_data::set_allocated_tar_role_id(::std::string* tar_role_id) {
  if (tar_role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete tar_role_id_;
  }
  if (tar_role_id) {
    set_has_tar_role_id();
    tar_role_id_ = tar_role_id;
  } else {
    clear_has_tar_role_id();
    tar_role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// chat_common_role_info

// repeated .proto.common.item_single item_single = 1;
inline int chat_common_role_info::item_single_size() const {
  return item_single_.size();
}
inline void chat_common_role_info::clear_item_single() {
  item_single_.Clear();
}
inline const ::proto::common::item_single& chat_common_role_info::item_single(int index) const {
  return item_single_.Get(index);
}
inline ::proto::common::item_single* chat_common_role_info::mutable_item_single(int index) {
  return item_single_.Mutable(index);
}
inline ::proto::common::item_single* chat_common_role_info::add_item_single() {
  return item_single_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
chat_common_role_info::item_single() const {
  return item_single_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
chat_common_role_info::mutable_item_single() {
  return &item_single_;
}

// repeated .proto.common.hero_single hero_single = 2;
inline int chat_common_role_info::hero_single_size() const {
  return hero_single_.size();
}
inline void chat_common_role_info::clear_hero_single() {
  hero_single_.Clear();
}
inline const ::proto::common::hero_single& chat_common_role_info::hero_single(int index) const {
  return hero_single_.Get(index);
}
inline ::proto::common::hero_single* chat_common_role_info::mutable_hero_single(int index) {
  return hero_single_.Mutable(index);
}
inline ::proto::common::hero_single* chat_common_role_info::add_hero_single() {
  return hero_single_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
chat_common_role_info::hero_single() const {
  return hero_single_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
chat_common_role_info::mutable_hero_single() {
  return &hero_single_;
}

// -------------------------------------------------------------------

// user_troop_member

// optional string id = 1;
inline bool user_troop_member::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_troop_member::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_troop_member::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_troop_member::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& user_troop_member::id() const {
  return *id_;
}
inline void user_troop_member::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void user_troop_member::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void user_troop_member::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_troop_member::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* user_troop_member::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_troop_member::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool user_troop_member::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_troop_member::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_troop_member::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_troop_member::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& user_troop_member::name() const {
  return *name_;
}
inline void user_troop_member::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void user_troop_member::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void user_troop_member::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_troop_member::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* user_troop_member::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_troop_member::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 plugin = 3;
inline bool user_troop_member::has_plugin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_troop_member::set_has_plugin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_troop_member::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_troop_member::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 user_troop_member::plugin() const {
  return plugin_;
}
inline void user_troop_member::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 fighting = 4;
inline bool user_troop_member::has_fighting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_troop_member::set_has_fighting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_troop_member::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_troop_member::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 user_troop_member::fighting() const {
  return fighting_;
}
inline void user_troop_member::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 level = 5;
inline bool user_troop_member::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_troop_member::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_troop_member::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_troop_member::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 user_troop_member::level() const {
  return level_;
}
inline void user_troop_member::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 state = 6;
inline bool user_troop_member::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_troop_member::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_troop_member::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_troop_member::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 user_troop_member::state() const {
  return state_;
}
inline void user_troop_member::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 7 [default = SCENEOBJECT_USER];
inline bool user_troop_member::has_object_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_troop_member::set_has_object_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_troop_member::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_troop_member::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE user_troop_member::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void user_troop_member::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional uint32 fight_times = 8;
inline bool user_troop_member::has_fight_times() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_troop_member::set_has_fight_times() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_troop_member::clear_has_fight_times() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_troop_member::clear_fight_times() {
  fight_times_ = 0u;
  clear_has_fight_times();
}
inline ::google::protobuf::uint32 user_troop_member::fight_times() const {
  return fight_times_;
}
inline void user_troop_member::set_fight_times(::google::protobuf::uint32 value) {
  set_has_fight_times();
  fight_times_ = value;
}

// optional string owner_uid = 9;
inline bool user_troop_member::has_owner_uid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_troop_member::set_has_owner_uid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_troop_member::clear_has_owner_uid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_troop_member::clear_owner_uid() {
  if (owner_uid_ != &::google::protobuf::internal::kEmptyString) {
    owner_uid_->clear();
  }
  clear_has_owner_uid();
}
inline const ::std::string& user_troop_member::owner_uid() const {
  return *owner_uid_;
}
inline void user_troop_member::set_owner_uid(const ::std::string& value) {
  set_has_owner_uid();
  if (owner_uid_ == &::google::protobuf::internal::kEmptyString) {
    owner_uid_ = new ::std::string;
  }
  owner_uid_->assign(value);
}
inline void user_troop_member::set_owner_uid(const char* value) {
  set_has_owner_uid();
  if (owner_uid_ == &::google::protobuf::internal::kEmptyString) {
    owner_uid_ = new ::std::string;
  }
  owner_uid_->assign(value);
}
inline void user_troop_member::set_owner_uid(const char* value, size_t size) {
  set_has_owner_uid();
  if (owner_uid_ == &::google::protobuf::internal::kEmptyString) {
    owner_uid_ = new ::std::string;
  }
  owner_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_troop_member::mutable_owner_uid() {
  set_has_owner_uid();
  if (owner_uid_ == &::google::protobuf::internal::kEmptyString) {
    owner_uid_ = new ::std::string;
  }
  return owner_uid_;
}
inline ::std::string* user_troop_member::release_owner_uid() {
  clear_has_owner_uid();
  if (owner_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_uid_;
    owner_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_troop_member::set_allocated_owner_uid(::std::string* owner_uid) {
  if (owner_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_uid_;
  }
  if (owner_uid) {
    set_has_owner_uid();
    owner_uid_ = owner_uid;
  } else {
    clear_has_owner_uid();
    owner_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// troop_data

// optional string id = 1;
inline bool troop_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void troop_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void troop_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void troop_data::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& troop_data::id() const {
  return *id_;
}
inline void troop_data::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void troop_data::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void troop_data::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* troop_data::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* troop_data::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void troop_data::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 2;
inline bool troop_data::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void troop_data::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void troop_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void troop_data::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 troop_data::type() const {
  return type_;
}
inline void troop_data::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional bool is_free_join = 3;
inline bool troop_data::has_is_free_join() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void troop_data::set_has_is_free_join() {
  _has_bits_[0] |= 0x00000004u;
}
inline void troop_data::clear_has_is_free_join() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void troop_data::clear_is_free_join() {
  is_free_join_ = false;
  clear_has_is_free_join();
}
inline bool troop_data::is_free_join() const {
  return is_free_join_;
}
inline void troop_data::set_is_free_join(bool value) {
  set_has_is_free_join();
  is_free_join_ = value;
}

// optional string leader = 4;
inline bool troop_data::has_leader() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void troop_data::set_has_leader() {
  _has_bits_[0] |= 0x00000008u;
}
inline void troop_data::clear_has_leader() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void troop_data::clear_leader() {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    leader_->clear();
  }
  clear_has_leader();
}
inline const ::std::string& troop_data::leader() const {
  return *leader_;
}
inline void troop_data::set_leader(const ::std::string& value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void troop_data::set_leader(const char* value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void troop_data::set_leader(const char* value, size_t size) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* troop_data::mutable_leader() {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  return leader_;
}
inline ::std::string* troop_data::release_leader() {
  clear_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leader_;
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void troop_data::set_allocated_leader(::std::string* leader) {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    delete leader_;
  }
  if (leader) {
    set_has_leader();
    leader_ = leader;
  } else {
    clear_has_leader();
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.common.user_troop_member members = 5;
inline int troop_data::members_size() const {
  return members_.size();
}
inline void troop_data::clear_members() {
  members_.Clear();
}
inline const ::proto::common::user_troop_member& troop_data::members(int index) const {
  return members_.Get(index);
}
inline ::proto::common::user_troop_member* troop_data::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::proto::common::user_troop_member* troop_data::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::user_troop_member >&
troop_data::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::user_troop_member >*
troop_data::mutable_members() {
  return &members_;
}

// optional uint32 level_min = 7;
inline bool troop_data::has_level_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void troop_data::set_has_level_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void troop_data::clear_has_level_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void troop_data::clear_level_min() {
  level_min_ = 0u;
  clear_has_level_min();
}
inline ::google::protobuf::uint32 troop_data::level_min() const {
  return level_min_;
}
inline void troop_data::set_level_min(::google::protobuf::uint32 value) {
  set_has_level_min();
  level_min_ = value;
}

// optional uint32 level_max = 8;
inline bool troop_data::has_level_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void troop_data::set_has_level_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void troop_data::clear_has_level_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void troop_data::clear_level_max() {
  level_max_ = 0u;
  clear_has_level_max();
}
inline ::google::protobuf::uint32 troop_data::level_max() const {
  return level_max_;
}
inline void troop_data::set_level_max(::google::protobuf::uint32 value) {
  set_has_level_max();
  level_max_ = value;
}

// optional uint32 fighting = 9;
inline bool troop_data::has_fighting() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void troop_data::set_has_fighting() {
  _has_bits_[0] |= 0x00000080u;
}
inline void troop_data::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void troop_data::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 troop_data::fighting() const {
  return fighting_;
}
inline void troop_data::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional .proto.common.task_state zg_task_info = 10;
inline bool troop_data::has_zg_task_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void troop_data::set_has_zg_task_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void troop_data::clear_has_zg_task_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void troop_data::clear_zg_task_info() {
  if (zg_task_info_ != NULL) zg_task_info_->::proto::common::task_state::Clear();
  clear_has_zg_task_info();
}
inline const ::proto::common::task_state& troop_data::zg_task_info() const {
  return zg_task_info_ != NULL ? *zg_task_info_ : *default_instance_->zg_task_info_;
}
inline ::proto::common::task_state* troop_data::mutable_zg_task_info() {
  set_has_zg_task_info();
  if (zg_task_info_ == NULL) zg_task_info_ = new ::proto::common::task_state;
  return zg_task_info_;
}
inline ::proto::common::task_state* troop_data::release_zg_task_info() {
  clear_has_zg_task_info();
  ::proto::common::task_state* temp = zg_task_info_;
  zg_task_info_ = NULL;
  return temp;
}
inline void troop_data::set_allocated_zg_task_info(::proto::common::task_state* zg_task_info) {
  delete zg_task_info_;
  zg_task_info_ = zg_task_info;
  if (zg_task_info) {
    set_has_zg_task_info();
  } else {
    clear_has_zg_task_info();
  }
}

// -------------------------------------------------------------------

// troop_type

// optional uint32 big_type = 1;
inline bool troop_type::has_big_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void troop_type::set_has_big_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void troop_type::clear_has_big_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void troop_type::clear_big_type() {
  big_type_ = 0u;
  clear_has_big_type();
}
inline ::google::protobuf::uint32 troop_type::big_type() const {
  return big_type_;
}
inline void troop_type::set_big_type(::google::protobuf::uint32 value) {
  set_has_big_type();
  big_type_ = value;
}

// repeated uint32 types = 2;
inline int troop_type::types_size() const {
  return types_.size();
}
inline void troop_type::clear_types() {
  types_.Clear();
}
inline ::google::protobuf::uint32 troop_type::types(int index) const {
  return types_.Get(index);
}
inline void troop_type::set_types(int index, ::google::protobuf::uint32 value) {
  types_.Set(index, value);
}
inline void troop_type::add_types(::google::protobuf::uint32 value) {
  types_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
troop_type::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
troop_type::mutable_types() {
  return &types_;
}

// -------------------------------------------------------------------

// user_troop_member_hero_list

// optional string role_id = 1;
inline bool user_troop_member_hero_list::has_role_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_troop_member_hero_list::set_has_role_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_troop_member_hero_list::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_troop_member_hero_list::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& user_troop_member_hero_list::role_id() const {
  return *role_id_;
}
inline void user_troop_member_hero_list::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void user_troop_member_hero_list::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void user_troop_member_hero_list::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_troop_member_hero_list::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* user_troop_member_hero_list::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_troop_member_hero_list::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool user_troop_member_hero_list::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_troop_member_hero_list::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_troop_member_hero_list::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_troop_member_hero_list::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& user_troop_member_hero_list::role_name() const {
  return *role_name_;
}
inline void user_troop_member_hero_list::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void user_troop_member_hero_list::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void user_troop_member_hero_list::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_troop_member_hero_list::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* user_troop_member_hero_list::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_troop_member_hero_list::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.common.hero_single heroes = 3;
inline int user_troop_member_hero_list::heroes_size() const {
  return heroes_.size();
}
inline void user_troop_member_hero_list::clear_heroes() {
  heroes_.Clear();
}
inline const ::proto::common::hero_single& user_troop_member_hero_list::heroes(int index) const {
  return heroes_.Get(index);
}
inline ::proto::common::hero_single* user_troop_member_hero_list::mutable_heroes(int index) {
  return heroes_.Mutable(index);
}
inline ::proto::common::hero_single* user_troop_member_hero_list::add_heroes() {
  return heroes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >&
user_troop_member_hero_list::heroes() const {
  return heroes_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_single >*
user_troop_member_hero_list::mutable_heroes() {
  return &heroes_;
}

// -------------------------------------------------------------------

// city_base_info

// optional uint32 city_id = 1;
inline bool city_base_info::has_city_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_base_info::set_has_city_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_base_info::clear_has_city_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_base_info::clear_city_id() {
  city_id_ = 0u;
  clear_has_city_id();
}
inline ::google::protobuf::uint32 city_base_info::city_id() const {
  return city_id_;
}
inline void city_base_info::set_city_id(::google::protobuf::uint32 value) {
  set_has_city_id();
  city_id_ = value;
}

// optional uint32 prosperity_value = 2;
inline bool city_base_info::has_prosperity_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_base_info::set_has_prosperity_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_base_info::clear_has_prosperity_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_base_info::clear_prosperity_value() {
  prosperity_value_ = 0u;
  clear_has_prosperity_value();
}
inline ::google::protobuf::uint32 city_base_info::prosperity_value() const {
  return prosperity_value_;
}
inline void city_base_info::set_prosperity_value(::google::protobuf::uint32 value) {
  set_has_prosperity_value();
  prosperity_value_ = value;
}

// optional uint32 city_hold_value = 3;
inline bool city_base_info::has_city_hold_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_base_info::set_has_city_hold_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_base_info::clear_has_city_hold_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_base_info::clear_city_hold_value() {
  city_hold_value_ = 0u;
  clear_has_city_hold_value();
}
inline ::google::protobuf::uint32 city_base_info::city_hold_value() const {
  return city_hold_value_;
}
inline void city_base_info::set_city_hold_value(::google::protobuf::uint32 value) {
  set_has_city_hold_value();
  city_hold_value_ = value;
}

// optional uint32 hold_country_id = 4;
inline bool city_base_info::has_hold_country_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void city_base_info::set_has_hold_country_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void city_base_info::clear_has_hold_country_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void city_base_info::clear_hold_country_id() {
  hold_country_id_ = 0u;
  clear_has_hold_country_id();
}
inline ::google::protobuf::uint32 city_base_info::hold_country_id() const {
  return hold_country_id_;
}
inline void city_base_info::set_hold_country_id(::google::protobuf::uint32 value) {
  set_has_hold_country_id();
  hold_country_id_ = value;
}

// optional uint32 prosperity_level = 5;
inline bool city_base_info::has_prosperity_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void city_base_info::set_has_prosperity_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void city_base_info::clear_has_prosperity_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void city_base_info::clear_prosperity_level() {
  prosperity_level_ = 0u;
  clear_has_prosperity_level();
}
inline ::google::protobuf::uint32 city_base_info::prosperity_level() const {
  return prosperity_level_;
}
inline void city_base_info::set_prosperity_level(::google::protobuf::uint32 value) {
  set_has_prosperity_level();
  prosperity_level_ = value;
}

// -------------------------------------------------------------------

// role_trade_info

// optional uint32 trade_point = 1;
inline bool role_trade_info::has_trade_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_trade_info::set_has_trade_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_trade_info::clear_has_trade_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_trade_info::clear_trade_point() {
  trade_point_ = 0u;
  clear_has_trade_point();
}
inline ::google::protobuf::uint32 role_trade_info::trade_point() const {
  return trade_point_;
}
inline void role_trade_info::set_trade_point(::google::protobuf::uint32 value) {
  set_has_trade_point();
  trade_point_ = value;
}

// optional uint32 trade_bag_weight = 2;
inline bool role_trade_info::has_trade_bag_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_trade_info::set_has_trade_bag_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_trade_info::clear_has_trade_bag_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_trade_info::clear_trade_bag_weight() {
  trade_bag_weight_ = 0u;
  clear_has_trade_bag_weight();
}
inline ::google::protobuf::uint32 role_trade_info::trade_bag_weight() const {
  return trade_bag_weight_;
}
inline void role_trade_info::set_trade_bag_weight(::google::protobuf::uint32 value) {
  set_has_trade_bag_weight();
  trade_bag_weight_ = value;
}

// optional uint32 last_reset_buy_num_time = 3;
inline bool role_trade_info::has_last_reset_buy_num_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_trade_info::set_has_last_reset_buy_num_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_trade_info::clear_has_last_reset_buy_num_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_trade_info::clear_last_reset_buy_num_time() {
  last_reset_buy_num_time_ = 0u;
  clear_has_last_reset_buy_num_time();
}
inline ::google::protobuf::uint32 role_trade_info::last_reset_buy_num_time() const {
  return last_reset_buy_num_time_;
}
inline void role_trade_info::set_last_reset_buy_num_time(::google::protobuf::uint32 value) {
  set_has_last_reset_buy_num_time();
  last_reset_buy_num_time_ = value;
}

// optional uint32 total_week_gain = 4;
inline bool role_trade_info::has_total_week_gain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_trade_info::set_has_total_week_gain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_trade_info::clear_has_total_week_gain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_trade_info::clear_total_week_gain() {
  total_week_gain_ = 0u;
  clear_has_total_week_gain();
}
inline ::google::protobuf::uint32 role_trade_info::total_week_gain() const {
  return total_week_gain_;
}
inline void role_trade_info::set_total_week_gain(::google::protobuf::uint32 value) {
  set_has_total_week_gain();
  total_week_gain_ = value;
}

// optional uint32 rank = 5;
inline bool role_trade_info::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_trade_info::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_trade_info::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_trade_info::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 role_trade_info::rank() const {
  return rank_;
}
inline void role_trade_info::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// -------------------------------------------------------------------

// role_trade_item_single

// optional uint32 item_tid = 1;
inline bool role_trade_item_single::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_trade_item_single::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_trade_item_single::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_trade_item_single::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 role_trade_item_single::item_tid() const {
  return item_tid_;
}
inline void role_trade_item_single::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_buy_num = 2;
inline bool role_trade_item_single::has_item_buy_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_trade_item_single::set_has_item_buy_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_trade_item_single::clear_has_item_buy_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_trade_item_single::clear_item_buy_num() {
  item_buy_num_ = 0u;
  clear_has_item_buy_num();
}
inline ::google::protobuf::uint32 role_trade_item_single::item_buy_num() const {
  return item_buy_num_;
}
inline void role_trade_item_single::set_item_buy_num(::google::protobuf::uint32 value) {
  set_has_item_buy_num();
  item_buy_num_ = value;
}

// optional uint32 item_max_buy_num = 3;
inline bool role_trade_item_single::has_item_max_buy_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_trade_item_single::set_has_item_max_buy_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_trade_item_single::clear_has_item_max_buy_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_trade_item_single::clear_item_max_buy_num() {
  item_max_buy_num_ = 0u;
  clear_has_item_max_buy_num();
}
inline ::google::protobuf::uint32 role_trade_item_single::item_max_buy_num() const {
  return item_max_buy_num_;
}
inline void role_trade_item_single::set_item_max_buy_num(::google::protobuf::uint32 value) {
  set_has_item_max_buy_num();
  item_max_buy_num_ = value;
}

// optional uint32 item_buy_price = 4;
inline bool role_trade_item_single::has_item_buy_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_trade_item_single::set_has_item_buy_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_trade_item_single::clear_has_item_buy_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_trade_item_single::clear_item_buy_price() {
  item_buy_price_ = 0u;
  clear_has_item_buy_price();
}
inline ::google::protobuf::uint32 role_trade_item_single::item_buy_price() const {
  return item_buy_price_;
}
inline void role_trade_item_single::set_item_buy_price(::google::protobuf::uint32 value) {
  set_has_item_buy_price();
  item_buy_price_ = value;
}

// optional uint32 item_max_buy_num_addi = 5;
inline bool role_trade_item_single::has_item_max_buy_num_addi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_trade_item_single::set_has_item_max_buy_num_addi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_trade_item_single::clear_has_item_max_buy_num_addi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_trade_item_single::clear_item_max_buy_num_addi() {
  item_max_buy_num_addi_ = 0u;
  clear_has_item_max_buy_num_addi();
}
inline ::google::protobuf::uint32 role_trade_item_single::item_max_buy_num_addi() const {
  return item_max_buy_num_addi_;
}
inline void role_trade_item_single::set_item_max_buy_num_addi(::google::protobuf::uint32 value) {
  set_has_item_max_buy_num_addi();
  item_max_buy_num_addi_ = value;
}

// -------------------------------------------------------------------

// role_trade_item

// repeated .proto.common.role_trade_item_single trade_item_list = 1;
inline int role_trade_item::trade_item_list_size() const {
  return trade_item_list_.size();
}
inline void role_trade_item::clear_trade_item_list() {
  trade_item_list_.Clear();
}
inline const ::proto::common::role_trade_item_single& role_trade_item::trade_item_list(int index) const {
  return trade_item_list_.Get(index);
}
inline ::proto::common::role_trade_item_single* role_trade_item::mutable_trade_item_list(int index) {
  return trade_item_list_.Mutable(index);
}
inline ::proto::common::role_trade_item_single* role_trade_item::add_trade_item_list() {
  return trade_item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_trade_item_single >&
role_trade_item::trade_item_list() const {
  return trade_item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_trade_item_single >*
role_trade_item::mutable_trade_item_list() {
  return &trade_item_list_;
}

// -------------------------------------------------------------------

// city_trade_shop_item_info

// optional uint32 item_tid = 1;
inline bool city_trade_shop_item_info::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_trade_shop_item_info::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_trade_shop_item_info::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_trade_shop_item_info::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 city_trade_shop_item_info::item_tid() const {
  return item_tid_;
}
inline void city_trade_shop_item_info::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 can_buy_max_num = 2;
inline bool city_trade_shop_item_info::has_can_buy_max_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_trade_shop_item_info::set_has_can_buy_max_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_trade_shop_item_info::clear_has_can_buy_max_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_trade_shop_item_info::clear_can_buy_max_num() {
  can_buy_max_num_ = 0u;
  clear_has_can_buy_max_num();
}
inline ::google::protobuf::uint32 city_trade_shop_item_info::can_buy_max_num() const {
  return can_buy_max_num_;
}
inline void city_trade_shop_item_info::set_can_buy_max_num(::google::protobuf::uint32 value) {
  set_has_can_buy_max_num();
  can_buy_max_num_ = value;
}

// optional uint32 item_buy_price = 3;
inline bool city_trade_shop_item_info::has_item_buy_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_trade_shop_item_info::set_has_item_buy_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_trade_shop_item_info::clear_has_item_buy_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_trade_shop_item_info::clear_item_buy_price() {
  item_buy_price_ = 0u;
  clear_has_item_buy_price();
}
inline ::google::protobuf::uint32 city_trade_shop_item_info::item_buy_price() const {
  return item_buy_price_;
}
inline void city_trade_shop_item_info::set_item_buy_price(::google::protobuf::uint32 value) {
  set_has_item_buy_price();
  item_buy_price_ = value;
}

// optional uint32 item_sell_price = 4;
inline bool city_trade_shop_item_info::has_item_sell_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void city_trade_shop_item_info::set_has_item_sell_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void city_trade_shop_item_info::clear_has_item_sell_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void city_trade_shop_item_info::clear_item_sell_price() {
  item_sell_price_ = 0u;
  clear_has_item_sell_price();
}
inline ::google::protobuf::uint32 city_trade_shop_item_info::item_sell_price() const {
  return item_sell_price_;
}
inline void city_trade_shop_item_info::set_item_sell_price(::google::protobuf::uint32 value) {
  set_has_item_sell_price();
  item_sell_price_ = value;
}

// optional int32 trade_market = 5;
inline bool city_trade_shop_item_info::has_trade_market() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void city_trade_shop_item_info::set_has_trade_market() {
  _has_bits_[0] |= 0x00000010u;
}
inline void city_trade_shop_item_info::clear_has_trade_market() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void city_trade_shop_item_info::clear_trade_market() {
  trade_market_ = 0;
  clear_has_trade_market();
}
inline ::google::protobuf::int32 city_trade_shop_item_info::trade_market() const {
  return trade_market_;
}
inline void city_trade_shop_item_info::set_trade_market(::google::protobuf::int32 value) {
  set_has_trade_market();
  trade_market_ = value;
}

// optional int32 new_trade_market = 6;
inline bool city_trade_shop_item_info::has_new_trade_market() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void city_trade_shop_item_info::set_has_new_trade_market() {
  _has_bits_[0] |= 0x00000020u;
}
inline void city_trade_shop_item_info::clear_has_new_trade_market() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void city_trade_shop_item_info::clear_new_trade_market() {
  new_trade_market_ = 0;
  clear_has_new_trade_market();
}
inline ::google::protobuf::int32 city_trade_shop_item_info::new_trade_market() const {
  return new_trade_market_;
}
inline void city_trade_shop_item_info::set_new_trade_market(::google::protobuf::int32 value) {
  set_has_new_trade_market();
  new_trade_market_ = value;
}

// optional uint32 city_buy_max_num = 7;
inline bool city_trade_shop_item_info::has_city_buy_max_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void city_trade_shop_item_info::set_has_city_buy_max_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void city_trade_shop_item_info::clear_has_city_buy_max_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void city_trade_shop_item_info::clear_city_buy_max_num() {
  city_buy_max_num_ = 0u;
  clear_has_city_buy_max_num();
}
inline ::google::protobuf::uint32 city_trade_shop_item_info::city_buy_max_num() const {
  return city_buy_max_num_;
}
inline void city_trade_shop_item_info::set_city_buy_max_num(::google::protobuf::uint32 value) {
  set_has_city_buy_max_num();
  city_buy_max_num_ = value;
}

// -------------------------------------------------------------------

// city_trade_shop_info

// optional .proto.common.city_base_info city_info = 1;
inline bool city_trade_shop_info::has_city_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_trade_shop_info::set_has_city_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_trade_shop_info::clear_has_city_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_trade_shop_info::clear_city_info() {
  if (city_info_ != NULL) city_info_->::proto::common::city_base_info::Clear();
  clear_has_city_info();
}
inline const ::proto::common::city_base_info& city_trade_shop_info::city_info() const {
  return city_info_ != NULL ? *city_info_ : *default_instance_->city_info_;
}
inline ::proto::common::city_base_info* city_trade_shop_info::mutable_city_info() {
  set_has_city_info();
  if (city_info_ == NULL) city_info_ = new ::proto::common::city_base_info;
  return city_info_;
}
inline ::proto::common::city_base_info* city_trade_shop_info::release_city_info() {
  clear_has_city_info();
  ::proto::common::city_base_info* temp = city_info_;
  city_info_ = NULL;
  return temp;
}
inline void city_trade_shop_info::set_allocated_city_info(::proto::common::city_base_info* city_info) {
  delete city_info_;
  city_info_ = city_info;
  if (city_info) {
    set_has_city_info();
  } else {
    clear_has_city_info();
  }
}

// repeated .proto.common.city_trade_shop_item_info item_list = 2;
inline int city_trade_shop_info::item_list_size() const {
  return item_list_.size();
}
inline void city_trade_shop_info::clear_item_list() {
  item_list_.Clear();
}
inline const ::proto::common::city_trade_shop_item_info& city_trade_shop_info::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::proto::common::city_trade_shop_item_info* city_trade_shop_info::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::proto::common::city_trade_shop_item_info* city_trade_shop_info::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::city_trade_shop_item_info >&
city_trade_shop_info::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::city_trade_shop_item_info >*
city_trade_shop_info::mutable_item_list() {
  return &item_list_;
}

// optional uint32 trade_id = 3;
inline bool city_trade_shop_info::has_trade_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_trade_shop_info::set_has_trade_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_trade_shop_info::clear_has_trade_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_trade_shop_info::clear_trade_id() {
  trade_id_ = 0u;
  clear_has_trade_id();
}
inline ::google::protobuf::uint32 city_trade_shop_info::trade_id() const {
  return trade_id_;
}
inline void city_trade_shop_info::set_trade_id(::google::protobuf::uint32 value) {
  set_has_trade_id();
  trade_id_ = value;
}

// optional uint32 event_item_id = 4;
inline bool city_trade_shop_info::has_event_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void city_trade_shop_info::set_has_event_item_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void city_trade_shop_info::clear_has_event_item_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void city_trade_shop_info::clear_event_item_id() {
  event_item_id_ = 0u;
  clear_has_event_item_id();
}
inline ::google::protobuf::uint32 city_trade_shop_info::event_item_id() const {
  return event_item_id_;
}
inline void city_trade_shop_info::set_event_item_id(::google::protobuf::uint32 value) {
  set_has_event_item_id();
  event_item_id_ = value;
}

// -------------------------------------------------------------------

// city_trade_event_info

// optional uint32 city_tid = 1;
inline bool city_trade_event_info::has_city_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void city_trade_event_info::set_has_city_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void city_trade_event_info::clear_has_city_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void city_trade_event_info::clear_city_tid() {
  city_tid_ = 0u;
  clear_has_city_tid();
}
inline ::google::protobuf::uint32 city_trade_event_info::city_tid() const {
  return city_tid_;
}
inline void city_trade_event_info::set_city_tid(::google::protobuf::uint32 value) {
  set_has_city_tid();
  city_tid_ = value;
}

// optional .proto.common.trade_event_type event_type = 2 [default = trade_event_type_normal];
inline bool city_trade_event_info::has_event_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void city_trade_event_info::set_has_event_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void city_trade_event_info::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void city_trade_event_info::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::proto::common::trade_event_type city_trade_event_info::event_type() const {
  return static_cast< ::proto::common::trade_event_type >(event_type_);
}
inline void city_trade_event_info::set_event_type(::proto::common::trade_event_type value) {
  assert(::proto::common::trade_event_type_IsValid(value));
  set_has_event_type();
  event_type_ = value;
}

// optional uint32 trade_event_param = 3;
inline bool city_trade_event_info::has_trade_event_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void city_trade_event_info::set_has_trade_event_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void city_trade_event_info::clear_has_trade_event_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void city_trade_event_info::clear_trade_event_param() {
  trade_event_param_ = 0u;
  clear_has_trade_event_param();
}
inline ::google::protobuf::uint32 city_trade_event_info::trade_event_param() const {
  return trade_event_param_;
}
inline void city_trade_event_info::set_trade_event_param(::google::protobuf::uint32 value) {
  set_has_trade_event_param();
  trade_event_param_ = value;
}

// optional uint32 trade_event_param2 = 4;
inline bool city_trade_event_info::has_trade_event_param2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void city_trade_event_info::set_has_trade_event_param2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void city_trade_event_info::clear_has_trade_event_param2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void city_trade_event_info::clear_trade_event_param2() {
  trade_event_param2_ = 0u;
  clear_has_trade_event_param2();
}
inline ::google::protobuf::uint32 city_trade_event_info::trade_event_param2() const {
  return trade_event_param2_;
}
inline void city_trade_event_info::set_trade_event_param2(::google::protobuf::uint32 value) {
  set_has_trade_event_param2();
  trade_event_param2_ = value;
}

// -------------------------------------------------------------------

// trade_supplement_info

// optional uint32 item_tid = 1;
inline bool trade_supplement_info::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trade_supplement_info::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trade_supplement_info::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trade_supplement_info::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 trade_supplement_info::item_tid() const {
  return item_tid_;
}
inline void trade_supplement_info::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_num = 2;
inline bool trade_supplement_info::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void trade_supplement_info::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void trade_supplement_info::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void trade_supplement_info::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 trade_supplement_info::item_num() const {
  return item_num_;
}
inline void trade_supplement_info::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// grid_single

// optional uint32 index = 1;
inline bool grid_single::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void grid_single::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void grid_single::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void grid_single::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 grid_single::index() const {
  return index_;
}
inline void grid_single::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .proto.common.attr_data attr = 2;
inline bool grid_single::has_attr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void grid_single::set_has_attr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void grid_single::clear_has_attr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void grid_single::clear_attr() {
  if (attr_ != NULL) attr_->::proto::common::attr_data::Clear();
  clear_has_attr();
}
inline const ::proto::common::attr_data& grid_single::attr() const {
  return attr_ != NULL ? *attr_ : *default_instance_->attr_;
}
inline ::proto::common::attr_data* grid_single::mutable_attr() {
  set_has_attr();
  if (attr_ == NULL) attr_ = new ::proto::common::attr_data;
  return attr_;
}
inline ::proto::common::attr_data* grid_single::release_attr() {
  clear_has_attr();
  ::proto::common::attr_data* temp = attr_;
  attr_ = NULL;
  return temp;
}
inline void grid_single::set_allocated_attr(::proto::common::attr_data* attr) {
  delete attr_;
  attr_ = attr;
  if (attr) {
    set_has_attr();
  } else {
    clear_has_attr();
  }
}

// optional uint32 type = 3;
inline bool grid_single::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void grid_single::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void grid_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void grid_single::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 grid_single::type() const {
  return type_;
}
inline void grid_single::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// grid_data

// repeated .proto.common.grid_single grid = 1;
inline int grid_data::grid_size() const {
  return grid_.size();
}
inline void grid_data::clear_grid() {
  grid_.Clear();
}
inline const ::proto::common::grid_single& grid_data::grid(int index) const {
  return grid_.Get(index);
}
inline ::proto::common::grid_single* grid_data::mutable_grid(int index) {
  return grid_.Mutable(index);
}
inline ::proto::common::grid_single* grid_data::add_grid() {
  return grid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::grid_single >&
grid_data::grid() const {
  return grid_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::grid_single >*
grid_data::mutable_grid() {
  return &grid_;
}

// -------------------------------------------------------------------

// fight_dark_param

// optional uint32 monster_id = 1;
inline bool fight_dark_param::has_monster_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_dark_param::set_has_monster_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_dark_param::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_dark_param::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 fight_dark_param::monster_id() const {
  return monster_id_;
}
inline void fight_dark_param::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// optional uint32 task_id = 2;
inline bool fight_dark_param::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_dark_param::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_dark_param::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_dark_param::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 fight_dark_param::task_id() const {
  return task_id_;
}
inline void fight_dark_param::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// -------------------------------------------------------------------

// fight_light_param

// optional uint32 monster_id = 1;
inline bool fight_light_param::has_monster_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_light_param::set_has_monster_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_light_param::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_light_param::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 fight_light_param::monster_id() const {
  return monster_id_;
}
inline void fight_light_param::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// optional string object_id = 2;
inline bool fight_light_param::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_light_param::set_has_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_light_param::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_light_param::clear_object_id() {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    object_id_->clear();
  }
  clear_has_object_id();
}
inline const ::std::string& fight_light_param::object_id() const {
  return *object_id_;
}
inline void fight_light_param::set_object_id(const ::std::string& value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void fight_light_param::set_object_id(const char* value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void fight_light_param::set_object_id(const char* value, size_t size) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_light_param::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  return object_id_;
}
inline ::std::string* fight_light_param::release_object_id() {
  clear_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_id_;
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_light_param::set_allocated_object_id(::std::string* object_id) {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    delete object_id_;
  }
  if (object_id) {
    set_has_object_id();
    object_id_ = object_id;
  } else {
    clear_has_object_id();
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// cross_arena_ex

// optional uint32 rank_lv = 1;
inline bool cross_arena_ex::has_rank_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cross_arena_ex::set_has_rank_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cross_arena_ex::clear_has_rank_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cross_arena_ex::clear_rank_lv() {
  rank_lv_ = 0u;
  clear_has_rank_lv();
}
inline ::google::protobuf::uint32 cross_arena_ex::rank_lv() const {
  return rank_lv_;
}
inline void cross_arena_ex::set_rank_lv(::google::protobuf::uint32 value) {
  set_has_rank_lv();
  rank_lv_ = value;
}

// optional uint32 score = 2;
inline bool cross_arena_ex::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cross_arena_ex::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cross_arena_ex::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cross_arena_ex::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 cross_arena_ex::score() const {
  return score_;
}
inline void cross_arena_ex::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// cross_arena_param

// optional .proto.common.cross_arena_ex obj1 = 1;
inline bool cross_arena_param::has_obj1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cross_arena_param::set_has_obj1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cross_arena_param::clear_has_obj1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cross_arena_param::clear_obj1() {
  if (obj1_ != NULL) obj1_->::proto::common::cross_arena_ex::Clear();
  clear_has_obj1();
}
inline const ::proto::common::cross_arena_ex& cross_arena_param::obj1() const {
  return obj1_ != NULL ? *obj1_ : *default_instance_->obj1_;
}
inline ::proto::common::cross_arena_ex* cross_arena_param::mutable_obj1() {
  set_has_obj1();
  if (obj1_ == NULL) obj1_ = new ::proto::common::cross_arena_ex;
  return obj1_;
}
inline ::proto::common::cross_arena_ex* cross_arena_param::release_obj1() {
  clear_has_obj1();
  ::proto::common::cross_arena_ex* temp = obj1_;
  obj1_ = NULL;
  return temp;
}
inline void cross_arena_param::set_allocated_obj1(::proto::common::cross_arena_ex* obj1) {
  delete obj1_;
  obj1_ = obj1;
  if (obj1) {
    set_has_obj1();
  } else {
    clear_has_obj1();
  }
}

// optional .proto.common.cross_arena_ex obj2 = 2;
inline bool cross_arena_param::has_obj2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cross_arena_param::set_has_obj2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cross_arena_param::clear_has_obj2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cross_arena_param::clear_obj2() {
  if (obj2_ != NULL) obj2_->::proto::common::cross_arena_ex::Clear();
  clear_has_obj2();
}
inline const ::proto::common::cross_arena_ex& cross_arena_param::obj2() const {
  return obj2_ != NULL ? *obj2_ : *default_instance_->obj2_;
}
inline ::proto::common::cross_arena_ex* cross_arena_param::mutable_obj2() {
  set_has_obj2();
  if (obj2_ == NULL) obj2_ = new ::proto::common::cross_arena_ex;
  return obj2_;
}
inline ::proto::common::cross_arena_ex* cross_arena_param::release_obj2() {
  clear_has_obj2();
  ::proto::common::cross_arena_ex* temp = obj2_;
  obj2_ = NULL;
  return temp;
}
inline void cross_arena_param::set_allocated_obj2(::proto::common::cross_arena_ex* obj2) {
  delete obj2_;
  obj2_ = obj2;
  if (obj2) {
    set_has_obj2();
  } else {
    clear_has_obj2();
  }
}

// optional uint32 arena_ai_id = 3;
inline bool cross_arena_param::has_arena_ai_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cross_arena_param::set_has_arena_ai_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cross_arena_param::clear_has_arena_ai_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cross_arena_param::clear_arena_ai_id() {
  arena_ai_id_ = 0u;
  clear_has_arena_ai_id();
}
inline ::google::protobuf::uint32 cross_arena_param::arena_ai_id() const {
  return arena_ai_id_;
}
inline void cross_arena_param::set_arena_ai_id(::google::protobuf::uint32 value) {
  set_has_arena_ai_id();
  arena_ai_id_ = value;
}

// optional uint32 monster_id = 4;
inline bool cross_arena_param::has_monster_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cross_arena_param::set_has_monster_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cross_arena_param::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cross_arena_param::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 cross_arena_param::monster_id() const {
  return monster_id_;
}
inline void cross_arena_param::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// -------------------------------------------------------------------

// fight_param

// optional .proto.common.fight_type type = 1;
inline bool fight_param::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_param::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_param::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_param::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::common::fight_type fight_param::type() const {
  return static_cast< ::proto::common::fight_type >(type_);
}
inline void fight_param::set_type(::proto::common::fight_type value) {
  assert(::proto::common::fight_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .proto.common.fight_state start = 2;
inline bool fight_param::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_param::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_param::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_param::clear_start() {
  if (start_ != NULL) start_->::proto::common::fight_state::Clear();
  clear_has_start();
}
inline const ::proto::common::fight_state& fight_param::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::proto::common::fight_state* fight_param::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::proto::common::fight_state;
  return start_;
}
inline ::proto::common::fight_state* fight_param::release_start() {
  clear_has_start();
  ::proto::common::fight_state* temp = start_;
  start_ = NULL;
  return temp;
}
inline void fight_param::set_allocated_start(::proto::common::fight_state* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional .proto.common.fight_dark_param dark = 3;
inline bool fight_param::has_dark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_param::set_has_dark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_param::clear_has_dark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_param::clear_dark() {
  if (dark_ != NULL) dark_->::proto::common::fight_dark_param::Clear();
  clear_has_dark();
}
inline const ::proto::common::fight_dark_param& fight_param::dark() const {
  return dark_ != NULL ? *dark_ : *default_instance_->dark_;
}
inline ::proto::common::fight_dark_param* fight_param::mutable_dark() {
  set_has_dark();
  if (dark_ == NULL) dark_ = new ::proto::common::fight_dark_param;
  return dark_;
}
inline ::proto::common::fight_dark_param* fight_param::release_dark() {
  clear_has_dark();
  ::proto::common::fight_dark_param* temp = dark_;
  dark_ = NULL;
  return temp;
}
inline void fight_param::set_allocated_dark(::proto::common::fight_dark_param* dark) {
  delete dark_;
  dark_ = dark;
  if (dark) {
    set_has_dark();
  } else {
    clear_has_dark();
  }
}

// optional .proto.common.fight_light_param light = 4;
inline bool fight_param::has_light() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_param::set_has_light() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_param::clear_has_light() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_param::clear_light() {
  if (light_ != NULL) light_->::proto::common::fight_light_param::Clear();
  clear_has_light();
}
inline const ::proto::common::fight_light_param& fight_param::light() const {
  return light_ != NULL ? *light_ : *default_instance_->light_;
}
inline ::proto::common::fight_light_param* fight_param::mutable_light() {
  set_has_light();
  if (light_ == NULL) light_ = new ::proto::common::fight_light_param;
  return light_;
}
inline ::proto::common::fight_light_param* fight_param::release_light() {
  clear_has_light();
  ::proto::common::fight_light_param* temp = light_;
  light_ = NULL;
  return temp;
}
inline void fight_param::set_allocated_light(::proto::common::fight_light_param* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
}

// optional .proto.common.cross_arena_param cross_arena = 5;
inline bool fight_param::has_cross_arena() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_param::set_has_cross_arena() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_param::clear_has_cross_arena() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_param::clear_cross_arena() {
  if (cross_arena_ != NULL) cross_arena_->::proto::common::cross_arena_param::Clear();
  clear_has_cross_arena();
}
inline const ::proto::common::cross_arena_param& fight_param::cross_arena() const {
  return cross_arena_ != NULL ? *cross_arena_ : *default_instance_->cross_arena_;
}
inline ::proto::common::cross_arena_param* fight_param::mutable_cross_arena() {
  set_has_cross_arena();
  if (cross_arena_ == NULL) cross_arena_ = new ::proto::common::cross_arena_param;
  return cross_arena_;
}
inline ::proto::common::cross_arena_param* fight_param::release_cross_arena() {
  clear_has_cross_arena();
  ::proto::common::cross_arena_param* temp = cross_arena_;
  cross_arena_ = NULL;
  return temp;
}
inline void fight_param::set_allocated_cross_arena(::proto::common::cross_arena_param* cross_arena) {
  delete cross_arena_;
  cross_arena_ = cross_arena;
  if (cross_arena) {
    set_has_cross_arena();
  } else {
    clear_has_cross_arena();
  }
}

// optional uint32 stage_id = 6;
inline bool fight_param::has_stage_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fight_param::set_has_stage_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fight_param::clear_has_stage_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fight_param::clear_stage_id() {
  stage_id_ = 0u;
  clear_has_stage_id();
}
inline ::google::protobuf::uint32 fight_param::stage_id() const {
  return stage_id_;
}
inline void fight_param::set_stage_id(::google::protobuf::uint32 value) {
  set_has_stage_id();
  stage_id_ = value;
}

// optional uint32 against_id = 7;
inline bool fight_param::has_against_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fight_param::set_has_against_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fight_param::clear_has_against_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fight_param::clear_against_id() {
  against_id_ = 0u;
  clear_has_against_id();
}
inline ::google::protobuf::uint32 fight_param::against_id() const {
  return against_id_;
}
inline void fight_param::set_against_id(::google::protobuf::uint32 value) {
  set_has_against_id();
  against_id_ = value;
}

// optional uint64 trigger_id = 8;
inline bool fight_param::has_trigger_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void fight_param::set_has_trigger_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void fight_param::clear_has_trigger_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void fight_param::clear_trigger_id() {
  trigger_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trigger_id();
}
inline ::google::protobuf::uint64 fight_param::trigger_id() const {
  return trigger_id_;
}
inline void fight_param::set_trigger_id(::google::protobuf::uint64 value) {
  set_has_trigger_id();
  trigger_id_ = value;
}

// optional uint32 prepare_time = 9;
inline bool fight_param::has_prepare_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void fight_param::set_has_prepare_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void fight_param::clear_has_prepare_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void fight_param::clear_prepare_time() {
  prepare_time_ = 0u;
  clear_has_prepare_time();
}
inline ::google::protobuf::uint32 fight_param::prepare_time() const {
  return prepare_time_;
}
inline void fight_param::set_prepare_time(::google::protobuf::uint32 value) {
  set_has_prepare_time();
  prepare_time_ = value;
}

// optional uint32 offline_arena_class = 10;
inline bool fight_param::has_offline_arena_class() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void fight_param::set_has_offline_arena_class() {
  _has_bits_[0] |= 0x00000200u;
}
inline void fight_param::clear_has_offline_arena_class() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void fight_param::clear_offline_arena_class() {
  offline_arena_class_ = 0u;
  clear_has_offline_arena_class();
}
inline ::google::protobuf::uint32 fight_param::offline_arena_class() const {
  return offline_arena_class_;
}
inline void fight_param::set_offline_arena_class(::google::protobuf::uint32 value) {
  set_has_offline_arena_class();
  offline_arena_class_ = value;
}

// optional uint32 page_id = 11;
inline bool fight_param::has_page_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void fight_param::set_has_page_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void fight_param::clear_has_page_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void fight_param::clear_page_id() {
  page_id_ = 0u;
  clear_has_page_id();
}
inline ::google::protobuf::uint32 fight_param::page_id() const {
  return page_id_;
}
inline void fight_param::set_page_id(::google::protobuf::uint32 value) {
  set_has_page_id();
  page_id_ = value;
}

// optional uint32 max_rounds = 12;
inline bool fight_param::has_max_rounds() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void fight_param::set_has_max_rounds() {
  _has_bits_[0] |= 0x00000800u;
}
inline void fight_param::clear_has_max_rounds() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void fight_param::clear_max_rounds() {
  max_rounds_ = 0u;
  clear_has_max_rounds();
}
inline ::google::protobuf::uint32 fight_param::max_rounds() const {
  return max_rounds_;
}
inline void fight_param::set_max_rounds(::google::protobuf::uint32 value) {
  set_has_max_rounds();
  max_rounds_ = value;
}

// -------------------------------------------------------------------

// fight_common

// optional string fight_id = 1;
inline bool fight_common::has_fight_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_common::set_has_fight_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_common::clear_has_fight_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_common::clear_fight_id() {
  if (fight_id_ != &::google::protobuf::internal::kEmptyString) {
    fight_id_->clear();
  }
  clear_has_fight_id();
}
inline const ::std::string& fight_common::fight_id() const {
  return *fight_id_;
}
inline void fight_common::set_fight_id(const ::std::string& value) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(value);
}
inline void fight_common::set_fight_id(const char* value) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(value);
}
inline void fight_common::set_fight_id(const char* value, size_t size) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_common::mutable_fight_id() {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  return fight_id_;
}
inline ::std::string* fight_common::release_fight_id() {
  clear_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_id_;
    fight_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_common::set_allocated_fight_id(::std::string* fight_id) {
  if (fight_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_id_;
  }
  if (fight_id) {
    set_has_fight_id();
    fight_id_ = fight_id;
  } else {
    clear_has_fight_id();
    fight_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.fight_param param = 2;
inline bool fight_common::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_common::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_common::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_common::clear_param() {
  if (param_ != NULL) param_->::proto::common::fight_param::Clear();
  clear_has_param();
}
inline const ::proto::common::fight_param& fight_common::param() const {
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::proto::common::fight_param* fight_common::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::proto::common::fight_param;
  return param_;
}
inline ::proto::common::fight_param* fight_common::release_param() {
  clear_has_param();
  ::proto::common::fight_param* temp = param_;
  param_ = NULL;
  return temp;
}
inline void fight_common::set_allocated_param(::proto::common::fight_param* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
}

// optional uint32 self_position_id = 3;
inline bool fight_common::has_self_position_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_common::set_has_self_position_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_common::clear_has_self_position_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_common::clear_self_position_id() {
  self_position_id_ = 0u;
  clear_has_self_position_id();
}
inline ::google::protobuf::uint32 fight_common::self_position_id() const {
  return self_position_id_;
}
inline void fight_common::set_self_position_id(::google::protobuf::uint32 value) {
  set_has_self_position_id();
  self_position_id_ = value;
}

// optional uint32 enemy_position_id = 4;
inline bool fight_common::has_enemy_position_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_common::set_has_enemy_position_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_common::clear_has_enemy_position_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_common::clear_enemy_position_id() {
  enemy_position_id_ = 0u;
  clear_has_enemy_position_id();
}
inline ::google::protobuf::uint32 fight_common::enemy_position_id() const {
  return enemy_position_id_;
}
inline void fight_common::set_enemy_position_id(::google::protobuf::uint32 value) {
  set_has_enemy_position_id();
  enemy_position_id_ = value;
}

// optional string fight_initiator = 5;
inline bool fight_common::has_fight_initiator() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_common::set_has_fight_initiator() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_common::clear_has_fight_initiator() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_common::clear_fight_initiator() {
  if (fight_initiator_ != &::google::protobuf::internal::kEmptyString) {
    fight_initiator_->clear();
  }
  clear_has_fight_initiator();
}
inline const ::std::string& fight_common::fight_initiator() const {
  return *fight_initiator_;
}
inline void fight_common::set_fight_initiator(const ::std::string& value) {
  set_has_fight_initiator();
  if (fight_initiator_ == &::google::protobuf::internal::kEmptyString) {
    fight_initiator_ = new ::std::string;
  }
  fight_initiator_->assign(value);
}
inline void fight_common::set_fight_initiator(const char* value) {
  set_has_fight_initiator();
  if (fight_initiator_ == &::google::protobuf::internal::kEmptyString) {
    fight_initiator_ = new ::std::string;
  }
  fight_initiator_->assign(value);
}
inline void fight_common::set_fight_initiator(const char* value, size_t size) {
  set_has_fight_initiator();
  if (fight_initiator_ == &::google::protobuf::internal::kEmptyString) {
    fight_initiator_ = new ::std::string;
  }
  fight_initiator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_common::mutable_fight_initiator() {
  set_has_fight_initiator();
  if (fight_initiator_ == &::google::protobuf::internal::kEmptyString) {
    fight_initiator_ = new ::std::string;
  }
  return fight_initiator_;
}
inline ::std::string* fight_common::release_fight_initiator() {
  clear_has_fight_initiator();
  if (fight_initiator_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_initiator_;
    fight_initiator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_common::set_allocated_fight_initiator(::std::string* fight_initiator) {
  if (fight_initiator_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_initiator_;
  }
  if (fight_initiator) {
    set_has_fight_initiator();
    fight_initiator_ = fight_initiator;
  } else {
    clear_has_fight_initiator();
    fight_initiator_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// obj_single

// optional string object_uid = 1;
inline bool obj_single::has_object_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void obj_single::set_has_object_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void obj_single::clear_has_object_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void obj_single::clear_object_uid() {
  if (object_uid_ != &::google::protobuf::internal::kEmptyString) {
    object_uid_->clear();
  }
  clear_has_object_uid();
}
inline const ::std::string& obj_single::object_uid() const {
  return *object_uid_;
}
inline void obj_single::set_object_uid(const ::std::string& value) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(value);
}
inline void obj_single::set_object_uid(const char* value) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(value);
}
inline void obj_single::set_object_uid(const char* value, size_t size) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* obj_single::mutable_object_uid() {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  return object_uid_;
}
inline ::std::string* obj_single::release_object_uid() {
  clear_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_uid_;
    object_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void obj_single::set_allocated_object_uid(::std::string* object_uid) {
  if (object_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete object_uid_;
  }
  if (object_uid) {
    set_has_object_uid();
    object_uid_ = object_uid;
  } else {
    clear_has_object_uid();
    object_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2 [default = SCENEOBJECT_USER];
inline bool obj_single::has_object_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void obj_single::set_has_object_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void obj_single::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void obj_single::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE obj_single::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void obj_single::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional uint32 monster_id = 3;
inline bool obj_single::has_monster_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void obj_single::set_has_monster_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void obj_single::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void obj_single::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 obj_single::monster_id() const {
  return monster_id_;
}
inline void obj_single::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// optional uint32 camp = 4;
inline bool obj_single::has_camp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void obj_single::set_has_camp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void obj_single::clear_has_camp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void obj_single::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 obj_single::camp() const {
  return camp_;
}
inline void obj_single::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
}

// optional uint32 auto_fight = 5;
inline bool obj_single::has_auto_fight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void obj_single::set_has_auto_fight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void obj_single::clear_has_auto_fight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void obj_single::clear_auto_fight() {
  auto_fight_ = 0u;
  clear_has_auto_fight();
}
inline ::google::protobuf::uint32 obj_single::auto_fight() const {
  return auto_fight_;
}
inline void obj_single::set_auto_fight(::google::protobuf::uint32 value) {
  set_has_auto_fight();
  auto_fight_ = value;
}

// optional uint32 sp = 6;
inline bool obj_single::has_sp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void obj_single::set_has_sp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void obj_single::clear_has_sp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void obj_single::clear_sp() {
  sp_ = 0u;
  clear_has_sp();
}
inline ::google::protobuf::uint32 obj_single::sp() const {
  return sp_;
}
inline void obj_single::set_sp(::google::protobuf::uint32 value) {
  set_has_sp();
  sp_ = value;
}

// optional string name = 7;
inline bool obj_single::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void obj_single::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void obj_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void obj_single::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& obj_single::name() const {
  return *name_;
}
inline void obj_single::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void obj_single::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void obj_single::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* obj_single::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* obj_single::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void obj_single::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 8;
inline bool obj_single::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void obj_single::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void obj_single::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void obj_single::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 obj_single::level() const {
  return level_;
}
inline void obj_single::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 head_id = 9;
inline bool obj_single::has_head_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void obj_single::set_has_head_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void obj_single::clear_has_head_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void obj_single::clear_head_id() {
  head_id_ = 0u;
  clear_has_head_id();
}
inline ::google::protobuf::uint32 obj_single::head_id() const {
  return head_id_;
}
inline void obj_single::set_head_id(::google::protobuf::uint32 value) {
  set_has_head_id();
  head_id_ = value;
}

// optional uint32 country = 10;
inline bool obj_single::has_country() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void obj_single::set_has_country() {
  _has_bits_[0] |= 0x00000200u;
}
inline void obj_single::clear_has_country() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void obj_single::clear_country() {
  country_ = 0u;
  clear_has_country();
}
inline ::google::protobuf::uint32 obj_single::country() const {
  return country_;
}
inline void obj_single::set_country(::google::protobuf::uint32 value) {
  set_has_country();
  country_ = value;
}

// optional string family_name = 11;
inline bool obj_single::has_family_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void obj_single::set_has_family_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void obj_single::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void obj_single::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& obj_single::family_name() const {
  return *family_name_;
}
inline void obj_single::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void obj_single::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void obj_single::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* obj_single::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* obj_single::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void obj_single::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fighting = 12;
inline bool obj_single::has_fighting() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void obj_single::set_has_fighting() {
  _has_bits_[0] |= 0x00000800u;
}
inline void obj_single::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void obj_single::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 obj_single::fighting() const {
  return fighting_;
}
inline void obj_single::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 life_level = 13;
inline bool obj_single::has_life_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void obj_single::set_has_life_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void obj_single::clear_has_life_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void obj_single::clear_life_level() {
  life_level_ = 0u;
  clear_has_life_level();
}
inline ::google::protobuf::uint32 obj_single::life_level() const {
  return life_level_;
}
inline void obj_single::set_life_level(::google::protobuf::uint32 value) {
  set_has_life_level();
  life_level_ = value;
}

// optional uint32 team_member_size = 14;
inline bool obj_single::has_team_member_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void obj_single::set_has_team_member_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void obj_single::clear_has_team_member_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void obj_single::clear_team_member_size() {
  team_member_size_ = 0u;
  clear_has_team_member_size();
}
inline ::google::protobuf::uint32 obj_single::team_member_size() const {
  return team_member_size_;
}
inline void obj_single::set_team_member_size(::google::protobuf::uint32 value) {
  set_has_team_member_size();
  team_member_size_ = value;
}

// optional int32 team_member_pos = 15;
inline bool obj_single::has_team_member_pos() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void obj_single::set_has_team_member_pos() {
  _has_bits_[0] |= 0x00004000u;
}
inline void obj_single::clear_has_team_member_pos() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void obj_single::clear_team_member_pos() {
  team_member_pos_ = 0;
  clear_has_team_member_pos();
}
inline ::google::protobuf::int32 obj_single::team_member_pos() const {
  return team_member_pos_;
}
inline void obj_single::set_team_member_pos(::google::protobuf::int32 value) {
  set_has_team_member_pos();
  team_member_pos_ = value;
}

// optional uint32 auto_ignore_lineup = 16;
inline bool obj_single::has_auto_ignore_lineup() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void obj_single::set_has_auto_ignore_lineup() {
  _has_bits_[0] |= 0x00008000u;
}
inline void obj_single::clear_has_auto_ignore_lineup() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void obj_single::clear_auto_ignore_lineup() {
  auto_ignore_lineup_ = 0u;
  clear_has_auto_ignore_lineup();
}
inline ::google::protobuf::uint32 obj_single::auto_ignore_lineup() const {
  return auto_ignore_lineup_;
}
inline void obj_single::set_auto_ignore_lineup(::google::protobuf::uint32 value) {
  set_has_auto_ignore_lineup();
  auto_ignore_lineup_ = value;
}

// -------------------------------------------------------------------

// obj_data

// repeated .proto.common.obj_single obj = 1;
inline int obj_data::obj_size() const {
  return obj_.size();
}
inline void obj_data::clear_obj() {
  obj_.Clear();
}
inline const ::proto::common::obj_single& obj_data::obj(int index) const {
  return obj_.Get(index);
}
inline ::proto::common::obj_single* obj_data::mutable_obj(int index) {
  return obj_.Mutable(index);
}
inline ::proto::common::obj_single* obj_data::add_obj() {
  return obj_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::obj_single >&
obj_data::obj() const {
  return obj_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::obj_single >*
obj_data::mutable_obj() {
  return &obj_;
}

// -------------------------------------------------------------------

// fight_camp

// optional .proto.common.obj_data objs = 1;
inline bool fight_camp::has_objs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_camp::set_has_objs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_camp::clear_has_objs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_camp::clear_objs() {
  if (objs_ != NULL) objs_->::proto::common::obj_data::Clear();
  clear_has_objs();
}
inline const ::proto::common::obj_data& fight_camp::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::proto::common::obj_data* fight_camp::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::proto::common::obj_data;
  return objs_;
}
inline ::proto::common::obj_data* fight_camp::release_objs() {
  clear_has_objs();
  ::proto::common::obj_data* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void fight_camp::set_allocated_objs(::proto::common::obj_data* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// optional .proto.common.hero_data heroes = 2;
inline bool fight_camp::has_heroes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_camp::set_has_heroes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_camp::clear_has_heroes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_camp::clear_heroes() {
  if (heroes_ != NULL) heroes_->::proto::common::hero_data::Clear();
  clear_has_heroes();
}
inline const ::proto::common::hero_data& fight_camp::heroes() const {
  return heroes_ != NULL ? *heroes_ : *default_instance_->heroes_;
}
inline ::proto::common::hero_data* fight_camp::mutable_heroes() {
  set_has_heroes();
  if (heroes_ == NULL) heroes_ = new ::proto::common::hero_data;
  return heroes_;
}
inline ::proto::common::hero_data* fight_camp::release_heroes() {
  clear_has_heroes();
  ::proto::common::hero_data* temp = heroes_;
  heroes_ = NULL;
  return temp;
}
inline void fight_camp::set_allocated_heroes(::proto::common::hero_data* heroes) {
  delete heroes_;
  heroes_ = heroes;
  if (heroes) {
    set_has_heroes();
  } else {
    clear_has_heroes();
  }
}

// optional uint32 camp = 3;
inline bool fight_camp::has_camp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_camp::set_has_camp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_camp::clear_has_camp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_camp::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 fight_camp::camp() const {
  return camp_;
}
inline void fight_camp::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
}

// optional uint32 tactic = 4;
inline bool fight_camp::has_tactic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_camp::set_has_tactic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_camp::clear_has_tactic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_camp::clear_tactic() {
  tactic_ = 0u;
  clear_has_tactic();
}
inline ::google::protobuf::uint32 fight_camp::tactic() const {
  return tactic_;
}
inline void fight_camp::set_tactic(::google::protobuf::uint32 value) {
  set_has_tactic();
  tactic_ = value;
}

// optional uint32 tactic_switch = 5;
inline bool fight_camp::has_tactic_switch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_camp::set_has_tactic_switch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_camp::clear_has_tactic_switch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_camp::clear_tactic_switch() {
  tactic_switch_ = 0u;
  clear_has_tactic_switch();
}
inline ::google::protobuf::uint32 fight_camp::tactic_switch() const {
  return tactic_switch_;
}
inline void fight_camp::set_tactic_switch(::google::protobuf::uint32 value) {
  set_has_tactic_switch();
  tactic_switch_ = value;
}

// optional .proto.common.hero_data help_heroes = 6;
inline bool fight_camp::has_help_heroes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fight_camp::set_has_help_heroes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fight_camp::clear_has_help_heroes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fight_camp::clear_help_heroes() {
  if (help_heroes_ != NULL) help_heroes_->::proto::common::hero_data::Clear();
  clear_has_help_heroes();
}
inline const ::proto::common::hero_data& fight_camp::help_heroes() const {
  return help_heroes_ != NULL ? *help_heroes_ : *default_instance_->help_heroes_;
}
inline ::proto::common::hero_data* fight_camp::mutable_help_heroes() {
  set_has_help_heroes();
  if (help_heroes_ == NULL) help_heroes_ = new ::proto::common::hero_data;
  return help_heroes_;
}
inline ::proto::common::hero_data* fight_camp::release_help_heroes() {
  clear_has_help_heroes();
  ::proto::common::hero_data* temp = help_heroes_;
  help_heroes_ = NULL;
  return temp;
}
inline void fight_camp::set_allocated_help_heroes(::proto::common::hero_data* help_heroes) {
  delete help_heroes_;
  help_heroes_ = help_heroes;
  if (help_heroes) {
    set_has_help_heroes();
  } else {
    clear_has_help_heroes();
  }
}

// -------------------------------------------------------------------

// fight_state

// optional .proto.common.hero_state_data self = 1;
inline bool fight_state::has_self() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_state::set_has_self() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_state::clear_has_self() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_state::clear_self() {
  if (self_ != NULL) self_->::proto::common::hero_state_data::Clear();
  clear_has_self();
}
inline const ::proto::common::hero_state_data& fight_state::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::proto::common::hero_state_data* fight_state::mutable_self() {
  set_has_self();
  if (self_ == NULL) self_ = new ::proto::common::hero_state_data;
  return self_;
}
inline ::proto::common::hero_state_data* fight_state::release_self() {
  clear_has_self();
  ::proto::common::hero_state_data* temp = self_;
  self_ = NULL;
  return temp;
}
inline void fight_state::set_allocated_self(::proto::common::hero_state_data* self) {
  delete self_;
  self_ = self;
  if (self) {
    set_has_self();
  } else {
    clear_has_self();
  }
}

// optional .proto.common.hero_state_data enemy = 2;
inline bool fight_state::has_enemy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_state::set_has_enemy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_state::clear_has_enemy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_state::clear_enemy() {
  if (enemy_ != NULL) enemy_->::proto::common::hero_state_data::Clear();
  clear_has_enemy();
}
inline const ::proto::common::hero_state_data& fight_state::enemy() const {
  return enemy_ != NULL ? *enemy_ : *default_instance_->enemy_;
}
inline ::proto::common::hero_state_data* fight_state::mutable_enemy() {
  set_has_enemy();
  if (enemy_ == NULL) enemy_ = new ::proto::common::hero_state_data;
  return enemy_;
}
inline ::proto::common::hero_state_data* fight_state::release_enemy() {
  clear_has_enemy();
  ::proto::common::hero_state_data* temp = enemy_;
  enemy_ = NULL;
  return temp;
}
inline void fight_state::set_allocated_enemy(::proto::common::hero_state_data* enemy) {
  delete enemy_;
  enemy_ = enemy;
  if (enemy) {
    set_has_enemy();
  } else {
    clear_has_enemy();
  }
}

// -------------------------------------------------------------------

// fight_data

// optional .proto.common.fight_common common = 1;
inline bool fight_data::has_common() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_data::set_has_common() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_data::clear_has_common() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_data::clear_common() {
  if (common_ != NULL) common_->::proto::common::fight_common::Clear();
  clear_has_common();
}
inline const ::proto::common::fight_common& fight_data::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::proto::common::fight_common* fight_data::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::proto::common::fight_common;
  return common_;
}
inline ::proto::common::fight_common* fight_data::release_common() {
  clear_has_common();
  ::proto::common::fight_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void fight_data::set_allocated_common(::proto::common::fight_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// optional .proto.common.fight_camp self = 2;
inline bool fight_data::has_self() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_data::set_has_self() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_data::clear_has_self() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_data::clear_self() {
  if (self_ != NULL) self_->::proto::common::fight_camp::Clear();
  clear_has_self();
}
inline const ::proto::common::fight_camp& fight_data::self() const {
  return self_ != NULL ? *self_ : *default_instance_->self_;
}
inline ::proto::common::fight_camp* fight_data::mutable_self() {
  set_has_self();
  if (self_ == NULL) self_ = new ::proto::common::fight_camp;
  return self_;
}
inline ::proto::common::fight_camp* fight_data::release_self() {
  clear_has_self();
  ::proto::common::fight_camp* temp = self_;
  self_ = NULL;
  return temp;
}
inline void fight_data::set_allocated_self(::proto::common::fight_camp* self) {
  delete self_;
  self_ = self;
  if (self) {
    set_has_self();
  } else {
    clear_has_self();
  }
}

// optional .proto.common.fight_camp enemy = 3;
inline bool fight_data::has_enemy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_data::set_has_enemy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_data::clear_has_enemy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_data::clear_enemy() {
  if (enemy_ != NULL) enemy_->::proto::common::fight_camp::Clear();
  clear_has_enemy();
}
inline const ::proto::common::fight_camp& fight_data::enemy() const {
  return enemy_ != NULL ? *enemy_ : *default_instance_->enemy_;
}
inline ::proto::common::fight_camp* fight_data::mutable_enemy() {
  set_has_enemy();
  if (enemy_ == NULL) enemy_ = new ::proto::common::fight_camp;
  return enemy_;
}
inline ::proto::common::fight_camp* fight_data::release_enemy() {
  clear_has_enemy();
  ::proto::common::fight_camp* temp = enemy_;
  enemy_ = NULL;
  return temp;
}
inline void fight_data::set_allocated_enemy(::proto::common::fight_camp* enemy) {
  delete enemy_;
  enemy_ = enemy;
  if (enemy) {
    set_has_enemy();
  } else {
    clear_has_enemy();
  }
}

// -------------------------------------------------------------------

// fight_recovery_obj_single

// optional string id = 1;
inline bool fight_recovery_obj_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_recovery_obj_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_recovery_obj_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_recovery_obj_single::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& fight_recovery_obj_single::id() const {
  return *id_;
}
inline void fight_recovery_obj_single::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void fight_recovery_obj_single::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void fight_recovery_obj_single::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_recovery_obj_single::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* fight_recovery_obj_single::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_recovery_obj_single::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sp = 2;
inline bool fight_recovery_obj_single::has_sp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_recovery_obj_single::set_has_sp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_recovery_obj_single::clear_has_sp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_recovery_obj_single::clear_sp() {
  sp_ = 0u;
  clear_has_sp();
}
inline ::google::protobuf::uint32 fight_recovery_obj_single::sp() const {
  return sp_;
}
inline void fight_recovery_obj_single::set_sp(::google::protobuf::uint32 value) {
  set_has_sp();
  sp_ = value;
}

// -------------------------------------------------------------------

// fight_recovery_obj_data

// repeated .proto.common.fight_recovery_obj_single objs = 1;
inline int fight_recovery_obj_data::objs_size() const {
  return objs_.size();
}
inline void fight_recovery_obj_data::clear_objs() {
  objs_.Clear();
}
inline const ::proto::common::fight_recovery_obj_single& fight_recovery_obj_data::objs(int index) const {
  return objs_.Get(index);
}
inline ::proto::common::fight_recovery_obj_single* fight_recovery_obj_data::mutable_objs(int index) {
  return objs_.Mutable(index);
}
inline ::proto::common::fight_recovery_obj_single* fight_recovery_obj_data::add_objs() {
  return objs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_obj_single >&
fight_recovery_obj_data::objs() const {
  return objs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_obj_single >*
fight_recovery_obj_data::mutable_objs() {
  return &objs_;
}

// -------------------------------------------------------------------

// fight_buff_single_data

// optional uint32 buff_id = 1;
inline bool fight_buff_single_data::has_buff_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_buff_single_data::set_has_buff_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_buff_single_data::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_buff_single_data::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 fight_buff_single_data::buff_id() const {
  return buff_id_;
}
inline void fight_buff_single_data::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// optional string attacker = 2;
inline bool fight_buff_single_data::has_attacker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_buff_single_data::set_has_attacker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_buff_single_data::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_buff_single_data::clear_attacker() {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    attacker_->clear();
  }
  clear_has_attacker();
}
inline const ::std::string& fight_buff_single_data::attacker() const {
  return *attacker_;
}
inline void fight_buff_single_data::set_attacker(const ::std::string& value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void fight_buff_single_data::set_attacker(const char* value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void fight_buff_single_data::set_attacker(const char* value, size_t size) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_buff_single_data::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  return attacker_;
}
inline ::std::string* fight_buff_single_data::release_attacker() {
  clear_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attacker_;
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_buff_single_data::set_allocated_attacker(::std::string* attacker) {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    delete attacker_;
  }
  if (attacker) {
    set_has_attacker();
    attacker_ = attacker;
  } else {
    clear_has_attacker();
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 layer = 3;
inline bool fight_buff_single_data::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_buff_single_data::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_buff_single_data::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_buff_single_data::clear_layer() {
  layer_ = 0u;
  clear_has_layer();
}
inline ::google::protobuf::uint32 fight_buff_single_data::layer() const {
  return layer_;
}
inline void fight_buff_single_data::set_layer(::google::protobuf::uint32 value) {
  set_has_layer();
  layer_ = value;
}

// optional uint32 round = 4;
inline bool fight_buff_single_data::has_round() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_buff_single_data::set_has_round() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_buff_single_data::clear_has_round() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_buff_single_data::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 fight_buff_single_data::round() const {
  return round_;
}
inline void fight_buff_single_data::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// optional uint32 buff_tid = 5;
inline bool fight_buff_single_data::has_buff_tid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_buff_single_data::set_has_buff_tid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_buff_single_data::clear_has_buff_tid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_buff_single_data::clear_buff_tid() {
  buff_tid_ = 0u;
  clear_has_buff_tid();
}
inline ::google::protobuf::uint32 fight_buff_single_data::buff_tid() const {
  return buff_tid_;
}
inline void fight_buff_single_data::set_buff_tid(::google::protobuf::uint32 value) {
  set_has_buff_tid();
  buff_tid_ = value;
}

// -------------------------------------------------------------------

// fight_buff_data

// repeated .proto.common.fight_buff_single_data buff_list = 1;
inline int fight_buff_data::buff_list_size() const {
  return buff_list_.size();
}
inline void fight_buff_data::clear_buff_list() {
  buff_list_.Clear();
}
inline const ::proto::common::fight_buff_single_data& fight_buff_data::buff_list(int index) const {
  return buff_list_.Get(index);
}
inline ::proto::common::fight_buff_single_data* fight_buff_data::mutable_buff_list(int index) {
  return buff_list_.Mutable(index);
}
inline ::proto::common::fight_buff_single_data* fight_buff_data::add_buff_list() {
  return buff_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_buff_single_data >&
fight_buff_data::buff_list() const {
  return buff_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_buff_single_data >*
fight_buff_data::mutable_buff_list() {
  return &buff_list_;
}

// -------------------------------------------------------------------

// fight_hero_skill_single_data

// optional uint32 skill_id = 1;
inline bool fight_hero_skill_single_data::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_hero_skill_single_data::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_hero_skill_single_data::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_hero_skill_single_data::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 fight_hero_skill_single_data::skill_id() const {
  return skill_id_;
}
inline void fight_hero_skill_single_data::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 skill_cd = 2;
inline bool fight_hero_skill_single_data::has_skill_cd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_hero_skill_single_data::set_has_skill_cd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_hero_skill_single_data::clear_has_skill_cd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_hero_skill_single_data::clear_skill_cd() {
  skill_cd_ = 0u;
  clear_has_skill_cd();
}
inline ::google::protobuf::uint32 fight_hero_skill_single_data::skill_cd() const {
  return skill_cd_;
}
inline void fight_hero_skill_single_data::set_skill_cd(::google::protobuf::uint32 value) {
  set_has_skill_cd();
  skill_cd_ = value;
}

// -------------------------------------------------------------------

// combat_all_action_data

// repeated .proto.common.combat_action_data action_data = 1;
inline int combat_all_action_data::action_data_size() const {
  return action_data_.size();
}
inline void combat_all_action_data::clear_action_data() {
  action_data_.Clear();
}
inline const ::proto::common::combat_action_data& combat_all_action_data::action_data(int index) const {
  return action_data_.Get(index);
}
inline ::proto::common::combat_action_data* combat_all_action_data::mutable_action_data(int index) {
  return action_data_.Mutable(index);
}
inline ::proto::common::combat_action_data* combat_all_action_data::add_action_data() {
  return action_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_action_data >&
combat_all_action_data::action_data() const {
  return action_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_action_data >*
combat_all_action_data::mutable_action_data() {
  return &action_data_;
}

// -------------------------------------------------------------------

// fight_video_data

// optional .proto.common.fight_data data = 1;
inline bool fight_video_data::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_video_data::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_video_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_video_data::clear_data() {
  if (data_ != NULL) data_->::proto::common::fight_data::Clear();
  clear_has_data();
}
inline const ::proto::common::fight_data& fight_video_data::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::proto::common::fight_data* fight_video_data::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::proto::common::fight_data;
  return data_;
}
inline ::proto::common::fight_data* fight_video_data::release_data() {
  clear_has_data();
  ::proto::common::fight_data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void fight_video_data::set_allocated_data(::proto::common::fight_data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional .proto.common.combat_all_action_data action_data = 2;
inline bool fight_video_data::has_action_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_video_data::set_has_action_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_video_data::clear_has_action_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_video_data::clear_action_data() {
  if (action_data_ != NULL) action_data_->::proto::common::combat_all_action_data::Clear();
  clear_has_action_data();
}
inline const ::proto::common::combat_all_action_data& fight_video_data::action_data() const {
  return action_data_ != NULL ? *action_data_ : *default_instance_->action_data_;
}
inline ::proto::common::combat_all_action_data* fight_video_data::mutable_action_data() {
  set_has_action_data();
  if (action_data_ == NULL) action_data_ = new ::proto::common::combat_all_action_data;
  return action_data_;
}
inline ::proto::common::combat_all_action_data* fight_video_data::release_action_data() {
  clear_has_action_data();
  ::proto::common::combat_all_action_data* temp = action_data_;
  action_data_ = NULL;
  return temp;
}
inline void fight_video_data::set_allocated_action_data(::proto::common::combat_all_action_data* action_data) {
  delete action_data_;
  action_data_ = action_data;
  if (action_data) {
    set_has_action_data();
  } else {
    clear_has_action_data();
  }
}

// optional .proto.common.combat_count_data result = 3;
inline bool fight_video_data::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_video_data::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_video_data::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_video_data::clear_result() {
  if (result_ != NULL) result_->::proto::common::combat_count_data::Clear();
  clear_has_result();
}
inline const ::proto::common::combat_count_data& fight_video_data::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::proto::common::combat_count_data* fight_video_data::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::proto::common::combat_count_data;
  return result_;
}
inline ::proto::common::combat_count_data* fight_video_data::release_result() {
  clear_has_result();
  ::proto::common::combat_count_data* temp = result_;
  result_ = NULL;
  return temp;
}
inline void fight_video_data::set_allocated_result(::proto::common::combat_count_data* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// fight_hero_skill_data

// repeated .proto.common.skill_single skill_list = 1;
inline int fight_hero_skill_data::skill_list_size() const {
  return skill_list_.size();
}
inline void fight_hero_skill_data::clear_skill_list() {
  skill_list_.Clear();
}
inline const ::proto::common::skill_single& fight_hero_skill_data::skill_list(int index) const {
  return skill_list_.Get(index);
}
inline ::proto::common::skill_single* fight_hero_skill_data::mutable_skill_list(int index) {
  return skill_list_.Mutable(index);
}
inline ::proto::common::skill_single* fight_hero_skill_data::add_skill_list() {
  return skill_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >&
fight_hero_skill_data::skill_list() const {
  return skill_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_single >*
fight_hero_skill_data::mutable_skill_list() {
  return &skill_list_;
}

// -------------------------------------------------------------------

// fight_hero_attr_single_data

// optional uint32 id = 1;
inline bool fight_hero_attr_single_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_hero_attr_single_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_hero_attr_single_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_hero_attr_single_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 fight_hero_attr_single_data::id() const {
  return id_;
}
inline void fight_hero_attr_single_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 value = 2;
inline bool fight_hero_attr_single_data::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_hero_attr_single_data::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_hero_attr_single_data::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_hero_attr_single_data::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 fight_hero_attr_single_data::value() const {
  return value_;
}
inline void fight_hero_attr_single_data::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// fight_hero_attr_data

// repeated .proto.common.fight_hero_attr_single_data attr_list = 1;
inline int fight_hero_attr_data::attr_list_size() const {
  return attr_list_.size();
}
inline void fight_hero_attr_data::clear_attr_list() {
  attr_list_.Clear();
}
inline const ::proto::common::fight_hero_attr_single_data& fight_hero_attr_data::attr_list(int index) const {
  return attr_list_.Get(index);
}
inline ::proto::common::fight_hero_attr_single_data* fight_hero_attr_data::mutable_attr_list(int index) {
  return attr_list_.Mutable(index);
}
inline ::proto::common::fight_hero_attr_single_data* fight_hero_attr_data::add_attr_list() {
  return attr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_hero_attr_single_data >&
fight_hero_attr_data::attr_list() const {
  return attr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_hero_attr_single_data >*
fight_hero_attr_data::mutable_attr_list() {
  return &attr_list_;
}

// -------------------------------------------------------------------

// fight_recovery_hero_single_data

// optional string id = 1;
inline bool fight_recovery_hero_single_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_recovery_hero_single_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_recovery_hero_single_data::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& fight_recovery_hero_single_data::id() const {
  return *id_;
}
inline void fight_recovery_hero_single_data::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void fight_recovery_hero_single_data::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void fight_recovery_hero_single_data::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_recovery_hero_single_data::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* fight_recovery_hero_single_data::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_recovery_hero_single_data::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cur_hp = 2;
inline bool fight_recovery_hero_single_data::has_cur_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_cur_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_recovery_hero_single_data::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_recovery_hero_single_data::clear_cur_hp() {
  cur_hp_ = 0u;
  clear_has_cur_hp();
}
inline ::google::protobuf::uint32 fight_recovery_hero_single_data::cur_hp() const {
  return cur_hp_;
}
inline void fight_recovery_hero_single_data::set_cur_hp(::google::protobuf::uint32 value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// optional .proto.common.fight_buff_data buff_data = 3;
inline bool fight_recovery_hero_single_data::has_buff_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_buff_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_recovery_hero_single_data::clear_has_buff_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_recovery_hero_single_data::clear_buff_data() {
  if (buff_data_ != NULL) buff_data_->::proto::common::fight_buff_data::Clear();
  clear_has_buff_data();
}
inline const ::proto::common::fight_buff_data& fight_recovery_hero_single_data::buff_data() const {
  return buff_data_ != NULL ? *buff_data_ : *default_instance_->buff_data_;
}
inline ::proto::common::fight_buff_data* fight_recovery_hero_single_data::mutable_buff_data() {
  set_has_buff_data();
  if (buff_data_ == NULL) buff_data_ = new ::proto::common::fight_buff_data;
  return buff_data_;
}
inline ::proto::common::fight_buff_data* fight_recovery_hero_single_data::release_buff_data() {
  clear_has_buff_data();
  ::proto::common::fight_buff_data* temp = buff_data_;
  buff_data_ = NULL;
  return temp;
}
inline void fight_recovery_hero_single_data::set_allocated_buff_data(::proto::common::fight_buff_data* buff_data) {
  delete buff_data_;
  buff_data_ = buff_data;
  if (buff_data) {
    set_has_buff_data();
  } else {
    clear_has_buff_data();
  }
}

// optional uint32 mark_id = 4;
inline bool fight_recovery_hero_single_data::has_mark_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_mark_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_recovery_hero_single_data::clear_has_mark_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_recovery_hero_single_data::clear_mark_id() {
  mark_id_ = 0u;
  clear_has_mark_id();
}
inline ::google::protobuf::uint32 fight_recovery_hero_single_data::mark_id() const {
  return mark_id_;
}
inline void fight_recovery_hero_single_data::set_mark_id(::google::protobuf::uint32 value) {
  set_has_mark_id();
  mark_id_ = value;
}

// optional .proto.common.fight_hero_skill_data skill_data = 5;
inline bool fight_recovery_hero_single_data::has_skill_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_skill_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void fight_recovery_hero_single_data::clear_has_skill_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void fight_recovery_hero_single_data::clear_skill_data() {
  if (skill_data_ != NULL) skill_data_->::proto::common::fight_hero_skill_data::Clear();
  clear_has_skill_data();
}
inline const ::proto::common::fight_hero_skill_data& fight_recovery_hero_single_data::skill_data() const {
  return skill_data_ != NULL ? *skill_data_ : *default_instance_->skill_data_;
}
inline ::proto::common::fight_hero_skill_data* fight_recovery_hero_single_data::mutable_skill_data() {
  set_has_skill_data();
  if (skill_data_ == NULL) skill_data_ = new ::proto::common::fight_hero_skill_data;
  return skill_data_;
}
inline ::proto::common::fight_hero_skill_data* fight_recovery_hero_single_data::release_skill_data() {
  clear_has_skill_data();
  ::proto::common::fight_hero_skill_data* temp = skill_data_;
  skill_data_ = NULL;
  return temp;
}
inline void fight_recovery_hero_single_data::set_allocated_skill_data(::proto::common::fight_hero_skill_data* skill_data) {
  delete skill_data_;
  skill_data_ = skill_data;
  if (skill_data) {
    set_has_skill_data();
  } else {
    clear_has_skill_data();
  }
}

// optional uint32 speed = 6;
inline bool fight_recovery_hero_single_data::has_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void fight_recovery_hero_single_data::clear_has_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void fight_recovery_hero_single_data::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
inline ::google::protobuf::uint32 fight_recovery_hero_single_data::speed() const {
  return speed_;
}
inline void fight_recovery_hero_single_data::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
}

// optional .proto.common.fight_hero_attr_data attrs = 7;
inline bool fight_recovery_hero_single_data::has_attrs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void fight_recovery_hero_single_data::set_has_attrs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void fight_recovery_hero_single_data::clear_has_attrs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void fight_recovery_hero_single_data::clear_attrs() {
  if (attrs_ != NULL) attrs_->::proto::common::fight_hero_attr_data::Clear();
  clear_has_attrs();
}
inline const ::proto::common::fight_hero_attr_data& fight_recovery_hero_single_data::attrs() const {
  return attrs_ != NULL ? *attrs_ : *default_instance_->attrs_;
}
inline ::proto::common::fight_hero_attr_data* fight_recovery_hero_single_data::mutable_attrs() {
  set_has_attrs();
  if (attrs_ == NULL) attrs_ = new ::proto::common::fight_hero_attr_data;
  return attrs_;
}
inline ::proto::common::fight_hero_attr_data* fight_recovery_hero_single_data::release_attrs() {
  clear_has_attrs();
  ::proto::common::fight_hero_attr_data* temp = attrs_;
  attrs_ = NULL;
  return temp;
}
inline void fight_recovery_hero_single_data::set_allocated_attrs(::proto::common::fight_hero_attr_data* attrs) {
  delete attrs_;
  attrs_ = attrs;
  if (attrs) {
    set_has_attrs();
  } else {
    clear_has_attrs();
  }
}

// -------------------------------------------------------------------

// fight_recovery_hero_data

// repeated .proto.common.fight_recovery_hero_single_data hero_list = 1;
inline int fight_recovery_hero_data::hero_list_size() const {
  return hero_list_.size();
}
inline void fight_recovery_hero_data::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::fight_recovery_hero_single_data& fight_recovery_hero_data::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::fight_recovery_hero_single_data* fight_recovery_hero_data::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::fight_recovery_hero_single_data* fight_recovery_hero_data::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_hero_single_data >&
fight_recovery_hero_data::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_recovery_hero_single_data >*
fight_recovery_hero_data::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// fight_recovery_data

// optional .proto.common.fight_recovery_obj_data objs = 1;
inline bool fight_recovery_data::has_objs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_recovery_data::set_has_objs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_recovery_data::clear_has_objs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_recovery_data::clear_objs() {
  if (objs_ != NULL) objs_->::proto::common::fight_recovery_obj_data::Clear();
  clear_has_objs();
}
inline const ::proto::common::fight_recovery_obj_data& fight_recovery_data::objs() const {
  return objs_ != NULL ? *objs_ : *default_instance_->objs_;
}
inline ::proto::common::fight_recovery_obj_data* fight_recovery_data::mutable_objs() {
  set_has_objs();
  if (objs_ == NULL) objs_ = new ::proto::common::fight_recovery_obj_data;
  return objs_;
}
inline ::proto::common::fight_recovery_obj_data* fight_recovery_data::release_objs() {
  clear_has_objs();
  ::proto::common::fight_recovery_obj_data* temp = objs_;
  objs_ = NULL;
  return temp;
}
inline void fight_recovery_data::set_allocated_objs(::proto::common::fight_recovery_obj_data* objs) {
  delete objs_;
  objs_ = objs;
  if (objs) {
    set_has_objs();
  } else {
    clear_has_objs();
  }
}

// optional .proto.common.fight_recovery_hero_data heroes = 2;
inline bool fight_recovery_data::has_heroes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_recovery_data::set_has_heroes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_recovery_data::clear_has_heroes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_recovery_data::clear_heroes() {
  if (heroes_ != NULL) heroes_->::proto::common::fight_recovery_hero_data::Clear();
  clear_has_heroes();
}
inline const ::proto::common::fight_recovery_hero_data& fight_recovery_data::heroes() const {
  return heroes_ != NULL ? *heroes_ : *default_instance_->heroes_;
}
inline ::proto::common::fight_recovery_hero_data* fight_recovery_data::mutable_heroes() {
  set_has_heroes();
  if (heroes_ == NULL) heroes_ = new ::proto::common::fight_recovery_hero_data;
  return heroes_;
}
inline ::proto::common::fight_recovery_hero_data* fight_recovery_data::release_heroes() {
  clear_has_heroes();
  ::proto::common::fight_recovery_hero_data* temp = heroes_;
  heroes_ = NULL;
  return temp;
}
inline void fight_recovery_data::set_allocated_heroes(::proto::common::fight_recovery_hero_data* heroes) {
  delete heroes_;
  heroes_ = heroes;
  if (heroes) {
    set_has_heroes();
  } else {
    clear_has_heroes();
  }
}

// optional .proto.common.formation_single self_formation_data = 3;
inline bool fight_recovery_data::has_self_formation_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_recovery_data::set_has_self_formation_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_recovery_data::clear_has_self_formation_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_recovery_data::clear_self_formation_data() {
  if (self_formation_data_ != NULL) self_formation_data_->::proto::common::formation_single::Clear();
  clear_has_self_formation_data();
}
inline const ::proto::common::formation_single& fight_recovery_data::self_formation_data() const {
  return self_formation_data_ != NULL ? *self_formation_data_ : *default_instance_->self_formation_data_;
}
inline ::proto::common::formation_single* fight_recovery_data::mutable_self_formation_data() {
  set_has_self_formation_data();
  if (self_formation_data_ == NULL) self_formation_data_ = new ::proto::common::formation_single;
  return self_formation_data_;
}
inline ::proto::common::formation_single* fight_recovery_data::release_self_formation_data() {
  clear_has_self_formation_data();
  ::proto::common::formation_single* temp = self_formation_data_;
  self_formation_data_ = NULL;
  return temp;
}
inline void fight_recovery_data::set_allocated_self_formation_data(::proto::common::formation_single* self_formation_data) {
  delete self_formation_data_;
  self_formation_data_ = self_formation_data;
  if (self_formation_data) {
    set_has_self_formation_data();
  } else {
    clear_has_self_formation_data();
  }
}

// optional .proto.common.formation_single enemy_formation_data = 4;
inline bool fight_recovery_data::has_enemy_formation_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fight_recovery_data::set_has_enemy_formation_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void fight_recovery_data::clear_has_enemy_formation_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void fight_recovery_data::clear_enemy_formation_data() {
  if (enemy_formation_data_ != NULL) enemy_formation_data_->::proto::common::formation_single::Clear();
  clear_has_enemy_formation_data();
}
inline const ::proto::common::formation_single& fight_recovery_data::enemy_formation_data() const {
  return enemy_formation_data_ != NULL ? *enemy_formation_data_ : *default_instance_->enemy_formation_data_;
}
inline ::proto::common::formation_single* fight_recovery_data::mutable_enemy_formation_data() {
  set_has_enemy_formation_data();
  if (enemy_formation_data_ == NULL) enemy_formation_data_ = new ::proto::common::formation_single;
  return enemy_formation_data_;
}
inline ::proto::common::formation_single* fight_recovery_data::release_enemy_formation_data() {
  clear_has_enemy_formation_data();
  ::proto::common::formation_single* temp = enemy_formation_data_;
  enemy_formation_data_ = NULL;
  return temp;
}
inline void fight_recovery_data::set_allocated_enemy_formation_data(::proto::common::formation_single* enemy_formation_data) {
  delete enemy_formation_data_;
  enemy_formation_data_ = enemy_formation_data;
  if (enemy_formation_data) {
    set_has_enemy_formation_data();
  } else {
    clear_has_enemy_formation_data();
  }
}

// -------------------------------------------------------------------

// fight_process

// optional .proto.common.fight_state state = 1;
inline bool fight_process::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_process::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_process::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_process::clear_state() {
  if (state_ != NULL) state_->::proto::common::fight_state::Clear();
  clear_has_state();
}
inline const ::proto::common::fight_state& fight_process::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::proto::common::fight_state* fight_process::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::proto::common::fight_state;
  return state_;
}
inline ::proto::common::fight_state* fight_process::release_state() {
  clear_has_state();
  ::proto::common::fight_state* temp = state_;
  state_ = NULL;
  return temp;
}
inline void fight_process::set_allocated_state(::proto::common::fight_state* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// -------------------------------------------------------------------

// fight_result

// optional string fight_id = 1;
inline bool fight_result::has_fight_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_result::set_has_fight_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_result::clear_has_fight_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_result::clear_fight_id() {
  if (fight_id_ != &::google::protobuf::internal::kEmptyString) {
    fight_id_->clear();
  }
  clear_has_fight_id();
}
inline const ::std::string& fight_result::fight_id() const {
  return *fight_id_;
}
inline void fight_result::set_fight_id(const ::std::string& value) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(value);
}
inline void fight_result::set_fight_id(const char* value) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(value);
}
inline void fight_result::set_fight_id(const char* value, size_t size) {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  fight_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_result::mutable_fight_id() {
  set_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    fight_id_ = new ::std::string;
  }
  return fight_id_;
}
inline ::std::string* fight_result::release_fight_id() {
  clear_has_fight_id();
  if (fight_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_id_;
    fight_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_result::set_allocated_fight_id(::std::string* fight_id) {
  if (fight_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_id_;
  }
  if (fight_id) {
    set_has_fight_id();
    fight_id_ = fight_id;
  } else {
    clear_has_fight_id();
    fight_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.fight_process process = 2;
inline bool fight_result::has_process() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_result::set_has_process() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_result::clear_has_process() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_result::clear_process() {
  if (process_ != NULL) process_->::proto::common::fight_process::Clear();
  clear_has_process();
}
inline const ::proto::common::fight_process& fight_result::process() const {
  return process_ != NULL ? *process_ : *default_instance_->process_;
}
inline ::proto::common::fight_process* fight_result::mutable_process() {
  set_has_process();
  if (process_ == NULL) process_ = new ::proto::common::fight_process;
  return process_;
}
inline ::proto::common::fight_process* fight_result::release_process() {
  clear_has_process();
  ::proto::common::fight_process* temp = process_;
  process_ = NULL;
  return temp;
}
inline void fight_result::set_allocated_process(::proto::common::fight_process* process) {
  delete process_;
  process_ = process;
  if (process) {
    set_has_process();
  } else {
    clear_has_process();
  }
}

// optional uint32 result = 3;
inline bool fight_result::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fight_result::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fight_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fight_result::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 fight_result::result() const {
  return result_;
}
inline void fight_result::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// rank_role_base

// optional uint32 level = 1;
inline bool rank_role_base::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_role_base::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_role_base::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_role_base::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 rank_role_base::level() const {
  return level_;
}
inline void rank_role_base::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 plugin = 2;
inline bool rank_role_base::has_plugin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_role_base::set_has_plugin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_role_base::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_role_base::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 rank_role_base::plugin() const {
  return plugin_;
}
inline void rank_role_base::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 head_frame_id = 3;
inline bool rank_role_base::has_head_frame_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_role_base::set_has_head_frame_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_role_base::clear_has_head_frame_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_role_base::clear_head_frame_id() {
  head_frame_id_ = 0u;
  clear_has_head_frame_id();
}
inline ::google::protobuf::uint32 rank_role_base::head_frame_id() const {
  return head_frame_id_;
}
inline void rank_role_base::set_head_frame_id(::google::protobuf::uint32 value) {
  set_has_head_frame_id();
  head_frame_id_ = value;
}

// -------------------------------------------------------------------

// rank_family_base

// optional string id = 1;
inline bool rank_family_base::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_family_base::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_family_base::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_family_base::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& rank_family_base::id() const {
  return *id_;
}
inline void rank_family_base::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void rank_family_base::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void rank_family_base::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_family_base::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* rank_family_base::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_family_base::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool rank_family_base::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_family_base::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_family_base::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_family_base::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& rank_family_base::name() const {
  return *name_;
}
inline void rank_family_base::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_family_base::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_family_base::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_family_base::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* rank_family_base::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_family_base::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool rank_family_base::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_family_base::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_family_base::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_family_base::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 rank_family_base::level() const {
  return level_;
}
inline void rank_family_base::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// rank_score_tower

// optional uint32 cost_day = 1;
inline bool rank_score_tower::has_cost_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_score_tower::set_has_cost_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_score_tower::clear_has_cost_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_score_tower::clear_cost_day() {
  cost_day_ = 0u;
  clear_has_cost_day();
}
inline ::google::protobuf::uint32 rank_score_tower::cost_day() const {
  return cost_day_;
}
inline void rank_score_tower::set_cost_day(::google::protobuf::uint32 value) {
  set_has_cost_day();
  cost_day_ = value;
}

// optional uint32 level = 2;
inline bool rank_score_tower::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_score_tower::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_score_tower::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_score_tower::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 rank_score_tower::level() const {
  return level_;
}
inline void rank_score_tower::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// rank_score_achievement

// optional uint32 level = 1;
inline bool rank_score_achievement::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_score_achievement::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_score_achievement::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_score_achievement::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 rank_score_achievement::level() const {
  return level_;
}
inline void rank_score_achievement::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// rank_data_extra

// optional .proto.common.rank_score_tower tower = 1;
inline bool rank_data_extra::has_tower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_data_extra::set_has_tower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_data_extra::clear_has_tower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_data_extra::clear_tower() {
  if (tower_ != NULL) tower_->::proto::common::rank_score_tower::Clear();
  clear_has_tower();
}
inline const ::proto::common::rank_score_tower& rank_data_extra::tower() const {
  return tower_ != NULL ? *tower_ : *default_instance_->tower_;
}
inline ::proto::common::rank_score_tower* rank_data_extra::mutable_tower() {
  set_has_tower();
  if (tower_ == NULL) tower_ = new ::proto::common::rank_score_tower;
  return tower_;
}
inline ::proto::common::rank_score_tower* rank_data_extra::release_tower() {
  clear_has_tower();
  ::proto::common::rank_score_tower* temp = tower_;
  tower_ = NULL;
  return temp;
}
inline void rank_data_extra::set_allocated_tower(::proto::common::rank_score_tower* tower) {
  delete tower_;
  tower_ = tower;
  if (tower) {
    set_has_tower();
  } else {
    clear_has_tower();
  }
}

// optional .proto.common.rank_score_achievement achieve = 2;
inline bool rank_data_extra::has_achieve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_data_extra::set_has_achieve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_data_extra::clear_has_achieve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_data_extra::clear_achieve() {
  if (achieve_ != NULL) achieve_->::proto::common::rank_score_achievement::Clear();
  clear_has_achieve();
}
inline const ::proto::common::rank_score_achievement& rank_data_extra::achieve() const {
  return achieve_ != NULL ? *achieve_ : *default_instance_->achieve_;
}
inline ::proto::common::rank_score_achievement* rank_data_extra::mutable_achieve() {
  set_has_achieve();
  if (achieve_ == NULL) achieve_ = new ::proto::common::rank_score_achievement;
  return achieve_;
}
inline ::proto::common::rank_score_achievement* rank_data_extra::release_achieve() {
  clear_has_achieve();
  ::proto::common::rank_score_achievement* temp = achieve_;
  achieve_ = NULL;
  return temp;
}
inline void rank_data_extra::set_allocated_achieve(::proto::common::rank_score_achievement* achieve) {
  delete achieve_;
  achieve_ = achieve;
  if (achieve) {
    set_has_achieve();
  } else {
    clear_has_achieve();
  }
}

// -------------------------------------------------------------------

// rank_single_data

// optional string id = 1;
inline bool rank_single_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_single_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_single_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_single_data::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& rank_single_data::id() const {
  return *id_;
}
inline void rank_single_data::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void rank_single_data::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void rank_single_data::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_single_data::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* rank_single_data::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_single_data::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool rank_single_data::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_single_data::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_single_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_single_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& rank_single_data::name() const {
  return *name_;
}
inline void rank_single_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_single_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void rank_single_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_single_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* rank_single_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rank_single_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 key = 4;
inline bool rank_single_data::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_single_data::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_single_data::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_single_data::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 rank_single_data::key() const {
  return key_;
}
inline void rank_single_data::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// optional uint32 index = 5;
inline bool rank_single_data::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void rank_single_data::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void rank_single_data::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void rank_single_data::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 rank_single_data::index() const {
  return index_;
}
inline void rank_single_data::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional .proto.common.rank_role_base role_data = 6;
inline bool rank_single_data::has_role_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void rank_single_data::set_has_role_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void rank_single_data::clear_has_role_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void rank_single_data::clear_role_data() {
  if (role_data_ != NULL) role_data_->::proto::common::rank_role_base::Clear();
  clear_has_role_data();
}
inline const ::proto::common::rank_role_base& rank_single_data::role_data() const {
  return role_data_ != NULL ? *role_data_ : *default_instance_->role_data_;
}
inline ::proto::common::rank_role_base* rank_single_data::mutable_role_data() {
  set_has_role_data();
  if (role_data_ == NULL) role_data_ = new ::proto::common::rank_role_base;
  return role_data_;
}
inline ::proto::common::rank_role_base* rank_single_data::release_role_data() {
  clear_has_role_data();
  ::proto::common::rank_role_base* temp = role_data_;
  role_data_ = NULL;
  return temp;
}
inline void rank_single_data::set_allocated_role_data(::proto::common::rank_role_base* role_data) {
  delete role_data_;
  role_data_ = role_data;
  if (role_data) {
    set_has_role_data();
  } else {
    clear_has_role_data();
  }
}

// optional .proto.common.rank_family_base family_data = 7;
inline bool rank_single_data::has_family_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void rank_single_data::set_has_family_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void rank_single_data::clear_has_family_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void rank_single_data::clear_family_data() {
  if (family_data_ != NULL) family_data_->::proto::common::rank_family_base::Clear();
  clear_has_family_data();
}
inline const ::proto::common::rank_family_base& rank_single_data::family_data() const {
  return family_data_ != NULL ? *family_data_ : *default_instance_->family_data_;
}
inline ::proto::common::rank_family_base* rank_single_data::mutable_family_data() {
  set_has_family_data();
  if (family_data_ == NULL) family_data_ = new ::proto::common::rank_family_base;
  return family_data_;
}
inline ::proto::common::rank_family_base* rank_single_data::release_family_data() {
  clear_has_family_data();
  ::proto::common::rank_family_base* temp = family_data_;
  family_data_ = NULL;
  return temp;
}
inline void rank_single_data::set_allocated_family_data(::proto::common::rank_family_base* family_data) {
  delete family_data_;
  family_data_ = family_data;
  if (family_data) {
    set_has_family_data();
  } else {
    clear_has_family_data();
  }
}

// optional .proto.common.country_common country_data = 8;
inline bool rank_single_data::has_country_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void rank_single_data::set_has_country_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void rank_single_data::clear_has_country_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void rank_single_data::clear_country_data() {
  if (country_data_ != NULL) country_data_->::proto::common::country_common::Clear();
  clear_has_country_data();
}
inline const ::proto::common::country_common& rank_single_data::country_data() const {
  return country_data_ != NULL ? *country_data_ : *default_instance_->country_data_;
}
inline ::proto::common::country_common* rank_single_data::mutable_country_data() {
  set_has_country_data();
  if (country_data_ == NULL) country_data_ = new ::proto::common::country_common;
  return country_data_;
}
inline ::proto::common::country_common* rank_single_data::release_country_data() {
  clear_has_country_data();
  ::proto::common::country_common* temp = country_data_;
  country_data_ = NULL;
  return temp;
}
inline void rank_single_data::set_allocated_country_data(::proto::common::country_common* country_data) {
  delete country_data_;
  country_data_ = country_data;
  if (country_data) {
    set_has_country_data();
  } else {
    clear_has_country_data();
  }
}

// repeated string custom_data = 10;
inline int rank_single_data::custom_data_size() const {
  return custom_data_.size();
}
inline void rank_single_data::clear_custom_data() {
  custom_data_.Clear();
}
inline const ::std::string& rank_single_data::custom_data(int index) const {
  return custom_data_.Get(index);
}
inline ::std::string* rank_single_data::mutable_custom_data(int index) {
  return custom_data_.Mutable(index);
}
inline void rank_single_data::set_custom_data(int index, const ::std::string& value) {
  custom_data_.Mutable(index)->assign(value);
}
inline void rank_single_data::set_custom_data(int index, const char* value) {
  custom_data_.Mutable(index)->assign(value);
}
inline void rank_single_data::set_custom_data(int index, const char* value, size_t size) {
  custom_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rank_single_data::add_custom_data() {
  return custom_data_.Add();
}
inline void rank_single_data::add_custom_data(const ::std::string& value) {
  custom_data_.Add()->assign(value);
}
inline void rank_single_data::add_custom_data(const char* value) {
  custom_data_.Add()->assign(value);
}
inline void rank_single_data::add_custom_data(const char* value, size_t size) {
  custom_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
rank_single_data::custom_data() const {
  return custom_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
rank_single_data::mutable_custom_data() {
  return &custom_data_;
}

// -------------------------------------------------------------------

// mount_data_single

// optional uint32 mount_tid = 1;
inline bool mount_data_single::has_mount_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mount_data_single::set_has_mount_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mount_data_single::clear_has_mount_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mount_data_single::clear_mount_tid() {
  mount_tid_ = 0u;
  clear_has_mount_tid();
}
inline ::google::protobuf::uint32 mount_data_single::mount_tid() const {
  return mount_tid_;
}
inline void mount_data_single::set_mount_tid(::google::protobuf::uint32 value) {
  set_has_mount_tid();
  mount_tid_ = value;
}

// optional .proto.common.mount_state_type mount_state = 2;
inline bool mount_data_single::has_mount_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mount_data_single::set_has_mount_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mount_data_single::clear_has_mount_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mount_data_single::clear_mount_state() {
  mount_state_ = 1;
  clear_has_mount_state();
}
inline ::proto::common::mount_state_type mount_data_single::mount_state() const {
  return static_cast< ::proto::common::mount_state_type >(mount_state_);
}
inline void mount_data_single::set_mount_state(::proto::common::mount_state_type value) {
  assert(::proto::common::mount_state_type_IsValid(value));
  set_has_mount_state();
  mount_state_ = value;
}

// -------------------------------------------------------------------

// mount_data

// repeated .proto.common.mount_data_single mount_data_list = 1;
inline int mount_data::mount_data_list_size() const {
  return mount_data_list_.size();
}
inline void mount_data::clear_mount_data_list() {
  mount_data_list_.Clear();
}
inline const ::proto::common::mount_data_single& mount_data::mount_data_list(int index) const {
  return mount_data_list_.Get(index);
}
inline ::proto::common::mount_data_single* mount_data::mutable_mount_data_list(int index) {
  return mount_data_list_.Mutable(index);
}
inline ::proto::common::mount_data_single* mount_data::add_mount_data_list() {
  return mount_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::mount_data_single >&
mount_data::mount_data_list() const {
  return mount_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::mount_data_single >*
mount_data::mutable_mount_data_list() {
  return &mount_data_list_;
}

// -------------------------------------------------------------------

// field_boss_rank

// optional uint32 rank = 1;
inline bool field_boss_rank::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void field_boss_rank::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void field_boss_rank::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void field_boss_rank::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 field_boss_rank::rank() const {
  return rank_;
}
inline void field_boss_rank::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// optional string name = 2;
inline bool field_boss_rank::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void field_boss_rank::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void field_boss_rank::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void field_boss_rank::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& field_boss_rank::name() const {
  return *name_;
}
inline void field_boss_rank::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_boss_rank::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void field_boss_rank::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_boss_rank::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* field_boss_rank::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_boss_rank::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 hurt = 3;
inline bool field_boss_rank::has_hurt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void field_boss_rank::set_has_hurt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void field_boss_rank::clear_has_hurt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void field_boss_rank::clear_hurt() {
  hurt_ = 0u;
  clear_has_hurt();
}
inline ::google::protobuf::uint32 field_boss_rank::hurt() const {
  return hurt_;
}
inline void field_boss_rank::set_hurt(::google::protobuf::uint32 value) {
  set_has_hurt();
  hurt_ = value;
}

// -------------------------------------------------------------------

// filed_boss_one_state

// optional uint32 id = 1;
inline bool filed_boss_one_state::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void filed_boss_one_state::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void filed_boss_one_state::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void filed_boss_one_state::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 filed_boss_one_state::id() const {
  return id_;
}
inline void filed_boss_one_state::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 monster_tid = 2;
inline bool filed_boss_one_state::has_monster_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void filed_boss_one_state::set_has_monster_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void filed_boss_one_state::clear_has_monster_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void filed_boss_one_state::clear_monster_tid() {
  monster_tid_ = 0u;
  clear_has_monster_tid();
}
inline ::google::protobuf::uint32 filed_boss_one_state::monster_tid() const {
  return monster_tid_;
}
inline void filed_boss_one_state::set_monster_tid(::google::protobuf::uint32 value) {
  set_has_monster_tid();
  monster_tid_ = value;
}

// optional .proto.common.em_field_boss_state state = 3 [default = FIELD_BOSS_STATE_NONE];
inline bool filed_boss_one_state::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void filed_boss_one_state::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void filed_boss_one_state::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void filed_boss_one_state::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::proto::common::em_field_boss_state filed_boss_one_state::state() const {
  return static_cast< ::proto::common::em_field_boss_state >(state_);
}
inline void filed_boss_one_state::set_state(::proto::common::em_field_boss_state value) {
  assert(::proto::common::em_field_boss_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string name = 4;
inline bool filed_boss_one_state::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void filed_boss_one_state::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void filed_boss_one_state::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void filed_boss_one_state::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& filed_boss_one_state::name() const {
  return *name_;
}
inline void filed_boss_one_state::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void filed_boss_one_state::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void filed_boss_one_state::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* filed_boss_one_state::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* filed_boss_one_state::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void filed_boss_one_state::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 map_id = 5;
inline bool filed_boss_one_state::has_map_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void filed_boss_one_state::set_has_map_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void filed_boss_one_state::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void filed_boss_one_state::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 filed_boss_one_state::map_id() const {
  return map_id_;
}
inline void filed_boss_one_state::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 pos_x = 6;
inline bool filed_boss_one_state::has_pos_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void filed_boss_one_state::set_has_pos_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void filed_boss_one_state::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void filed_boss_one_state::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 filed_boss_one_state::pos_x() const {
  return pos_x_;
}
inline void filed_boss_one_state::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional uint32 pos_y = 7;
inline bool filed_boss_one_state::has_pos_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void filed_boss_one_state::set_has_pos_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void filed_boss_one_state::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void filed_boss_one_state::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 filed_boss_one_state::pos_y() const {
  return pos_y_;
}
inline void filed_boss_one_state::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// filed_boss_state

// optional uint32 id = 1;
inline bool filed_boss_state::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void filed_boss_state::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void filed_boss_state::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void filed_boss_state::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 filed_boss_state::id() const {
  return id_;
}
inline void filed_boss_state::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// repeated .proto.common.filed_boss_one_state states = 2;
inline int filed_boss_state::states_size() const {
  return states_.size();
}
inline void filed_boss_state::clear_states() {
  states_.Clear();
}
inline const ::proto::common::filed_boss_one_state& filed_boss_state::states(int index) const {
  return states_.Get(index);
}
inline ::proto::common::filed_boss_one_state* filed_boss_state::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::proto::common::filed_boss_one_state* filed_boss_state::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::filed_boss_one_state >&
filed_boss_state::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::filed_boss_one_state >*
filed_boss_state::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// field_boss_pos_info

// optional .proto.common.em_field_boss_pos pos_act = 1;
inline bool field_boss_pos_info::has_pos_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void field_boss_pos_info::set_has_pos_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void field_boss_pos_info::clear_has_pos_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void field_boss_pos_info::clear_pos_act() {
  pos_act_ = 1;
  clear_has_pos_act();
}
inline ::proto::common::em_field_boss_pos field_boss_pos_info::pos_act() const {
  return static_cast< ::proto::common::em_field_boss_pos >(pos_act_);
}
inline void field_boss_pos_info::set_pos_act(::proto::common::em_field_boss_pos value) {
  assert(::proto::common::em_field_boss_pos_IsValid(value));
  set_has_pos_act();
  pos_act_ = value;
}

// optional string object_id = 2;
inline bool field_boss_pos_info::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void field_boss_pos_info::set_has_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void field_boss_pos_info::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void field_boss_pos_info::clear_object_id() {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    object_id_->clear();
  }
  clear_has_object_id();
}
inline const ::std::string& field_boss_pos_info::object_id() const {
  return *object_id_;
}
inline void field_boss_pos_info::set_object_id(const ::std::string& value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void field_boss_pos_info::set_object_id(const char* value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void field_boss_pos_info::set_object_id(const char* value, size_t size) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* field_boss_pos_info::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  return object_id_;
}
inline ::std::string* field_boss_pos_info::release_object_id() {
  clear_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_id_;
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void field_boss_pos_info::set_allocated_object_id(::std::string* object_id) {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    delete object_id_;
  }
  if (object_id) {
    set_has_object_id();
    object_id_ = object_id;
  } else {
    clear_has_object_id();
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 monster_id = 3;
inline bool field_boss_pos_info::has_monster_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void field_boss_pos_info::set_has_monster_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void field_boss_pos_info::clear_has_monster_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void field_boss_pos_info::clear_monster_id() {
  monster_id_ = 0u;
  clear_has_monster_id();
}
inline ::google::protobuf::uint32 field_boss_pos_info::monster_id() const {
  return monster_id_;
}
inline void field_boss_pos_info::set_monster_id(::google::protobuf::uint32 value) {
  set_has_monster_id();
  monster_id_ = value;
}

// optional uint32 pos_x = 4;
inline bool field_boss_pos_info::has_pos_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void field_boss_pos_info::set_has_pos_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void field_boss_pos_info::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void field_boss_pos_info::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 field_boss_pos_info::pos_x() const {
  return pos_x_;
}
inline void field_boss_pos_info::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional uint32 pos_y = 5;
inline bool field_boss_pos_info::has_pos_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void field_boss_pos_info::set_has_pos_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void field_boss_pos_info::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void field_boss_pos_info::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 field_boss_pos_info::pos_y() const {
  return pos_y_;
}
inline void field_boss_pos_info::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// mail_common_info

// optional string id = 1;
inline bool mail_common_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mail_common_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mail_common_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mail_common_info::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& mail_common_info::id() const {
  return *id_;
}
inline void mail_common_info::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void mail_common_info::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void mail_common_info::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mail_common_info::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* mail_common_info::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mail_common_info::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.em_mail_type type = 2;
inline bool mail_common_info::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mail_common_info::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mail_common_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mail_common_info::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::common::em_mail_type mail_common_info::type() const {
  return static_cast< ::proto::common::em_mail_type >(type_);
}
inline void mail_common_info::set_type(::proto::common::em_mail_type value) {
  assert(::proto::common::em_mail_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .proto.common.em_mail_state state = 3;
inline bool mail_common_info::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mail_common_info::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mail_common_info::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mail_common_info::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::proto::common::em_mail_state mail_common_info::state() const {
  return static_cast< ::proto::common::em_mail_state >(state_);
}
inline void mail_common_info::set_state(::proto::common::em_mail_state value) {
  assert(::proto::common::em_mail_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .proto.common.em_mail_addenda addenda = 4;
inline bool mail_common_info::has_addenda() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mail_common_info::set_has_addenda() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mail_common_info::clear_has_addenda() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mail_common_info::clear_addenda() {
  addenda_ = 0;
  clear_has_addenda();
}
inline ::proto::common::em_mail_addenda mail_common_info::addenda() const {
  return static_cast< ::proto::common::em_mail_addenda >(addenda_);
}
inline void mail_common_info::set_addenda(::proto::common::em_mail_addenda value) {
  assert(::proto::common::em_mail_addenda_IsValid(value));
  set_has_addenda();
  addenda_ = value;
}

// -------------------------------------------------------------------

// mail_base_info

// optional .proto.common.mail_common_info common_info = 1;
inline bool mail_base_info::has_common_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mail_base_info::set_has_common_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mail_base_info::clear_has_common_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mail_base_info::clear_common_info() {
  if (common_info_ != NULL) common_info_->::proto::common::mail_common_info::Clear();
  clear_has_common_info();
}
inline const ::proto::common::mail_common_info& mail_base_info::common_info() const {
  return common_info_ != NULL ? *common_info_ : *default_instance_->common_info_;
}
inline ::proto::common::mail_common_info* mail_base_info::mutable_common_info() {
  set_has_common_info();
  if (common_info_ == NULL) common_info_ = new ::proto::common::mail_common_info;
  return common_info_;
}
inline ::proto::common::mail_common_info* mail_base_info::release_common_info() {
  clear_has_common_info();
  ::proto::common::mail_common_info* temp = common_info_;
  common_info_ = NULL;
  return temp;
}
inline void mail_base_info::set_allocated_common_info(::proto::common::mail_common_info* common_info) {
  delete common_info_;
  common_info_ = common_info;
  if (common_info) {
    set_has_common_info();
  } else {
    clear_has_common_info();
  }
}

// optional uint32 content_id = 2;
inline bool mail_base_info::has_content_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mail_base_info::set_has_content_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mail_base_info::clear_has_content_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mail_base_info::clear_content_id() {
  content_id_ = 0u;
  clear_has_content_id();
}
inline ::google::protobuf::uint32 mail_base_info::content_id() const {
  return content_id_;
}
inline void mail_base_info::set_content_id(::google::protobuf::uint32 value) {
  set_has_content_id();
  content_id_ = value;
}

// optional string from_name = 3;
inline bool mail_base_info::has_from_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mail_base_info::set_has_from_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mail_base_info::clear_has_from_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mail_base_info::clear_from_name() {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    from_name_->clear();
  }
  clear_has_from_name();
}
inline const ::std::string& mail_base_info::from_name() const {
  return *from_name_;
}
inline void mail_base_info::set_from_name(const ::std::string& value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void mail_base_info::set_from_name(const char* value) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(value);
}
inline void mail_base_info::set_from_name(const char* value, size_t size) {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  from_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mail_base_info::mutable_from_name() {
  set_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    from_name_ = new ::std::string;
  }
  return from_name_;
}
inline ::std::string* mail_base_info::release_from_name() {
  clear_has_from_name();
  if (from_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_name_;
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mail_base_info::set_allocated_from_name(::std::string* from_name) {
  if (from_name_ != &::google::protobuf::internal::kEmptyString) {
    delete from_name_;
  }
  if (from_name) {
    set_has_from_name();
    from_name_ = from_name;
  } else {
    clear_has_from_name();
    from_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 4;
inline bool mail_base_info::has_title() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mail_base_info::set_has_title() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mail_base_info::clear_has_title() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mail_base_info::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& mail_base_info::title() const {
  return *title_;
}
inline void mail_base_info::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void mail_base_info::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void mail_base_info::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mail_base_info::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* mail_base_info::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mail_base_info::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 create_time = 5;
inline bool mail_base_info::has_create_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mail_base_info::set_has_create_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mail_base_info::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mail_base_info::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 mail_base_info::create_time() const {
  return create_time_;
}
inline void mail_base_info::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
}

// optional uint32 del_time = 6;
inline bool mail_base_info::has_del_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mail_base_info::set_has_del_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mail_base_info::clear_has_del_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mail_base_info::clear_del_time() {
  del_time_ = 0u;
  clear_has_del_time();
}
inline ::google::protobuf::uint32 mail_base_info::del_time() const {
  return del_time_;
}
inline void mail_base_info::set_del_time(::google::protobuf::uint32 value) {
  set_has_del_time();
  del_time_ = value;
}

// -------------------------------------------------------------------

// mail_item_obj

// optional uint32 item_id = 1;
inline bool mail_item_obj::has_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mail_item_obj::set_has_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mail_item_obj::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mail_item_obj::clear_item_id() {
  item_id_ = 0u;
  clear_has_item_id();
}
inline ::google::protobuf::uint32 mail_item_obj::item_id() const {
  return item_id_;
}
inline void mail_item_obj::set_item_id(::google::protobuf::uint32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional uint32 item_num = 2;
inline bool mail_item_obj::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mail_item_obj::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mail_item_obj::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mail_item_obj::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 mail_item_obj::item_num() const {
  return item_num_;
}
inline void mail_item_obj::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// combat_act

// optional .proto.common.combat_act_type act_type = 1 [default = combat_act_type_skill];
inline bool combat_act::has_act_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_act::set_has_act_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_act::clear_has_act_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_act::clear_act_type() {
  act_type_ = 1;
  clear_has_act_type();
}
inline ::proto::common::combat_act_type combat_act::act_type() const {
  return static_cast< ::proto::common::combat_act_type >(act_type_);
}
inline void combat_act::set_act_type(::proto::common::combat_act_type value) {
  assert(::proto::common::combat_act_type_IsValid(value));
  set_has_act_type();
  act_type_ = value;
}

// optional uint32 act_value = 2;
inline bool combat_act::has_act_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_act::set_has_act_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_act::clear_has_act_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_act::clear_act_value() {
  act_value_ = 0u;
  clear_has_act_value();
}
inline ::google::protobuf::uint32 combat_act::act_value() const {
  return act_value_;
}
inline void combat_act::set_act_value(::google::protobuf::uint32 value) {
  set_has_act_value();
  act_value_ = value;
}

// repeated string target = 3;
inline int combat_act::target_size() const {
  return target_.size();
}
inline void combat_act::clear_target() {
  target_.Clear();
}
inline const ::std::string& combat_act::target(int index) const {
  return target_.Get(index);
}
inline ::std::string* combat_act::mutable_target(int index) {
  return target_.Mutable(index);
}
inline void combat_act::set_target(int index, const ::std::string& value) {
  target_.Mutable(index)->assign(value);
}
inline void combat_act::set_target(int index, const char* value) {
  target_.Mutable(index)->assign(value);
}
inline void combat_act::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_act::add_target() {
  return target_.Add();
}
inline void combat_act::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
}
inline void combat_act::add_target(const char* value) {
  target_.Add()->assign(value);
}
inline void combat_act::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
combat_act::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
combat_act::mutable_target() {
  return &target_;
}

// optional string attacker = 4;
inline bool combat_act::has_attacker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void combat_act::set_has_attacker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void combat_act::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void combat_act::clear_attacker() {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    attacker_->clear();
  }
  clear_has_attacker();
}
inline const ::std::string& combat_act::attacker() const {
  return *attacker_;
}
inline void combat_act::set_attacker(const ::std::string& value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void combat_act::set_attacker(const char* value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void combat_act::set_attacker(const char* value, size_t size) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_act::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  return attacker_;
}
inline ::std::string* combat_act::release_attacker() {
  clear_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attacker_;
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_act::set_allocated_attacker(::std::string* attacker) {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    delete attacker_;
  }
  if (attacker) {
    set_has_attacker();
    attacker_ = attacker;
  } else {
    clear_has_attacker();
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.combat_state step = 5;
inline bool combat_act::has_step() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void combat_act::set_has_step() {
  _has_bits_[0] |= 0x00000010u;
}
inline void combat_act::clear_has_step() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void combat_act::clear_step() {
  step_ = 1;
  clear_has_step();
}
inline ::proto::common::combat_state combat_act::step() const {
  return static_cast< ::proto::common::combat_state >(step_);
}
inline void combat_act::set_step(::proto::common::combat_state value) {
  assert(::proto::common::combat_state_IsValid(value));
  set_has_step();
  step_ = value;
}

// optional uint32 remain_value = 6;
inline bool combat_act::has_remain_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void combat_act::set_has_remain_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void combat_act::clear_has_remain_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void combat_act::clear_remain_value() {
  remain_value_ = 0u;
  clear_has_remain_value();
}
inline ::google::protobuf::uint32 combat_act::remain_value() const {
  return remain_value_;
}
inline void combat_act::set_remain_value(::google::protobuf::uint32 value) {
  set_has_remain_value();
  remain_value_ = value;
}

// optional uint32 remain_value2 = 7;
inline bool combat_act::has_remain_value2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void combat_act::set_has_remain_value2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void combat_act::clear_has_remain_value2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void combat_act::clear_remain_value2() {
  remain_value2_ = 0u;
  clear_has_remain_value2();
}
inline ::google::protobuf::uint32 combat_act::remain_value2() const {
  return remain_value2_;
}
inline void combat_act::set_remain_value2(::google::protobuf::uint32 value) {
  set_has_remain_value2();
  remain_value2_ = value;
}

// optional uint32 param = 8;
inline bool combat_act::has_param() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void combat_act::set_has_param() {
  _has_bits_[0] |= 0x00000080u;
}
inline void combat_act::clear_has_param() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void combat_act::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 combat_act::param() const {
  return param_;
}
inline void combat_act::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional uint32 param1 = 9;
inline bool combat_act::has_param1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void combat_act::set_has_param1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void combat_act::clear_has_param1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void combat_act::clear_param1() {
  param1_ = 0u;
  clear_has_param1();
}
inline ::google::protobuf::uint32 combat_act::param1() const {
  return param1_;
}
inline void combat_act::set_param1(::google::protobuf::uint32 value) {
  set_has_param1();
  param1_ = value;
}

// -------------------------------------------------------------------

// combat_action_data

// repeated .proto.common.combat_act actions = 1;
inline int combat_action_data::actions_size() const {
  return actions_.size();
}
inline void combat_action_data::clear_actions() {
  actions_.Clear();
}
inline const ::proto::common::combat_act& combat_action_data::actions(int index) const {
  return actions_.Get(index);
}
inline ::proto::common::combat_act* combat_action_data::mutable_actions(int index) {
  return actions_.Mutable(index);
}
inline ::proto::common::combat_act* combat_action_data::add_actions() {
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_act >&
combat_action_data::actions() const {
  return actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_act >*
combat_action_data::mutable_actions() {
  return &actions_;
}

// -------------------------------------------------------------------

// combat_hero_att_order_single

// optional string hero_uid = 1;
inline bool combat_hero_att_order_single::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_hero_att_order_single::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_hero_att_order_single::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_hero_att_order_single::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& combat_hero_att_order_single::hero_uid() const {
  return *hero_uid_;
}
inline void combat_hero_att_order_single::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void combat_hero_att_order_single::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void combat_hero_att_order_single::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_hero_att_order_single::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* combat_hero_att_order_single::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_hero_att_order_single::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 att_speed = 2;
inline bool combat_hero_att_order_single::has_att_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_hero_att_order_single::set_has_att_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_hero_att_order_single::clear_has_att_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_hero_att_order_single::clear_att_speed() {
  att_speed_ = 0u;
  clear_has_att_speed();
}
inline ::google::protobuf::uint32 combat_hero_att_order_single::att_speed() const {
  return att_speed_;
}
inline void combat_hero_att_order_single::set_att_speed(::google::protobuf::uint32 value) {
  set_has_att_speed();
  att_speed_ = value;
}

// optional uint32 att_more_speed = 3;
inline bool combat_hero_att_order_single::has_att_more_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_hero_att_order_single::set_has_att_more_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_hero_att_order_single::clear_has_att_more_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_hero_att_order_single::clear_att_more_speed() {
  att_more_speed_ = 0u;
  clear_has_att_more_speed();
}
inline ::google::protobuf::uint32 combat_hero_att_order_single::att_more_speed() const {
  return att_more_speed_;
}
inline void combat_hero_att_order_single::set_att_more_speed(::google::protobuf::uint32 value) {
  set_has_att_more_speed();
  att_more_speed_ = value;
}

// -------------------------------------------------------------------

// combat_hero_att_order

// repeated .proto.common.combat_hero_att_order_single hero_list = 1;
inline int combat_hero_att_order::hero_list_size() const {
  return hero_list_.size();
}
inline void combat_hero_att_order::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::combat_hero_att_order_single& combat_hero_att_order::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::combat_hero_att_order_single* combat_hero_att_order::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::combat_hero_att_order_single* combat_hero_att_order::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_hero_att_order_single >&
combat_hero_att_order::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_hero_att_order_single >*
combat_hero_att_order::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// combat_end_ahead

// optional uint32 cond_type = 1;
inline bool combat_end_ahead::has_cond_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_end_ahead::set_has_cond_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_end_ahead::clear_has_cond_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_end_ahead::clear_cond_type() {
  cond_type_ = 0u;
  clear_has_cond_type();
}
inline ::google::protobuf::uint32 combat_end_ahead::cond_type() const {
  return cond_type_;
}
inline void combat_end_ahead::set_cond_type(::google::protobuf::uint32 value) {
  set_has_cond_type();
  cond_type_ = value;
}

// optional uint32 param1 = 2;
inline bool combat_end_ahead::has_param1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_end_ahead::set_has_param1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_end_ahead::clear_has_param1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_end_ahead::clear_param1() {
  param1_ = 0u;
  clear_has_param1();
}
inline ::google::protobuf::uint32 combat_end_ahead::param1() const {
  return param1_;
}
inline void combat_end_ahead::set_param1(::google::protobuf::uint32 value) {
  set_has_param1();
  param1_ = value;
}

// optional uint32 param2 = 3;
inline bool combat_end_ahead::has_param2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_end_ahead::set_has_param2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_end_ahead::clear_has_param2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_end_ahead::clear_param2() {
  param2_ = 0u;
  clear_has_param2();
}
inline ::google::protobuf::uint32 combat_end_ahead::param2() const {
  return param2_;
}
inline void combat_end_ahead::set_param2(::google::protobuf::uint32 value) {
  set_has_param2();
  param2_ = value;
}

// optional uint32 param3 = 4;
inline bool combat_end_ahead::has_param3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void combat_end_ahead::set_has_param3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void combat_end_ahead::clear_has_param3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void combat_end_ahead::clear_param3() {
  param3_ = 0u;
  clear_has_param3();
}
inline ::google::protobuf::uint32 combat_end_ahead::param3() const {
  return param3_;
}
inline void combat_end_ahead::set_param3(::google::protobuf::uint32 value) {
  set_has_param3();
  param3_ = value;
}

// optional uint32 param4 = 5;
inline bool combat_end_ahead::has_param4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void combat_end_ahead::set_has_param4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void combat_end_ahead::clear_has_param4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void combat_end_ahead::clear_param4() {
  param4_ = 0u;
  clear_has_param4();
}
inline ::google::protobuf::uint32 combat_end_ahead::param4() const {
  return param4_;
}
inline void combat_end_ahead::set_param4(::google::protobuf::uint32 value) {
  set_has_param4();
  param4_ = value;
}

// -------------------------------------------------------------------

// combat_data

// optional string fight_uid = 1;
inline bool combat_data::has_fight_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_data::set_has_fight_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_data::clear_has_fight_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_data::clear_fight_uid() {
  if (fight_uid_ != &::google::protobuf::internal::kEmptyString) {
    fight_uid_->clear();
  }
  clear_has_fight_uid();
}
inline const ::std::string& combat_data::fight_uid() const {
  return *fight_uid_;
}
inline void combat_data::set_fight_uid(const ::std::string& value) {
  set_has_fight_uid();
  if (fight_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_uid_ = new ::std::string;
  }
  fight_uid_->assign(value);
}
inline void combat_data::set_fight_uid(const char* value) {
  set_has_fight_uid();
  if (fight_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_uid_ = new ::std::string;
  }
  fight_uid_->assign(value);
}
inline void combat_data::set_fight_uid(const char* value, size_t size) {
  set_has_fight_uid();
  if (fight_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_uid_ = new ::std::string;
  }
  fight_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_data::mutable_fight_uid() {
  set_has_fight_uid();
  if (fight_uid_ == &::google::protobuf::internal::kEmptyString) {
    fight_uid_ = new ::std::string;
  }
  return fight_uid_;
}
inline ::std::string* combat_data::release_fight_uid() {
  clear_has_fight_uid();
  if (fight_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fight_uid_;
    fight_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_data::set_allocated_fight_uid(::std::string* fight_uid) {
  if (fight_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete fight_uid_;
  }
  if (fight_uid) {
    set_has_fight_uid();
    fight_uid_ = fight_uid;
  } else {
    clear_has_fight_uid();
    fight_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.combat_step step = 2;
inline bool combat_data::has_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_data::set_has_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_data::clear_has_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_data::clear_step() {
  step_ = 1;
  clear_has_step();
}
inline ::proto::common::combat_step combat_data::step() const {
  return static_cast< ::proto::common::combat_step >(step_);
}
inline void combat_data::set_step(::proto::common::combat_step value) {
  assert(::proto::common::combat_step_IsValid(value));
  set_has_step();
  step_ = value;
}

// optional uint32 round = 3;
inline bool combat_data::has_round() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_data::set_has_round() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_data::clear_has_round() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_data::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 combat_data::round() const {
  return round_;
}
inline void combat_data::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// optional .proto.common.combat_state state = 4 [default = combat_state_prepare];
inline bool combat_data::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void combat_data::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void combat_data::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void combat_data::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::proto::common::combat_state combat_data::state() const {
  return static_cast< ::proto::common::combat_state >(state_);
}
inline void combat_data::set_state(::proto::common::combat_state value) {
  assert(::proto::common::combat_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .proto.common.combat_action_data action_data = 5;
inline bool combat_data::has_action_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void combat_data::set_has_action_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void combat_data::clear_has_action_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void combat_data::clear_action_data() {
  if (action_data_ != NULL) action_data_->::proto::common::combat_action_data::Clear();
  clear_has_action_data();
}
inline const ::proto::common::combat_action_data& combat_data::action_data() const {
  return action_data_ != NULL ? *action_data_ : *default_instance_->action_data_;
}
inline ::proto::common::combat_action_data* combat_data::mutable_action_data() {
  set_has_action_data();
  if (action_data_ == NULL) action_data_ = new ::proto::common::combat_action_data;
  return action_data_;
}
inline ::proto::common::combat_action_data* combat_data::release_action_data() {
  clear_has_action_data();
  ::proto::common::combat_action_data* temp = action_data_;
  action_data_ = NULL;
  return temp;
}
inline void combat_data::set_allocated_action_data(::proto::common::combat_action_data* action_data) {
  delete action_data_;
  action_data_ = action_data;
  if (action_data) {
    set_has_action_data();
  } else {
    clear_has_action_data();
  }
}

// optional .proto.common.fight_data data = 6;
inline bool combat_data::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void combat_data::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void combat_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void combat_data::clear_data() {
  if (data_ != NULL) data_->::proto::common::fight_data::Clear();
  clear_has_data();
}
inline const ::proto::common::fight_data& combat_data::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::proto::common::fight_data* combat_data::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::proto::common::fight_data;
  return data_;
}
inline ::proto::common::fight_data* combat_data::release_data() {
  clear_has_data();
  ::proto::common::fight_data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void combat_data::set_allocated_data(::proto::common::fight_data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional uint32 remain_time = 7;
inline bool combat_data::has_remain_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void combat_data::set_has_remain_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void combat_data::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void combat_data::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 combat_data::remain_time() const {
  return remain_time_;
}
inline void combat_data::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional .proto.common.combat_hero_att_order att_order = 8;
inline bool combat_data::has_att_order() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void combat_data::set_has_att_order() {
  _has_bits_[0] |= 0x00000080u;
}
inline void combat_data::clear_has_att_order() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void combat_data::clear_att_order() {
  if (att_order_ != NULL) att_order_->::proto::common::combat_hero_att_order::Clear();
  clear_has_att_order();
}
inline const ::proto::common::combat_hero_att_order& combat_data::att_order() const {
  return att_order_ != NULL ? *att_order_ : *default_instance_->att_order_;
}
inline ::proto::common::combat_hero_att_order* combat_data::mutable_att_order() {
  set_has_att_order();
  if (att_order_ == NULL) att_order_ = new ::proto::common::combat_hero_att_order;
  return att_order_;
}
inline ::proto::common::combat_hero_att_order* combat_data::release_att_order() {
  clear_has_att_order();
  ::proto::common::combat_hero_att_order* temp = att_order_;
  att_order_ = NULL;
  return temp;
}
inline void combat_data::set_allocated_att_order(::proto::common::combat_hero_att_order* att_order) {
  delete att_order_;
  att_order_ = att_order;
  if (att_order) {
    set_has_att_order();
  } else {
    clear_has_att_order();
  }
}

// optional string cur_att_hero_uid = 9;
inline bool combat_data::has_cur_att_hero_uid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void combat_data::set_has_cur_att_hero_uid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void combat_data::clear_has_cur_att_hero_uid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void combat_data::clear_cur_att_hero_uid() {
  if (cur_att_hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    cur_att_hero_uid_->clear();
  }
  clear_has_cur_att_hero_uid();
}
inline const ::std::string& combat_data::cur_att_hero_uid() const {
  return *cur_att_hero_uid_;
}
inline void combat_data::set_cur_att_hero_uid(const ::std::string& value) {
  set_has_cur_att_hero_uid();
  if (cur_att_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    cur_att_hero_uid_ = new ::std::string;
  }
  cur_att_hero_uid_->assign(value);
}
inline void combat_data::set_cur_att_hero_uid(const char* value) {
  set_has_cur_att_hero_uid();
  if (cur_att_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    cur_att_hero_uid_ = new ::std::string;
  }
  cur_att_hero_uid_->assign(value);
}
inline void combat_data::set_cur_att_hero_uid(const char* value, size_t size) {
  set_has_cur_att_hero_uid();
  if (cur_att_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    cur_att_hero_uid_ = new ::std::string;
  }
  cur_att_hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_data::mutable_cur_att_hero_uid() {
  set_has_cur_att_hero_uid();
  if (cur_att_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    cur_att_hero_uid_ = new ::std::string;
  }
  return cur_att_hero_uid_;
}
inline ::std::string* combat_data::release_cur_att_hero_uid() {
  clear_has_cur_att_hero_uid();
  if (cur_att_hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cur_att_hero_uid_;
    cur_att_hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_data::set_allocated_cur_att_hero_uid(::std::string* cur_att_hero_uid) {
  if (cur_att_hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete cur_att_hero_uid_;
  }
  if (cur_att_hero_uid) {
    set_has_cur_att_hero_uid();
    cur_att_hero_uid_ = cur_att_hero_uid;
  } else {
    clear_has_cur_att_hero_uid();
    cur_att_hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 hero_att_round = 10;
inline bool combat_data::has_hero_att_round() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void combat_data::set_has_hero_att_round() {
  _has_bits_[0] |= 0x00000200u;
}
inline void combat_data::clear_has_hero_att_round() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void combat_data::clear_hero_att_round() {
  hero_att_round_ = 0u;
  clear_has_hero_att_round();
}
inline ::google::protobuf::uint32 combat_data::hero_att_round() const {
  return hero_att_round_;
}
inline void combat_data::set_hero_att_round(::google::protobuf::uint32 value) {
  set_has_hero_att_round();
  hero_att_round_ = value;
}

// optional .proto.common.fight_hero_skill_data skill_data = 11;
inline bool combat_data::has_skill_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void combat_data::set_has_skill_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void combat_data::clear_has_skill_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void combat_data::clear_skill_data() {
  if (skill_data_ != NULL) skill_data_->::proto::common::fight_hero_skill_data::Clear();
  clear_has_skill_data();
}
inline const ::proto::common::fight_hero_skill_data& combat_data::skill_data() const {
  return skill_data_ != NULL ? *skill_data_ : *default_instance_->skill_data_;
}
inline ::proto::common::fight_hero_skill_data* combat_data::mutable_skill_data() {
  set_has_skill_data();
  if (skill_data_ == NULL) skill_data_ = new ::proto::common::fight_hero_skill_data;
  return skill_data_;
}
inline ::proto::common::fight_hero_skill_data* combat_data::release_skill_data() {
  clear_has_skill_data();
  ::proto::common::fight_hero_skill_data* temp = skill_data_;
  skill_data_ = NULL;
  return temp;
}
inline void combat_data::set_allocated_skill_data(::proto::common::fight_hero_skill_data* skill_data) {
  delete skill_data_;
  skill_data_ = skill_data;
  if (skill_data) {
    set_has_skill_data();
  } else {
    clear_has_skill_data();
  }
}

// optional .proto.common.combat_hero_att_order first_att_order = 12;
inline bool combat_data::has_first_att_order() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void combat_data::set_has_first_att_order() {
  _has_bits_[0] |= 0x00000800u;
}
inline void combat_data::clear_has_first_att_order() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void combat_data::clear_first_att_order() {
  if (first_att_order_ != NULL) first_att_order_->::proto::common::combat_hero_att_order::Clear();
  clear_has_first_att_order();
}
inline const ::proto::common::combat_hero_att_order& combat_data::first_att_order() const {
  return first_att_order_ != NULL ? *first_att_order_ : *default_instance_->first_att_order_;
}
inline ::proto::common::combat_hero_att_order* combat_data::mutable_first_att_order() {
  set_has_first_att_order();
  if (first_att_order_ == NULL) first_att_order_ = new ::proto::common::combat_hero_att_order;
  return first_att_order_;
}
inline ::proto::common::combat_hero_att_order* combat_data::release_first_att_order() {
  clear_has_first_att_order();
  ::proto::common::combat_hero_att_order* temp = first_att_order_;
  first_att_order_ = NULL;
  return temp;
}
inline void combat_data::set_allocated_first_att_order(::proto::common::combat_hero_att_order* first_att_order) {
  delete first_att_order_;
  first_att_order_ = first_att_order;
  if (first_att_order) {
    set_has_first_att_order();
  } else {
    clear_has_first_att_order();
  }
}

// optional uint32 watching_role_num = 13;
inline bool combat_data::has_watching_role_num() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void combat_data::set_has_watching_role_num() {
  _has_bits_[0] |= 0x00001000u;
}
inline void combat_data::clear_has_watching_role_num() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void combat_data::clear_watching_role_num() {
  watching_role_num_ = 0u;
  clear_has_watching_role_num();
}
inline ::google::protobuf::uint32 combat_data::watching_role_num() const {
  return watching_role_num_;
}
inline void combat_data::set_watching_role_num(::google::protobuf::uint32 value) {
  set_has_watching_role_num();
  watching_role_num_ = value;
}

// optional uint32 cur_wave_num = 14;
inline bool combat_data::has_cur_wave_num() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void combat_data::set_has_cur_wave_num() {
  _has_bits_[0] |= 0x00002000u;
}
inline void combat_data::clear_has_cur_wave_num() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void combat_data::clear_cur_wave_num() {
  cur_wave_num_ = 0u;
  clear_has_cur_wave_num();
}
inline ::google::protobuf::uint32 combat_data::cur_wave_num() const {
  return cur_wave_num_;
}
inline void combat_data::set_cur_wave_num(::google::protobuf::uint32 value) {
  set_has_cur_wave_num();
  cur_wave_num_ = value;
}

// -------------------------------------------------------------------

// combat_form_single

// optional string attacker = 1;
inline bool combat_form_single::has_attacker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_form_single::set_has_attacker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_form_single::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_form_single::clear_attacker() {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    attacker_->clear();
  }
  clear_has_attacker();
}
inline const ::std::string& combat_form_single::attacker() const {
  return *attacker_;
}
inline void combat_form_single::set_attacker(const ::std::string& value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void combat_form_single::set_attacker(const char* value) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(value);
}
inline void combat_form_single::set_attacker(const char* value, size_t size) {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  attacker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_form_single::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    attacker_ = new ::std::string;
  }
  return attacker_;
}
inline ::std::string* combat_form_single::release_attacker() {
  clear_has_attacker();
  if (attacker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attacker_;
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_form_single::set_allocated_attacker(::std::string* attacker) {
  if (attacker_ != &::google::protobuf::internal::kEmptyString) {
    delete attacker_;
  }
  if (attacker) {
    set_has_attacker();
    attacker_ = attacker;
  } else {
    clear_has_attacker();
    attacker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 skill = 2;
inline bool combat_form_single::has_skill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_form_single::set_has_skill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_form_single::clear_has_skill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_form_single::clear_skill() {
  skill_ = 0u;
  clear_has_skill();
}
inline ::google::protobuf::uint32 combat_form_single::skill() const {
  return skill_;
}
inline void combat_form_single::set_skill(::google::protobuf::uint32 value) {
  set_has_skill();
  skill_ = value;
}

// optional string target = 3;
inline bool combat_form_single::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_form_single::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_form_single::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_form_single::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& combat_form_single::target() const {
  return *target_;
}
inline void combat_form_single::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void combat_form_single::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void combat_form_single::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_form_single::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* combat_form_single::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_form_single::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// combat_form_data

// repeated .proto.common.combat_form_single forms = 1;
inline int combat_form_data::forms_size() const {
  return forms_.size();
}
inline void combat_form_data::clear_forms() {
  forms_.Clear();
}
inline const ::proto::common::combat_form_single& combat_form_data::forms(int index) const {
  return forms_.Get(index);
}
inline ::proto::common::combat_form_single* combat_form_data::mutable_forms(int index) {
  return forms_.Mutable(index);
}
inline ::proto::common::combat_form_single* combat_form_data::add_forms() {
  return forms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_form_single >&
combat_form_data::forms() const {
  return forms_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_form_single >*
combat_form_data::mutable_forms() {
  return &forms_;
}

// -------------------------------------------------------------------

// combat_finish_single_task

// optional .proto.common.combat_finish_task_type finish_task = 1 [default = combat_finish_task_type_none];
inline bool combat_finish_single_task::has_finish_task() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_finish_single_task::set_has_finish_task() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_finish_single_task::clear_has_finish_task() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_finish_single_task::clear_finish_task() {
  finish_task_ = 0;
  clear_has_finish_task();
}
inline ::proto::common::combat_finish_task_type combat_finish_single_task::finish_task() const {
  return static_cast< ::proto::common::combat_finish_task_type >(finish_task_);
}
inline void combat_finish_single_task::set_finish_task(::proto::common::combat_finish_task_type value) {
  assert(::proto::common::combat_finish_task_type_IsValid(value));
  set_has_finish_task();
  finish_task_ = value;
}

// -------------------------------------------------------------------

// combat_camp_finish_task

// repeated .proto.common.combat_finish_single_task finish_tasks = 2;
inline int combat_camp_finish_task::finish_tasks_size() const {
  return finish_tasks_.size();
}
inline void combat_camp_finish_task::clear_finish_tasks() {
  finish_tasks_.Clear();
}
inline const ::proto::common::combat_finish_single_task& combat_camp_finish_task::finish_tasks(int index) const {
  return finish_tasks_.Get(index);
}
inline ::proto::common::combat_finish_single_task* combat_camp_finish_task::mutable_finish_tasks(int index) {
  return finish_tasks_.Mutable(index);
}
inline ::proto::common::combat_finish_single_task* combat_camp_finish_task::add_finish_tasks() {
  return finish_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_finish_single_task >&
combat_camp_finish_task::finish_tasks() const {
  return finish_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_finish_single_task >*
combat_camp_finish_task::mutable_finish_tasks() {
  return &finish_tasks_;
}

// -------------------------------------------------------------------

// combat_result

// optional uint32 win_camp = 1;
inline bool combat_result::has_win_camp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_result::set_has_win_camp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_result::clear_has_win_camp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_result::clear_win_camp() {
  win_camp_ = 0u;
  clear_has_win_camp();
}
inline ::google::protobuf::uint32 combat_result::win_camp() const {
  return win_camp_;
}
inline void combat_result::set_win_camp(::google::protobuf::uint32 value) {
  set_has_win_camp();
  win_camp_ = value;
}

// optional .proto.common.combat_fight_result result = 2 [default = combat_fight_result_none];
inline bool combat_result::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_result::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_result::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_result::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::proto::common::combat_fight_result combat_result::result() const {
  return static_cast< ::proto::common::combat_fight_result >(result_);
}
inline void combat_result::set_result(::proto::common::combat_fight_result value) {
  assert(::proto::common::combat_fight_result_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional .proto.common.combat_camp_finish_task win_camp_tasks = 3;
inline bool combat_result::has_win_camp_tasks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_result::set_has_win_camp_tasks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_result::clear_has_win_camp_tasks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_result::clear_win_camp_tasks() {
  if (win_camp_tasks_ != NULL) win_camp_tasks_->::proto::common::combat_camp_finish_task::Clear();
  clear_has_win_camp_tasks();
}
inline const ::proto::common::combat_camp_finish_task& combat_result::win_camp_tasks() const {
  return win_camp_tasks_ != NULL ? *win_camp_tasks_ : *default_instance_->win_camp_tasks_;
}
inline ::proto::common::combat_camp_finish_task* combat_result::mutable_win_camp_tasks() {
  set_has_win_camp_tasks();
  if (win_camp_tasks_ == NULL) win_camp_tasks_ = new ::proto::common::combat_camp_finish_task;
  return win_camp_tasks_;
}
inline ::proto::common::combat_camp_finish_task* combat_result::release_win_camp_tasks() {
  clear_has_win_camp_tasks();
  ::proto::common::combat_camp_finish_task* temp = win_camp_tasks_;
  win_camp_tasks_ = NULL;
  return temp;
}
inline void combat_result::set_allocated_win_camp_tasks(::proto::common::combat_camp_finish_task* win_camp_tasks) {
  delete win_camp_tasks_;
  win_camp_tasks_ = win_camp_tasks;
  if (win_camp_tasks) {
    set_has_win_camp_tasks();
  } else {
    clear_has_win_camp_tasks();
  }
}

// optional .proto.common.combat_camp_finish_task lose_camp_tasks = 4;
inline bool combat_result::has_lose_camp_tasks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void combat_result::set_has_lose_camp_tasks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void combat_result::clear_has_lose_camp_tasks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void combat_result::clear_lose_camp_tasks() {
  if (lose_camp_tasks_ != NULL) lose_camp_tasks_->::proto::common::combat_camp_finish_task::Clear();
  clear_has_lose_camp_tasks();
}
inline const ::proto::common::combat_camp_finish_task& combat_result::lose_camp_tasks() const {
  return lose_camp_tasks_ != NULL ? *lose_camp_tasks_ : *default_instance_->lose_camp_tasks_;
}
inline ::proto::common::combat_camp_finish_task* combat_result::mutable_lose_camp_tasks() {
  set_has_lose_camp_tasks();
  if (lose_camp_tasks_ == NULL) lose_camp_tasks_ = new ::proto::common::combat_camp_finish_task;
  return lose_camp_tasks_;
}
inline ::proto::common::combat_camp_finish_task* combat_result::release_lose_camp_tasks() {
  clear_has_lose_camp_tasks();
  ::proto::common::combat_camp_finish_task* temp = lose_camp_tasks_;
  lose_camp_tasks_ = NULL;
  return temp;
}
inline void combat_result::set_allocated_lose_camp_tasks(::proto::common::combat_camp_finish_task* lose_camp_tasks) {
  delete lose_camp_tasks_;
  lose_camp_tasks_ = lose_camp_tasks;
  if (lose_camp_tasks) {
    set_has_lose_camp_tasks();
  } else {
    clear_has_lose_camp_tasks();
  }
}

// -------------------------------------------------------------------

// combat_count_data_single_hero

// optional uint32 hero_tid = 1;
inline bool combat_count_data_single_hero::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_count_data_single_hero::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_count_data_single_hero::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_count_data_single_hero::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::hero_tid() const {
  return hero_tid_;
}
inline void combat_count_data_single_hero::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional uint32 pos = 2;
inline bool combat_count_data_single_hero::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void combat_count_data_single_hero::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void combat_count_data_single_hero::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void combat_count_data_single_hero::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::pos() const {
  return pos_;
}
inline void combat_count_data_single_hero::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional uint32 heal = 3;
inline bool combat_count_data_single_hero::has_heal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void combat_count_data_single_hero::set_has_heal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void combat_count_data_single_hero::clear_has_heal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void combat_count_data_single_hero::clear_heal() {
  heal_ = 0u;
  clear_has_heal();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::heal() const {
  return heal_;
}
inline void combat_count_data_single_hero::set_heal(::google::protobuf::uint32 value) {
  set_has_heal();
  heal_ = value;
}

// optional uint32 damage = 4;
inline bool combat_count_data_single_hero::has_damage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void combat_count_data_single_hero::set_has_damage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void combat_count_data_single_hero::clear_has_damage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void combat_count_data_single_hero::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::damage() const {
  return damage_;
}
inline void combat_count_data_single_hero::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// optional uint32 accept_damage = 5;
inline bool combat_count_data_single_hero::has_accept_damage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void combat_count_data_single_hero::set_has_accept_damage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void combat_count_data_single_hero::clear_has_accept_damage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void combat_count_data_single_hero::clear_accept_damage() {
  accept_damage_ = 0u;
  clear_has_accept_damage();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::accept_damage() const {
  return accept_damage_;
}
inline void combat_count_data_single_hero::set_accept_damage(::google::protobuf::uint32 value) {
  set_has_accept_damage();
  accept_damage_ = value;
}

// optional uint32 plugin = 6;
inline bool combat_count_data_single_hero::has_plugin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void combat_count_data_single_hero::set_has_plugin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void combat_count_data_single_hero::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void combat_count_data_single_hero::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 combat_count_data_single_hero::plugin() const {
  return plugin_;
}
inline void combat_count_data_single_hero::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// -------------------------------------------------------------------

// combat_count_data_heroes_obj

// optional string obj_uid = 1;
inline bool combat_count_data_heroes_obj::has_obj_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void combat_count_data_heroes_obj::set_has_obj_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void combat_count_data_heroes_obj::clear_has_obj_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void combat_count_data_heroes_obj::clear_obj_uid() {
  if (obj_uid_ != &::google::protobuf::internal::kEmptyString) {
    obj_uid_->clear();
  }
  clear_has_obj_uid();
}
inline const ::std::string& combat_count_data_heroes_obj::obj_uid() const {
  return *obj_uid_;
}
inline void combat_count_data_heroes_obj::set_obj_uid(const ::std::string& value) {
  set_has_obj_uid();
  if (obj_uid_ == &::google::protobuf::internal::kEmptyString) {
    obj_uid_ = new ::std::string;
  }
  obj_uid_->assign(value);
}
inline void combat_count_data_heroes_obj::set_obj_uid(const char* value) {
  set_has_obj_uid();
  if (obj_uid_ == &::google::protobuf::internal::kEmptyString) {
    obj_uid_ = new ::std::string;
  }
  obj_uid_->assign(value);
}
inline void combat_count_data_heroes_obj::set_obj_uid(const char* value, size_t size) {
  set_has_obj_uid();
  if (obj_uid_ == &::google::protobuf::internal::kEmptyString) {
    obj_uid_ = new ::std::string;
  }
  obj_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* combat_count_data_heroes_obj::mutable_obj_uid() {
  set_has_obj_uid();
  if (obj_uid_ == &::google::protobuf::internal::kEmptyString) {
    obj_uid_ = new ::std::string;
  }
  return obj_uid_;
}
inline ::std::string* combat_count_data_heroes_obj::release_obj_uid() {
  clear_has_obj_uid();
  if (obj_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = obj_uid_;
    obj_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void combat_count_data_heroes_obj::set_allocated_obj_uid(::std::string* obj_uid) {
  if (obj_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete obj_uid_;
  }
  if (obj_uid) {
    set_has_obj_uid();
    obj_uid_ = obj_uid;
  } else {
    clear_has_obj_uid();
    obj_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.common.combat_count_data_single_hero hero_list = 2;
inline int combat_count_data_heroes_obj::hero_list_size() const {
  return hero_list_.size();
}
inline void combat_count_data_heroes_obj::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::combat_count_data_single_hero& combat_count_data_heroes_obj::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::combat_count_data_single_hero* combat_count_data_heroes_obj::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::combat_count_data_single_hero* combat_count_data_heroes_obj::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_single_hero >&
combat_count_data_heroes_obj::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_single_hero >*
combat_count_data_heroes_obj::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// combat_count_data

// repeated .proto.common.combat_count_data_heroes_obj obj_list = 1;
inline int combat_count_data::obj_list_size() const {
  return obj_list_.size();
}
inline void combat_count_data::clear_obj_list() {
  obj_list_.Clear();
}
inline const ::proto::common::combat_count_data_heroes_obj& combat_count_data::obj_list(int index) const {
  return obj_list_.Get(index);
}
inline ::proto::common::combat_count_data_heroes_obj* combat_count_data::mutable_obj_list(int index) {
  return obj_list_.Mutable(index);
}
inline ::proto::common::combat_count_data_heroes_obj* combat_count_data::add_obj_list() {
  return obj_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_heroes_obj >&
combat_count_data::obj_list() const {
  return obj_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::combat_count_data_heroes_obj >*
combat_count_data::mutable_obj_list() {
  return &obj_list_;
}

// -------------------------------------------------------------------

// fight_obj_state

// optional string object_uid = 1;
inline bool fight_obj_state::has_object_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fight_obj_state::set_has_object_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fight_obj_state::clear_has_object_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fight_obj_state::clear_object_uid() {
  if (object_uid_ != &::google::protobuf::internal::kEmptyString) {
    object_uid_->clear();
  }
  clear_has_object_uid();
}
inline const ::std::string& fight_obj_state::object_uid() const {
  return *object_uid_;
}
inline void fight_obj_state::set_object_uid(const ::std::string& value) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(value);
}
inline void fight_obj_state::set_object_uid(const char* value) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(value);
}
inline void fight_obj_state::set_object_uid(const char* value, size_t size) {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  object_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* fight_obj_state::mutable_object_uid() {
  set_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    object_uid_ = new ::std::string;
  }
  return object_uid_;
}
inline ::std::string* fight_obj_state::release_object_uid() {
  clear_has_object_uid();
  if (object_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_uid_;
    object_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void fight_obj_state::set_allocated_object_uid(::std::string* object_uid) {
  if (object_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete object_uid_;
  }
  if (object_uid) {
    set_has_object_uid();
    object_uid_ = object_uid;
  } else {
    clear_has_object_uid();
    object_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.combat_obj_state state = 2 [default = combat_obj_state_none];
inline bool fight_obj_state::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fight_obj_state::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fight_obj_state::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fight_obj_state::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::proto::common::combat_obj_state fight_obj_state::state() const {
  return static_cast< ::proto::common::combat_obj_state >(state_);
}
inline void fight_obj_state::set_state(::proto::common::combat_obj_state value) {
  assert(::proto::common::combat_obj_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// fight_obj_state_data

// repeated .proto.common.fight_obj_state states = 1;
inline int fight_obj_state_data::states_size() const {
  return states_.size();
}
inline void fight_obj_state_data::clear_states() {
  states_.Clear();
}
inline const ::proto::common::fight_obj_state& fight_obj_state_data::states(int index) const {
  return states_.Get(index);
}
inline ::proto::common::fight_obj_state* fight_obj_state_data::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::proto::common::fight_obj_state* fight_obj_state_data::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::fight_obj_state >&
fight_obj_state_data::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::fight_obj_state >*
fight_obj_state_data::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// bounty_single

// optional uint32 bounty_id = 1;
inline bool bounty_single::has_bounty_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bounty_single::set_has_bounty_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bounty_single::clear_has_bounty_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bounty_single::clear_bounty_id() {
  bounty_id_ = 0u;
  clear_has_bounty_id();
}
inline ::google::protobuf::uint32 bounty_single::bounty_id() const {
  return bounty_id_;
}
inline void bounty_single::set_bounty_id(::google::protobuf::uint32 value) {
  set_has_bounty_id();
  bounty_id_ = value;
}

// optional uint32 state = 2;
inline bool bounty_single::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bounty_single::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bounty_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bounty_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 bounty_single::state() const {
  return state_;
}
inline void bounty_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 star = 3;
inline bool bounty_single::has_star() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bounty_single::set_has_star() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bounty_single::clear_has_star() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bounty_single::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 bounty_single::star() const {
  return star_;
}
inline void bounty_single::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// -------------------------------------------------------------------

// star_box

// optional uint32 star = 1;
inline bool star_box::has_star() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void star_box::set_has_star() {
  _has_bits_[0] |= 0x00000001u;
}
inline void star_box::clear_has_star() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void star_box::clear_star() {
  star_ = 0u;
  clear_has_star();
}
inline ::google::protobuf::uint32 star_box::star() const {
  return star_;
}
inline void star_box::set_star(::google::protobuf::uint32 value) {
  set_has_star();
  star_ = value;
}

// optional uint32 state = 2;
inline bool star_box::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void star_box::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void star_box::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void star_box::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 star_box::state() const {
  return state_;
}
inline void star_box::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// country_bounty_data

// optional uint32 accept_count = 1;
inline bool country_bounty_data::has_accept_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_bounty_data::set_has_accept_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_bounty_data::clear_has_accept_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_bounty_data::clear_accept_count() {
  accept_count_ = 0u;
  clear_has_accept_count();
}
inline ::google::protobuf::uint32 country_bounty_data::accept_count() const {
  return accept_count_;
}
inline void country_bounty_data::set_accept_count(::google::protobuf::uint32 value) {
  set_has_accept_count();
  accept_count_ = value;
}

// optional uint32 max_accept_count = 2;
inline bool country_bounty_data::has_max_accept_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_bounty_data::set_has_max_accept_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_bounty_data::clear_has_max_accept_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_bounty_data::clear_max_accept_count() {
  max_accept_count_ = 0u;
  clear_has_max_accept_count();
}
inline ::google::protobuf::uint32 country_bounty_data::max_accept_count() const {
  return max_accept_count_;
}
inline void country_bounty_data::set_max_accept_count(::google::protobuf::uint32 value) {
  set_has_max_accept_count();
  max_accept_count_ = value;
}

// optional uint32 refresh_count = 3;
inline bool country_bounty_data::has_refresh_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_bounty_data::set_has_refresh_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_bounty_data::clear_has_refresh_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_bounty_data::clear_refresh_count() {
  refresh_count_ = 0u;
  clear_has_refresh_count();
}
inline ::google::protobuf::uint32 country_bounty_data::refresh_count() const {
  return refresh_count_;
}
inline void country_bounty_data::set_refresh_count(::google::protobuf::uint32 value) {
  set_has_refresh_count();
  refresh_count_ = value;
}

// optional uint32 star_count = 4;
inline bool country_bounty_data::has_star_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void country_bounty_data::set_has_star_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void country_bounty_data::clear_has_star_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void country_bounty_data::clear_star_count() {
  star_count_ = 0u;
  clear_has_star_count();
}
inline ::google::protobuf::uint32 country_bounty_data::star_count() const {
  return star_count_;
}
inline void country_bounty_data::set_star_count(::google::protobuf::uint32 value) {
  set_has_star_count();
  star_count_ = value;
}

// repeated .proto.common.star_box box_list = 5;
inline int country_bounty_data::box_list_size() const {
  return box_list_.size();
}
inline void country_bounty_data::clear_box_list() {
  box_list_.Clear();
}
inline const ::proto::common::star_box& country_bounty_data::box_list(int index) const {
  return box_list_.Get(index);
}
inline ::proto::common::star_box* country_bounty_data::mutable_box_list(int index) {
  return box_list_.Mutable(index);
}
inline ::proto::common::star_box* country_bounty_data::add_box_list() {
  return box_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::star_box >&
country_bounty_data::box_list() const {
  return box_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::star_box >*
country_bounty_data::mutable_box_list() {
  return &box_list_;
}

// repeated .proto.common.bounty_single bounty_data = 6;
inline int country_bounty_data::bounty_data_size() const {
  return bounty_data_.size();
}
inline void country_bounty_data::clear_bounty_data() {
  bounty_data_.Clear();
}
inline const ::proto::common::bounty_single& country_bounty_data::bounty_data(int index) const {
  return bounty_data_.Get(index);
}
inline ::proto::common::bounty_single* country_bounty_data::mutable_bounty_data(int index) {
  return bounty_data_.Mutable(index);
}
inline ::proto::common::bounty_single* country_bounty_data::add_bounty_data() {
  return bounty_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::bounty_single >&
country_bounty_data::bounty_data() const {
  return bounty_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::bounty_single >*
country_bounty_data::mutable_bounty_data() {
  return &bounty_data_;
}

// optional uint32 accept_level = 7;
inline bool country_bounty_data::has_accept_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void country_bounty_data::set_has_accept_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void country_bounty_data::clear_has_accept_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void country_bounty_data::clear_accept_level() {
  accept_level_ = 0u;
  clear_has_accept_level();
}
inline ::google::protobuf::uint32 country_bounty_data::accept_level() const {
  return accept_level_;
}
inline void country_bounty_data::set_accept_level(::google::protobuf::uint32 value) {
  set_has_accept_level();
  accept_level_ = value;
}

// -------------------------------------------------------------------

// item_limit_data

// optional uint32 item_tid = 1;
inline bool item_limit_data::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void item_limit_data::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void item_limit_data::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void item_limit_data::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 item_limit_data::item_tid() const {
  return item_tid_;
}
inline void item_limit_data::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_num = 2;
inline bool item_limit_data::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void item_limit_data::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void item_limit_data::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void item_limit_data::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 item_limit_data::item_num() const {
  return item_num_;
}
inline void item_limit_data::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional uint32 last_give_time = 3;
inline bool item_limit_data::has_last_give_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void item_limit_data::set_has_last_give_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void item_limit_data::clear_has_last_give_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void item_limit_data::clear_last_give_time() {
  last_give_time_ = 0u;
  clear_has_last_give_time();
}
inline ::google::protobuf::uint32 item_limit_data::last_give_time() const {
  return last_give_time_;
}
inline void item_limit_data::set_last_give_time(::google::protobuf::uint32 value) {
  set_has_last_give_time();
  last_give_time_ = value;
}

// -------------------------------------------------------------------

// friend_member

// optional string friend_uid = 1;
inline bool friend_member::has_friend_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void friend_member::set_has_friend_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void friend_member::clear_has_friend_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void friend_member::clear_friend_uid() {
  if (friend_uid_ != &::google::protobuf::internal::kEmptyString) {
    friend_uid_->clear();
  }
  clear_has_friend_uid();
}
inline const ::std::string& friend_member::friend_uid() const {
  return *friend_uid_;
}
inline void friend_member::set_friend_uid(const ::std::string& value) {
  set_has_friend_uid();
  if (friend_uid_ == &::google::protobuf::internal::kEmptyString) {
    friend_uid_ = new ::std::string;
  }
  friend_uid_->assign(value);
}
inline void friend_member::set_friend_uid(const char* value) {
  set_has_friend_uid();
  if (friend_uid_ == &::google::protobuf::internal::kEmptyString) {
    friend_uid_ = new ::std::string;
  }
  friend_uid_->assign(value);
}
inline void friend_member::set_friend_uid(const char* value, size_t size) {
  set_has_friend_uid();
  if (friend_uid_ == &::google::protobuf::internal::kEmptyString) {
    friend_uid_ = new ::std::string;
  }
  friend_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* friend_member::mutable_friend_uid() {
  set_has_friend_uid();
  if (friend_uid_ == &::google::protobuf::internal::kEmptyString) {
    friend_uid_ = new ::std::string;
  }
  return friend_uid_;
}
inline ::std::string* friend_member::release_friend_uid() {
  clear_has_friend_uid();
  if (friend_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_uid_;
    friend_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void friend_member::set_allocated_friend_uid(::std::string* friend_uid) {
  if (friend_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_uid_;
  }
  if (friend_uid) {
    set_has_friend_uid();
    friend_uid_ = friend_uid;
  } else {
    clear_has_friend_uid();
    friend_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 contact_time = 2;
inline bool friend_member::has_contact_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void friend_member::set_has_contact_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void friend_member::clear_has_contact_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void friend_member::clear_contact_time() {
  contact_time_ = 0u;
  clear_has_contact_time();
}
inline ::google::protobuf::uint32 friend_member::contact_time() const {
  return contact_time_;
}
inline void friend_member::set_contact_time(::google::protobuf::uint32 value) {
  set_has_contact_time();
  contact_time_ = value;
}

// optional .proto.common.friend_type ftype = 3;
inline bool friend_member::has_ftype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void friend_member::set_has_ftype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void friend_member::clear_has_ftype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void friend_member::clear_ftype() {
  ftype_ = 0;
  clear_has_ftype();
}
inline ::proto::common::friend_type friend_member::ftype() const {
  return static_cast< ::proto::common::friend_type >(ftype_);
}
inline void friend_member::set_ftype(::proto::common::friend_type value) {
  assert(::proto::common::friend_type_IsValid(value));
  set_has_ftype();
  ftype_ = value;
}

// optional uint32 is_top = 4;
inline bool friend_member::has_is_top() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void friend_member::set_has_is_top() {
  _has_bits_[0] |= 0x00000008u;
}
inline void friend_member::clear_has_is_top() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void friend_member::clear_is_top() {
  is_top_ = 0u;
  clear_has_is_top();
}
inline ::google::protobuf::uint32 friend_member::is_top() const {
  return is_top_;
}
inline void friend_member::set_is_top(::google::protobuf::uint32 value) {
  set_has_is_top();
  is_top_ = value;
}

// optional uint32 top_time = 5;
inline bool friend_member::has_top_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void friend_member::set_has_top_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void friend_member::clear_has_top_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void friend_member::clear_top_time() {
  top_time_ = 0u;
  clear_has_top_time();
}
inline ::google::protobuf::uint32 friend_member::top_time() const {
  return top_time_;
}
inline void friend_member::set_top_time(::google::protobuf::uint32 value) {
  set_has_top_time();
  top_time_ = value;
}

// optional uint32 time = 6;
inline bool friend_member::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void friend_member::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void friend_member::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void friend_member::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 friend_member::time() const {
  return time_;
}
inline void friend_member::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional .proto.common.user_info info = 7;
inline bool friend_member::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void friend_member::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void friend_member::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void friend_member::clear_info() {
  if (info_ != NULL) info_->::proto::common::user_info::Clear();
  clear_has_info();
}
inline const ::proto::common::user_info& friend_member::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto::common::user_info* friend_member::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto::common::user_info;
  return info_;
}
inline ::proto::common::user_info* friend_member::release_info() {
  clear_has_info();
  ::proto::common::user_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void friend_member::set_allocated_info(::proto::common::user_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 shadow_time = 8;
inline bool friend_member::has_shadow_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void friend_member::set_has_shadow_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void friend_member::clear_has_shadow_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void friend_member::clear_shadow_time() {
  shadow_time_ = 0u;
  clear_has_shadow_time();
}
inline ::google::protobuf::uint32 friend_member::shadow_time() const {
  return shadow_time_;
}
inline void friend_member::set_shadow_time(::google::protobuf::uint32 value) {
  set_has_shadow_time();
  shadow_time_ = value;
}

// optional uint32 shadow_count = 9;
inline bool friend_member::has_shadow_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void friend_member::set_has_shadow_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void friend_member::clear_has_shadow_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void friend_member::clear_shadow_count() {
  shadow_count_ = 0u;
  clear_has_shadow_count();
}
inline ::google::protobuf::uint32 friend_member::shadow_count() const {
  return shadow_count_;
}
inline void friend_member::set_shadow_count(::google::protobuf::uint32 value) {
  set_has_shadow_count();
  shadow_count_ = value;
}

// optional int32 friendliness = 10;
inline bool friend_member::has_friendliness() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void friend_member::set_has_friendliness() {
  _has_bits_[0] |= 0x00000200u;
}
inline void friend_member::clear_has_friendliness() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void friend_member::clear_friendliness() {
  friendliness_ = 0;
  clear_has_friendliness();
}
inline ::google::protobuf::int32 friend_member::friendliness() const {
  return friendliness_;
}
inline void friend_member::set_friendliness(::google::protobuf::int32 value) {
  set_has_friendliness();
  friendliness_ = value;
}

// optional uint32 friendliness_added_today = 15;
inline bool friend_member::has_friendliness_added_today() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void friend_member::set_has_friendliness_added_today() {
  _has_bits_[0] |= 0x00000400u;
}
inline void friend_member::clear_has_friendliness_added_today() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void friend_member::clear_friendliness_added_today() {
  friendliness_added_today_ = 0u;
  clear_has_friendliness_added_today();
}
inline ::google::protobuf::uint32 friend_member::friendliness_added_today() const {
  return friendliness_added_today_;
}
inline void friend_member::set_friendliness_added_today(::google::protobuf::uint32 value) {
  set_has_friendliness_added_today();
  friendliness_added_today_ = value;
}

// optional uint32 friendliness_refresh_time = 16;
inline bool friend_member::has_friendliness_refresh_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void friend_member::set_has_friendliness_refresh_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void friend_member::clear_has_friendliness_refresh_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void friend_member::clear_friendliness_refresh_time() {
  friendliness_refresh_time_ = 0u;
  clear_has_friendliness_refresh_time();
}
inline ::google::protobuf::uint32 friend_member::friendliness_refresh_time() const {
  return friendliness_refresh_time_;
}
inline void friend_member::set_friendliness_refresh_time(::google::protobuf::uint32 value) {
  set_has_friendliness_refresh_time();
  friendliness_refresh_time_ = value;
}

// optional uint32 can_get_friendship_point = 11;
inline bool friend_member::has_can_get_friendship_point() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void friend_member::set_has_can_get_friendship_point() {
  _has_bits_[0] |= 0x00001000u;
}
inline void friend_member::clear_has_can_get_friendship_point() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void friend_member::clear_can_get_friendship_point() {
  can_get_friendship_point_ = 0u;
  clear_has_can_get_friendship_point();
}
inline ::google::protobuf::uint32 friend_member::can_get_friendship_point() const {
  return can_get_friendship_point_;
}
inline void friend_member::set_can_get_friendship_point(::google::protobuf::uint32 value) {
  set_has_can_get_friendship_point();
  can_get_friendship_point_ = value;
}

// optional uint32 last_get_fp_time = 12;
inline bool friend_member::has_last_get_fp_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void friend_member::set_has_last_get_fp_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void friend_member::clear_has_last_get_fp_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void friend_member::clear_last_get_fp_time() {
  last_get_fp_time_ = 0u;
  clear_has_last_get_fp_time();
}
inline ::google::protobuf::uint32 friend_member::last_get_fp_time() const {
  return last_get_fp_time_;
}
inline void friend_member::set_last_get_fp_time(::google::protobuf::uint32 value) {
  set_has_last_get_fp_time();
  last_get_fp_time_ = value;
}

// optional uint32 last_sent_fp_time = 13;
inline bool friend_member::has_last_sent_fp_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void friend_member::set_has_last_sent_fp_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void friend_member::clear_has_last_sent_fp_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void friend_member::clear_last_sent_fp_time() {
  last_sent_fp_time_ = 0u;
  clear_has_last_sent_fp_time();
}
inline ::google::protobuf::uint32 friend_member::last_sent_fp_time() const {
  return last_sent_fp_time_;
}
inline void friend_member::set_last_sent_fp_time(::google::protobuf::uint32 value) {
  set_has_last_sent_fp_time();
  last_sent_fp_time_ = value;
}

// -------------------------------------------------------------------

// relation_interface_data

// optional uint32 level = 1;
inline bool relation_interface_data::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void relation_interface_data::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void relation_interface_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void relation_interface_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 relation_interface_data::level() const {
  return level_;
}
inline void relation_interface_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 friends_quantity = 2;
inline bool relation_interface_data::has_friends_quantity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void relation_interface_data::set_has_friends_quantity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void relation_interface_data::clear_has_friends_quantity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void relation_interface_data::clear_friends_quantity() {
  friends_quantity_ = 0u;
  clear_has_friends_quantity();
}
inline ::google::protobuf::uint32 relation_interface_data::friends_quantity() const {
  return friends_quantity_;
}
inline void relation_interface_data::set_friends_quantity(::google::protobuf::uint32 value) {
  set_has_friends_quantity();
  friends_quantity_ = value;
}

// optional bool has_got = 3;
inline bool relation_interface_data::has_has_got() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void relation_interface_data::set_has_has_got() {
  _has_bits_[0] |= 0x00000004u;
}
inline void relation_interface_data::clear_has_has_got() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void relation_interface_data::clear_has_got() {
  has_got_ = false;
  clear_has_has_got();
}
inline bool relation_interface_data::has_got() const {
  return has_got_;
}
inline void relation_interface_data::set_has_got(bool value) {
  set_has_has_got();
  has_got_ = value;
}

// -------------------------------------------------------------------

// recommend_member

// optional .proto.common.user_info info = 1;
inline bool recommend_member::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recommend_member::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recommend_member::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recommend_member::clear_info() {
  if (info_ != NULL) info_->::proto::common::user_info::Clear();
  clear_has_info();
}
inline const ::proto::common::user_info& recommend_member::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto::common::user_info* recommend_member::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto::common::user_info;
  return info_;
}
inline ::proto::common::user_info* recommend_member::release_info() {
  clear_has_info();
  ::proto::common::user_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void recommend_member::set_allocated_info(::proto::common::user_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional uint32 src = 2;
inline bool recommend_member::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void recommend_member::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void recommend_member::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void recommend_member::clear_src() {
  src_ = 0u;
  clear_has_src();
}
inline ::google::protobuf::uint32 recommend_member::src() const {
  return src_;
}
inline void recommend_member::set_src(::google::protobuf::uint32 value) {
  set_has_src();
  src_ = value;
}

// -------------------------------------------------------------------

// user_info

// optional string uid = 1;
inline bool user_info::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_info::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_info::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& user_info::uid() const {
  return *uid_;
}
inline void user_info::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void user_info::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void user_info::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_info::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* user_info::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_info::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool user_info::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_info::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& user_info::name() const {
  return *name_;
}
inline void user_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void user_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void user_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* user_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 level = 3;
inline bool user_info::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_info::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 user_info::level() const {
  return level_;
}
inline void user_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional .proto.common.country_common country = 4;
inline bool user_info::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void user_info::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void user_info::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void user_info::clear_country() {
  if (country_ != NULL) country_->::proto::common::country_common::Clear();
  clear_has_country();
}
inline const ::proto::common::country_common& user_info::country() const {
  return country_ != NULL ? *country_ : *default_instance_->country_;
}
inline ::proto::common::country_common* user_info::mutable_country() {
  set_has_country();
  if (country_ == NULL) country_ = new ::proto::common::country_common;
  return country_;
}
inline ::proto::common::country_common* user_info::release_country() {
  clear_has_country();
  ::proto::common::country_common* temp = country_;
  country_ = NULL;
  return temp;
}
inline void user_info::set_allocated_country(::proto::common::country_common* country) {
  delete country_;
  country_ = country;
  if (country) {
    set_has_country();
  } else {
    clear_has_country();
  }
}

// optional string family = 5;
inline bool user_info::has_family() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void user_info::set_has_family() {
  _has_bits_[0] |= 0x00000010u;
}
inline void user_info::clear_has_family() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void user_info::clear_family() {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    family_->clear();
  }
  clear_has_family();
}
inline const ::std::string& user_info::family() const {
  return *family_;
}
inline void user_info::set_family(const ::std::string& value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void user_info::set_family(const char* value) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(value);
}
inline void user_info::set_family(const char* value, size_t size) {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* user_info::mutable_family() {
  set_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    family_ = new ::std::string;
  }
  return family_;
}
inline ::std::string* user_info::release_family() {
  clear_has_family();
  if (family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_;
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void user_info::set_allocated_family(::std::string* family) {
  if (family_ != &::google::protobuf::internal::kEmptyString) {
    delete family_;
  }
  if (family) {
    set_has_family();
    family_ = family;
  } else {
    clear_has_family();
    family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 offline_time = 6;
inline bool user_info::has_offline_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void user_info::set_has_offline_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void user_info::clear_has_offline_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void user_info::clear_offline_time() {
  offline_time_ = 0u;
  clear_has_offline_time();
}
inline ::google::protobuf::uint32 user_info::offline_time() const {
  return offline_time_;
}
inline void user_info::set_offline_time(::google::protobuf::uint32 value) {
  set_has_offline_time();
  offline_time_ = value;
}

// optional uint32 fighting = 7;
inline bool user_info::has_fighting() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void user_info::set_has_fighting() {
  _has_bits_[0] |= 0x00000040u;
}
inline void user_info::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void user_info::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 user_info::fighting() const {
  return fighting_;
}
inline void user_info::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 plugin = 8;
inline bool user_info::has_plugin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void user_info::set_has_plugin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void user_info::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void user_info::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 user_info::plugin() const {
  return plugin_;
}
inline void user_info::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 charm = 9;
inline bool user_info::has_charm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void user_info::set_has_charm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void user_info::clear_has_charm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void user_info::clear_charm() {
  charm_ = 0u;
  clear_has_charm();
}
inline ::google::protobuf::uint32 user_info::charm() const {
  return charm_;
}
inline void user_info::set_charm(::google::protobuf::uint32 value) {
  set_has_charm();
  charm_ = value;
}

// -------------------------------------------------------------------

// luck_gift_info

// optional uint32 luck_gift_uid = 1;
inline bool luck_gift_info::has_luck_gift_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void luck_gift_info::set_has_luck_gift_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void luck_gift_info::clear_has_luck_gift_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void luck_gift_info::clear_luck_gift_uid() {
  luck_gift_uid_ = 0u;
  clear_has_luck_gift_uid();
}
inline ::google::protobuf::uint32 luck_gift_info::luck_gift_uid() const {
  return luck_gift_uid_;
}
inline void luck_gift_info::set_luck_gift_uid(::google::protobuf::uint32 value) {
  set_has_luck_gift_uid();
  luck_gift_uid_ = value;
}

// optional string src_role_uid = 2;
inline bool luck_gift_info::has_src_role_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luck_gift_info::set_has_src_role_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luck_gift_info::clear_has_src_role_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luck_gift_info::clear_src_role_uid() {
  if (src_role_uid_ != &::google::protobuf::internal::kEmptyString) {
    src_role_uid_->clear();
  }
  clear_has_src_role_uid();
}
inline const ::std::string& luck_gift_info::src_role_uid() const {
  return *src_role_uid_;
}
inline void luck_gift_info::set_src_role_uid(const ::std::string& value) {
  set_has_src_role_uid();
  if (src_role_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_role_uid_ = new ::std::string;
  }
  src_role_uid_->assign(value);
}
inline void luck_gift_info::set_src_role_uid(const char* value) {
  set_has_src_role_uid();
  if (src_role_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_role_uid_ = new ::std::string;
  }
  src_role_uid_->assign(value);
}
inline void luck_gift_info::set_src_role_uid(const char* value, size_t size) {
  set_has_src_role_uid();
  if (src_role_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_role_uid_ = new ::std::string;
  }
  src_role_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* luck_gift_info::mutable_src_role_uid() {
  set_has_src_role_uid();
  if (src_role_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_role_uid_ = new ::std::string;
  }
  return src_role_uid_;
}
inline ::std::string* luck_gift_info::release_src_role_uid() {
  clear_has_src_role_uid();
  if (src_role_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_role_uid_;
    src_role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void luck_gift_info::set_allocated_src_role_uid(::std::string* src_role_uid) {
  if (src_role_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete src_role_uid_;
  }
  if (src_role_uid) {
    set_has_src_role_uid();
    src_role_uid_ = src_role_uid;
  } else {
    clear_has_src_role_uid();
    src_role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string src_role_name = 3;
inline bool luck_gift_info::has_src_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void luck_gift_info::set_has_src_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void luck_gift_info::clear_has_src_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void luck_gift_info::clear_src_role_name() {
  if (src_role_name_ != &::google::protobuf::internal::kEmptyString) {
    src_role_name_->clear();
  }
  clear_has_src_role_name();
}
inline const ::std::string& luck_gift_info::src_role_name() const {
  return *src_role_name_;
}
inline void luck_gift_info::set_src_role_name(const ::std::string& value) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(value);
}
inline void luck_gift_info::set_src_role_name(const char* value) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(value);
}
inline void luck_gift_info::set_src_role_name(const char* value, size_t size) {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  src_role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* luck_gift_info::mutable_src_role_name() {
  set_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    src_role_name_ = new ::std::string;
  }
  return src_role_name_;
}
inline ::std::string* luck_gift_info::release_src_role_name() {
  clear_has_src_role_name();
  if (src_role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_role_name_;
    src_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void luck_gift_info::set_allocated_src_role_name(::std::string* src_role_name) {
  if (src_role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete src_role_name_;
  }
  if (src_role_name) {
    set_has_src_role_name();
    src_role_name_ = src_role_name;
  } else {
    clear_has_src_role_name();
    src_role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gift_single

// optional string uid = 1;
inline bool gift_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gift_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gift_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gift_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& gift_single::uid() const {
  return *uid_;
}
inline void gift_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void gift_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void gift_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gift_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* gift_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gift_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool gift_single::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gift_single::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gift_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gift_single::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& gift_single::name() const {
  return *name_;
}
inline void gift_single::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void gift_single::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void gift_single::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gift_single::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* gift_single::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gift_single::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 value = 3;
inline bool gift_single::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gift_single::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gift_single::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gift_single::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 gift_single::value() const {
  return value_;
}
inline void gift_single::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// gift_data

// optional string src_uid = 1;
inline bool gift_data::has_src_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gift_data::set_has_src_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gift_data::clear_has_src_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gift_data::clear_src_uid() {
  if (src_uid_ != &::google::protobuf::internal::kEmptyString) {
    src_uid_->clear();
  }
  clear_has_src_uid();
}
inline const ::std::string& gift_data::src_uid() const {
  return *src_uid_;
}
inline void gift_data::set_src_uid(const ::std::string& value) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(value);
}
inline void gift_data::set_src_uid(const char* value) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(value);
}
inline void gift_data::set_src_uid(const char* value, size_t size) {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  src_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gift_data::mutable_src_uid() {
  set_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    src_uid_ = new ::std::string;
  }
  return src_uid_;
}
inline ::std::string* gift_data::release_src_uid() {
  clear_has_src_uid();
  if (src_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_uid_;
    src_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gift_data::set_allocated_src_uid(::std::string* src_uid) {
  if (src_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete src_uid_;
  }
  if (src_uid) {
    set_has_src_uid();
    src_uid_ = src_uid;
  } else {
    clear_has_src_uid();
    src_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string src_name = 2;
inline bool gift_data::has_src_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gift_data::set_has_src_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gift_data::clear_has_src_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gift_data::clear_src_name() {
  if (src_name_ != &::google::protobuf::internal::kEmptyString) {
    src_name_->clear();
  }
  clear_has_src_name();
}
inline const ::std::string& gift_data::src_name() const {
  return *src_name_;
}
inline void gift_data::set_src_name(const ::std::string& value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
}
inline void gift_data::set_src_name(const char* value) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(value);
}
inline void gift_data::set_src_name(const char* value, size_t size) {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  src_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gift_data::mutable_src_name() {
  set_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    src_name_ = new ::std::string;
  }
  return src_name_;
}
inline ::std::string* gift_data::release_src_name() {
  clear_has_src_name();
  if (src_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_name_;
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gift_data::set_allocated_src_name(::std::string* src_name) {
  if (src_name_ != &::google::protobuf::internal::kEmptyString) {
    delete src_name_;
  }
  if (src_name) {
    set_has_src_name();
    src_name_ = src_name;
  } else {
    clear_has_src_name();
    src_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gift_count = 3;
inline bool gift_data::has_gift_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gift_data::set_has_gift_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gift_data::clear_has_gift_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gift_data::clear_gift_count() {
  gift_count_ = 0u;
  clear_has_gift_count();
}
inline ::google::protobuf::uint32 gift_data::gift_count() const {
  return gift_count_;
}
inline void gift_data::set_gift_count(::google::protobuf::uint32 value) {
  set_has_gift_count();
  gift_count_ = value;
}

// optional uint32 gift_value = 4;
inline bool gift_data::has_gift_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gift_data::set_has_gift_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gift_data::clear_has_gift_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gift_data::clear_gift_value() {
  gift_value_ = 0u;
  clear_has_gift_value();
}
inline ::google::protobuf::uint32 gift_data::gift_value() const {
  return gift_value_;
}
inline void gift_data::set_gift_value(::google::protobuf::uint32 value) {
  set_has_gift_value();
  gift_value_ = value;
}

// optional uint32 finish_time = 5;
inline bool gift_data::has_finish_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gift_data::set_has_finish_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gift_data::clear_has_finish_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gift_data::clear_finish_time() {
  finish_time_ = 0u;
  clear_has_finish_time();
}
inline ::google::protobuf::uint32 gift_data::finish_time() const {
  return finish_time_;
}
inline void gift_data::set_finish_time(::google::protobuf::uint32 value) {
  set_has_finish_time();
  finish_time_ = value;
}

// repeated .proto.common.gift_single gift_single = 6;
inline int gift_data::gift_single_size() const {
  return gift_single_.size();
}
inline void gift_data::clear_gift_single() {
  gift_single_.Clear();
}
inline const ::proto::common::gift_single& gift_data::gift_single(int index) const {
  return gift_single_.Get(index);
}
inline ::proto::common::gift_single* gift_data::mutable_gift_single(int index) {
  return gift_single_.Mutable(index);
}
inline ::proto::common::gift_single* gift_data::add_gift_single() {
  return gift_single_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::gift_single >&
gift_data::gift_single() const {
  return gift_single_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::gift_single >*
gift_data::mutable_gift_single() {
  return &gift_single_;
}

// -------------------------------------------------------------------

// activity_single

// optional uint32 activity_id = 1;
inline bool activity_single::has_activity_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_single::set_has_activity_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_single::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_single::clear_activity_id() {
  activity_id_ = 0u;
  clear_has_activity_id();
}
inline ::google::protobuf::uint32 activity_single::activity_id() const {
  return activity_id_;
}
inline void activity_single::set_activity_id(::google::protobuf::uint32 value) {
  set_has_activity_id();
  activity_id_ = value;
}

// optional uint32 count = 2;
inline bool activity_single::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_single::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 activity_single::count() const {
  return count_;
}
inline void activity_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 last_reset_time = 3;
inline bool activity_single::has_last_reset_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void activity_single::set_has_last_reset_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void activity_single::clear_has_last_reset_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void activity_single::clear_last_reset_time() {
  last_reset_time_ = 0u;
  clear_has_last_reset_time();
}
inline ::google::protobuf::uint32 activity_single::last_reset_time() const {
  return last_reset_time_;
}
inline void activity_single::set_last_reset_time(::google::protobuf::uint32 value) {
  set_has_last_reset_time();
  last_reset_time_ = value;
}

// optional uint32 add_count = 4;
inline bool activity_single::has_add_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void activity_single::set_has_add_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void activity_single::clear_has_add_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void activity_single::clear_add_count() {
  add_count_ = 0u;
  clear_has_add_count();
}
inline ::google::protobuf::uint32 activity_single::add_count() const {
  return add_count_;
}
inline void activity_single::set_add_count(::google::protobuf::uint32 value) {
  set_has_add_count();
  add_count_ = value;
}

// -------------------------------------------------------------------

// liveness_box

// optional uint32 liveness = 1;
inline bool liveness_box::has_liveness() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void liveness_box::set_has_liveness() {
  _has_bits_[0] |= 0x00000001u;
}
inline void liveness_box::clear_has_liveness() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void liveness_box::clear_liveness() {
  liveness_ = 0u;
  clear_has_liveness();
}
inline ::google::protobuf::uint32 liveness_box::liveness() const {
  return liveness_;
}
inline void liveness_box::set_liveness(::google::protobuf::uint32 value) {
  set_has_liveness();
  liveness_ = value;
}

// optional uint32 state = 2;
inline bool liveness_box::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void liveness_box::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void liveness_box::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void liveness_box::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 liveness_box::state() const {
  return state_;
}
inline void liveness_box::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// activities_data

// optional uint32 liveness = 1;
inline bool activities_data::has_liveness() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activities_data::set_has_liveness() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activities_data::clear_has_liveness() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activities_data::clear_liveness() {
  liveness_ = 0u;
  clear_has_liveness();
}
inline ::google::protobuf::uint32 activities_data::liveness() const {
  return liveness_;
}
inline void activities_data::set_liveness(::google::protobuf::uint32 value) {
  set_has_liveness();
  liveness_ = value;
}

// repeated .proto.common.liveness_box box_list = 2;
inline int activities_data::box_list_size() const {
  return box_list_.size();
}
inline void activities_data::clear_box_list() {
  box_list_.Clear();
}
inline const ::proto::common::liveness_box& activities_data::box_list(int index) const {
  return box_list_.Get(index);
}
inline ::proto::common::liveness_box* activities_data::mutable_box_list(int index) {
  return box_list_.Mutable(index);
}
inline ::proto::common::liveness_box* activities_data::add_box_list() {
  return box_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
activities_data::box_list() const {
  return box_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
activities_data::mutable_box_list() {
  return &box_list_;
}

// repeated .proto.common.activity_single activity_data = 3;
inline int activities_data::activity_data_size() const {
  return activity_data_.size();
}
inline void activities_data::clear_activity_data() {
  activity_data_.Clear();
}
inline const ::proto::common::activity_single& activities_data::activity_data(int index) const {
  return activity_data_.Get(index);
}
inline ::proto::common::activity_single* activities_data::mutable_activity_data(int index) {
  return activity_data_.Mutable(index);
}
inline ::proto::common::activity_single* activities_data::add_activity_data() {
  return activity_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::activity_single >&
activities_data::activity_data() const {
  return activity_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::activity_single >*
activities_data::mutable_activity_data() {
  return &activity_data_;
}

// -------------------------------------------------------------------

// arena_role_rank_info

// optional string uid = 1;
inline bool arena_role_rank_info::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_role_rank_info::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_role_rank_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_role_rank_info::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& arena_role_rank_info::uid() const {
  return *uid_;
}
inline void arena_role_rank_info::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void arena_role_rank_info::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void arena_role_rank_info::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_role_rank_info::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* arena_role_rank_info::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_role_rank_info::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 score = 2;
inline bool arena_role_rank_info::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_role_rank_info::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_role_rank_info::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_role_rank_info::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 arena_role_rank_info::score() const {
  return score_;
}
inline void arena_role_rank_info::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 stage = 3;
inline bool arena_role_rank_info::has_stage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_role_rank_info::set_has_stage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_role_rank_info::clear_has_stage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_role_rank_info::clear_stage() {
  stage_ = 0u;
  clear_has_stage();
}
inline ::google::protobuf::uint32 arena_role_rank_info::stage() const {
  return stage_;
}
inline void arena_role_rank_info::set_stage(::google::protobuf::uint32 value) {
  set_has_stage();
  stage_ = value;
}

// optional uint32 time = 4;
inline bool arena_role_rank_info::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_role_rank_info::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_role_rank_info::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_role_rank_info::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 arena_role_rank_info::time() const {
  return time_;
}
inline void arena_role_rank_info::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 server_id = 5;
inline bool arena_role_rank_info::has_server_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void arena_role_rank_info::set_has_server_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void arena_role_rank_info::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void arena_role_rank_info::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 arena_role_rank_info::server_id() const {
  return server_id_;
}
inline void arena_role_rank_info::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional uint32 rank = 6;
inline bool arena_role_rank_info::has_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void arena_role_rank_info::set_has_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void arena_role_rank_info::clear_has_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void arena_role_rank_info::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 arena_role_rank_info::rank() const {
  return rank_;
}
inline void arena_role_rank_info::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// optional uint32 num = 7;
inline bool arena_role_rank_info::has_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void arena_role_rank_info::set_has_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void arena_role_rank_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void arena_role_rank_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 arena_role_rank_info::num() const {
  return num_;
}
inline void arena_role_rank_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional string name = 8;
inline bool arena_role_rank_info::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void arena_role_rank_info::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void arena_role_rank_info::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void arena_role_rank_info::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& arena_role_rank_info::name() const {
  return *name_;
}
inline void arena_role_rank_info::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void arena_role_rank_info::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void arena_role_rank_info::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_role_rank_info::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* arena_role_rank_info::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_role_rank_info::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.hero_data fight_heroes = 9;
inline bool arena_role_rank_info::has_fight_heroes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void arena_role_rank_info::set_has_fight_heroes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void arena_role_rank_info::clear_has_fight_heroes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void arena_role_rank_info::clear_fight_heroes() {
  if (fight_heroes_ != NULL) fight_heroes_->::proto::common::hero_data::Clear();
  clear_has_fight_heroes();
}
inline const ::proto::common::hero_data& arena_role_rank_info::fight_heroes() const {
  return fight_heroes_ != NULL ? *fight_heroes_ : *default_instance_->fight_heroes_;
}
inline ::proto::common::hero_data* arena_role_rank_info::mutable_fight_heroes() {
  set_has_fight_heroes();
  if (fight_heroes_ == NULL) fight_heroes_ = new ::proto::common::hero_data;
  return fight_heroes_;
}
inline ::proto::common::hero_data* arena_role_rank_info::release_fight_heroes() {
  clear_has_fight_heroes();
  ::proto::common::hero_data* temp = fight_heroes_;
  fight_heroes_ = NULL;
  return temp;
}
inline void arena_role_rank_info::set_allocated_fight_heroes(::proto::common::hero_data* fight_heroes) {
  delete fight_heroes_;
  fight_heroes_ = fight_heroes;
  if (fight_heroes) {
    set_has_fight_heroes();
  } else {
    clear_has_fight_heroes();
  }
}

// optional .proto.common.item_data hero_equips = 10;
inline bool arena_role_rank_info::has_hero_equips() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void arena_role_rank_info::set_has_hero_equips() {
  _has_bits_[0] |= 0x00000200u;
}
inline void arena_role_rank_info::clear_has_hero_equips() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void arena_role_rank_info::clear_hero_equips() {
  if (hero_equips_ != NULL) hero_equips_->::proto::common::item_data::Clear();
  clear_has_hero_equips();
}
inline const ::proto::common::item_data& arena_role_rank_info::hero_equips() const {
  return hero_equips_ != NULL ? *hero_equips_ : *default_instance_->hero_equips_;
}
inline ::proto::common::item_data* arena_role_rank_info::mutable_hero_equips() {
  set_has_hero_equips();
  if (hero_equips_ == NULL) hero_equips_ = new ::proto::common::item_data;
  return hero_equips_;
}
inline ::proto::common::item_data* arena_role_rank_info::release_hero_equips() {
  clear_has_hero_equips();
  ::proto::common::item_data* temp = hero_equips_;
  hero_equips_ = NULL;
  return temp;
}
inline void arena_role_rank_info::set_allocated_hero_equips(::proto::common::item_data* hero_equips) {
  delete hero_equips_;
  hero_equips_ = hero_equips;
  if (hero_equips) {
    set_has_hero_equips();
  } else {
    clear_has_hero_equips();
  }
}

// optional uint32 fighting_value = 11;
inline bool arena_role_rank_info::has_fighting_value() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void arena_role_rank_info::set_has_fighting_value() {
  _has_bits_[0] |= 0x00000400u;
}
inline void arena_role_rank_info::clear_has_fighting_value() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void arena_role_rank_info::clear_fighting_value() {
  fighting_value_ = 0u;
  clear_has_fighting_value();
}
inline ::google::protobuf::uint32 arena_role_rank_info::fighting_value() const {
  return fighting_value_;
}
inline void arena_role_rank_info::set_fighting_value(::google::protobuf::uint32 value) {
  set_has_fighting_value();
  fighting_value_ = value;
}

// optional string server_name = 12;
inline bool arena_role_rank_info::has_server_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void arena_role_rank_info::set_has_server_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void arena_role_rank_info::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void arena_role_rank_info::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& arena_role_rank_info::server_name() const {
  return *server_name_;
}
inline void arena_role_rank_info::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void arena_role_rank_info::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void arena_role_rank_info::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* arena_role_rank_info::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* arena_role_rank_info::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void arena_role_rank_info::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// arena_rank_info_array

// repeated .proto.common.arena_role_rank_info info_list = 1;
inline int arena_rank_info_array::info_list_size() const {
  return info_list_.size();
}
inline void arena_rank_info_array::clear_info_list() {
  info_list_.Clear();
}
inline const ::proto::common::arena_role_rank_info& arena_rank_info_array::info_list(int index) const {
  return info_list_.Get(index);
}
inline ::proto::common::arena_role_rank_info* arena_rank_info_array::mutable_info_list(int index) {
  return info_list_.Mutable(index);
}
inline ::proto::common::arena_role_rank_info* arena_rank_info_array::add_info_list() {
  return info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::arena_role_rank_info >&
arena_rank_info_array::info_list() const {
  return info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::arena_role_rank_info >*
arena_rank_info_array::mutable_info_list() {
  return &info_list_;
}

// -------------------------------------------------------------------

// arena_role_data

// optional uint32 win_times = 1;
inline bool arena_role_data::has_win_times() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_role_data::set_has_win_times() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_role_data::clear_has_win_times() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_role_data::clear_win_times() {
  win_times_ = 0u;
  clear_has_win_times();
}
inline ::google::protobuf::uint32 arena_role_data::win_times() const {
  return win_times_;
}
inline void arena_role_data::set_win_times(::google::protobuf::uint32 value) {
  set_has_win_times();
  win_times_ = value;
}

// optional uint32 lose_times = 2;
inline bool arena_role_data::has_lose_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_role_data::set_has_lose_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_role_data::clear_has_lose_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_role_data::clear_lose_times() {
  lose_times_ = 0u;
  clear_has_lose_times();
}
inline ::google::protobuf::uint32 arena_role_data::lose_times() const {
  return lose_times_;
}
inline void arena_role_data::set_lose_times(::google::protobuf::uint32 value) {
  set_has_lose_times();
  lose_times_ = value;
}

// optional uint32 is_start = 3;
inline bool arena_role_data::has_is_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_role_data::set_has_is_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_role_data::clear_has_is_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_role_data::clear_is_start() {
  is_start_ = 0u;
  clear_has_is_start();
}
inline ::google::protobuf::uint32 arena_role_data::is_start() const {
  return is_start_;
}
inline void arena_role_data::set_is_start(::google::protobuf::uint32 value) {
  set_has_is_start();
  is_start_ = value;
}

// optional uint32 score = 4;
inline bool arena_role_data::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void arena_role_data::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void arena_role_data::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void arena_role_data::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 arena_role_data::score() const {
  return score_;
}
inline void arena_role_data::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 arena_level = 5;
inline bool arena_role_data::has_arena_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void arena_role_data::set_has_arena_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void arena_role_data::clear_has_arena_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void arena_role_data::clear_arena_level() {
  arena_level_ = 0u;
  clear_has_arena_level();
}
inline ::google::protobuf::uint32 arena_role_data::arena_level() const {
  return arena_level_;
}
inline void arena_role_data::set_arena_level(::google::protobuf::uint32 value) {
  set_has_arena_level();
  arena_level_ = value;
}

// optional uint32 all_fight_times = 6;
inline bool arena_role_data::has_all_fight_times() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void arena_role_data::set_has_all_fight_times() {
  _has_bits_[0] |= 0x00000020u;
}
inline void arena_role_data::clear_has_all_fight_times() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void arena_role_data::clear_all_fight_times() {
  all_fight_times_ = 0u;
  clear_has_all_fight_times();
}
inline ::google::protobuf::uint32 arena_role_data::all_fight_times() const {
  return all_fight_times_;
}
inline void arena_role_data::set_all_fight_times(::google::protobuf::uint32 value) {
  set_has_all_fight_times();
  all_fight_times_ = value;
}

// optional uint32 all_win_times = 7;
inline bool arena_role_data::has_all_win_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void arena_role_data::set_has_all_win_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void arena_role_data::clear_has_all_win_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void arena_role_data::clear_all_win_times() {
  all_win_times_ = 0u;
  clear_has_all_win_times();
}
inline ::google::protobuf::uint32 arena_role_data::all_win_times() const {
  return all_win_times_;
}
inline void arena_role_data::set_all_win_times(::google::protobuf::uint32 value) {
  set_has_all_win_times();
  all_win_times_ = value;
}

// optional uint32 honor = 8;
inline bool arena_role_data::has_honor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void arena_role_data::set_has_honor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void arena_role_data::clear_has_honor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void arena_role_data::clear_honor() {
  honor_ = 0u;
  clear_has_honor();
}
inline ::google::protobuf::uint32 arena_role_data::honor() const {
  return honor_;
}
inline void arena_role_data::set_honor(::google::protobuf::uint32 value) {
  set_has_honor();
  honor_ = value;
}

// optional uint32 honor_limit = 9;
inline bool arena_role_data::has_honor_limit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void arena_role_data::set_has_honor_limit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void arena_role_data::clear_has_honor_limit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void arena_role_data::clear_honor_limit() {
  honor_limit_ = 0u;
  clear_has_honor_limit();
}
inline ::google::protobuf::uint32 arena_role_data::honor_limit() const {
  return honor_limit_;
}
inline void arena_role_data::set_honor_limit(::google::protobuf::uint32 value) {
  set_has_honor_limit();
  honor_limit_ = value;
}

// optional uint32 rank = 10;
inline bool arena_role_data::has_rank() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void arena_role_data::set_has_rank() {
  _has_bits_[0] |= 0x00000200u;
}
inline void arena_role_data::clear_has_rank() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void arena_role_data::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 arena_role_data::rank() const {
  return rank_;
}
inline void arena_role_data::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}

// optional uint32 best_win_times = 11;
inline bool arena_role_data::has_best_win_times() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void arena_role_data::set_has_best_win_times() {
  _has_bits_[0] |= 0x00000400u;
}
inline void arena_role_data::clear_has_best_win_times() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void arena_role_data::clear_best_win_times() {
  best_win_times_ = 0u;
  clear_has_best_win_times();
}
inline ::google::protobuf::uint32 arena_role_data::best_win_times() const {
  return best_win_times_;
}
inline void arena_role_data::set_best_win_times(::google::protobuf::uint32 value) {
  set_has_best_win_times();
  best_win_times_ = value;
}

// optional uint32 last_reset_time = 12;
inline bool arena_role_data::has_last_reset_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void arena_role_data::set_has_last_reset_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void arena_role_data::clear_has_last_reset_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void arena_role_data::clear_last_reset_time() {
  last_reset_time_ = 0u;
  clear_has_last_reset_time();
}
inline ::google::protobuf::uint32 arena_role_data::last_reset_time() const {
  return last_reset_time_;
}
inline void arena_role_data::set_last_reset_time(::google::protobuf::uint32 value) {
  set_has_last_reset_time();
  last_reset_time_ = value;
}

// -------------------------------------------------------------------

// treasure_single

// optional string uid = 1;
inline bool treasure_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void treasure_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void treasure_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void treasure_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& treasure_single::uid() const {
  return *uid_;
}
inline void treasure_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void treasure_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void treasure_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* treasure_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* treasure_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void treasure_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 item_tid = 2;
inline bool treasure_single::has_item_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void treasure_single::set_has_item_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void treasure_single::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void treasure_single::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 treasure_single::item_tid() const {
  return item_tid_;
}
inline void treasure_single::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// -------------------------------------------------------------------

// treasure_data

// repeated .proto.common.treasure_single treasure_list = 1;
inline int treasure_data::treasure_list_size() const {
  return treasure_list_.size();
}
inline void treasure_data::clear_treasure_list() {
  treasure_list_.Clear();
}
inline const ::proto::common::treasure_single& treasure_data::treasure_list(int index) const {
  return treasure_list_.Get(index);
}
inline ::proto::common::treasure_single* treasure_data::mutable_treasure_list(int index) {
  return treasure_list_.Mutable(index);
}
inline ::proto::common::treasure_single* treasure_data::add_treasure_list() {
  return treasure_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::treasure_single >&
treasure_data::treasure_list() const {
  return treasure_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::treasure_single >*
treasure_data::mutable_treasure_list() {
  return &treasure_list_;
}

// optional uint32 treasure_id = 2;
inline bool treasure_data::has_treasure_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void treasure_data::set_has_treasure_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void treasure_data::clear_has_treasure_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void treasure_data::clear_treasure_id() {
  treasure_id_ = 0u;
  clear_has_treasure_id();
}
inline ::google::protobuf::uint32 treasure_data::treasure_id() const {
  return treasure_id_;
}
inline void treasure_data::set_treasure_id(::google::protobuf::uint32 value) {
  set_has_treasure_id();
  treasure_id_ = value;
}

// -------------------------------------------------------------------

// sys_notice_data

// optional .proto.common.system_notice_type type = 1 [default = SYS_NOTICE_DEFAULT];
inline bool sys_notice_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_notice_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_notice_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_notice_data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::common::system_notice_type sys_notice_data::type() const {
  return static_cast< ::proto::common::system_notice_type >(type_);
}
inline void sys_notice_data::set_type(::proto::common::system_notice_type value) {
  assert(::proto::common::system_notice_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 priority = 2;
inline bool sys_notice_data::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_notice_data::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_notice_data::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_notice_data::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 sys_notice_data::priority() const {
  return priority_;
}
inline void sys_notice_data::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
}

// optional string text = 3;
inline bool sys_notice_data::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sys_notice_data::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sys_notice_data::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sys_notice_data::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& sys_notice_data::text() const {
  return *text_;
}
inline void sys_notice_data::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void sys_notice_data::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void sys_notice_data::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* sys_notice_data::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notice_data::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_id = 4;
inline bool sys_notice_data::has_role_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sys_notice_data::set_has_role_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sys_notice_data::clear_has_role_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sys_notice_data::clear_role_id() {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    role_id_->clear();
  }
  clear_has_role_id();
}
inline const ::std::string& sys_notice_data::role_id() const {
  return *role_id_;
}
inline void sys_notice_data::set_role_id(const ::std::string& value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void sys_notice_data::set_role_id(const char* value) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(value);
}
inline void sys_notice_data::set_role_id(const char* value, size_t size) {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  role_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::mutable_role_id() {
  set_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    role_id_ = new ::std::string;
  }
  return role_id_;
}
inline ::std::string* sys_notice_data::release_role_id() {
  clear_has_role_id();
  if (role_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_id_;
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notice_data::set_allocated_role_id(::std::string* role_id) {
  if (role_id_ != &::google::protobuf::internal::kEmptyString) {
    delete role_id_;
  }
  if (role_id) {
    set_has_role_id();
    role_id_ = role_id;
  } else {
    clear_has_role_id();
    role_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_id = 5;
inline bool sys_notice_data::has_family_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sys_notice_data::set_has_family_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sys_notice_data::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sys_notice_data::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& sys_notice_data::family_id() const {
  return *family_id_;
}
inline void sys_notice_data::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void sys_notice_data::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void sys_notice_data::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* sys_notice_data::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notice_data::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string country_id = 6;
inline bool sys_notice_data::has_country_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void sys_notice_data::set_has_country_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void sys_notice_data::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void sys_notice_data::clear_country_id() {
  if (country_id_ != &::google::protobuf::internal::kEmptyString) {
    country_id_->clear();
  }
  clear_has_country_id();
}
inline const ::std::string& sys_notice_data::country_id() const {
  return *country_id_;
}
inline void sys_notice_data::set_country_id(const ::std::string& value) {
  set_has_country_id();
  if (country_id_ == &::google::protobuf::internal::kEmptyString) {
    country_id_ = new ::std::string;
  }
  country_id_->assign(value);
}
inline void sys_notice_data::set_country_id(const char* value) {
  set_has_country_id();
  if (country_id_ == &::google::protobuf::internal::kEmptyString) {
    country_id_ = new ::std::string;
  }
  country_id_->assign(value);
}
inline void sys_notice_data::set_country_id(const char* value, size_t size) {
  set_has_country_id();
  if (country_id_ == &::google::protobuf::internal::kEmptyString) {
    country_id_ = new ::std::string;
  }
  country_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::mutable_country_id() {
  set_has_country_id();
  if (country_id_ == &::google::protobuf::internal::kEmptyString) {
    country_id_ = new ::std::string;
  }
  return country_id_;
}
inline ::std::string* sys_notice_data::release_country_id() {
  clear_has_country_id();
  if (country_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_id_;
    country_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notice_data::set_allocated_country_id(::std::string* country_id) {
  if (country_id_ != &::google::protobuf::internal::kEmptyString) {
    delete country_id_;
  }
  if (country_id) {
    set_has_country_id();
    country_id_ = country_id;
  } else {
    clear_has_country_id();
    country_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 label = 7;
inline bool sys_notice_data::has_label() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void sys_notice_data::set_has_label() {
  _has_bits_[0] |= 0x00000040u;
}
inline void sys_notice_data::clear_has_label() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void sys_notice_data::clear_label() {
  label_ = 0u;
  clear_has_label();
}
inline ::google::protobuf::uint32 sys_notice_data::label() const {
  return label_;
}
inline void sys_notice_data::set_label(::google::protobuf::uint32 value) {
  set_has_label();
  label_ = value;
}

// optional string default_text = 8;
inline bool sys_notice_data::has_default_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void sys_notice_data::set_has_default_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void sys_notice_data::clear_has_default_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void sys_notice_data::clear_default_text() {
  if (default_text_ != &::google::protobuf::internal::kEmptyString) {
    default_text_->clear();
  }
  clear_has_default_text();
}
inline const ::std::string& sys_notice_data::default_text() const {
  return *default_text_;
}
inline void sys_notice_data::set_default_text(const ::std::string& value) {
  set_has_default_text();
  if (default_text_ == &::google::protobuf::internal::kEmptyString) {
    default_text_ = new ::std::string;
  }
  default_text_->assign(value);
}
inline void sys_notice_data::set_default_text(const char* value) {
  set_has_default_text();
  if (default_text_ == &::google::protobuf::internal::kEmptyString) {
    default_text_ = new ::std::string;
  }
  default_text_->assign(value);
}
inline void sys_notice_data::set_default_text(const char* value, size_t size) {
  set_has_default_text();
  if (default_text_ == &::google::protobuf::internal::kEmptyString) {
    default_text_ = new ::std::string;
  }
  default_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::mutable_default_text() {
  set_has_default_text();
  if (default_text_ == &::google::protobuf::internal::kEmptyString) {
    default_text_ = new ::std::string;
  }
  return default_text_;
}
inline ::std::string* sys_notice_data::release_default_text() {
  clear_has_default_text();
  if (default_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_text_;
    default_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notice_data::set_allocated_default_text(::std::string* default_text) {
  if (default_text_ != &::google::protobuf::internal::kEmptyString) {
    delete default_text_;
  }
  if (default_text) {
    set_has_default_text();
    default_text_ = default_text;
  } else {
    clear_has_default_text();
    default_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 table_type_id = 9;
inline bool sys_notice_data::has_table_type_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void sys_notice_data::set_has_table_type_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void sys_notice_data::clear_has_table_type_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void sys_notice_data::clear_table_type_id() {
  table_type_id_ = 0u;
  clear_has_table_type_id();
}
inline ::google::protobuf::uint32 sys_notice_data::table_type_id() const {
  return table_type_id_;
}
inline void sys_notice_data::set_table_type_id(::google::protobuf::uint32 value) {
  set_has_table_type_id();
  table_type_id_ = value;
}

// optional uint32 param = 10;
inline bool sys_notice_data::has_param() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void sys_notice_data::set_has_param() {
  _has_bits_[0] |= 0x00000200u;
}
inline void sys_notice_data::clear_has_param() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void sys_notice_data::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 sys_notice_data::param() const {
  return param_;
}
inline void sys_notice_data::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// repeated string param_str_list = 11;
inline int sys_notice_data::param_str_list_size() const {
  return param_str_list_.size();
}
inline void sys_notice_data::clear_param_str_list() {
  param_str_list_.Clear();
}
inline const ::std::string& sys_notice_data::param_str_list(int index) const {
  return param_str_list_.Get(index);
}
inline ::std::string* sys_notice_data::mutable_param_str_list(int index) {
  return param_str_list_.Mutable(index);
}
inline void sys_notice_data::set_param_str_list(int index, const ::std::string& value) {
  param_str_list_.Mutable(index)->assign(value);
}
inline void sys_notice_data::set_param_str_list(int index, const char* value) {
  param_str_list_.Mutable(index)->assign(value);
}
inline void sys_notice_data::set_param_str_list(int index, const char* value, size_t size) {
  param_str_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notice_data::add_param_str_list() {
  return param_str_list_.Add();
}
inline void sys_notice_data::add_param_str_list(const ::std::string& value) {
  param_str_list_.Add()->assign(value);
}
inline void sys_notice_data::add_param_str_list(const char* value) {
  param_str_list_.Add()->assign(value);
}
inline void sys_notice_data::add_param_str_list(const char* value, size_t size) {
  param_str_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
sys_notice_data::param_str_list() const {
  return param_str_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
sys_notice_data::mutable_param_str_list() {
  return &param_str_list_;
}

// -------------------------------------------------------------------

// shop_goods

// optional uint32 goods_id = 1;
inline bool shop_goods::has_goods_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void shop_goods::set_has_goods_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void shop_goods::clear_has_goods_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void shop_goods::clear_goods_id() {
  goods_id_ = 0u;
  clear_has_goods_id();
}
inline ::google::protobuf::uint32 shop_goods::goods_id() const {
  return goods_id_;
}
inline void shop_goods::set_goods_id(::google::protobuf::uint32 value) {
  set_has_goods_id();
  goods_id_ = value;
}

// optional uint32 buy_count = 2;
inline bool shop_goods::has_buy_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void shop_goods::set_has_buy_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void shop_goods::clear_has_buy_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void shop_goods::clear_buy_count() {
  buy_count_ = 0u;
  clear_has_buy_count();
}
inline ::google::protobuf::uint32 shop_goods::buy_count() const {
  return buy_count_;
}
inline void shop_goods::set_buy_count(::google::protobuf::uint32 value) {
  set_has_buy_count();
  buy_count_ = value;
}

// optional uint32 start_time = 3;
inline bool shop_goods::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void shop_goods::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void shop_goods::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void shop_goods::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 shop_goods::start_time() const {
  return start_time_;
}
inline void shop_goods::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 end_time = 4;
inline bool shop_goods::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void shop_goods::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void shop_goods::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void shop_goods::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 shop_goods::end_time() const {
  return end_time_;
}
inline void shop_goods::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional uint32 last_refresh_time = 5;
inline bool shop_goods::has_last_refresh_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void shop_goods::set_has_last_refresh_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void shop_goods::clear_has_last_refresh_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void shop_goods::clear_last_refresh_time() {
  last_refresh_time_ = 0u;
  clear_has_last_refresh_time();
}
inline ::google::protobuf::uint32 shop_goods::last_refresh_time() const {
  return last_refresh_time_;
}
inline void shop_goods::set_last_refresh_time(::google::protobuf::uint32 value) {
  set_has_last_refresh_time();
  last_refresh_time_ = value;
}

// -------------------------------------------------------------------

// shop_goods_list

// repeated .proto.common.shop_goods goods_list = 1;
inline int shop_goods_list::goods_list_size() const {
  return goods_list_.size();
}
inline void shop_goods_list::clear_goods_list() {
  goods_list_.Clear();
}
inline const ::proto::common::shop_goods& shop_goods_list::goods_list(int index) const {
  return goods_list_.Get(index);
}
inline ::proto::common::shop_goods* shop_goods_list::mutable_goods_list(int index) {
  return goods_list_.Mutable(index);
}
inline ::proto::common::shop_goods* shop_goods_list::add_goods_list() {
  return goods_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::shop_goods >&
shop_goods_list::goods_list() const {
  return goods_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::shop_goods >*
shop_goods_list::mutable_goods_list() {
  return &goods_list_;
}

// -------------------------------------------------------------------

// user_goods

// optional uint32 goods_id = 1;
inline bool user_goods::has_goods_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_goods::set_has_goods_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_goods::clear_has_goods_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_goods::clear_goods_id() {
  goods_id_ = 0u;
  clear_has_goods_id();
}
inline ::google::protobuf::uint32 user_goods::goods_id() const {
  return goods_id_;
}
inline void user_goods::set_goods_id(::google::protobuf::uint32 value) {
  set_has_goods_id();
  goods_id_ = value;
}

// optional uint32 buy_count = 2;
inline bool user_goods::has_buy_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_goods::set_has_buy_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_goods::clear_has_buy_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_goods::clear_buy_count() {
  buy_count_ = 0u;
  clear_has_buy_count();
}
inline ::google::protobuf::uint32 user_goods::buy_count() const {
  return buy_count_;
}
inline void user_goods::set_buy_count(::google::protobuf::uint32 value) {
  set_has_buy_count();
  buy_count_ = value;
}

// optional uint32 last_refresh_time = 3;
inline bool user_goods::has_last_refresh_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void user_goods::set_has_last_refresh_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void user_goods::clear_has_last_refresh_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void user_goods::clear_last_refresh_time() {
  last_refresh_time_ = 0u;
  clear_has_last_refresh_time();
}
inline ::google::protobuf::uint32 user_goods::last_refresh_time() const {
  return last_refresh_time_;
}
inline void user_goods::set_last_refresh_time(::google::protobuf::uint32 value) {
  set_has_last_refresh_time();
  last_refresh_time_ = value;
}

// -------------------------------------------------------------------

// user_goods_list

// repeated .proto.common.user_goods goods_list = 1;
inline int user_goods_list::goods_list_size() const {
  return goods_list_.size();
}
inline void user_goods_list::clear_goods_list() {
  goods_list_.Clear();
}
inline const ::proto::common::user_goods& user_goods_list::goods_list(int index) const {
  return goods_list_.Get(index);
}
inline ::proto::common::user_goods* user_goods_list::mutable_goods_list(int index) {
  return goods_list_.Mutable(index);
}
inline ::proto::common::user_goods* user_goods_list::add_goods_list() {
  return goods_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::user_goods >&
user_goods_list::goods_list() const {
  return goods_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::user_goods >*
user_goods_list::mutable_goods_list() {
  return &goods_list_;
}

// -------------------------------------------------------------------

// user_buy_goods

// optional uint32 goods_id = 1;
inline bool user_buy_goods::has_goods_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void user_buy_goods::set_has_goods_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void user_buy_goods::clear_has_goods_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void user_buy_goods::clear_goods_id() {
  goods_id_ = 0u;
  clear_has_goods_id();
}
inline ::google::protobuf::uint32 user_buy_goods::goods_id() const {
  return goods_id_;
}
inline void user_buy_goods::set_goods_id(::google::protobuf::uint32 value) {
  set_has_goods_id();
  goods_id_ = value;
}

// optional uint32 goods_num = 2;
inline bool user_buy_goods::has_goods_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void user_buy_goods::set_has_goods_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void user_buy_goods::clear_has_goods_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void user_buy_goods::clear_goods_num() {
  goods_num_ = 0u;
  clear_has_goods_num();
}
inline ::google::protobuf::uint32 user_buy_goods::goods_num() const {
  return goods_num_;
}
inline void user_buy_goods::set_goods_num(::google::protobuf::uint32 value) {
  set_has_goods_num();
  goods_num_ = value;
}

// -------------------------------------------------------------------

// challenge_info

// optional string challenge_uid = 1;
inline bool challenge_info::has_challenge_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void challenge_info::set_has_challenge_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void challenge_info::clear_has_challenge_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void challenge_info::clear_challenge_uid() {
  if (challenge_uid_ != &::google::protobuf::internal::kEmptyString) {
    challenge_uid_->clear();
  }
  clear_has_challenge_uid();
}
inline const ::std::string& challenge_info::challenge_uid() const {
  return *challenge_uid_;
}
inline void challenge_info::set_challenge_uid(const ::std::string& value) {
  set_has_challenge_uid();
  if (challenge_uid_ == &::google::protobuf::internal::kEmptyString) {
    challenge_uid_ = new ::std::string;
  }
  challenge_uid_->assign(value);
}
inline void challenge_info::set_challenge_uid(const char* value) {
  set_has_challenge_uid();
  if (challenge_uid_ == &::google::protobuf::internal::kEmptyString) {
    challenge_uid_ = new ::std::string;
  }
  challenge_uid_->assign(value);
}
inline void challenge_info::set_challenge_uid(const char* value, size_t size) {
  set_has_challenge_uid();
  if (challenge_uid_ == &::google::protobuf::internal::kEmptyString) {
    challenge_uid_ = new ::std::string;
  }
  challenge_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* challenge_info::mutable_challenge_uid() {
  set_has_challenge_uid();
  if (challenge_uid_ == &::google::protobuf::internal::kEmptyString) {
    challenge_uid_ = new ::std::string;
  }
  return challenge_uid_;
}
inline ::std::string* challenge_info::release_challenge_uid() {
  clear_has_challenge_uid();
  if (challenge_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_uid_;
    challenge_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void challenge_info::set_allocated_challenge_uid(::std::string* challenge_uid) {
  if (challenge_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_uid_;
  }
  if (challenge_uid) {
    set_has_challenge_uid();
    challenge_uid_ = challenge_uid;
  } else {
    clear_has_challenge_uid();
    challenge_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string challenger_name = 2;
inline bool challenge_info::has_challenger_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void challenge_info::set_has_challenger_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void challenge_info::clear_has_challenger_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void challenge_info::clear_challenger_name() {
  if (challenger_name_ != &::google::protobuf::internal::kEmptyString) {
    challenger_name_->clear();
  }
  clear_has_challenger_name();
}
inline const ::std::string& challenge_info::challenger_name() const {
  return *challenger_name_;
}
inline void challenge_info::set_challenger_name(const ::std::string& value) {
  set_has_challenger_name();
  if (challenger_name_ == &::google::protobuf::internal::kEmptyString) {
    challenger_name_ = new ::std::string;
  }
  challenger_name_->assign(value);
}
inline void challenge_info::set_challenger_name(const char* value) {
  set_has_challenger_name();
  if (challenger_name_ == &::google::protobuf::internal::kEmptyString) {
    challenger_name_ = new ::std::string;
  }
  challenger_name_->assign(value);
}
inline void challenge_info::set_challenger_name(const char* value, size_t size) {
  set_has_challenger_name();
  if (challenger_name_ == &::google::protobuf::internal::kEmptyString) {
    challenger_name_ = new ::std::string;
  }
  challenger_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* challenge_info::mutable_challenger_name() {
  set_has_challenger_name();
  if (challenger_name_ == &::google::protobuf::internal::kEmptyString) {
    challenger_name_ = new ::std::string;
  }
  return challenger_name_;
}
inline ::std::string* challenge_info::release_challenger_name() {
  clear_has_challenger_name();
  if (challenger_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenger_name_;
    challenger_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void challenge_info::set_allocated_challenger_name(::std::string* challenger_name) {
  if (challenger_name_ != &::google::protobuf::internal::kEmptyString) {
    delete challenger_name_;
  }
  if (challenger_name) {
    set_has_challenger_name();
    challenger_name_ = challenger_name;
  } else {
    clear_has_challenger_name();
    challenger_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string target_name = 3;
inline bool challenge_info::has_target_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void challenge_info::set_has_target_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void challenge_info::clear_has_target_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void challenge_info::clear_target_name() {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    target_name_->clear();
  }
  clear_has_target_name();
}
inline const ::std::string& challenge_info::target_name() const {
  return *target_name_;
}
inline void challenge_info::set_target_name(const ::std::string& value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void challenge_info::set_target_name(const char* value) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(value);
}
inline void challenge_info::set_target_name(const char* value, size_t size) {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  target_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* challenge_info::mutable_target_name() {
  set_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    target_name_ = new ::std::string;
  }
  return target_name_;
}
inline ::std::string* challenge_info::release_target_name() {
  clear_has_target_name();
  if (target_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_name_;
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void challenge_info::set_allocated_target_name(::std::string* target_name) {
  if (target_name_ != &::google::protobuf::internal::kEmptyString) {
    delete target_name_;
  }
  if (target_name) {
    set_has_target_name();
    target_name_ = target_name;
  } else {
    clear_has_target_name();
    target_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string challenge_time = 4;
inline bool challenge_info::has_challenge_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void challenge_info::set_has_challenge_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void challenge_info::clear_has_challenge_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void challenge_info::clear_challenge_time() {
  if (challenge_time_ != &::google::protobuf::internal::kEmptyString) {
    challenge_time_->clear();
  }
  clear_has_challenge_time();
}
inline const ::std::string& challenge_info::challenge_time() const {
  return *challenge_time_;
}
inline void challenge_info::set_challenge_time(const ::std::string& value) {
  set_has_challenge_time();
  if (challenge_time_ == &::google::protobuf::internal::kEmptyString) {
    challenge_time_ = new ::std::string;
  }
  challenge_time_->assign(value);
}
inline void challenge_info::set_challenge_time(const char* value) {
  set_has_challenge_time();
  if (challenge_time_ == &::google::protobuf::internal::kEmptyString) {
    challenge_time_ = new ::std::string;
  }
  challenge_time_->assign(value);
}
inline void challenge_info::set_challenge_time(const char* value, size_t size) {
  set_has_challenge_time();
  if (challenge_time_ == &::google::protobuf::internal::kEmptyString) {
    challenge_time_ = new ::std::string;
  }
  challenge_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* challenge_info::mutable_challenge_time() {
  set_has_challenge_time();
  if (challenge_time_ == &::google::protobuf::internal::kEmptyString) {
    challenge_time_ = new ::std::string;
  }
  return challenge_time_;
}
inline ::std::string* challenge_info::release_challenge_time() {
  clear_has_challenge_time();
  if (challenge_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_time_;
    challenge_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void challenge_info::set_allocated_challenge_time(::std::string* challenge_time) {
  if (challenge_time_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_time_;
  }
  if (challenge_time) {
    set_has_challenge_time();
    challenge_time_ = challenge_time;
  } else {
    clear_has_challenge_time();
    challenge_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 result = 5;
inline bool challenge_info::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void challenge_info::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void challenge_info::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void challenge_info::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 challenge_info::result() const {
  return result_;
}
inline void challenge_info::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// troop_formation_pair

// optional uint32 pos = 1;
inline bool troop_formation_pair::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void troop_formation_pair::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void troop_formation_pair::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void troop_formation_pair::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 troop_formation_pair::pos() const {
  return pos_;
}
inline void troop_formation_pair::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string unique_id = 2;
inline bool troop_formation_pair::has_unique_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void troop_formation_pair::set_has_unique_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void troop_formation_pair::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void troop_formation_pair::clear_unique_id() {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    unique_id_->clear();
  }
  clear_has_unique_id();
}
inline const ::std::string& troop_formation_pair::unique_id() const {
  return *unique_id_;
}
inline void troop_formation_pair::set_unique_id(const ::std::string& value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void troop_formation_pair::set_unique_id(const char* value) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(value);
}
inline void troop_formation_pair::set_unique_id(const char* value, size_t size) {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  unique_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* troop_formation_pair::mutable_unique_id() {
  set_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    unique_id_ = new ::std::string;
  }
  return unique_id_;
}
inline ::std::string* troop_formation_pair::release_unique_id() {
  clear_has_unique_id();
  if (unique_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unique_id_;
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void troop_formation_pair::set_allocated_unique_id(::std::string* unique_id) {
  if (unique_id_ != &::google::protobuf::internal::kEmptyString) {
    delete unique_id_;
  }
  if (unique_id) {
    set_has_unique_id();
    unique_id_ = unique_id;
  } else {
    clear_has_unique_id();
    unique_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string owner_id = 3;
inline bool troop_formation_pair::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void troop_formation_pair::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void troop_formation_pair::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void troop_formation_pair::clear_owner_id() {
  if (owner_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_id_->clear();
  }
  clear_has_owner_id();
}
inline const ::std::string& troop_formation_pair::owner_id() const {
  return *owner_id_;
}
inline void troop_formation_pair::set_owner_id(const ::std::string& value) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(value);
}
inline void troop_formation_pair::set_owner_id(const char* value) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(value);
}
inline void troop_formation_pair::set_owner_id(const char* value, size_t size) {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  owner_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* troop_formation_pair::mutable_owner_id() {
  set_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_id_ = new ::std::string;
  }
  return owner_id_;
}
inline ::std::string* troop_formation_pair::release_owner_id() {
  clear_has_owner_id();
  if (owner_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_id_;
    owner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void troop_formation_pair::set_allocated_owner_id(::std::string* owner_id) {
  if (owner_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_id_;
  }
  if (owner_id) {
    set_has_owner_id();
    owner_id_ = owner_id;
  } else {
    clear_has_owner_id();
    owner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// troop_formation

// optional uint32 tactic_id = 1;
inline bool troop_formation::has_tactic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void troop_formation::set_has_tactic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void troop_formation::clear_has_tactic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void troop_formation::clear_tactic_id() {
  tactic_id_ = 0u;
  clear_has_tactic_id();
}
inline ::google::protobuf::uint32 troop_formation::tactic_id() const {
  return tactic_id_;
}
inline void troop_formation::set_tactic_id(::google::protobuf::uint32 value) {
  set_has_tactic_id();
  tactic_id_ = value;
}

// repeated .proto.common.troop_formation_pair formations = 2;
inline int troop_formation::formations_size() const {
  return formations_.size();
}
inline void troop_formation::clear_formations() {
  formations_.Clear();
}
inline const ::proto::common::troop_formation_pair& troop_formation::formations(int index) const {
  return formations_.Get(index);
}
inline ::proto::common::troop_formation_pair* troop_formation::mutable_formations(int index) {
  return formations_.Mutable(index);
}
inline ::proto::common::troop_formation_pair* troop_formation::add_formations() {
  return formations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::troop_formation_pair >&
troop_formation::formations() const {
  return formations_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::troop_formation_pair >*
troop_formation::mutable_formations() {
  return &formations_;
}

// -------------------------------------------------------------------

// king_war_country_sign_up_single

// optional .proto.common.country_base_data country_base = 1;
inline bool king_war_country_sign_up_single::has_country_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_country_sign_up_single::set_has_country_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_country_sign_up_single::clear_has_country_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_country_sign_up_single::clear_country_base() {
  if (country_base_ != NULL) country_base_->::proto::common::country_base_data::Clear();
  clear_has_country_base();
}
inline const ::proto::common::country_base_data& king_war_country_sign_up_single::country_base() const {
  return country_base_ != NULL ? *country_base_ : *default_instance_->country_base_;
}
inline ::proto::common::country_base_data* king_war_country_sign_up_single::mutable_country_base() {
  set_has_country_base();
  if (country_base_ == NULL) country_base_ = new ::proto::common::country_base_data;
  return country_base_;
}
inline ::proto::common::country_base_data* king_war_country_sign_up_single::release_country_base() {
  clear_has_country_base();
  ::proto::common::country_base_data* temp = country_base_;
  country_base_ = NULL;
  return temp;
}
inline void king_war_country_sign_up_single::set_allocated_country_base(::proto::common::country_base_data* country_base) {
  delete country_base_;
  country_base_ = country_base;
  if (country_base) {
    set_has_country_base();
  } else {
    clear_has_country_base();
  }
}

// optional uint32 money = 2;
inline bool king_war_country_sign_up_single::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_country_sign_up_single::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_country_sign_up_single::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_country_sign_up_single::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 king_war_country_sign_up_single::money() const {
  return money_;
}
inline void king_war_country_sign_up_single::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 power = 3;
inline bool king_war_country_sign_up_single::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_country_sign_up_single::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_country_sign_up_single::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_country_sign_up_single::clear_power() {
  power_ = 0u;
  clear_has_power();
}
inline ::google::protobuf::uint32 king_war_country_sign_up_single::power() const {
  return power_;
}
inline void king_war_country_sign_up_single::set_power(::google::protobuf::uint32 value) {
  set_has_power();
  power_ = value;
}

// optional uint32 family_number = 4;
inline bool king_war_country_sign_up_single::has_family_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void king_war_country_sign_up_single::set_has_family_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void king_war_country_sign_up_single::clear_has_family_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void king_war_country_sign_up_single::clear_family_number() {
  family_number_ = 0u;
  clear_has_family_number();
}
inline ::google::protobuf::uint32 king_war_country_sign_up_single::family_number() const {
  return family_number_;
}
inline void king_war_country_sign_up_single::set_family_number(::google::protobuf::uint32 value) {
  set_has_family_number();
  family_number_ = value;
}

// optional uint32 sign_up_number = 5;
inline bool king_war_country_sign_up_single::has_sign_up_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void king_war_country_sign_up_single::set_has_sign_up_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void king_war_country_sign_up_single::clear_has_sign_up_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void king_war_country_sign_up_single::clear_sign_up_number() {
  sign_up_number_ = 0u;
  clear_has_sign_up_number();
}
inline ::google::protobuf::uint32 king_war_country_sign_up_single::sign_up_number() const {
  return sign_up_number_;
}
inline void king_war_country_sign_up_single::set_sign_up_number(::google::protobuf::uint32 value) {
  set_has_sign_up_number();
  sign_up_number_ = value;
}

// optional bool is_sign_up = 6;
inline bool king_war_country_sign_up_single::has_is_sign_up() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void king_war_country_sign_up_single::set_has_is_sign_up() {
  _has_bits_[0] |= 0x00000020u;
}
inline void king_war_country_sign_up_single::clear_has_is_sign_up() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void king_war_country_sign_up_single::clear_is_sign_up() {
  is_sign_up_ = false;
  clear_has_is_sign_up();
}
inline bool king_war_country_sign_up_single::is_sign_up() const {
  return is_sign_up_;
}
inline void king_war_country_sign_up_single::set_is_sign_up(bool value) {
  set_has_is_sign_up();
  is_sign_up_ = value;
}

// -------------------------------------------------------------------

// king_war_country_sign_up_info

// optional uint32 end_time = 1;
inline bool king_war_country_sign_up_info::has_end_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_country_sign_up_info::set_has_end_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_country_sign_up_info::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_country_sign_up_info::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 king_war_country_sign_up_info::end_time() const {
  return end_time_;
}
inline void king_war_country_sign_up_info::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// repeated .proto.common.king_war_country_sign_up_single countries = 2;
inline int king_war_country_sign_up_info::countries_size() const {
  return countries_.size();
}
inline void king_war_country_sign_up_info::clear_countries() {
  countries_.Clear();
}
inline const ::proto::common::king_war_country_sign_up_single& king_war_country_sign_up_info::countries(int index) const {
  return countries_.Get(index);
}
inline ::proto::common::king_war_country_sign_up_single* king_war_country_sign_up_info::mutable_countries(int index) {
  return countries_.Mutable(index);
}
inline ::proto::common::king_war_country_sign_up_single* king_war_country_sign_up_info::add_countries() {
  return countries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_sign_up_single >&
king_war_country_sign_up_info::countries() const {
  return countries_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_sign_up_single >*
king_war_country_sign_up_info::mutable_countries() {
  return &countries_;
}

// -------------------------------------------------------------------

// king_war_family_info

// optional string family_id = 1;
inline bool king_war_family_info::has_family_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_family_info::set_has_family_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_family_info::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_family_info::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& king_war_family_info::family_id() const {
  return *family_id_;
}
inline void king_war_family_info::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void king_war_family_info::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void king_war_family_info::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* king_war_family_info::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 2;
inline bool king_war_family_info::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_family_info::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_family_info::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_family_info::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& king_war_family_info::family_name() const {
  return *family_name_;
}
inline void king_war_family_info::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_family_info::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_family_info::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* king_war_family_info::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_king_family = 3;
inline bool king_war_family_info::has_is_king_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_family_info::set_has_is_king_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_family_info::clear_has_is_king_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_family_info::clear_is_king_family() {
  is_king_family_ = false;
  clear_has_is_king_family();
}
inline bool king_war_family_info::is_king_family() const {
  return is_king_family_;
}
inline void king_war_family_info::set_is_king_family(bool value) {
  set_has_is_king_family();
  is_king_family_ = value;
}

// optional string friend_family_id = 4;
inline bool king_war_family_info::has_friend_family_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void king_war_family_info::set_has_friend_family_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void king_war_family_info::clear_has_friend_family_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void king_war_family_info::clear_friend_family_id() {
  if (friend_family_id_ != &::google::protobuf::internal::kEmptyString) {
    friend_family_id_->clear();
  }
  clear_has_friend_family_id();
}
inline const ::std::string& king_war_family_info::friend_family_id() const {
  return *friend_family_id_;
}
inline void king_war_family_info::set_friend_family_id(const ::std::string& value) {
  set_has_friend_family_id();
  if (friend_family_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_id_ = new ::std::string;
  }
  friend_family_id_->assign(value);
}
inline void king_war_family_info::set_friend_family_id(const char* value) {
  set_has_friend_family_id();
  if (friend_family_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_id_ = new ::std::string;
  }
  friend_family_id_->assign(value);
}
inline void king_war_family_info::set_friend_family_id(const char* value, size_t size) {
  set_has_friend_family_id();
  if (friend_family_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_id_ = new ::std::string;
  }
  friend_family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_friend_family_id() {
  set_has_friend_family_id();
  if (friend_family_id_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_id_ = new ::std::string;
  }
  return friend_family_id_;
}
inline ::std::string* king_war_family_info::release_friend_family_id() {
  clear_has_friend_family_id();
  if (friend_family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_family_id_;
    friend_family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_friend_family_id(::std::string* friend_family_id) {
  if (friend_family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_family_id_;
  }
  if (friend_family_id) {
    set_has_friend_family_id();
    friend_family_id_ = friend_family_id;
  } else {
    clear_has_friend_family_id();
    friend_family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string friend_family_name = 5;
inline bool king_war_family_info::has_friend_family_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void king_war_family_info::set_has_friend_family_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void king_war_family_info::clear_has_friend_family_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void king_war_family_info::clear_friend_family_name() {
  if (friend_family_name_ != &::google::protobuf::internal::kEmptyString) {
    friend_family_name_->clear();
  }
  clear_has_friend_family_name();
}
inline const ::std::string& king_war_family_info::friend_family_name() const {
  return *friend_family_name_;
}
inline void king_war_family_info::set_friend_family_name(const ::std::string& value) {
  set_has_friend_family_name();
  if (friend_family_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_name_ = new ::std::string;
  }
  friend_family_name_->assign(value);
}
inline void king_war_family_info::set_friend_family_name(const char* value) {
  set_has_friend_family_name();
  if (friend_family_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_name_ = new ::std::string;
  }
  friend_family_name_->assign(value);
}
inline void king_war_family_info::set_friend_family_name(const char* value, size_t size) {
  set_has_friend_family_name();
  if (friend_family_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_name_ = new ::std::string;
  }
  friend_family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_friend_family_name() {
  set_has_friend_family_name();
  if (friend_family_name_ == &::google::protobuf::internal::kEmptyString) {
    friend_family_name_ = new ::std::string;
  }
  return friend_family_name_;
}
inline ::std::string* king_war_family_info::release_friend_family_name() {
  clear_has_friend_family_name();
  if (friend_family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friend_family_name_;
    friend_family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_friend_family_name(::std::string* friend_family_name) {
  if (friend_family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete friend_family_name_;
  }
  if (friend_family_name) {
    set_has_friend_family_name();
    friend_family_name_ = friend_family_name;
  } else {
    clear_has_friend_family_name();
    friend_family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string notice_user = 6;
inline bool king_war_family_info::has_notice_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void king_war_family_info::set_has_notice_user() {
  _has_bits_[0] |= 0x00000020u;
}
inline void king_war_family_info::clear_has_notice_user() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void king_war_family_info::clear_notice_user() {
  if (notice_user_ != &::google::protobuf::internal::kEmptyString) {
    notice_user_->clear();
  }
  clear_has_notice_user();
}
inline const ::std::string& king_war_family_info::notice_user() const {
  return *notice_user_;
}
inline void king_war_family_info::set_notice_user(const ::std::string& value) {
  set_has_notice_user();
  if (notice_user_ == &::google::protobuf::internal::kEmptyString) {
    notice_user_ = new ::std::string;
  }
  notice_user_->assign(value);
}
inline void king_war_family_info::set_notice_user(const char* value) {
  set_has_notice_user();
  if (notice_user_ == &::google::protobuf::internal::kEmptyString) {
    notice_user_ = new ::std::string;
  }
  notice_user_->assign(value);
}
inline void king_war_family_info::set_notice_user(const char* value, size_t size) {
  set_has_notice_user();
  if (notice_user_ == &::google::protobuf::internal::kEmptyString) {
    notice_user_ = new ::std::string;
  }
  notice_user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_notice_user() {
  set_has_notice_user();
  if (notice_user_ == &::google::protobuf::internal::kEmptyString) {
    notice_user_ = new ::std::string;
  }
  return notice_user_;
}
inline ::std::string* king_war_family_info::release_notice_user() {
  clear_has_notice_user();
  if (notice_user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_user_;
    notice_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_notice_user(::std::string* notice_user) {
  if (notice_user_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_user_;
  }
  if (notice_user) {
    set_has_notice_user();
    notice_user_ = notice_user;
  } else {
    clear_has_notice_user();
    notice_user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 family_officer = 7;
inline bool king_war_family_info::has_family_officer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void king_war_family_info::set_has_family_officer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void king_war_family_info::clear_has_family_officer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void king_war_family_info::clear_family_officer() {
  family_officer_ = 0u;
  clear_has_family_officer();
}
inline ::google::protobuf::uint32 king_war_family_info::family_officer() const {
  return family_officer_;
}
inline void king_war_family_info::set_family_officer(::google::protobuf::uint32 value) {
  set_has_family_officer();
  family_officer_ = value;
}

// optional string notice = 8;
inline bool king_war_family_info::has_notice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void king_war_family_info::set_has_notice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void king_war_family_info::clear_has_notice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void king_war_family_info::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& king_war_family_info::notice() const {
  return *notice_;
}
inline void king_war_family_info::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void king_war_family_info::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void king_war_family_info::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_family_info::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* king_war_family_info::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_family_info::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 like_num = 9;
inline bool king_war_family_info::has_like_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void king_war_family_info::set_has_like_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void king_war_family_info::clear_has_like_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void king_war_family_info::clear_like_num() {
  like_num_ = 0u;
  clear_has_like_num();
}
inline ::google::protobuf::uint32 king_war_family_info::like_num() const {
  return like_num_;
}
inline void king_war_family_info::set_like_num(::google::protobuf::uint32 value) {
  set_has_like_num();
  like_num_ = value;
}

// optional uint32 dislike_num = 10;
inline bool king_war_family_info::has_dislike_num() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void king_war_family_info::set_has_dislike_num() {
  _has_bits_[0] |= 0x00000200u;
}
inline void king_war_family_info::clear_has_dislike_num() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void king_war_family_info::clear_dislike_num() {
  dislike_num_ = 0u;
  clear_has_dislike_num();
}
inline ::google::protobuf::uint32 king_war_family_info::dislike_num() const {
  return dislike_num_;
}
inline void king_war_family_info::set_dislike_num(::google::protobuf::uint32 value) {
  set_has_dislike_num();
  dislike_num_ = value;
}

// optional bool is_like = 11;
inline bool king_war_family_info::has_is_like() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void king_war_family_info::set_has_is_like() {
  _has_bits_[0] |= 0x00000400u;
}
inline void king_war_family_info::clear_has_is_like() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void king_war_family_info::clear_is_like() {
  is_like_ = false;
  clear_has_is_like();
}
inline bool king_war_family_info::is_like() const {
  return is_like_;
}
inline void king_war_family_info::set_is_like(bool value) {
  set_has_is_like();
  is_like_ = value;
}

// -------------------------------------------------------------------

// king_war_country_pre_single

// optional uint32 country_id = 1;
inline bool king_war_country_pre_single::has_country_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_country_pre_single::set_has_country_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_country_pre_single::clear_has_country_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_country_pre_single::clear_country_id() {
  country_id_ = 0u;
  clear_has_country_id();
}
inline ::google::protobuf::uint32 king_war_country_pre_single::country_id() const {
  return country_id_;
}
inline void king_war_country_pre_single::set_country_id(::google::protobuf::uint32 value) {
  set_has_country_id();
  country_id_ = value;
}

// optional .proto.common.king_war_family_info left_family = 2;
inline bool king_war_country_pre_single::has_left_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_country_pre_single::set_has_left_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_country_pre_single::clear_has_left_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_country_pre_single::clear_left_family() {
  if (left_family_ != NULL) left_family_->::proto::common::king_war_family_info::Clear();
  clear_has_left_family();
}
inline const ::proto::common::king_war_family_info& king_war_country_pre_single::left_family() const {
  return left_family_ != NULL ? *left_family_ : *default_instance_->left_family_;
}
inline ::proto::common::king_war_family_info* king_war_country_pre_single::mutable_left_family() {
  set_has_left_family();
  if (left_family_ == NULL) left_family_ = new ::proto::common::king_war_family_info;
  return left_family_;
}
inline ::proto::common::king_war_family_info* king_war_country_pre_single::release_left_family() {
  clear_has_left_family();
  ::proto::common::king_war_family_info* temp = left_family_;
  left_family_ = NULL;
  return temp;
}
inline void king_war_country_pre_single::set_allocated_left_family(::proto::common::king_war_family_info* left_family) {
  delete left_family_;
  left_family_ = left_family;
  if (left_family) {
    set_has_left_family();
  } else {
    clear_has_left_family();
  }
}

// optional .proto.common.king_war_family_info right_family = 3;
inline bool king_war_country_pre_single::has_right_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_country_pre_single::set_has_right_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_country_pre_single::clear_has_right_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_country_pre_single::clear_right_family() {
  if (right_family_ != NULL) right_family_->::proto::common::king_war_family_info::Clear();
  clear_has_right_family();
}
inline const ::proto::common::king_war_family_info& king_war_country_pre_single::right_family() const {
  return right_family_ != NULL ? *right_family_ : *default_instance_->right_family_;
}
inline ::proto::common::king_war_family_info* king_war_country_pre_single::mutable_right_family() {
  set_has_right_family();
  if (right_family_ == NULL) right_family_ = new ::proto::common::king_war_family_info;
  return right_family_;
}
inline ::proto::common::king_war_family_info* king_war_country_pre_single::release_right_family() {
  clear_has_right_family();
  ::proto::common::king_war_family_info* temp = right_family_;
  right_family_ = NULL;
  return temp;
}
inline void king_war_country_pre_single::set_allocated_right_family(::proto::common::king_war_family_info* right_family) {
  delete right_family_;
  right_family_ = right_family;
  if (right_family) {
    set_has_right_family();
  } else {
    clear_has_right_family();
  }
}

// -------------------------------------------------------------------

// king_war_country_pre_info

// optional uint32 fight_time = 1;
inline bool king_war_country_pre_info::has_fight_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_country_pre_info::set_has_fight_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_country_pre_info::clear_has_fight_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_country_pre_info::clear_fight_time() {
  fight_time_ = 0u;
  clear_has_fight_time();
}
inline ::google::protobuf::uint32 king_war_country_pre_info::fight_time() const {
  return fight_time_;
}
inline void king_war_country_pre_info::set_fight_time(::google::protobuf::uint32 value) {
  set_has_fight_time();
  fight_time_ = value;
}

// repeated .proto.common.king_war_country_pre_single countries = 2;
inline int king_war_country_pre_info::countries_size() const {
  return countries_.size();
}
inline void king_war_country_pre_info::clear_countries() {
  countries_.Clear();
}
inline const ::proto::common::king_war_country_pre_single& king_war_country_pre_info::countries(int index) const {
  return countries_.Get(index);
}
inline ::proto::common::king_war_country_pre_single* king_war_country_pre_info::mutable_countries(int index) {
  return countries_.Mutable(index);
}
inline ::proto::common::king_war_country_pre_single* king_war_country_pre_info::add_countries() {
  return countries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_pre_single >&
king_war_country_pre_info::countries() const {
  return countries_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_country_pre_single >*
king_war_country_pre_info::mutable_countries() {
  return &countries_;
}

// -------------------------------------------------------------------

// country_king_war_info

// optional uint32 state = 1 [default = 0];
inline bool country_king_war_info::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void country_king_war_info::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void country_king_war_info::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void country_king_war_info::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 country_king_war_info::state() const {
  return state_;
}
inline void country_king_war_info::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional .proto.common.king_war_country_sign_up_info sign_up_info = 2;
inline bool country_king_war_info::has_sign_up_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void country_king_war_info::set_has_sign_up_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void country_king_war_info::clear_has_sign_up_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void country_king_war_info::clear_sign_up_info() {
  if (sign_up_info_ != NULL) sign_up_info_->::proto::common::king_war_country_sign_up_info::Clear();
  clear_has_sign_up_info();
}
inline const ::proto::common::king_war_country_sign_up_info& country_king_war_info::sign_up_info() const {
  return sign_up_info_ != NULL ? *sign_up_info_ : *default_instance_->sign_up_info_;
}
inline ::proto::common::king_war_country_sign_up_info* country_king_war_info::mutable_sign_up_info() {
  set_has_sign_up_info();
  if (sign_up_info_ == NULL) sign_up_info_ = new ::proto::common::king_war_country_sign_up_info;
  return sign_up_info_;
}
inline ::proto::common::king_war_country_sign_up_info* country_king_war_info::release_sign_up_info() {
  clear_has_sign_up_info();
  ::proto::common::king_war_country_sign_up_info* temp = sign_up_info_;
  sign_up_info_ = NULL;
  return temp;
}
inline void country_king_war_info::set_allocated_sign_up_info(::proto::common::king_war_country_sign_up_info* sign_up_info) {
  delete sign_up_info_;
  sign_up_info_ = sign_up_info;
  if (sign_up_info) {
    set_has_sign_up_info();
  } else {
    clear_has_sign_up_info();
  }
}

// optional .proto.common.king_war_country_pre_info pre_info = 3;
inline bool country_king_war_info::has_pre_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void country_king_war_info::set_has_pre_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void country_king_war_info::clear_has_pre_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void country_king_war_info::clear_pre_info() {
  if (pre_info_ != NULL) pre_info_->::proto::common::king_war_country_pre_info::Clear();
  clear_has_pre_info();
}
inline const ::proto::common::king_war_country_pre_info& country_king_war_info::pre_info() const {
  return pre_info_ != NULL ? *pre_info_ : *default_instance_->pre_info_;
}
inline ::proto::common::king_war_country_pre_info* country_king_war_info::mutable_pre_info() {
  set_has_pre_info();
  if (pre_info_ == NULL) pre_info_ = new ::proto::common::king_war_country_pre_info;
  return pre_info_;
}
inline ::proto::common::king_war_country_pre_info* country_king_war_info::release_pre_info() {
  clear_has_pre_info();
  ::proto::common::king_war_country_pre_info* temp = pre_info_;
  pre_info_ = NULL;
  return temp;
}
inline void country_king_war_info::set_allocated_pre_info(::proto::common::king_war_country_pre_info* pre_info) {
  delete pre_info_;
  pre_info_ = pre_info;
  if (pre_info) {
    set_has_pre_info();
  } else {
    clear_has_pre_info();
  }
}

// -------------------------------------------------------------------

// family_war_info

// optional .proto.common.family_war_state state = 1 [default = family_war_state_end];
inline bool family_war_info::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_war_info::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_war_info::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_war_info::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::proto::common::family_war_state family_war_info::state() const {
  return static_cast< ::proto::common::family_war_state >(state_);
}
inline void family_war_info::set_state(::proto::common::family_war_state value) {
  assert(::proto::common::family_war_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .proto.common.family_against_data data = 2;
inline bool family_war_info::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_war_info::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_war_info::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_war_info::clear_data() {
  if (data_ != NULL) data_->::proto::common::family_against_data::Clear();
  clear_has_data();
}
inline const ::proto::common::family_against_data& family_war_info::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::proto::common::family_against_data* family_war_info::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::proto::common::family_against_data;
  return data_;
}
inline ::proto::common::family_against_data* family_war_info::release_data() {
  clear_has_data();
  ::proto::common::family_against_data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void family_war_info::set_allocated_data(::proto::common::family_against_data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// optional uint32 war_time = 3;
inline bool family_war_info::has_war_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void family_war_info::set_has_war_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void family_war_info::clear_has_war_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void family_war_info::clear_war_time() {
  war_time_ = 0u;
  clear_has_war_time();
}
inline ::google::protobuf::uint32 family_war_info::war_time() const {
  return war_time_;
}
inline void family_war_info::set_war_time(::google::protobuf::uint32 value) {
  set_has_war_time();
  war_time_ = value;
}

// -------------------------------------------------------------------

// king_war_sign_up_data

// optional string family_name = 1;
inline bool king_war_sign_up_data::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_sign_up_data::set_has_family_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_sign_up_data::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_sign_up_data::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& king_war_sign_up_data::family_name() const {
  return *family_name_;
}
inline void king_war_sign_up_data::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_sign_up_data::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_sign_up_data::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_sign_up_data::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* king_war_sign_up_data::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_sign_up_data::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string patriarch_name = 2;
inline bool king_war_sign_up_data::has_patriarch_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_sign_up_data::set_has_patriarch_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_sign_up_data::clear_has_patriarch_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_sign_up_data::clear_patriarch_name() {
  if (patriarch_name_ != &::google::protobuf::internal::kEmptyString) {
    patriarch_name_->clear();
  }
  clear_has_patriarch_name();
}
inline const ::std::string& king_war_sign_up_data::patriarch_name() const {
  return *patriarch_name_;
}
inline void king_war_sign_up_data::set_patriarch_name(const ::std::string& value) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(value);
}
inline void king_war_sign_up_data::set_patriarch_name(const char* value) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(value);
}
inline void king_war_sign_up_data::set_patriarch_name(const char* value, size_t size) {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  patriarch_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_sign_up_data::mutable_patriarch_name() {
  set_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    patriarch_name_ = new ::std::string;
  }
  return patriarch_name_;
}
inline ::std::string* king_war_sign_up_data::release_patriarch_name() {
  clear_has_patriarch_name();
  if (patriarch_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patriarch_name_;
    patriarch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_sign_up_data::set_allocated_patriarch_name(::std::string* patriarch_name) {
  if (patriarch_name_ != &::google::protobuf::internal::kEmptyString) {
    delete patriarch_name_;
  }
  if (patriarch_name) {
    set_has_patriarch_name();
    patriarch_name_ = patriarch_name;
  } else {
    clear_has_patriarch_name();
    patriarch_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time = 3;
inline bool king_war_sign_up_data::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_sign_up_data::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_sign_up_data::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_sign_up_data::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 king_war_sign_up_data::time() const {
  return time_;
}
inline void king_war_sign_up_data::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// king_war_help_family

// optional .proto.common.family_list_info info = 1;
inline bool king_war_help_family::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_help_family::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_help_family::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_help_family::clear_info() {
  if (info_ != NULL) info_->::proto::common::family_list_info::Clear();
  clear_has_info();
}
inline const ::proto::common::family_list_info& king_war_help_family::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::proto::common::family_list_info* king_war_help_family::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::proto::common::family_list_info;
  return info_;
}
inline ::proto::common::family_list_info* king_war_help_family::release_info() {
  clear_has_info();
  ::proto::common::family_list_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void king_war_help_family::set_allocated_info(::proto::common::family_list_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .proto.common.king_war_help_state state = 2;
inline bool king_war_help_family::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_help_family::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_help_family::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_help_family::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::proto::common::king_war_help_state king_war_help_family::state() const {
  return static_cast< ::proto::common::king_war_help_state >(state_);
}
inline void king_war_help_family::set_state(::proto::common::king_war_help_state value) {
  assert(::proto::common::king_war_help_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// king_war_helf_info

// optional string family_uid = 1;
inline bool king_war_helf_info::has_family_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_helf_info::set_has_family_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_helf_info::clear_has_family_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_helf_info::clear_family_uid() {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    family_uid_->clear();
  }
  clear_has_family_uid();
}
inline const ::std::string& king_war_helf_info::family_uid() const {
  return *family_uid_;
}
inline void king_war_helf_info::set_family_uid(const ::std::string& value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void king_war_helf_info::set_family_uid(const char* value) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(value);
}
inline void king_war_helf_info::set_family_uid(const char* value, size_t size) {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  family_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_helf_info::mutable_family_uid() {
  set_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    family_uid_ = new ::std::string;
  }
  return family_uid_;
}
inline ::std::string* king_war_helf_info::release_family_uid() {
  clear_has_family_uid();
  if (family_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_uid_;
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_helf_info::set_allocated_family_uid(::std::string* family_uid) {
  if (family_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete family_uid_;
  }
  if (family_uid) {
    set_has_family_uid();
    family_uid_ = family_uid;
  } else {
    clear_has_family_uid();
    family_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 2;
inline bool king_war_helf_info::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_helf_info::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_helf_info::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_helf_info::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& king_war_helf_info::family_name() const {
  return *family_name_;
}
inline void king_war_helf_info::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_helf_info::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_helf_info::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_helf_info::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* king_war_helf_info::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_helf_info::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 country = 3;
inline bool king_war_helf_info::has_country() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_helf_info::set_has_country() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_helf_info::clear_has_country() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_helf_info::clear_country() {
  country_ = 0u;
  clear_has_country();
}
inline ::google::protobuf::uint32 king_war_helf_info::country() const {
  return country_;
}
inline void king_war_helf_info::set_country(::google::protobuf::uint32 value) {
  set_has_country();
  country_ = value;
}

// optional uint32 fight_time = 4;
inline bool king_war_helf_info::has_fight_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void king_war_helf_info::set_has_fight_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void king_war_helf_info::clear_has_fight_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void king_war_helf_info::clear_fight_time() {
  fight_time_ = 0u;
  clear_has_fight_time();
}
inline ::google::protobuf::uint32 king_war_helf_info::fight_time() const {
  return fight_time_;
}
inline void king_war_helf_info::set_fight_time(::google::protobuf::uint32 value) {
  set_has_fight_time();
  fight_time_ = value;
}

// -------------------------------------------------------------------

// king_war_long_info

// optional string object_id = 1;
inline bool king_war_long_info::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_long_info::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_long_info::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_long_info::clear_object_id() {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    object_id_->clear();
  }
  clear_has_object_id();
}
inline const ::std::string& king_war_long_info::object_id() const {
  return *object_id_;
}
inline void king_war_long_info::set_object_id(const ::std::string& value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void king_war_long_info::set_object_id(const char* value) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(value);
}
inline void king_war_long_info::set_object_id(const char* value, size_t size) {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  object_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_long_info::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    object_id_ = new ::std::string;
  }
  return object_id_;
}
inline ::std::string* king_war_long_info::release_object_id() {
  clear_has_object_id();
  if (object_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_id_;
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_long_info::set_allocated_object_id(::std::string* object_id) {
  if (object_id_ != &::google::protobuf::internal::kEmptyString) {
    delete object_id_;
  }
  if (object_id) {
    set_has_object_id();
    object_id_ = object_id;
  } else {
    clear_has_object_id();
    object_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 monster_tid = 2;
inline bool king_war_long_info::has_monster_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_long_info::set_has_monster_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_long_info::clear_has_monster_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_long_info::clear_monster_tid() {
  monster_tid_ = 0u;
  clear_has_monster_tid();
}
inline ::google::protobuf::uint32 king_war_long_info::monster_tid() const {
  return monster_tid_;
}
inline void king_war_long_info::set_monster_tid(::google::protobuf::uint32 value) {
  set_has_monster_tid();
  monster_tid_ = value;
}

// optional uint32 curr_x = 3;
inline bool king_war_long_info::has_curr_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_long_info::set_has_curr_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_long_info::clear_has_curr_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_long_info::clear_curr_x() {
  curr_x_ = 0u;
  clear_has_curr_x();
}
inline ::google::protobuf::uint32 king_war_long_info::curr_x() const {
  return curr_x_;
}
inline void king_war_long_info::set_curr_x(::google::protobuf::uint32 value) {
  set_has_curr_x();
  curr_x_ = value;
}

// optional uint32 curr_y = 4;
inline bool king_war_long_info::has_curr_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void king_war_long_info::set_has_curr_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void king_war_long_info::clear_has_curr_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void king_war_long_info::clear_curr_y() {
  curr_y_ = 0u;
  clear_has_curr_y();
}
inline ::google::protobuf::uint32 king_war_long_info::curr_y() const {
  return curr_y_;
}
inline void king_war_long_info::set_curr_y(::google::protobuf::uint32 value) {
  set_has_curr_y();
  curr_y_ = value;
}

// optional uint32 curr_hp = 5;
inline bool king_war_long_info::has_curr_hp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void king_war_long_info::set_has_curr_hp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void king_war_long_info::clear_has_curr_hp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void king_war_long_info::clear_curr_hp() {
  curr_hp_ = 0u;
  clear_has_curr_hp();
}
inline ::google::protobuf::uint32 king_war_long_info::curr_hp() const {
  return curr_hp_;
}
inline void king_war_long_info::set_curr_hp(::google::protobuf::uint32 value) {
  set_has_curr_hp();
  curr_hp_ = value;
}

// optional uint32 max_hp = 6;
inline bool king_war_long_info::has_max_hp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void king_war_long_info::set_has_max_hp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void king_war_long_info::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void king_war_long_info::clear_max_hp() {
  max_hp_ = 0u;
  clear_has_max_hp();
}
inline ::google::protobuf::uint32 king_war_long_info::max_hp() const {
  return max_hp_;
}
inline void king_war_long_info::set_max_hp(::google::protobuf::uint32 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// optional uint32 long_type = 7;
inline bool king_war_long_info::has_long_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void king_war_long_info::set_has_long_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void king_war_long_info::clear_has_long_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void king_war_long_info::clear_long_type() {
  long_type_ = 0u;
  clear_has_long_type();
}
inline ::google::protobuf::uint32 king_war_long_info::long_type() const {
  return long_type_;
}
inline void king_war_long_info::set_long_type(::google::protobuf::uint32 value) {
  set_has_long_type();
  long_type_ = value;
}

// optional string occupy_family = 8;
inline bool king_war_long_info::has_occupy_family() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void king_war_long_info::set_has_occupy_family() {
  _has_bits_[0] |= 0x00000080u;
}
inline void king_war_long_info::clear_has_occupy_family() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void king_war_long_info::clear_occupy_family() {
  if (occupy_family_ != &::google::protobuf::internal::kEmptyString) {
    occupy_family_->clear();
  }
  clear_has_occupy_family();
}
inline const ::std::string& king_war_long_info::occupy_family() const {
  return *occupy_family_;
}
inline void king_war_long_info::set_occupy_family(const ::std::string& value) {
  set_has_occupy_family();
  if (occupy_family_ == &::google::protobuf::internal::kEmptyString) {
    occupy_family_ = new ::std::string;
  }
  occupy_family_->assign(value);
}
inline void king_war_long_info::set_occupy_family(const char* value) {
  set_has_occupy_family();
  if (occupy_family_ == &::google::protobuf::internal::kEmptyString) {
    occupy_family_ = new ::std::string;
  }
  occupy_family_->assign(value);
}
inline void king_war_long_info::set_occupy_family(const char* value, size_t size) {
  set_has_occupy_family();
  if (occupy_family_ == &::google::protobuf::internal::kEmptyString) {
    occupy_family_ = new ::std::string;
  }
  occupy_family_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_long_info::mutable_occupy_family() {
  set_has_occupy_family();
  if (occupy_family_ == &::google::protobuf::internal::kEmptyString) {
    occupy_family_ = new ::std::string;
  }
  return occupy_family_;
}
inline ::std::string* king_war_long_info::release_occupy_family() {
  clear_has_occupy_family();
  if (occupy_family_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = occupy_family_;
    occupy_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_long_info::set_allocated_occupy_family(::std::string* occupy_family) {
  if (occupy_family_ != &::google::protobuf::internal::kEmptyString) {
    delete occupy_family_;
  }
  if (occupy_family) {
    set_has_occupy_family();
    occupy_family_ = occupy_family;
  } else {
    clear_has_occupy_family();
    occupy_family_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string occupy_help = 9;
inline bool king_war_long_info::has_occupy_help() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void king_war_long_info::set_has_occupy_help() {
  _has_bits_[0] |= 0x00000100u;
}
inline void king_war_long_info::clear_has_occupy_help() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void king_war_long_info::clear_occupy_help() {
  if (occupy_help_ != &::google::protobuf::internal::kEmptyString) {
    occupy_help_->clear();
  }
  clear_has_occupy_help();
}
inline const ::std::string& king_war_long_info::occupy_help() const {
  return *occupy_help_;
}
inline void king_war_long_info::set_occupy_help(const ::std::string& value) {
  set_has_occupy_help();
  if (occupy_help_ == &::google::protobuf::internal::kEmptyString) {
    occupy_help_ = new ::std::string;
  }
  occupy_help_->assign(value);
}
inline void king_war_long_info::set_occupy_help(const char* value) {
  set_has_occupy_help();
  if (occupy_help_ == &::google::protobuf::internal::kEmptyString) {
    occupy_help_ = new ::std::string;
  }
  occupy_help_->assign(value);
}
inline void king_war_long_info::set_occupy_help(const char* value, size_t size) {
  set_has_occupy_help();
  if (occupy_help_ == &::google::protobuf::internal::kEmptyString) {
    occupy_help_ = new ::std::string;
  }
  occupy_help_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_long_info::mutable_occupy_help() {
  set_has_occupy_help();
  if (occupy_help_ == &::google::protobuf::internal::kEmptyString) {
    occupy_help_ = new ::std::string;
  }
  return occupy_help_;
}
inline ::std::string* king_war_long_info::release_occupy_help() {
  clear_has_occupy_help();
  if (occupy_help_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = occupy_help_;
    occupy_help_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_long_info::set_allocated_occupy_help(::std::string* occupy_help) {
  if (occupy_help_ != &::google::protobuf::internal::kEmptyString) {
    delete occupy_help_;
  }
  if (occupy_help) {
    set_has_occupy_help();
    occupy_help_ = occupy_help;
  } else {
    clear_has_occupy_help();
    occupy_help_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// king_war_role_pos

// optional float pos_x = 1;
inline bool king_war_role_pos::has_pos_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_role_pos::set_has_pos_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_role_pos::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_role_pos::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline float king_war_role_pos::pos_x() const {
  return pos_x_;
}
inline void king_war_role_pos::set_pos_x(float value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional float pos_y = 2;
inline bool king_war_role_pos::has_pos_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_role_pos::set_has_pos_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_role_pos::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_role_pos::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline float king_war_role_pos::pos_y() const {
  return pos_y_;
}
inline void king_war_role_pos::set_pos_y(float value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// king_war_side_roles

// repeated .proto.common.king_war_role_pos roles = 1;
inline int king_war_side_roles::roles_size() const {
  return roles_.size();
}
inline void king_war_side_roles::clear_roles() {
  roles_.Clear();
}
inline const ::proto::common::king_war_role_pos& king_war_side_roles::roles(int index) const {
  return roles_.Get(index);
}
inline ::proto::common::king_war_role_pos* king_war_side_roles::mutable_roles(int index) {
  return roles_.Mutable(index);
}
inline ::proto::common::king_war_role_pos* king_war_side_roles::add_roles() {
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_role_pos >&
king_war_side_roles::roles() const {
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_role_pos >*
king_war_side_roles::mutable_roles() {
  return &roles_;
}

// -------------------------------------------------------------------

// king_war_rank_single

// optional string role_name = 1;
inline bool king_war_rank_single::has_role_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void king_war_rank_single::set_has_role_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void king_war_rank_single::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void king_war_rank_single::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& king_war_rank_single::role_name() const {
  return *role_name_;
}
inline void king_war_rank_single::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void king_war_rank_single::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void king_war_rank_single::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_rank_single::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* king_war_rank_single::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_rank_single::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 2;
inline bool king_war_rank_single::has_family_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void king_war_rank_single::set_has_family_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void king_war_rank_single::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void king_war_rank_single::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& king_war_rank_single::family_name() const {
  return *family_name_;
}
inline void king_war_rank_single::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_rank_single::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void king_war_rank_single::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* king_war_rank_single::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* king_war_rank_single::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void king_war_rank_single::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 kill_count = 3;
inline bool king_war_rank_single::has_kill_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void king_war_rank_single::set_has_kill_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void king_war_rank_single::clear_has_kill_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void king_war_rank_single::clear_kill_count() {
  kill_count_ = 0u;
  clear_has_kill_count();
}
inline ::google::protobuf::uint32 king_war_rank_single::kill_count() const {
  return kill_count_;
}
inline void king_war_rank_single::set_kill_count(::google::protobuf::uint32 value) {
  set_has_kill_count();
  kill_count_ = value;
}

// optional uint32 death_count = 4;
inline bool king_war_rank_single::has_death_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void king_war_rank_single::set_has_death_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void king_war_rank_single::clear_has_death_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void king_war_rank_single::clear_death_count() {
  death_count_ = 0u;
  clear_has_death_count();
}
inline ::google::protobuf::uint32 king_war_rank_single::death_count() const {
  return death_count_;
}
inline void king_war_rank_single::set_death_count(::google::protobuf::uint32 value) {
  set_has_death_count();
  death_count_ = value;
}

// optional uint32 continued_kill = 5;
inline bool king_war_rank_single::has_continued_kill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void king_war_rank_single::set_has_continued_kill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void king_war_rank_single::clear_has_continued_kill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void king_war_rank_single::clear_continued_kill() {
  continued_kill_ = 0u;
  clear_has_continued_kill();
}
inline ::google::protobuf::uint32 king_war_rank_single::continued_kill() const {
  return continued_kill_;
}
inline void king_war_rank_single::set_continued_kill(::google::protobuf::uint32 value) {
  set_has_continued_kill();
  continued_kill_ = value;
}

// optional uint32 exploits = 6;
inline bool king_war_rank_single::has_exploits() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void king_war_rank_single::set_has_exploits() {
  _has_bits_[0] |= 0x00000020u;
}
inline void king_war_rank_single::clear_has_exploits() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void king_war_rank_single::clear_exploits() {
  exploits_ = 0u;
  clear_has_exploits();
}
inline ::google::protobuf::uint32 king_war_rank_single::exploits() const {
  return exploits_;
}
inline void king_war_rank_single::set_exploits(::google::protobuf::uint32 value) {
  set_has_exploits();
  exploits_ = value;
}

// -------------------------------------------------------------------

// king_war_rank_list

// repeated .proto.common.king_war_rank_single ranks = 1;
inline int king_war_rank_list::ranks_size() const {
  return ranks_.size();
}
inline void king_war_rank_list::clear_ranks() {
  ranks_.Clear();
}
inline const ::proto::common::king_war_rank_single& king_war_rank_list::ranks(int index) const {
  return ranks_.Get(index);
}
inline ::proto::common::king_war_rank_single* king_war_rank_list::mutable_ranks(int index) {
  return ranks_.Mutable(index);
}
inline ::proto::common::king_war_rank_single* king_war_rank_list::add_ranks() {
  return ranks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_rank_single >&
king_war_rank_list::ranks() const {
  return ranks_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::king_war_rank_single >*
king_war_rank_list::mutable_ranks() {
  return &ranks_;
}

// -------------------------------------------------------------------

// equip_single

// optional string hero_uid = 1;
inline bool equip_single::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void equip_single::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void equip_single::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void equip_single::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& equip_single::hero_uid() const {
  return *hero_uid_;
}
inline void equip_single::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void equip_single::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void equip_single::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_single::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* equip_single::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_single::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .proto.common.equip_attr attr = 2;
inline int equip_single::attr_size() const {
  return attr_.size();
}
inline void equip_single::clear_attr() {
  attr_.Clear();
}
inline const ::proto::common::equip_attr& equip_single::attr(int index) const {
  return attr_.Get(index);
}
inline ::proto::common::equip_attr* equip_single::mutable_attr(int index) {
  return attr_.Mutable(index);
}
inline ::proto::common::equip_attr* equip_single::add_attr() {
  return attr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::equip_attr >&
equip_single::attr() const {
  return attr_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::equip_attr >*
equip_single::mutable_attr() {
  return &attr_;
}

// repeated uint32 exattr = 3;
inline int equip_single::exattr_size() const {
  return exattr_.size();
}
inline void equip_single::clear_exattr() {
  exattr_.Clear();
}
inline ::google::protobuf::uint32 equip_single::exattr(int index) const {
  return exattr_.Get(index);
}
inline void equip_single::set_exattr(int index, ::google::protobuf::uint32 value) {
  exattr_.Set(index, value);
}
inline void equip_single::add_exattr(::google::protobuf::uint32 value) {
  exattr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
equip_single::exattr() const {
  return exattr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
equip_single::mutable_exattr() {
  return &exattr_;
}

// repeated uint32 remake_exattr = 4;
inline int equip_single::remake_exattr_size() const {
  return remake_exattr_.size();
}
inline void equip_single::clear_remake_exattr() {
  remake_exattr_.Clear();
}
inline ::google::protobuf::uint32 equip_single::remake_exattr(int index) const {
  return remake_exattr_.Get(index);
}
inline void equip_single::set_remake_exattr(int index, ::google::protobuf::uint32 value) {
  remake_exattr_.Set(index, value);
}
inline void equip_single::add_remake_exattr(::google::protobuf::uint32 value) {
  remake_exattr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
equip_single::remake_exattr() const {
  return remake_exattr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
equip_single::mutable_remake_exattr() {
  return &remake_exattr_;
}

// optional uint32 remake_exattr_bonus = 5;
inline bool equip_single::has_remake_exattr_bonus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void equip_single::set_has_remake_exattr_bonus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void equip_single::clear_has_remake_exattr_bonus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void equip_single::clear_remake_exattr_bonus() {
  remake_exattr_bonus_ = 0u;
  clear_has_remake_exattr_bonus();
}
inline ::google::protobuf::uint32 equip_single::remake_exattr_bonus() const {
  return remake_exattr_bonus_;
}
inline void equip_single::set_remake_exattr_bonus(::google::protobuf::uint32 value) {
  set_has_remake_exattr_bonus();
  remake_exattr_bonus_ = value;
}

// optional uint32 score = 6;
inline bool equip_single::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void equip_single::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void equip_single::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void equip_single::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 equip_single::score() const {
  return score_;
}
inline void equip_single::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional uint32 name = 7;
inline bool equip_single::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void equip_single::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void equip_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void equip_single::clear_name() {
  name_ = 0u;
  clear_has_name();
}
inline ::google::protobuf::uint32 equip_single::name() const {
  return name_;
}
inline void equip_single::set_name(::google::protobuf::uint32 value) {
  set_has_name();
  name_ = value;
}

// optional uint32 special = 8;
inline bool equip_single::has_special() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void equip_single::set_has_special() {
  _has_bits_[0] |= 0x00000080u;
}
inline void equip_single::clear_has_special() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void equip_single::clear_special() {
  special_ = 0u;
  clear_has_special();
}
inline ::google::protobuf::uint32 equip_single::special() const {
  return special_;
}
inline void equip_single::set_special(::google::protobuf::uint32 value) {
  set_has_special();
  special_ = value;
}

// optional uint32 strengthen_level = 9;
inline bool equip_single::has_strengthen_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void equip_single::set_has_strengthen_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void equip_single::clear_has_strengthen_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void equip_single::clear_strengthen_level() {
  strengthen_level_ = 0u;
  clear_has_strengthen_level();
}
inline ::google::protobuf::uint32 equip_single::strengthen_level() const {
  return strengthen_level_;
}
inline void equip_single::set_strengthen_level(::google::protobuf::uint32 value) {
  set_has_strengthen_level();
  strengthen_level_ = value;
}

// optional uint32 strmaster_level = 10;
inline bool equip_single::has_strmaster_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void equip_single::set_has_strmaster_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void equip_single::clear_has_strmaster_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void equip_single::clear_strmaster_level() {
  strmaster_level_ = 0u;
  clear_has_strmaster_level();
}
inline ::google::protobuf::uint32 equip_single::strmaster_level() const {
  return strmaster_level_;
}
inline void equip_single::set_strmaster_level(::google::protobuf::uint32 value) {
  set_has_strmaster_level();
  strmaster_level_ = value;
}

// optional uint32 remake_material = 11;
inline bool equip_single::has_remake_material() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void equip_single::set_has_remake_material() {
  _has_bits_[0] |= 0x00000400u;
}
inline void equip_single::clear_has_remake_material() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void equip_single::clear_remake_material() {
  remake_material_ = 0u;
  clear_has_remake_material();
}
inline ::google::protobuf::uint32 equip_single::remake_material() const {
  return remake_material_;
}
inline void equip_single::set_remake_material(::google::protobuf::uint32 value) {
  set_has_remake_material();
  remake_material_ = value;
}

// optional uint32 lock_material = 12;
inline bool equip_single::has_lock_material() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void equip_single::set_has_lock_material() {
  _has_bits_[0] |= 0x00000800u;
}
inline void equip_single::clear_has_lock_material() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void equip_single::clear_lock_material() {
  lock_material_ = 0u;
  clear_has_lock_material();
}
inline ::google::protobuf::uint32 equip_single::lock_material() const {
  return lock_material_;
}
inline void equip_single::set_lock_material(::google::protobuf::uint32 value) {
  set_has_lock_material();
  lock_material_ = value;
}

// optional uint32 strengthen_material = 13;
inline bool equip_single::has_strengthen_material() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void equip_single::set_has_strengthen_material() {
  _has_bits_[0] |= 0x00001000u;
}
inline void equip_single::clear_has_strengthen_material() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void equip_single::clear_strengthen_material() {
  strengthen_material_ = 0u;
  clear_has_strengthen_material();
}
inline ::google::protobuf::uint32 equip_single::strengthen_material() const {
  return strengthen_material_;
}
inline void equip_single::set_strengthen_material(::google::protobuf::uint32 value) {
  set_has_strengthen_material();
  strengthen_material_ = value;
}

// optional uint32 strengthen_material_ex = 14;
inline bool equip_single::has_strengthen_material_ex() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void equip_single::set_has_strengthen_material_ex() {
  _has_bits_[0] |= 0x00002000u;
}
inline void equip_single::clear_has_strengthen_material_ex() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void equip_single::clear_strengthen_material_ex() {
  strengthen_material_ex_ = 0u;
  clear_has_strengthen_material_ex();
}
inline ::google::protobuf::uint32 equip_single::strengthen_material_ex() const {
  return strengthen_material_ex_;
}
inline void equip_single::set_strengthen_material_ex(::google::protobuf::uint32 value) {
  set_has_strengthen_material_ex();
  strengthen_material_ex_ = value;
}

// optional uint32 strengthen_money = 15;
inline bool equip_single::has_strengthen_money() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void equip_single::set_has_strengthen_money() {
  _has_bits_[0] |= 0x00004000u;
}
inline void equip_single::clear_has_strengthen_money() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void equip_single::clear_strengthen_money() {
  strengthen_money_ = 0u;
  clear_has_strengthen_money();
}
inline ::google::protobuf::uint32 equip_single::strengthen_money() const {
  return strengthen_money_;
}
inline void equip_single::set_strengthen_money(::google::protobuf::uint32 value) {
  set_has_strengthen_money();
  strengthen_money_ = value;
}

// optional uint32 remake_score = 16;
inline bool equip_single::has_remake_score() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void equip_single::set_has_remake_score() {
  _has_bits_[0] |= 0x00008000u;
}
inline void equip_single::clear_has_remake_score() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void equip_single::clear_remake_score() {
  remake_score_ = 0u;
  clear_has_remake_score();
}
inline ::google::protobuf::uint32 equip_single::remake_score() const {
  return remake_score_;
}
inline void equip_single::set_remake_score(::google::protobuf::uint32 value) {
  set_has_remake_score();
  remake_score_ = value;
}

// optional uint32 remain_remake_count = 17;
inline bool equip_single::has_remain_remake_count() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void equip_single::set_has_remain_remake_count() {
  _has_bits_[0] |= 0x00010000u;
}
inline void equip_single::clear_has_remain_remake_count() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void equip_single::clear_remain_remake_count() {
  remain_remake_count_ = 0u;
  clear_has_remain_remake_count();
}
inline ::google::protobuf::uint32 equip_single::remain_remake_count() const {
  return remain_remake_count_;
}
inline void equip_single::set_remain_remake_count(::google::protobuf::uint32 value) {
  set_has_remain_remake_count();
  remain_remake_count_ = value;
}

// optional uint32 add_remake_count = 18;
inline bool equip_single::has_add_remake_count() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void equip_single::set_has_add_remake_count() {
  _has_bits_[0] |= 0x00020000u;
}
inline void equip_single::clear_has_add_remake_count() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void equip_single::clear_add_remake_count() {
  add_remake_count_ = 0u;
  clear_has_add_remake_count();
}
inline ::google::protobuf::uint32 equip_single::add_remake_count() const {
  return add_remake_count_;
}
inline void equip_single::set_add_remake_count(::google::protobuf::uint32 value) {
  set_has_add_remake_count();
  add_remake_count_ = value;
}

// -------------------------------------------------------------------

// equip_attr

// optional uint32 type = 1;
inline bool equip_attr::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void equip_attr::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void equip_attr::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void equip_attr::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 equip_attr::type() const {
  return type_;
}
inline void equip_attr::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 value = 2;
inline bool equip_attr::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void equip_attr::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void equip_attr::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void equip_attr::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 equip_attr::value() const {
  return value_;
}
inline void equip_attr::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// equip_smelt_box

// optional uint32 equip_smelt_value = 1;
inline bool equip_smelt_box::has_equip_smelt_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void equip_smelt_box::set_has_equip_smelt_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void equip_smelt_box::clear_has_equip_smelt_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void equip_smelt_box::clear_equip_smelt_value() {
  equip_smelt_value_ = 0u;
  clear_has_equip_smelt_value();
}
inline ::google::protobuf::uint32 equip_smelt_box::equip_smelt_value() const {
  return equip_smelt_value_;
}
inline void equip_smelt_box::set_equip_smelt_value(::google::protobuf::uint32 value) {
  set_has_equip_smelt_value();
  equip_smelt_value_ = value;
}

// optional uint32 state = 2;
inline bool equip_smelt_box::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void equip_smelt_box::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void equip_smelt_box::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void equip_smelt_box::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 equip_smelt_box::state() const {
  return state_;
}
inline void equip_smelt_box::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// world_cup_player

// optional string uid = 1;
inline bool world_cup_player::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void world_cup_player::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void world_cup_player::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void world_cup_player::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& world_cup_player::uid() const {
  return *uid_;
}
inline void world_cup_player::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_player::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_player::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_player::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* world_cup_player::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_player::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool world_cup_player::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void world_cup_player::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void world_cup_player::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void world_cup_player::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& world_cup_player::name() const {
  return *name_;
}
inline void world_cup_player::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void world_cup_player::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void world_cup_player::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_player::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* world_cup_player::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_player::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_id = 3;
inline bool world_cup_player::has_family_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void world_cup_player::set_has_family_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void world_cup_player::clear_has_family_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void world_cup_player::clear_family_id() {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    family_id_->clear();
  }
  clear_has_family_id();
}
inline const ::std::string& world_cup_player::family_id() const {
  return *family_id_;
}
inline void world_cup_player::set_family_id(const ::std::string& value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void world_cup_player::set_family_id(const char* value) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(value);
}
inline void world_cup_player::set_family_id(const char* value, size_t size) {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  family_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_player::mutable_family_id() {
  set_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    family_id_ = new ::std::string;
  }
  return family_id_;
}
inline ::std::string* world_cup_player::release_family_id() {
  clear_has_family_id();
  if (family_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_id_;
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_player::set_allocated_family_id(::std::string* family_id) {
  if (family_id_ != &::google::protobuf::internal::kEmptyString) {
    delete family_id_;
  }
  if (family_id) {
    set_has_family_id();
    family_id_ = family_id;
  } else {
    clear_has_family_id();
    family_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 4;
inline bool world_cup_player::has_family_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void world_cup_player::set_has_family_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void world_cup_player::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void world_cup_player::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& world_cup_player::family_name() const {
  return *family_name_;
}
inline void world_cup_player::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void world_cup_player::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void world_cup_player::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_player::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* world_cup_player::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_player::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// world_cup_battle

// optional string uid = 1;
inline bool world_cup_battle::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void world_cup_battle::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void world_cup_battle::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void world_cup_battle::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& world_cup_battle::uid() const {
  return *uid_;
}
inline void world_cup_battle::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_battle::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_battle::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_battle::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* world_cup_battle::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_battle::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 round = 2;
inline bool world_cup_battle::has_round() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void world_cup_battle::set_has_round() {
  _has_bits_[0] |= 0x00000002u;
}
inline void world_cup_battle::clear_has_round() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void world_cup_battle::clear_round() {
  round_ = 0u;
  clear_has_round();
}
inline ::google::protobuf::uint32 world_cup_battle::round() const {
  return round_;
}
inline void world_cup_battle::set_round(::google::protobuf::uint32 value) {
  set_has_round();
  round_ = value;
}

// optional uint32 battle_id = 3;
inline bool world_cup_battle::has_battle_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void world_cup_battle::set_has_battle_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void world_cup_battle::clear_has_battle_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void world_cup_battle::clear_battle_id() {
  battle_id_ = 0u;
  clear_has_battle_id();
}
inline ::google::protobuf::uint32 world_cup_battle::battle_id() const {
  return battle_id_;
}
inline void world_cup_battle::set_battle_id(::google::protobuf::uint32 value) {
  set_has_battle_id();
  battle_id_ = value;
}

// optional .proto.common.world_cup_player player_a = 4;
inline bool world_cup_battle::has_player_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void world_cup_battle::set_has_player_a() {
  _has_bits_[0] |= 0x00000008u;
}
inline void world_cup_battle::clear_has_player_a() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void world_cup_battle::clear_player_a() {
  if (player_a_ != NULL) player_a_->::proto::common::world_cup_player::Clear();
  clear_has_player_a();
}
inline const ::proto::common::world_cup_player& world_cup_battle::player_a() const {
  return player_a_ != NULL ? *player_a_ : *default_instance_->player_a_;
}
inline ::proto::common::world_cup_player* world_cup_battle::mutable_player_a() {
  set_has_player_a();
  if (player_a_ == NULL) player_a_ = new ::proto::common::world_cup_player;
  return player_a_;
}
inline ::proto::common::world_cup_player* world_cup_battle::release_player_a() {
  clear_has_player_a();
  ::proto::common::world_cup_player* temp = player_a_;
  player_a_ = NULL;
  return temp;
}
inline void world_cup_battle::set_allocated_player_a(::proto::common::world_cup_player* player_a) {
  delete player_a_;
  player_a_ = player_a;
  if (player_a) {
    set_has_player_a();
  } else {
    clear_has_player_a();
  }
}

// optional uint32 score_a = 5;
inline bool world_cup_battle::has_score_a() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void world_cup_battle::set_has_score_a() {
  _has_bits_[0] |= 0x00000010u;
}
inline void world_cup_battle::clear_has_score_a() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void world_cup_battle::clear_score_a() {
  score_a_ = 0u;
  clear_has_score_a();
}
inline ::google::protobuf::uint32 world_cup_battle::score_a() const {
  return score_a_;
}
inline void world_cup_battle::set_score_a(::google::protobuf::uint32 value) {
  set_has_score_a();
  score_a_ = value;
}

// optional .proto.common.world_cup_player player_b = 6;
inline bool world_cup_battle::has_player_b() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void world_cup_battle::set_has_player_b() {
  _has_bits_[0] |= 0x00000020u;
}
inline void world_cup_battle::clear_has_player_b() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void world_cup_battle::clear_player_b() {
  if (player_b_ != NULL) player_b_->::proto::common::world_cup_player::Clear();
  clear_has_player_b();
}
inline const ::proto::common::world_cup_player& world_cup_battle::player_b() const {
  return player_b_ != NULL ? *player_b_ : *default_instance_->player_b_;
}
inline ::proto::common::world_cup_player* world_cup_battle::mutable_player_b() {
  set_has_player_b();
  if (player_b_ == NULL) player_b_ = new ::proto::common::world_cup_player;
  return player_b_;
}
inline ::proto::common::world_cup_player* world_cup_battle::release_player_b() {
  clear_has_player_b();
  ::proto::common::world_cup_player* temp = player_b_;
  player_b_ = NULL;
  return temp;
}
inline void world_cup_battle::set_allocated_player_b(::proto::common::world_cup_player* player_b) {
  delete player_b_;
  player_b_ = player_b;
  if (player_b) {
    set_has_player_b();
  } else {
    clear_has_player_b();
  }
}

// optional uint32 score_b = 7;
inline bool world_cup_battle::has_score_b() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void world_cup_battle::set_has_score_b() {
  _has_bits_[0] |= 0x00000040u;
}
inline void world_cup_battle::clear_has_score_b() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void world_cup_battle::clear_score_b() {
  score_b_ = 0u;
  clear_has_score_b();
}
inline ::google::protobuf::uint32 world_cup_battle::score_b() const {
  return score_b_;
}
inline void world_cup_battle::set_score_b(::google::protobuf::uint32 value) {
  set_has_score_b();
  score_b_ = value;
}

// optional string winner = 8;
inline bool world_cup_battle::has_winner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void world_cup_battle::set_has_winner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void world_cup_battle::clear_has_winner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void world_cup_battle::clear_winner() {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    winner_->clear();
  }
  clear_has_winner();
}
inline const ::std::string& world_cup_battle::winner() const {
  return *winner_;
}
inline void world_cup_battle::set_winner(const ::std::string& value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void world_cup_battle::set_winner(const char* value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void world_cup_battle::set_winner(const char* value, size_t size) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_battle::mutable_winner() {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  return winner_;
}
inline ::std::string* world_cup_battle::release_winner() {
  clear_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winner_;
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_battle::set_allocated_winner(::std::string* winner) {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    delete winner_;
  }
  if (winner) {
    set_has_winner();
    winner_ = winner;
  } else {
    clear_has_winner();
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 9;
inline bool world_cup_battle::has_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void world_cup_battle::set_has_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void world_cup_battle::clear_has_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void world_cup_battle::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 world_cup_battle::state() const {
  return state_;
}
inline void world_cup_battle::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional .proto.common.world_cup_bet self_bet = 12;
inline bool world_cup_battle::has_self_bet() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void world_cup_battle::set_has_self_bet() {
  _has_bits_[0] |= 0x00000200u;
}
inline void world_cup_battle::clear_has_self_bet() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void world_cup_battle::clear_self_bet() {
  if (self_bet_ != NULL) self_bet_->::proto::common::world_cup_bet::Clear();
  clear_has_self_bet();
}
inline const ::proto::common::world_cup_bet& world_cup_battle::self_bet() const {
  return self_bet_ != NULL ? *self_bet_ : *default_instance_->self_bet_;
}
inline ::proto::common::world_cup_bet* world_cup_battle::mutable_self_bet() {
  set_has_self_bet();
  if (self_bet_ == NULL) self_bet_ = new ::proto::common::world_cup_bet;
  return self_bet_;
}
inline ::proto::common::world_cup_bet* world_cup_battle::release_self_bet() {
  clear_has_self_bet();
  ::proto::common::world_cup_bet* temp = self_bet_;
  self_bet_ = NULL;
  return temp;
}
inline void world_cup_battle::set_allocated_self_bet(::proto::common::world_cup_bet* self_bet) {
  delete self_bet_;
  self_bet_ = self_bet;
  if (self_bet) {
    set_has_self_bet();
  } else {
    clear_has_self_bet();
  }
}

// -------------------------------------------------------------------

// world_cup_data

// optional uint32 season = 1;
inline bool world_cup_data::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void world_cup_data::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void world_cup_data::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void world_cup_data::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 world_cup_data::season() const {
  return season_;
}
inline void world_cup_data::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// repeated .proto.common.world_cup_battle battle_list = 2;
inline int world_cup_data::battle_list_size() const {
  return battle_list_.size();
}
inline void world_cup_data::clear_battle_list() {
  battle_list_.Clear();
}
inline const ::proto::common::world_cup_battle& world_cup_data::battle_list(int index) const {
  return battle_list_.Get(index);
}
inline ::proto::common::world_cup_battle* world_cup_data::mutable_battle_list(int index) {
  return battle_list_.Mutable(index);
}
inline ::proto::common::world_cup_battle* world_cup_data::add_battle_list() {
  return battle_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::world_cup_battle >&
world_cup_data::battle_list() const {
  return battle_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::world_cup_battle >*
world_cup_data::mutable_battle_list() {
  return &battle_list_;
}

// -------------------------------------------------------------------

// world_cup_bet

// optional string uid = 1;
inline bool world_cup_bet::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void world_cup_bet::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void world_cup_bet::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void world_cup_bet::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& world_cup_bet::uid() const {
  return *uid_;
}
inline void world_cup_bet::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_bet::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void world_cup_bet::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_bet::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* world_cup_bet::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_bet::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string battle_uid = 2;
inline bool world_cup_bet::has_battle_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void world_cup_bet::set_has_battle_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void world_cup_bet::clear_has_battle_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void world_cup_bet::clear_battle_uid() {
  if (battle_uid_ != &::google::protobuf::internal::kEmptyString) {
    battle_uid_->clear();
  }
  clear_has_battle_uid();
}
inline const ::std::string& world_cup_bet::battle_uid() const {
  return *battle_uid_;
}
inline void world_cup_bet::set_battle_uid(const ::std::string& value) {
  set_has_battle_uid();
  if (battle_uid_ == &::google::protobuf::internal::kEmptyString) {
    battle_uid_ = new ::std::string;
  }
  battle_uid_->assign(value);
}
inline void world_cup_bet::set_battle_uid(const char* value) {
  set_has_battle_uid();
  if (battle_uid_ == &::google::protobuf::internal::kEmptyString) {
    battle_uid_ = new ::std::string;
  }
  battle_uid_->assign(value);
}
inline void world_cup_bet::set_battle_uid(const char* value, size_t size) {
  set_has_battle_uid();
  if (battle_uid_ == &::google::protobuf::internal::kEmptyString) {
    battle_uid_ = new ::std::string;
  }
  battle_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_bet::mutable_battle_uid() {
  set_has_battle_uid();
  if (battle_uid_ == &::google::protobuf::internal::kEmptyString) {
    battle_uid_ = new ::std::string;
  }
  return battle_uid_;
}
inline ::std::string* world_cup_bet::release_battle_uid() {
  clear_has_battle_uid();
  if (battle_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = battle_uid_;
    battle_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_bet::set_allocated_battle_uid(::std::string* battle_uid) {
  if (battle_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete battle_uid_;
  }
  if (battle_uid) {
    set_has_battle_uid();
    battle_uid_ = battle_uid;
  } else {
    clear_has_battle_uid();
    battle_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string player_uid = 3;
inline bool world_cup_bet::has_player_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void world_cup_bet::set_has_player_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void world_cup_bet::clear_has_player_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void world_cup_bet::clear_player_uid() {
  if (player_uid_ != &::google::protobuf::internal::kEmptyString) {
    player_uid_->clear();
  }
  clear_has_player_uid();
}
inline const ::std::string& world_cup_bet::player_uid() const {
  return *player_uid_;
}
inline void world_cup_bet::set_player_uid(const ::std::string& value) {
  set_has_player_uid();
  if (player_uid_ == &::google::protobuf::internal::kEmptyString) {
    player_uid_ = new ::std::string;
  }
  player_uid_->assign(value);
}
inline void world_cup_bet::set_player_uid(const char* value) {
  set_has_player_uid();
  if (player_uid_ == &::google::protobuf::internal::kEmptyString) {
    player_uid_ = new ::std::string;
  }
  player_uid_->assign(value);
}
inline void world_cup_bet::set_player_uid(const char* value, size_t size) {
  set_has_player_uid();
  if (player_uid_ == &::google::protobuf::internal::kEmptyString) {
    player_uid_ = new ::std::string;
  }
  player_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_bet::mutable_player_uid() {
  set_has_player_uid();
  if (player_uid_ == &::google::protobuf::internal::kEmptyString) {
    player_uid_ = new ::std::string;
  }
  return player_uid_;
}
inline ::std::string* world_cup_bet::release_player_uid() {
  clear_has_player_uid();
  if (player_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = player_uid_;
    player_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_bet::set_allocated_player_uid(::std::string* player_uid) {
  if (player_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete player_uid_;
  }
  if (player_uid) {
    set_has_player_uid();
    player_uid_ = player_uid;
  } else {
    clear_has_player_uid();
    player_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string winner = 4;
inline bool world_cup_bet::has_winner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void world_cup_bet::set_has_winner() {
  _has_bits_[0] |= 0x00000008u;
}
inline void world_cup_bet::clear_has_winner() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void world_cup_bet::clear_winner() {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    winner_->clear();
  }
  clear_has_winner();
}
inline const ::std::string& world_cup_bet::winner() const {
  return *winner_;
}
inline void world_cup_bet::set_winner(const ::std::string& value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void world_cup_bet::set_winner(const char* value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void world_cup_bet::set_winner(const char* value, size_t size) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* world_cup_bet::mutable_winner() {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  return winner_;
}
inline ::std::string* world_cup_bet::release_winner() {
  clear_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winner_;
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void world_cup_bet::set_allocated_winner(::std::string* winner) {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    delete winner_;
  }
  if (winner) {
    set_has_winner();
    winner_ = winner;
  } else {
    clear_has_winner();
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 odds = 5;
inline bool world_cup_bet::has_odds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void world_cup_bet::set_has_odds() {
  _has_bits_[0] |= 0x00000010u;
}
inline void world_cup_bet::clear_has_odds() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void world_cup_bet::clear_odds() {
  odds_ = 0u;
  clear_has_odds();
}
inline ::google::protobuf::uint32 world_cup_bet::odds() const {
  return odds_;
}
inline void world_cup_bet::set_odds(::google::protobuf::uint32 value) {
  set_has_odds();
  odds_ = value;
}

// optional uint32 bet = 6;
inline bool world_cup_bet::has_bet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void world_cup_bet::set_has_bet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void world_cup_bet::clear_has_bet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void world_cup_bet::clear_bet() {
  bet_ = 0u;
  clear_has_bet();
}
inline ::google::protobuf::uint32 world_cup_bet::bet() const {
  return bet_;
}
inline void world_cup_bet::set_bet(::google::protobuf::uint32 value) {
  set_has_bet();
  bet_ = value;
}

// optional uint32 result = 7;
inline bool world_cup_bet::has_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void world_cup_bet::set_has_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void world_cup_bet::clear_has_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void world_cup_bet::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 world_cup_bet::result() const {
  return result_;
}
inline void world_cup_bet::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// optional uint32 state = 8;
inline bool world_cup_bet::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void world_cup_bet::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void world_cup_bet::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void world_cup_bet::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 world_cup_bet::state() const {
  return state_;
}
inline void world_cup_bet::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// world_cup_odds

// optional uint32 odds_a = 1;
inline bool world_cup_odds::has_odds_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void world_cup_odds::set_has_odds_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void world_cup_odds::clear_has_odds_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void world_cup_odds::clear_odds_a() {
  odds_a_ = 0u;
  clear_has_odds_a();
}
inline ::google::protobuf::uint32 world_cup_odds::odds_a() const {
  return odds_a_;
}
inline void world_cup_odds::set_odds_a(::google::protobuf::uint32 value) {
  set_has_odds_a();
  odds_a_ = value;
}

// optional uint32 odds_b = 2;
inline bool world_cup_odds::has_odds_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void world_cup_odds::set_has_odds_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void world_cup_odds::clear_has_odds_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void world_cup_odds::clear_odds_b() {
  odds_b_ = 0u;
  clear_has_odds_b();
}
inline ::google::protobuf::uint32 world_cup_odds::odds_b() const {
  return odds_b_;
}
inline void world_cup_odds::set_odds_b(::google::protobuf::uint32 value) {
  set_has_odds_b();
  odds_b_ = value;
}

// optional uint32 bet_a = 3;
inline bool world_cup_odds::has_bet_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void world_cup_odds::set_has_bet_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void world_cup_odds::clear_has_bet_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void world_cup_odds::clear_bet_a() {
  bet_a_ = 0u;
  clear_has_bet_a();
}
inline ::google::protobuf::uint32 world_cup_odds::bet_a() const {
  return bet_a_;
}
inline void world_cup_odds::set_bet_a(::google::protobuf::uint32 value) {
  set_has_bet_a();
  bet_a_ = value;
}

// optional uint32 bet_b = 4;
inline bool world_cup_odds::has_bet_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void world_cup_odds::set_has_bet_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void world_cup_odds::clear_has_bet_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void world_cup_odds::clear_bet_b() {
  bet_b_ = 0u;
  clear_has_bet_b();
}
inline ::google::protobuf::uint32 world_cup_odds::bet_b() const {
  return bet_b_;
}
inline void world_cup_odds::set_bet_b(::google::protobuf::uint32 value) {
  set_has_bet_b();
  bet_b_ = value;
}

// optional uint32 vote_a = 5;
inline bool world_cup_odds::has_vote_a() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void world_cup_odds::set_has_vote_a() {
  _has_bits_[0] |= 0x00000010u;
}
inline void world_cup_odds::clear_has_vote_a() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void world_cup_odds::clear_vote_a() {
  vote_a_ = 0u;
  clear_has_vote_a();
}
inline ::google::protobuf::uint32 world_cup_odds::vote_a() const {
  return vote_a_;
}
inline void world_cup_odds::set_vote_a(::google::protobuf::uint32 value) {
  set_has_vote_a();
  vote_a_ = value;
}

// optional uint32 vote_b = 6;
inline bool world_cup_odds::has_vote_b() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void world_cup_odds::set_has_vote_b() {
  _has_bits_[0] |= 0x00000020u;
}
inline void world_cup_odds::clear_has_vote_b() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void world_cup_odds::clear_vote_b() {
  vote_b_ = 0u;
  clear_has_vote_b();
}
inline ::google::protobuf::uint32 world_cup_odds::vote_b() const {
  return vote_b_;
}
inline void world_cup_odds::set_vote_b(::google::protobuf::uint32 value) {
  set_has_vote_b();
  vote_b_ = value;
}

// -------------------------------------------------------------------

// achieve_finish_info_single

// optional uint32 level = 1;
inline bool achieve_finish_info_single::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void achieve_finish_info_single::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void achieve_finish_info_single::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void achieve_finish_info_single::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 achieve_finish_info_single::level() const {
  return level_;
}
inline void achieve_finish_info_single::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 time = 2;
inline bool achieve_finish_info_single::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void achieve_finish_info_single::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void achieve_finish_info_single::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void achieve_finish_info_single::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 achieve_finish_info_single::time() const {
  return time_;
}
inline void achieve_finish_info_single::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// achieve_finish_info

// repeated .proto.common.achieve_finish_info_single achieve_finish_info_list = 1;
inline int achieve_finish_info::achieve_finish_info_list_size() const {
  return achieve_finish_info_list_.size();
}
inline void achieve_finish_info::clear_achieve_finish_info_list() {
  achieve_finish_info_list_.Clear();
}
inline const ::proto::common::achieve_finish_info_single& achieve_finish_info::achieve_finish_info_list(int index) const {
  return achieve_finish_info_list_.Get(index);
}
inline ::proto::common::achieve_finish_info_single* achieve_finish_info::mutable_achieve_finish_info_list(int index) {
  return achieve_finish_info_list_.Mutable(index);
}
inline ::proto::common::achieve_finish_info_single* achieve_finish_info::add_achieve_finish_info_list() {
  return achieve_finish_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_finish_info_single >&
achieve_finish_info::achieve_finish_info_list() const {
  return achieve_finish_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_finish_info_single >*
achieve_finish_info::mutable_achieve_finish_info_list() {
  return &achieve_finish_info_list_;
}

// -------------------------------------------------------------------

// achieve_record_single

// optional uint32 tid = 1;
inline bool achieve_record_single::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void achieve_record_single::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void achieve_record_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void achieve_record_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 achieve_record_single::tid() const {
  return tid_;
}
inline void achieve_record_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional string achieve_person_record = 2;
inline bool achieve_record_single::has_achieve_person_record() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void achieve_record_single::set_has_achieve_person_record() {
  _has_bits_[0] |= 0x00000002u;
}
inline void achieve_record_single::clear_has_achieve_person_record() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void achieve_record_single::clear_achieve_person_record() {
  if (achieve_person_record_ != &::google::protobuf::internal::kEmptyString) {
    achieve_person_record_->clear();
  }
  clear_has_achieve_person_record();
}
inline const ::std::string& achieve_record_single::achieve_person_record() const {
  return *achieve_person_record_;
}
inline void achieve_record_single::set_achieve_person_record(const ::std::string& value) {
  set_has_achieve_person_record();
  if (achieve_person_record_ == &::google::protobuf::internal::kEmptyString) {
    achieve_person_record_ = new ::std::string;
  }
  achieve_person_record_->assign(value);
}
inline void achieve_record_single::set_achieve_person_record(const char* value) {
  set_has_achieve_person_record();
  if (achieve_person_record_ == &::google::protobuf::internal::kEmptyString) {
    achieve_person_record_ = new ::std::string;
  }
  achieve_person_record_->assign(value);
}
inline void achieve_record_single::set_achieve_person_record(const char* value, size_t size) {
  set_has_achieve_person_record();
  if (achieve_person_record_ == &::google::protobuf::internal::kEmptyString) {
    achieve_person_record_ = new ::std::string;
  }
  achieve_person_record_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* achieve_record_single::mutable_achieve_person_record() {
  set_has_achieve_person_record();
  if (achieve_person_record_ == &::google::protobuf::internal::kEmptyString) {
    achieve_person_record_ = new ::std::string;
  }
  return achieve_person_record_;
}
inline ::std::string* achieve_record_single::release_achieve_person_record() {
  clear_has_achieve_person_record();
  if (achieve_person_record_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = achieve_person_record_;
    achieve_person_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void achieve_record_single::set_allocated_achieve_person_record(::std::string* achieve_person_record) {
  if (achieve_person_record_ != &::google::protobuf::internal::kEmptyString) {
    delete achieve_person_record_;
  }
  if (achieve_person_record) {
    set_has_achieve_person_record();
    achieve_person_record_ = achieve_person_record;
  } else {
    clear_has_achieve_person_record();
    achieve_person_record_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// achieve_record

// repeated .proto.common.achieve_record_single achieve_record_list = 1;
inline int achieve_record::achieve_record_list_size() const {
  return achieve_record_list_.size();
}
inline void achieve_record::clear_achieve_record_list() {
  achieve_record_list_.Clear();
}
inline const ::proto::common::achieve_record_single& achieve_record::achieve_record_list(int index) const {
  return achieve_record_list_.Get(index);
}
inline ::proto::common::achieve_record_single* achieve_record::mutable_achieve_record_list(int index) {
  return achieve_record_list_.Mutable(index);
}
inline ::proto::common::achieve_record_single* achieve_record::add_achieve_record_list() {
  return achieve_record_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_record_single >&
achieve_record::achieve_record_list() const {
  return achieve_record_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_record_single >*
achieve_record::mutable_achieve_record_list() {
  return &achieve_record_list_;
}

// -------------------------------------------------------------------

// achieve_data_single

// optional string uid = 1;
inline bool achieve_data_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void achieve_data_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void achieve_data_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void achieve_data_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& achieve_data_single::uid() const {
  return *uid_;
}
inline void achieve_data_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void achieve_data_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void achieve_data_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* achieve_data_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* achieve_data_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void achieve_data_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool achieve_data_single::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void achieve_data_single::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void achieve_data_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void achieve_data_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 achieve_data_single::tid() const {
  return tid_;
}
inline void achieve_data_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 level = 3;
inline bool achieve_data_single::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void achieve_data_single::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void achieve_data_single::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void achieve_data_single::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 achieve_data_single::level() const {
  return level_;
}
inline void achieve_data_single::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 count = 4;
inline bool achieve_data_single::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void achieve_data_single::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void achieve_data_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void achieve_data_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 achieve_data_single::count() const {
  return count_;
}
inline void achieve_data_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional string finish_info_list = 5;
inline bool achieve_data_single::has_finish_info_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void achieve_data_single::set_has_finish_info_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void achieve_data_single::clear_has_finish_info_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void achieve_data_single::clear_finish_info_list() {
  if (finish_info_list_ != &::google::protobuf::internal::kEmptyString) {
    finish_info_list_->clear();
  }
  clear_has_finish_info_list();
}
inline const ::std::string& achieve_data_single::finish_info_list() const {
  return *finish_info_list_;
}
inline void achieve_data_single::set_finish_info_list(const ::std::string& value) {
  set_has_finish_info_list();
  if (finish_info_list_ == &::google::protobuf::internal::kEmptyString) {
    finish_info_list_ = new ::std::string;
  }
  finish_info_list_->assign(value);
}
inline void achieve_data_single::set_finish_info_list(const char* value) {
  set_has_finish_info_list();
  if (finish_info_list_ == &::google::protobuf::internal::kEmptyString) {
    finish_info_list_ = new ::std::string;
  }
  finish_info_list_->assign(value);
}
inline void achieve_data_single::set_finish_info_list(const char* value, size_t size) {
  set_has_finish_info_list();
  if (finish_info_list_ == &::google::protobuf::internal::kEmptyString) {
    finish_info_list_ = new ::std::string;
  }
  finish_info_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* achieve_data_single::mutable_finish_info_list() {
  set_has_finish_info_list();
  if (finish_info_list_ == &::google::protobuf::internal::kEmptyString) {
    finish_info_list_ = new ::std::string;
  }
  return finish_info_list_;
}
inline ::std::string* achieve_data_single::release_finish_info_list() {
  clear_has_finish_info_list();
  if (finish_info_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finish_info_list_;
    finish_info_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void achieve_data_single::set_allocated_finish_info_list(::std::string* finish_info_list) {
  if (finish_info_list_ != &::google::protobuf::internal::kEmptyString) {
    delete finish_info_list_;
  }
  if (finish_info_list) {
    set_has_finish_info_list();
    finish_info_list_ = finish_info_list;
  } else {
    clear_has_finish_info_list();
    finish_info_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.achieve_finish_info finish_list = 6;
inline bool achieve_data_single::has_finish_list() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void achieve_data_single::set_has_finish_list() {
  _has_bits_[0] |= 0x00000020u;
}
inline void achieve_data_single::clear_has_finish_list() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void achieve_data_single::clear_finish_list() {
  if (finish_list_ != NULL) finish_list_->::proto::common::achieve_finish_info::Clear();
  clear_has_finish_list();
}
inline const ::proto::common::achieve_finish_info& achieve_data_single::finish_list() const {
  return finish_list_ != NULL ? *finish_list_ : *default_instance_->finish_list_;
}
inline ::proto::common::achieve_finish_info* achieve_data_single::mutable_finish_list() {
  set_has_finish_list();
  if (finish_list_ == NULL) finish_list_ = new ::proto::common::achieve_finish_info;
  return finish_list_;
}
inline ::proto::common::achieve_finish_info* achieve_data_single::release_finish_list() {
  clear_has_finish_list();
  ::proto::common::achieve_finish_info* temp = finish_list_;
  finish_list_ = NULL;
  return temp;
}
inline void achieve_data_single::set_allocated_finish_list(::proto::common::achieve_finish_info* finish_list) {
  delete finish_list_;
  finish_list_ = finish_list;
  if (finish_list) {
    set_has_finish_list();
  } else {
    clear_has_finish_list();
  }
}

// -------------------------------------------------------------------

// achieve_data

// repeated .proto.common.achieve_data_single achieve_data_list = 1;
inline int achieve_data::achieve_data_list_size() const {
  return achieve_data_list_.size();
}
inline void achieve_data::clear_achieve_data_list() {
  achieve_data_list_.Clear();
}
inline const ::proto::common::achieve_data_single& achieve_data::achieve_data_list(int index) const {
  return achieve_data_list_.Get(index);
}
inline ::proto::common::achieve_data_single* achieve_data::mutable_achieve_data_list(int index) {
  return achieve_data_list_.Mutable(index);
}
inline ::proto::common::achieve_data_single* achieve_data::add_achieve_data_list() {
  return achieve_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_data_single >&
achieve_data::achieve_data_list() const {
  return achieve_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::achieve_data_single >*
achieve_data::mutable_achieve_data_list() {
  return &achieve_data_list_;
}

// -------------------------------------------------------------------

// tower_trigger

// optional string uid = 1;
inline bool tower_trigger::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tower_trigger::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tower_trigger::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tower_trigger::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& tower_trigger::uid() const {
  return *uid_;
}
inline void tower_trigger::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void tower_trigger::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void tower_trigger::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tower_trigger::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* tower_trigger::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tower_trigger::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool tower_trigger::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tower_trigger::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tower_trigger::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tower_trigger::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 tower_trigger::tid() const {
  return tid_;
}
inline void tower_trigger::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional string finder_name = 3;
inline bool tower_trigger::has_finder_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tower_trigger::set_has_finder_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tower_trigger::clear_has_finder_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tower_trigger::clear_finder_name() {
  if (finder_name_ != &::google::protobuf::internal::kEmptyString) {
    finder_name_->clear();
  }
  clear_has_finder_name();
}
inline const ::std::string& tower_trigger::finder_name() const {
  return *finder_name_;
}
inline void tower_trigger::set_finder_name(const ::std::string& value) {
  set_has_finder_name();
  if (finder_name_ == &::google::protobuf::internal::kEmptyString) {
    finder_name_ = new ::std::string;
  }
  finder_name_->assign(value);
}
inline void tower_trigger::set_finder_name(const char* value) {
  set_has_finder_name();
  if (finder_name_ == &::google::protobuf::internal::kEmptyString) {
    finder_name_ = new ::std::string;
  }
  finder_name_->assign(value);
}
inline void tower_trigger::set_finder_name(const char* value, size_t size) {
  set_has_finder_name();
  if (finder_name_ == &::google::protobuf::internal::kEmptyString) {
    finder_name_ = new ::std::string;
  }
  finder_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* tower_trigger::mutable_finder_name() {
  set_has_finder_name();
  if (finder_name_ == &::google::protobuf::internal::kEmptyString) {
    finder_name_ = new ::std::string;
  }
  return finder_name_;
}
inline ::std::string* tower_trigger::release_finder_name() {
  clear_has_finder_name();
  if (finder_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finder_name_;
    finder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void tower_trigger::set_allocated_finder_name(::std::string* finder_name) {
  if (finder_name_ != &::google::protobuf::internal::kEmptyString) {
    delete finder_name_;
  }
  if (finder_name) {
    set_has_finder_name();
    finder_name_ = finder_name;
  } else {
    clear_has_finder_name();
    finder_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 expired_time = 4;
inline bool tower_trigger::has_expired_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tower_trigger::set_has_expired_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tower_trigger::clear_has_expired_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tower_trigger::clear_expired_time() {
  expired_time_ = 0u;
  clear_has_expired_time();
}
inline ::google::protobuf::uint32 tower_trigger::expired_time() const {
  return expired_time_;
}
inline void tower_trigger::set_expired_time(::google::protobuf::uint32 value) {
  set_has_expired_time();
  expired_time_ = value;
}

// -------------------------------------------------------------------

// tower_trigger_data

// repeated .proto.common.tower_trigger self_trigger = 1;
inline int tower_trigger_data::self_trigger_size() const {
  return self_trigger_.size();
}
inline void tower_trigger_data::clear_self_trigger() {
  self_trigger_.Clear();
}
inline const ::proto::common::tower_trigger& tower_trigger_data::self_trigger(int index) const {
  return self_trigger_.Get(index);
}
inline ::proto::common::tower_trigger* tower_trigger_data::mutable_self_trigger(int index) {
  return self_trigger_.Mutable(index);
}
inline ::proto::common::tower_trigger* tower_trigger_data::add_self_trigger() {
  return self_trigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >&
tower_trigger_data::self_trigger() const {
  return self_trigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >*
tower_trigger_data::mutable_self_trigger() {
  return &self_trigger_;
}

// repeated .proto.common.tower_trigger other_trigger = 2;
inline int tower_trigger_data::other_trigger_size() const {
  return other_trigger_.size();
}
inline void tower_trigger_data::clear_other_trigger() {
  other_trigger_.Clear();
}
inline const ::proto::common::tower_trigger& tower_trigger_data::other_trigger(int index) const {
  return other_trigger_.Get(index);
}
inline ::proto::common::tower_trigger* tower_trigger_data::mutable_other_trigger(int index) {
  return other_trigger_.Mutable(index);
}
inline ::proto::common::tower_trigger* tower_trigger_data::add_other_trigger() {
  return other_trigger_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >&
tower_trigger_data::other_trigger() const {
  return other_trigger_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::tower_trigger >*
tower_trigger_data::mutable_other_trigger() {
  return &other_trigger_;
}

// -------------------------------------------------------------------

// tower_data

// optional uint32 record_tower = 1;
inline bool tower_data::has_record_tower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tower_data::set_has_record_tower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tower_data::clear_has_record_tower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tower_data::clear_record_tower() {
  record_tower_ = 0u;
  clear_has_record_tower();
}
inline ::google::protobuf::uint32 tower_data::record_tower() const {
  return record_tower_;
}
inline void tower_data::set_record_tower(::google::protobuf::uint32 value) {
  set_has_record_tower();
  record_tower_ = value;
}

// optional uint32 current_tower = 2;
inline bool tower_data::has_current_tower() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tower_data::set_has_current_tower() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tower_data::clear_has_current_tower() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tower_data::clear_current_tower() {
  current_tower_ = 0u;
  clear_has_current_tower();
}
inline ::google::protobuf::uint32 tower_data::current_tower() const {
  return current_tower_;
}
inline void tower_data::set_current_tower(::google::protobuf::uint32 value) {
  set_has_current_tower();
  current_tower_ = value;
}

// optional uint32 reset_count = 3;
inline bool tower_data::has_reset_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tower_data::set_has_reset_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tower_data::clear_has_reset_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tower_data::clear_reset_count() {
  reset_count_ = 0u;
  clear_has_reset_count();
}
inline ::google::protobuf::uint32 tower_data::reset_count() const {
  return reset_count_;
}
inline void tower_data::set_reset_count(::google::protobuf::uint32 value) {
  set_has_reset_count();
  reset_count_ = value;
}

// optional uint32 max_reset_count = 4;
inline bool tower_data::has_max_reset_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tower_data::set_has_max_reset_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tower_data::clear_has_max_reset_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tower_data::clear_max_reset_count() {
  max_reset_count_ = 0u;
  clear_has_max_reset_count();
}
inline ::google::protobuf::uint32 tower_data::max_reset_count() const {
  return max_reset_count_;
}
inline void tower_data::set_max_reset_count(::google::protobuf::uint32 value) {
  set_has_max_reset_count();
  max_reset_count_ = value;
}

// optional uint32 auto_fight_time = 5;
inline bool tower_data::has_auto_fight_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tower_data::set_has_auto_fight_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tower_data::clear_has_auto_fight_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tower_data::clear_auto_fight_time() {
  auto_fight_time_ = 0u;
  clear_has_auto_fight_time();
}
inline ::google::protobuf::uint32 tower_data::auto_fight_time() const {
  return auto_fight_time_;
}
inline void tower_data::set_auto_fight_time(::google::protobuf::uint32 value) {
  set_has_auto_fight_time();
  auto_fight_time_ = value;
}

// optional uint32 current_achieve = 6;
inline bool tower_data::has_current_achieve() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tower_data::set_has_current_achieve() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tower_data::clear_has_current_achieve() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tower_data::clear_current_achieve() {
  current_achieve_ = 0u;
  clear_has_current_achieve();
}
inline ::google::protobuf::uint32 tower_data::current_achieve() const {
  return current_achieve_;
}
inline void tower_data::set_current_achieve(::google::protobuf::uint32 value) {
  set_has_current_achieve();
  current_achieve_ = value;
}

// optional uint32 first_day = 7;
inline bool tower_data::has_first_day() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tower_data::set_has_first_day() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tower_data::clear_has_first_day() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tower_data::clear_first_day() {
  first_day_ = 0u;
  clear_has_first_day();
}
inline ::google::protobuf::uint32 tower_data::first_day() const {
  return first_day_;
}
inline void tower_data::set_first_day(::google::protobuf::uint32 value) {
  set_has_first_day();
  first_day_ = value;
}

// optional .proto.common.tower_trigger_data tower_trigger = 8;
inline bool tower_data::has_tower_trigger() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tower_data::set_has_tower_trigger() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tower_data::clear_has_tower_trigger() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tower_data::clear_tower_trigger() {
  if (tower_trigger_ != NULL) tower_trigger_->::proto::common::tower_trigger_data::Clear();
  clear_has_tower_trigger();
}
inline const ::proto::common::tower_trigger_data& tower_data::tower_trigger() const {
  return tower_trigger_ != NULL ? *tower_trigger_ : *default_instance_->tower_trigger_;
}
inline ::proto::common::tower_trigger_data* tower_data::mutable_tower_trigger() {
  set_has_tower_trigger();
  if (tower_trigger_ == NULL) tower_trigger_ = new ::proto::common::tower_trigger_data;
  return tower_trigger_;
}
inline ::proto::common::tower_trigger_data* tower_data::release_tower_trigger() {
  clear_has_tower_trigger();
  ::proto::common::tower_trigger_data* temp = tower_trigger_;
  tower_trigger_ = NULL;
  return temp;
}
inline void tower_data::set_allocated_tower_trigger(::proto::common::tower_trigger_data* tower_trigger) {
  delete tower_trigger_;
  tower_trigger_ = tower_trigger;
  if (tower_trigger) {
    set_has_tower_trigger();
  } else {
    clear_has_tower_trigger();
  }
}

// optional uint32 trigger_count = 9;
inline bool tower_data::has_trigger_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tower_data::set_has_trigger_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tower_data::clear_has_trigger_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tower_data::clear_trigger_count() {
  trigger_count_ = 0u;
  clear_has_trigger_count();
}
inline ::google::protobuf::uint32 tower_data::trigger_count() const {
  return trigger_count_;
}
inline void tower_data::set_trigger_count(::google::protobuf::uint32 value) {
  set_has_trigger_count();
  trigger_count_ = value;
}

// optional uint32 trigger_fight_count = 10;
inline bool tower_data::has_trigger_fight_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void tower_data::set_has_trigger_fight_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void tower_data::clear_has_trigger_fight_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void tower_data::clear_trigger_fight_count() {
  trigger_fight_count_ = 0u;
  clear_has_trigger_fight_count();
}
inline ::google::protobuf::uint32 tower_data::trigger_fight_count() const {
  return trigger_fight_count_;
}
inline void tower_data::set_trigger_fight_count(::google::protobuf::uint32 value) {
  set_has_trigger_fight_count();
  trigger_fight_count_ = value;
}

// optional uint32 send_mail_flag = 11;
inline bool tower_data::has_send_mail_flag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void tower_data::set_has_send_mail_flag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void tower_data::clear_has_send_mail_flag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void tower_data::clear_send_mail_flag() {
  send_mail_flag_ = 0u;
  clear_has_send_mail_flag();
}
inline ::google::protobuf::uint32 tower_data::send_mail_flag() const {
  return send_mail_flag_;
}
inline void tower_data::set_send_mail_flag(::google::protobuf::uint32 value) {
  set_has_send_mail_flag();
  send_mail_flag_ = value;
}

// -------------------------------------------------------------------

// red_point_single

// optional .proto.common.RED_POINT_TYPE red_type = 1;
inline bool red_point_single::has_red_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void red_point_single::set_has_red_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void red_point_single::clear_has_red_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void red_point_single::clear_red_type() {
  red_type_ = 0;
  clear_has_red_type();
}
inline ::proto::common::RED_POINT_TYPE red_point_single::red_type() const {
  return static_cast< ::proto::common::RED_POINT_TYPE >(red_type_);
}
inline void red_point_single::set_red_type(::proto::common::RED_POINT_TYPE value) {
  assert(::proto::common::RED_POINT_TYPE_IsValid(value));
  set_has_red_type();
  red_type_ = value;
}

// optional uint32 red_point_state = 2;
inline bool red_point_single::has_red_point_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void red_point_single::set_has_red_point_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void red_point_single::clear_has_red_point_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void red_point_single::clear_red_point_state() {
  red_point_state_ = 0u;
  clear_has_red_point_state();
}
inline ::google::protobuf::uint32 red_point_single::red_point_state() const {
  return red_point_state_;
}
inline void red_point_single::set_red_point_state(::google::protobuf::uint32 value) {
  set_has_red_point_state();
  red_point_state_ = value;
}

// optional string red_point_send_list = 3;
inline bool red_point_single::has_red_point_send_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void red_point_single::set_has_red_point_send_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void red_point_single::clear_has_red_point_send_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void red_point_single::clear_red_point_send_list() {
  if (red_point_send_list_ != &::google::protobuf::internal::kEmptyString) {
    red_point_send_list_->clear();
  }
  clear_has_red_point_send_list();
}
inline const ::std::string& red_point_single::red_point_send_list() const {
  return *red_point_send_list_;
}
inline void red_point_single::set_red_point_send_list(const ::std::string& value) {
  set_has_red_point_send_list();
  if (red_point_send_list_ == &::google::protobuf::internal::kEmptyString) {
    red_point_send_list_ = new ::std::string;
  }
  red_point_send_list_->assign(value);
}
inline void red_point_single::set_red_point_send_list(const char* value) {
  set_has_red_point_send_list();
  if (red_point_send_list_ == &::google::protobuf::internal::kEmptyString) {
    red_point_send_list_ = new ::std::string;
  }
  red_point_send_list_->assign(value);
}
inline void red_point_single::set_red_point_send_list(const char* value, size_t size) {
  set_has_red_point_send_list();
  if (red_point_send_list_ == &::google::protobuf::internal::kEmptyString) {
    red_point_send_list_ = new ::std::string;
  }
  red_point_send_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* red_point_single::mutable_red_point_send_list() {
  set_has_red_point_send_list();
  if (red_point_send_list_ == &::google::protobuf::internal::kEmptyString) {
    red_point_send_list_ = new ::std::string;
  }
  return red_point_send_list_;
}
inline ::std::string* red_point_single::release_red_point_send_list() {
  clear_has_red_point_send_list();
  if (red_point_send_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = red_point_send_list_;
    red_point_send_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void red_point_single::set_allocated_red_point_send_list(::std::string* red_point_send_list) {
  if (red_point_send_list_ != &::google::protobuf::internal::kEmptyString) {
    delete red_point_send_list_;
  }
  if (red_point_send_list) {
    set_has_red_point_send_list();
    red_point_send_list_ = red_point_send_list;
  } else {
    clear_has_red_point_send_list();
    red_point_send_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// red_point_data

// repeated .proto.common.red_point_single red_info_list = 1;
inline int red_point_data::red_info_list_size() const {
  return red_info_list_.size();
}
inline void red_point_data::clear_red_info_list() {
  red_info_list_.Clear();
}
inline const ::proto::common::red_point_single& red_point_data::red_info_list(int index) const {
  return red_info_list_.Get(index);
}
inline ::proto::common::red_point_single* red_point_data::mutable_red_info_list(int index) {
  return red_info_list_.Mutable(index);
}
inline ::proto::common::red_point_single* red_point_data::add_red_info_list() {
  return red_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::red_point_single >&
red_point_data::red_info_list() const {
  return red_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::red_point_single >*
red_point_data::mutable_red_info_list() {
  return &red_info_list_;
}

// -------------------------------------------------------------------

// new_role_guide_single

// optional uint32 tid = 1;
inline bool new_role_guide_single::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void new_role_guide_single::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void new_role_guide_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void new_role_guide_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 new_role_guide_single::tid() const {
  return tid_;
}
inline void new_role_guide_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 status = 2;
inline bool new_role_guide_single::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void new_role_guide_single::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void new_role_guide_single::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void new_role_guide_single::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 new_role_guide_single::status() const {
  return status_;
}
inline void new_role_guide_single::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 event_type = 3;
inline bool new_role_guide_single::has_event_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void new_role_guide_single::set_has_event_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void new_role_guide_single::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void new_role_guide_single::clear_event_type() {
  event_type_ = 0u;
  clear_has_event_type();
}
inline ::google::protobuf::uint32 new_role_guide_single::event_type() const {
  return event_type_;
}
inline void new_role_guide_single::set_event_type(::google::protobuf::uint32 value) {
  set_has_event_type();
  event_type_ = value;
}

// -------------------------------------------------------------------

// new_role_guide_data

// repeated .proto.common.new_role_guide_single guide_list = 1;
inline int new_role_guide_data::guide_list_size() const {
  return guide_list_.size();
}
inline void new_role_guide_data::clear_guide_list() {
  guide_list_.Clear();
}
inline const ::proto::common::new_role_guide_single& new_role_guide_data::guide_list(int index) const {
  return guide_list_.Get(index);
}
inline ::proto::common::new_role_guide_single* new_role_guide_data::mutable_guide_list(int index) {
  return guide_list_.Mutable(index);
}
inline ::proto::common::new_role_guide_single* new_role_guide_data::add_guide_list() {
  return guide_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::new_role_guide_single >&
new_role_guide_data::guide_list() const {
  return guide_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::new_role_guide_single >*
new_role_guide_data::mutable_guide_list() {
  return &guide_list_;
}

// -------------------------------------------------------------------

// luckydraw_data

// repeated .proto.common.luckydraw_info lucky_draw_list = 1;
inline int luckydraw_data::lucky_draw_list_size() const {
  return lucky_draw_list_.size();
}
inline void luckydraw_data::clear_lucky_draw_list() {
  lucky_draw_list_.Clear();
}
inline const ::proto::common::luckydraw_info& luckydraw_data::lucky_draw_list(int index) const {
  return lucky_draw_list_.Get(index);
}
inline ::proto::common::luckydraw_info* luckydraw_data::mutable_lucky_draw_list(int index) {
  return lucky_draw_list_.Mutable(index);
}
inline ::proto::common::luckydraw_info* luckydraw_data::add_lucky_draw_list() {
  return lucky_draw_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_info >&
luckydraw_data::lucky_draw_list() const {
  return lucky_draw_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_info >*
luckydraw_data::mutable_lucky_draw_list() {
  return &lucky_draw_list_;
}

// optional uint32 lucky = 2;
inline bool luckydraw_data::has_lucky() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luckydraw_data::set_has_lucky() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luckydraw_data::clear_has_lucky() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luckydraw_data::clear_lucky() {
  lucky_ = 0u;
  clear_has_lucky();
}
inline ::google::protobuf::uint32 luckydraw_data::lucky() const {
  return lucky_;
}
inline void luckydraw_data::set_lucky(::google::protobuf::uint32 value) {
  set_has_lucky();
  lucky_ = value;
}

// optional uint32 lucky_ex = 3;
inline bool luckydraw_data::has_lucky_ex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void luckydraw_data::set_has_lucky_ex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void luckydraw_data::clear_has_lucky_ex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void luckydraw_data::clear_lucky_ex() {
  lucky_ex_ = 0u;
  clear_has_lucky_ex();
}
inline ::google::protobuf::uint32 luckydraw_data::lucky_ex() const {
  return lucky_ex_;
}
inline void luckydraw_data::set_lucky_ex(::google::protobuf::uint32 value) {
  set_has_lucky_ex();
  lucky_ex_ = value;
}

// -------------------------------------------------------------------

// luckydraw_info

// optional uint32 type = 1;
inline bool luckydraw_info::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void luckydraw_info::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void luckydraw_info::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void luckydraw_info::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 luckydraw_info::type() const {
  return type_;
}
inline void luckydraw_info::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 senior_count = 2;
inline bool luckydraw_info::has_senior_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luckydraw_info::set_has_senior_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luckydraw_info::clear_has_senior_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luckydraw_info::clear_senior_count() {
  senior_count_ = 0u;
  clear_has_senior_count();
}
inline ::google::protobuf::uint32 luckydraw_info::senior_count() const {
  return senior_count_;
}
inline void luckydraw_info::set_senior_count(::google::protobuf::uint32 value) {
  set_has_senior_count();
  senior_count_ = value;
}

// repeated uint32 senior_seq = 3;
inline int luckydraw_info::senior_seq_size() const {
  return senior_seq_.size();
}
inline void luckydraw_info::clear_senior_seq() {
  senior_seq_.Clear();
}
inline ::google::protobuf::uint32 luckydraw_info::senior_seq(int index) const {
  return senior_seq_.Get(index);
}
inline void luckydraw_info::set_senior_seq(int index, ::google::protobuf::uint32 value) {
  senior_seq_.Set(index, value);
}
inline void luckydraw_info::add_senior_seq(::google::protobuf::uint32 value) {
  senior_seq_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
luckydraw_info::senior_seq() const {
  return senior_seq_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
luckydraw_info::mutable_senior_seq() {
  return &senior_seq_;
}

// optional uint32 today_count = 4;
inline bool luckydraw_info::has_today_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void luckydraw_info::set_has_today_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void luckydraw_info::clear_has_today_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void luckydraw_info::clear_today_count() {
  today_count_ = 0u;
  clear_has_today_count();
}
inline ::google::protobuf::uint32 luckydraw_info::today_count() const {
  return today_count_;
}
inline void luckydraw_info::set_today_count(::google::protobuf::uint32 value) {
  set_has_today_count();
  today_count_ = value;
}

// -------------------------------------------------------------------

// luckydraw_client_single

// optional uint32 type = 1;
inline bool luckydraw_client_single::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void luckydraw_client_single::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void luckydraw_client_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void luckydraw_client_single::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 luckydraw_client_single::type() const {
  return type_;
}
inline void luckydraw_client_single::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 today_count = 2;
inline bool luckydraw_client_single::has_today_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luckydraw_client_single::set_has_today_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luckydraw_client_single::clear_has_today_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luckydraw_client_single::clear_today_count() {
  today_count_ = 0u;
  clear_has_today_count();
}
inline ::google::protobuf::uint32 luckydraw_client_single::today_count() const {
  return today_count_;
}
inline void luckydraw_client_single::set_today_count(::google::protobuf::uint32 value) {
  set_has_today_count();
  today_count_ = value;
}

// optional uint32 card_id = 3;
inline bool luckydraw_client_single::has_card_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void luckydraw_client_single::set_has_card_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void luckydraw_client_single::clear_has_card_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void luckydraw_client_single::clear_card_id() {
  card_id_ = 0u;
  clear_has_card_id();
}
inline ::google::protobuf::uint32 luckydraw_client_single::card_id() const {
  return card_id_;
}
inline void luckydraw_client_single::set_card_id(::google::protobuf::uint32 value) {
  set_has_card_id();
  card_id_ = value;
}

// -------------------------------------------------------------------

// luckydraw_client_data

// repeated .proto.common.luckydraw_client_single client_data = 1;
inline int luckydraw_client_data::client_data_size() const {
  return client_data_.size();
}
inline void luckydraw_client_data::clear_client_data() {
  client_data_.Clear();
}
inline const ::proto::common::luckydraw_client_single& luckydraw_client_data::client_data(int index) const {
  return client_data_.Get(index);
}
inline ::proto::common::luckydraw_client_single* luckydraw_client_data::mutable_client_data(int index) {
  return client_data_.Mutable(index);
}
inline ::proto::common::luckydraw_client_single* luckydraw_client_data::add_client_data() {
  return client_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_client_single >&
luckydraw_client_data::client_data() const {
  return client_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::luckydraw_client_single >*
luckydraw_client_data::mutable_client_data() {
  return &client_data_;
}

// optional uint32 remain_time = 2;
inline bool luckydraw_client_data::has_remain_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void luckydraw_client_data::set_has_remain_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void luckydraw_client_data::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void luckydraw_client_data::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 luckydraw_client_data::remain_time() const {
  return remain_time_;
}
inline void luckydraw_client_data::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional uint32 lucky = 3;
inline bool luckydraw_client_data::has_lucky() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void luckydraw_client_data::set_has_lucky() {
  _has_bits_[0] |= 0x00000004u;
}
inline void luckydraw_client_data::clear_has_lucky() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void luckydraw_client_data::clear_lucky() {
  lucky_ = 0u;
  clear_has_lucky();
}
inline ::google::protobuf::uint32 luckydraw_client_data::lucky() const {
  return lucky_;
}
inline void luckydraw_client_data::set_lucky(::google::protobuf::uint32 value) {
  set_has_lucky();
  lucky_ = value;
}

// optional uint32 lucky_ex = 4;
inline bool luckydraw_client_data::has_lucky_ex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void luckydraw_client_data::set_has_lucky_ex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void luckydraw_client_data::clear_has_lucky_ex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void luckydraw_client_data::clear_lucky_ex() {
  lucky_ex_ = 0u;
  clear_has_lucky_ex();
}
inline ::google::protobuf::uint32 luckydraw_client_data::lucky_ex() const {
  return lucky_ex_;
}
inline void luckydraw_client_data::set_lucky_ex(::google::protobuf::uint32 value) {
  set_has_lucky_ex();
  lucky_ex_ = value;
}

// optional uint32 gold_luckydraw_expired_time = 5;
inline bool luckydraw_client_data::has_gold_luckydraw_expired_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void luckydraw_client_data::set_has_gold_luckydraw_expired_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void luckydraw_client_data::clear_has_gold_luckydraw_expired_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void luckydraw_client_data::clear_gold_luckydraw_expired_time() {
  gold_luckydraw_expired_time_ = 0u;
  clear_has_gold_luckydraw_expired_time();
}
inline ::google::protobuf::uint32 luckydraw_client_data::gold_luckydraw_expired_time() const {
  return gold_luckydraw_expired_time_;
}
inline void luckydraw_client_data::set_gold_luckydraw_expired_time(::google::protobuf::uint32 value) {
  set_has_gold_luckydraw_expired_time();
  gold_luckydraw_expired_time_ = value;
}

// optional uint32 today_count = 6;
inline bool luckydraw_client_data::has_today_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void luckydraw_client_data::set_has_today_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void luckydraw_client_data::clear_has_today_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void luckydraw_client_data::clear_today_count() {
  today_count_ = 0u;
  clear_has_today_count();
}
inline ::google::protobuf::uint32 luckydraw_client_data::today_count() const {
  return today_count_;
}
inline void luckydraw_client_data::set_today_count(::google::protobuf::uint32 value) {
  set_has_today_count();
  today_count_ = value;
}

// optional uint32 today_count_limit = 7;
inline bool luckydraw_client_data::has_today_count_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void luckydraw_client_data::set_has_today_count_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void luckydraw_client_data::clear_has_today_count_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void luckydraw_client_data::clear_today_count_limit() {
  today_count_limit_ = 0u;
  clear_has_today_count_limit();
}
inline ::google::protobuf::uint32 luckydraw_client_data::today_count_limit() const {
  return today_count_limit_;
}
inline void luckydraw_client_data::set_today_count_limit(::google::protobuf::uint32 value) {
  set_has_today_count_limit();
  today_count_limit_ = value;
}

// -------------------------------------------------------------------

// role_dungeon_monster

// optional uint32 monster_tid = 1;
inline bool role_dungeon_monster::has_monster_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_dungeon_monster::set_has_monster_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_dungeon_monster::clear_has_monster_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_dungeon_monster::clear_monster_tid() {
  monster_tid_ = 0u;
  clear_has_monster_tid();
}
inline ::google::protobuf::uint32 role_dungeon_monster::monster_tid() const {
  return monster_tid_;
}
inline void role_dungeon_monster::set_monster_tid(::google::protobuf::uint32 value) {
  set_has_monster_tid();
  monster_tid_ = value;
}

// optional uint32 num = 2;
inline bool role_dungeon_monster::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_dungeon_monster::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_dungeon_monster::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_dungeon_monster::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 role_dungeon_monster::num() const {
  return num_;
}
inline void role_dungeon_monster::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// role_dungeon_data

// optional uint32 dungeon_id = 1;
inline bool role_dungeon_data::has_dungeon_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_dungeon_data::set_has_dungeon_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_dungeon_data::clear_has_dungeon_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_dungeon_data::clear_dungeon_id() {
  dungeon_id_ = 0u;
  clear_has_dungeon_id();
}
inline ::google::protobuf::uint32 role_dungeon_data::dungeon_id() const {
  return dungeon_id_;
}
inline void role_dungeon_data::set_dungeon_id(::google::protobuf::uint32 value) {
  set_has_dungeon_id();
  dungeon_id_ = value;
}

// optional uint32 total_pass_time = 2;
inline bool role_dungeon_data::has_total_pass_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_dungeon_data::set_has_total_pass_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_dungeon_data::clear_has_total_pass_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_dungeon_data::clear_total_pass_time() {
  total_pass_time_ = 0u;
  clear_has_total_pass_time();
}
inline ::google::protobuf::uint32 role_dungeon_data::total_pass_time() const {
  return total_pass_time_;
}
inline void role_dungeon_data::set_total_pass_time(::google::protobuf::uint32 value) {
  set_has_total_pass_time();
  total_pass_time_ = value;
}

// repeated .proto.common.role_dungeon_monster monsters = 3;
inline int role_dungeon_data::monsters_size() const {
  return monsters_.size();
}
inline void role_dungeon_data::clear_monsters() {
  monsters_.Clear();
}
inline const ::proto::common::role_dungeon_monster& role_dungeon_data::monsters(int index) const {
  return monsters_.Get(index);
}
inline ::proto::common::role_dungeon_monster* role_dungeon_data::mutable_monsters(int index) {
  return monsters_.Mutable(index);
}
inline ::proto::common::role_dungeon_monster* role_dungeon_data::add_monsters() {
  return monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_monster >&
role_dungeon_data::monsters() const {
  return monsters_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_monster >*
role_dungeon_data::mutable_monsters() {
  return &monsters_;
}

// optional uint32 refresh_time = 4;
inline bool role_dungeon_data::has_refresh_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_dungeon_data::set_has_refresh_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_dungeon_data::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_dungeon_data::clear_refresh_time() {
  refresh_time_ = 0u;
  clear_has_refresh_time();
}
inline ::google::protobuf::uint32 role_dungeon_data::refresh_time() const {
  return refresh_time_;
}
inline void role_dungeon_data::set_refresh_time(::google::protobuf::uint32 value) {
  set_has_refresh_time();
  refresh_time_ = value;
}

// optional uint32 best_score = 5;
inline bool role_dungeon_data::has_best_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_dungeon_data::set_has_best_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_dungeon_data::clear_has_best_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_dungeon_data::clear_best_score() {
  best_score_ = 0u;
  clear_has_best_score();
}
inline ::google::protobuf::uint32 role_dungeon_data::best_score() const {
  return best_score_;
}
inline void role_dungeon_data::set_best_score(::google::protobuf::uint32 value) {
  set_has_best_score();
  best_score_ = value;
}

// optional uint32 best_pass_time = 6;
inline bool role_dungeon_data::has_best_pass_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_dungeon_data::set_has_best_pass_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_dungeon_data::clear_has_best_pass_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_dungeon_data::clear_best_pass_time() {
  best_pass_time_ = 0u;
  clear_has_best_pass_time();
}
inline ::google::protobuf::uint32 role_dungeon_data::best_pass_time() const {
  return best_pass_time_;
}
inline void role_dungeon_data::set_best_pass_time(::google::protobuf::uint32 value) {
  set_has_best_pass_time();
  best_pass_time_ = value;
}

// optional uint32 best_death_value = 7;
inline bool role_dungeon_data::has_best_death_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_dungeon_data::set_has_best_death_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_dungeon_data::clear_has_best_death_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_dungeon_data::clear_best_death_value() {
  best_death_value_ = 0u;
  clear_has_best_death_value();
}
inline ::google::protobuf::uint32 role_dungeon_data::best_death_value() const {
  return best_death_value_;
}
inline void role_dungeon_data::set_best_death_value(::google::protobuf::uint32 value) {
  set_has_best_death_value();
  best_death_value_ = value;
}

// -------------------------------------------------------------------

// role_dungeon_times_data

// optional uint32 dungeon_type = 1;
inline bool role_dungeon_times_data::has_dungeon_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_dungeon_times_data::set_has_dungeon_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_dungeon_times_data::clear_has_dungeon_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_dungeon_times_data::clear_dungeon_type() {
  dungeon_type_ = 0u;
  clear_has_dungeon_type();
}
inline ::google::protobuf::uint32 role_dungeon_times_data::dungeon_type() const {
  return dungeon_type_;
}
inline void role_dungeon_times_data::set_dungeon_type(::google::protobuf::uint32 value) {
  set_has_dungeon_type();
  dungeon_type_ = value;
}

// optional uint32 remain_fight_time = 2;
inline bool role_dungeon_times_data::has_remain_fight_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_dungeon_times_data::set_has_remain_fight_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_dungeon_times_data::clear_has_remain_fight_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_dungeon_times_data::clear_remain_fight_time() {
  remain_fight_time_ = 0u;
  clear_has_remain_fight_time();
}
inline ::google::protobuf::uint32 role_dungeon_times_data::remain_fight_time() const {
  return remain_fight_time_;
}
inline void role_dungeon_times_data::set_remain_fight_time(::google::protobuf::uint32 value) {
  set_has_remain_fight_time();
  remain_fight_time_ = value;
}

// optional uint32 today_buy_time = 3;
inline bool role_dungeon_times_data::has_today_buy_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_dungeon_times_data::set_has_today_buy_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_dungeon_times_data::clear_has_today_buy_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_dungeon_times_data::clear_today_buy_time() {
  today_buy_time_ = 0u;
  clear_has_today_buy_time();
}
inline ::google::protobuf::uint32 role_dungeon_times_data::today_buy_time() const {
  return today_buy_time_;
}
inline void role_dungeon_times_data::set_today_buy_time(::google::protobuf::uint32 value) {
  set_has_today_buy_time();
  today_buy_time_ = value;
}

// -------------------------------------------------------------------

// role_all_dungeon_data

// repeated .proto.common.role_dungeon_data datas = 1;
inline int role_all_dungeon_data::datas_size() const {
  return datas_.size();
}
inline void role_all_dungeon_data::clear_datas() {
  datas_.Clear();
}
inline const ::proto::common::role_dungeon_data& role_all_dungeon_data::datas(int index) const {
  return datas_.Get(index);
}
inline ::proto::common::role_dungeon_data* role_all_dungeon_data::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::proto::common::role_dungeon_data* role_all_dungeon_data::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_data >&
role_all_dungeon_data::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_data >*
role_all_dungeon_data::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// role_all_dungeon_times_data

// repeated .proto.common.role_dungeon_times_data datas = 1;
inline int role_all_dungeon_times_data::datas_size() const {
  return datas_.size();
}
inline void role_all_dungeon_times_data::clear_datas() {
  datas_.Clear();
}
inline const ::proto::common::role_dungeon_times_data& role_all_dungeon_times_data::datas(int index) const {
  return datas_.Get(index);
}
inline ::proto::common::role_dungeon_times_data* role_all_dungeon_times_data::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::proto::common::role_dungeon_times_data* role_all_dungeon_times_data::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >&
role_all_dungeon_times_data::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >*
role_all_dungeon_times_data::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// role_dungeon_condition

// optional uint32 type = 1;
inline bool role_dungeon_condition::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_dungeon_condition::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_dungeon_condition::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_dungeon_condition::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 role_dungeon_condition::type() const {
  return type_;
}
inline void role_dungeon_condition::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 param = 2;
inline bool role_dungeon_condition::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_dungeon_condition::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_dungeon_condition::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_dungeon_condition::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 role_dungeon_condition::param() const {
  return param_;
}
inline void role_dungeon_condition::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional bool is_pass = 3;
inline bool role_dungeon_condition::has_is_pass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_dungeon_condition::set_has_is_pass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_dungeon_condition::clear_has_is_pass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_dungeon_condition::clear_is_pass() {
  is_pass_ = false;
  clear_has_is_pass();
}
inline bool role_dungeon_condition::is_pass() const {
  return is_pass_;
}
inline void role_dungeon_condition::set_is_pass(bool value) {
  set_has_is_pass();
  is_pass_ = value;
}

// -------------------------------------------------------------------

// role_client_dungeon_data

// optional uint32 dungeon_id = 1;
inline bool role_client_dungeon_data::has_dungeon_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_client_dungeon_data::set_has_dungeon_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_client_dungeon_data::clear_has_dungeon_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_client_dungeon_data::clear_dungeon_id() {
  dungeon_id_ = 0u;
  clear_has_dungeon_id();
}
inline ::google::protobuf::uint32 role_client_dungeon_data::dungeon_id() const {
  return dungeon_id_;
}
inline void role_client_dungeon_data::set_dungeon_id(::google::protobuf::uint32 value) {
  set_has_dungeon_id();
  dungeon_id_ = value;
}

// repeated .proto.common.role_dungeon_condition cond = 2;
inline int role_client_dungeon_data::cond_size() const {
  return cond_.size();
}
inline void role_client_dungeon_data::clear_cond() {
  cond_.Clear();
}
inline const ::proto::common::role_dungeon_condition& role_client_dungeon_data::cond(int index) const {
  return cond_.Get(index);
}
inline ::proto::common::role_dungeon_condition* role_client_dungeon_data::mutable_cond(int index) {
  return cond_.Mutable(index);
}
inline ::proto::common::role_dungeon_condition* role_client_dungeon_data::add_cond() {
  return cond_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_condition >&
role_client_dungeon_data::cond() const {
  return cond_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_condition >*
role_client_dungeon_data::mutable_cond() {
  return &cond_;
}

// optional .proto.common.role_dungeon_data data = 3;
inline bool role_client_dungeon_data::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_client_dungeon_data::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_client_dungeon_data::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_client_dungeon_data::clear_data() {
  if (data_ != NULL) data_->::proto::common::role_dungeon_data::Clear();
  clear_has_data();
}
inline const ::proto::common::role_dungeon_data& role_client_dungeon_data::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::proto::common::role_dungeon_data* role_client_dungeon_data::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::proto::common::role_dungeon_data;
  return data_;
}
inline ::proto::common::role_dungeon_data* role_client_dungeon_data::release_data() {
  clear_has_data();
  ::proto::common::role_dungeon_data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void role_client_dungeon_data::set_allocated_data(::proto::common::role_dungeon_data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// role_all_client_dungeon_data

// repeated .proto.common.role_client_dungeon_data datas = 1;
inline int role_all_client_dungeon_data::datas_size() const {
  return datas_.size();
}
inline void role_all_client_dungeon_data::clear_datas() {
  datas_.Clear();
}
inline const ::proto::common::role_client_dungeon_data& role_all_client_dungeon_data::datas(int index) const {
  return datas_.Get(index);
}
inline ::proto::common::role_client_dungeon_data* role_all_client_dungeon_data::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::proto::common::role_client_dungeon_data* role_all_client_dungeon_data::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_client_dungeon_data >&
role_all_client_dungeon_data::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_client_dungeon_data >*
role_all_client_dungeon_data::mutable_datas() {
  return &datas_;
}

// repeated .proto.common.role_dungeon_times_data times_datas = 2;
inline int role_all_client_dungeon_data::times_datas_size() const {
  return times_datas_.size();
}
inline void role_all_client_dungeon_data::clear_times_datas() {
  times_datas_.Clear();
}
inline const ::proto::common::role_dungeon_times_data& role_all_client_dungeon_data::times_datas(int index) const {
  return times_datas_.Get(index);
}
inline ::proto::common::role_dungeon_times_data* role_all_client_dungeon_data::mutable_times_datas(int index) {
  return times_datas_.Mutable(index);
}
inline ::proto::common::role_dungeon_times_data* role_all_client_dungeon_data::add_times_datas() {
  return times_datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >&
role_all_client_dungeon_data::times_datas() const {
  return times_datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_dungeon_times_data >*
role_all_client_dungeon_data::mutable_times_datas() {
  return &times_datas_;
}

// -------------------------------------------------------------------

// teamcheck_data

// optional string uid = 1;
inline bool teamcheck_data::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void teamcheck_data::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void teamcheck_data::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void teamcheck_data::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& teamcheck_data::uid() const {
  return *uid_;
}
inline void teamcheck_data::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void teamcheck_data::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void teamcheck_data::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* teamcheck_data::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* teamcheck_data::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void teamcheck_data::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.team_check_type type = 2;
inline bool teamcheck_data::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void teamcheck_data::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void teamcheck_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void teamcheck_data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::proto::common::team_check_type teamcheck_data::type() const {
  return static_cast< ::proto::common::team_check_type >(type_);
}
inline void teamcheck_data::set_type(::proto::common::team_check_type value) {
  assert(::proto::common::team_check_type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// dungeon_schedule_data

// optional uint32 monster_tid = 1;
inline bool dungeon_schedule_data::has_monster_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dungeon_schedule_data::set_has_monster_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dungeon_schedule_data::clear_has_monster_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dungeon_schedule_data::clear_monster_tid() {
  monster_tid_ = 0u;
  clear_has_monster_tid();
}
inline ::google::protobuf::uint32 dungeon_schedule_data::monster_tid() const {
  return monster_tid_;
}
inline void dungeon_schedule_data::set_monster_tid(::google::protobuf::uint32 value) {
  set_has_monster_tid();
  monster_tid_ = value;
}

// optional uint32 curr_num = 2;
inline bool dungeon_schedule_data::has_curr_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dungeon_schedule_data::set_has_curr_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dungeon_schedule_data::clear_has_curr_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dungeon_schedule_data::clear_curr_num() {
  curr_num_ = 0u;
  clear_has_curr_num();
}
inline ::google::protobuf::uint32 dungeon_schedule_data::curr_num() const {
  return curr_num_;
}
inline void dungeon_schedule_data::set_curr_num(::google::protobuf::uint32 value) {
  set_has_curr_num();
  curr_num_ = value;
}

// optional uint32 max_num = 3;
inline bool dungeon_schedule_data::has_max_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dungeon_schedule_data::set_has_max_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dungeon_schedule_data::clear_has_max_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dungeon_schedule_data::clear_max_num() {
  max_num_ = 0u;
  clear_has_max_num();
}
inline ::google::protobuf::uint32 dungeon_schedule_data::max_num() const {
  return max_num_;
}
inline void dungeon_schedule_data::set_max_num(::google::protobuf::uint32 value) {
  set_has_max_num();
  max_num_ = value;
}

// optional uint32 pos_x = 4;
inline bool dungeon_schedule_data::has_pos_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dungeon_schedule_data::set_has_pos_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dungeon_schedule_data::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dungeon_schedule_data::clear_pos_x() {
  pos_x_ = 0u;
  clear_has_pos_x();
}
inline ::google::protobuf::uint32 dungeon_schedule_data::pos_x() const {
  return pos_x_;
}
inline void dungeon_schedule_data::set_pos_x(::google::protobuf::uint32 value) {
  set_has_pos_x();
  pos_x_ = value;
}

// optional uint32 pos_y = 5;
inline bool dungeon_schedule_data::has_pos_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dungeon_schedule_data::set_has_pos_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dungeon_schedule_data::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dungeon_schedule_data::clear_pos_y() {
  pos_y_ = 0u;
  clear_has_pos_y();
}
inline ::google::protobuf::uint32 dungeon_schedule_data::pos_y() const {
  return pos_y_;
}
inline void dungeon_schedule_data::set_pos_y(::google::protobuf::uint32 value) {
  set_has_pos_y();
  pos_y_ = value;
}

// -------------------------------------------------------------------

// tactic_single

// optional uint32 tactic_id = 1;
inline bool tactic_single::has_tactic_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tactic_single::set_has_tactic_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tactic_single::clear_has_tactic_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tactic_single::clear_tactic_id() {
  tactic_id_ = 0u;
  clear_has_tactic_id();
}
inline ::google::protobuf::uint32 tactic_single::tactic_id() const {
  return tactic_id_;
}
inline void tactic_single::set_tactic_id(::google::protobuf::uint32 value) {
  set_has_tactic_id();
  tactic_id_ = value;
}

// optional uint32 tactic_level = 2;
inline bool tactic_single::has_tactic_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tactic_single::set_has_tactic_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tactic_single::clear_has_tactic_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tactic_single::clear_tactic_level() {
  tactic_level_ = 0u;
  clear_has_tactic_level();
}
inline ::google::protobuf::uint32 tactic_single::tactic_level() const {
  return tactic_level_;
}
inline void tactic_single::set_tactic_level(::google::protobuf::uint32 value) {
  set_has_tactic_level();
  tactic_level_ = value;
}

// -------------------------------------------------------------------

// tactic_data

// repeated .proto.common.tactic_single tactics = 1;
inline int tactic_data::tactics_size() const {
  return tactics_.size();
}
inline void tactic_data::clear_tactics() {
  tactics_.Clear();
}
inline const ::proto::common::tactic_single& tactic_data::tactics(int index) const {
  return tactics_.Get(index);
}
inline ::proto::common::tactic_single* tactic_data::mutable_tactics(int index) {
  return tactics_.Mutable(index);
}
inline ::proto::common::tactic_single* tactic_data::add_tactics() {
  return tactics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::tactic_single >&
tactic_data::tactics() const {
  return tactics_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::tactic_single >*
tactic_data::mutable_tactics() {
  return &tactics_;
}

// -------------------------------------------------------------------

// role_buff_single

// optional uint32 buff_id = 1;
inline bool role_buff_single::has_buff_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_buff_single::set_has_buff_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_buff_single::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_buff_single::clear_buff_id() {
  buff_id_ = 0u;
  clear_has_buff_id();
}
inline ::google::protobuf::uint32 role_buff_single::buff_id() const {
  return buff_id_;
}
inline void role_buff_single::set_buff_id(::google::protobuf::uint32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// optional uint32 remain_time = 2;
inline bool role_buff_single::has_remain_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_buff_single::set_has_remain_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_buff_single::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_buff_single::clear_remain_time() {
  remain_time_ = 0u;
  clear_has_remain_time();
}
inline ::google::protobuf::uint32 role_buff_single::remain_time() const {
  return remain_time_;
}
inline void role_buff_single::set_remain_time(::google::protobuf::uint32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// -------------------------------------------------------------------

// role_buff_data

// repeated .proto.common.role_buff_single role_buffs = 1;
inline int role_buff_data::role_buffs_size() const {
  return role_buffs_.size();
}
inline void role_buff_data::clear_role_buffs() {
  role_buffs_.Clear();
}
inline const ::proto::common::role_buff_single& role_buff_data::role_buffs(int index) const {
  return role_buffs_.Get(index);
}
inline ::proto::common::role_buff_single* role_buff_data::mutable_role_buffs(int index) {
  return role_buffs_.Mutable(index);
}
inline ::proto::common::role_buff_single* role_buff_data::add_role_buffs() {
  return role_buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::role_buff_single >&
role_buff_data::role_buffs() const {
  return role_buffs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::role_buff_single >*
role_buff_data::mutable_role_buffs() {
  return &role_buffs_;
}

// -------------------------------------------------------------------

// goods_single

// optional string uid = 1;
inline bool goods_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void goods_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void goods_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void goods_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& goods_single::uid() const {
  return *uid_;
}
inline void goods_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void goods_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void goods_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* goods_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* goods_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void goods_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seller_uid = 2;
inline bool goods_single::has_seller_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void goods_single::set_has_seller_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void goods_single::clear_has_seller_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void goods_single::clear_seller_uid() {
  if (seller_uid_ != &::google::protobuf::internal::kEmptyString) {
    seller_uid_->clear();
  }
  clear_has_seller_uid();
}
inline const ::std::string& goods_single::seller_uid() const {
  return *seller_uid_;
}
inline void goods_single::set_seller_uid(const ::std::string& value) {
  set_has_seller_uid();
  if (seller_uid_ == &::google::protobuf::internal::kEmptyString) {
    seller_uid_ = new ::std::string;
  }
  seller_uid_->assign(value);
}
inline void goods_single::set_seller_uid(const char* value) {
  set_has_seller_uid();
  if (seller_uid_ == &::google::protobuf::internal::kEmptyString) {
    seller_uid_ = new ::std::string;
  }
  seller_uid_->assign(value);
}
inline void goods_single::set_seller_uid(const char* value, size_t size) {
  set_has_seller_uid();
  if (seller_uid_ == &::google::protobuf::internal::kEmptyString) {
    seller_uid_ = new ::std::string;
  }
  seller_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* goods_single::mutable_seller_uid() {
  set_has_seller_uid();
  if (seller_uid_ == &::google::protobuf::internal::kEmptyString) {
    seller_uid_ = new ::std::string;
  }
  return seller_uid_;
}
inline ::std::string* goods_single::release_seller_uid() {
  clear_has_seller_uid();
  if (seller_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_uid_;
    seller_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void goods_single::set_allocated_seller_uid(::std::string* seller_uid) {
  if (seller_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_uid_;
  }
  if (seller_uid) {
    set_has_seller_uid();
    seller_uid_ = seller_uid;
  } else {
    clear_has_seller_uid();
    seller_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string seller_name = 3;
inline bool goods_single::has_seller_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void goods_single::set_has_seller_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void goods_single::clear_has_seller_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void goods_single::clear_seller_name() {
  if (seller_name_ != &::google::protobuf::internal::kEmptyString) {
    seller_name_->clear();
  }
  clear_has_seller_name();
}
inline const ::std::string& goods_single::seller_name() const {
  return *seller_name_;
}
inline void goods_single::set_seller_name(const ::std::string& value) {
  set_has_seller_name();
  if (seller_name_ == &::google::protobuf::internal::kEmptyString) {
    seller_name_ = new ::std::string;
  }
  seller_name_->assign(value);
}
inline void goods_single::set_seller_name(const char* value) {
  set_has_seller_name();
  if (seller_name_ == &::google::protobuf::internal::kEmptyString) {
    seller_name_ = new ::std::string;
  }
  seller_name_->assign(value);
}
inline void goods_single::set_seller_name(const char* value, size_t size) {
  set_has_seller_name();
  if (seller_name_ == &::google::protobuf::internal::kEmptyString) {
    seller_name_ = new ::std::string;
  }
  seller_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* goods_single::mutable_seller_name() {
  set_has_seller_name();
  if (seller_name_ == &::google::protobuf::internal::kEmptyString) {
    seller_name_ = new ::std::string;
  }
  return seller_name_;
}
inline ::std::string* goods_single::release_seller_name() {
  clear_has_seller_name();
  if (seller_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_name_;
    seller_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void goods_single::set_allocated_seller_name(::std::string* seller_name) {
  if (seller_name_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_name_;
  }
  if (seller_name) {
    set_has_seller_name();
    seller_name_ = seller_name;
  } else {
    clear_has_seller_name();
    seller_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 item_tid = 4;
inline bool goods_single::has_item_tid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void goods_single::set_has_item_tid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void goods_single::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void goods_single::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 goods_single::item_tid() const {
  return item_tid_;
}
inline void goods_single::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_num = 5;
inline bool goods_single::has_item_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void goods_single::set_has_item_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void goods_single::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void goods_single::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 goods_single::item_num() const {
  return item_num_;
}
inline void goods_single::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional .proto.common.equip_single equip_info = 6;
inline bool goods_single::has_equip_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void goods_single::set_has_equip_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void goods_single::clear_has_equip_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void goods_single::clear_equip_info() {
  if (equip_info_ != NULL) equip_info_->::proto::common::equip_single::Clear();
  clear_has_equip_info();
}
inline const ::proto::common::equip_single& goods_single::equip_info() const {
  return equip_info_ != NULL ? *equip_info_ : *default_instance_->equip_info_;
}
inline ::proto::common::equip_single* goods_single::mutable_equip_info() {
  set_has_equip_info();
  if (equip_info_ == NULL) equip_info_ = new ::proto::common::equip_single;
  return equip_info_;
}
inline ::proto::common::equip_single* goods_single::release_equip_info() {
  clear_has_equip_info();
  ::proto::common::equip_single* temp = equip_info_;
  equip_info_ = NULL;
  return temp;
}
inline void goods_single::set_allocated_equip_info(::proto::common::equip_single* equip_info) {
  delete equip_info_;
  equip_info_ = equip_info;
  if (equip_info) {
    set_has_equip_info();
  } else {
    clear_has_equip_info();
  }
}

// optional uint32 item_price = 7;
inline bool goods_single::has_item_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void goods_single::set_has_item_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void goods_single::clear_has_item_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void goods_single::clear_item_price() {
  item_price_ = 0u;
  clear_has_item_price();
}
inline ::google::protobuf::uint32 goods_single::item_price() const {
  return item_price_;
}
inline void goods_single::set_item_price(::google::protobuf::uint32 value) {
  set_has_item_price();
  item_price_ = value;
}

// optional uint32 selled_num = 8;
inline bool goods_single::has_selled_num() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void goods_single::set_has_selled_num() {
  _has_bits_[0] |= 0x00000080u;
}
inline void goods_single::clear_has_selled_num() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void goods_single::clear_selled_num() {
  selled_num_ = 0u;
  clear_has_selled_num();
}
inline ::google::protobuf::uint32 goods_single::selled_num() const {
  return selled_num_;
}
inline void goods_single::set_selled_num(::google::protobuf::uint32 value) {
  set_has_selled_num();
  selled_num_ = value;
}

// optional uint32 profit = 9;
inline bool goods_single::has_profit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void goods_single::set_has_profit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void goods_single::clear_has_profit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void goods_single::clear_profit() {
  profit_ = 0u;
  clear_has_profit();
}
inline ::google::protobuf::uint32 goods_single::profit() const {
  return profit_;
}
inline void goods_single::set_profit(::google::protobuf::uint32 value) {
  set_has_profit();
  profit_ = value;
}

// optional uint32 state = 10;
inline bool goods_single::has_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void goods_single::set_has_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void goods_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void goods_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 goods_single::state() const {
  return state_;
}
inline void goods_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 expired_time = 11;
inline bool goods_single::has_expired_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void goods_single::set_has_expired_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void goods_single::clear_has_expired_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void goods_single::clear_expired_time() {
  expired_time_ = 0u;
  clear_has_expired_time();
}
inline ::google::protobuf::uint32 goods_single::expired_time() const {
  return expired_time_;
}
inline void goods_single::set_expired_time(::google::protobuf::uint32 value) {
  set_has_expired_time();
  expired_time_ = value;
}

// optional uint32 care = 12;
inline bool goods_single::has_care() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void goods_single::set_has_care() {
  _has_bits_[0] |= 0x00000800u;
}
inline void goods_single::clear_has_care() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void goods_single::clear_care() {
  care_ = 0u;
  clear_has_care();
}
inline ::google::protobuf::uint32 goods_single::care() const {
  return care_;
}
inline void goods_single::set_care(::google::protobuf::uint32 value) {
  set_has_care();
  care_ = value;
}

// optional uint32 heat = 13;
inline bool goods_single::has_heat() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void goods_single::set_has_heat() {
  _has_bits_[0] |= 0x00001000u;
}
inline void goods_single::clear_has_heat() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void goods_single::clear_heat() {
  heat_ = 0u;
  clear_has_heat();
}
inline ::google::protobuf::uint32 goods_single::heat() const {
  return heat_;
}
inline void goods_single::set_heat(::google::protobuf::uint32 value) {
  set_has_heat();
  heat_ = value;
}

// optional uint32 rarity = 14;
inline bool goods_single::has_rarity() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void goods_single::set_has_rarity() {
  _has_bits_[0] |= 0x00002000u;
}
inline void goods_single::clear_has_rarity() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void goods_single::clear_rarity() {
  rarity_ = 0u;
  clear_has_rarity();
}
inline ::google::protobuf::uint32 goods_single::rarity() const {
  return rarity_;
}
inline void goods_single::set_rarity(::google::protobuf::uint32 value) {
  set_has_rarity();
  rarity_ = value;
}

// -------------------------------------------------------------------

// rarity_price_single

// optional string uid = 1;
inline bool rarity_price_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rarity_price_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rarity_price_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rarity_price_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& rarity_price_single::uid() const {
  return *uid_;
}
inline void rarity_price_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void rarity_price_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void rarity_price_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rarity_price_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* rarity_price_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rarity_price_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 item_tid = 2;
inline bool rarity_price_single::has_item_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rarity_price_single::set_has_item_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rarity_price_single::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rarity_price_single::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 rarity_price_single::item_tid() const {
  return item_tid_;
}
inline void rarity_price_single::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// repeated uint32 deal_price = 3;
inline int rarity_price_single::deal_price_size() const {
  return deal_price_.size();
}
inline void rarity_price_single::clear_deal_price() {
  deal_price_.Clear();
}
inline ::google::protobuf::uint32 rarity_price_single::deal_price(int index) const {
  return deal_price_.Get(index);
}
inline void rarity_price_single::set_deal_price(int index, ::google::protobuf::uint32 value) {
  deal_price_.Set(index, value);
}
inline void rarity_price_single::add_deal_price(::google::protobuf::uint32 value) {
  deal_price_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
rarity_price_single::deal_price() const {
  return deal_price_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
rarity_price_single::mutable_deal_price() {
  return &deal_price_;
}

// -------------------------------------------------------------------

// goods_info

// optional uint32 item_tid = 1;
inline bool goods_info::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void goods_info::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void goods_info::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void goods_info::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 goods_info::item_tid() const {
  return item_tid_;
}
inline void goods_info::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 selling_num = 2;
inline bool goods_info::has_selling_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void goods_info::set_has_selling_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void goods_info::clear_has_selling_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void goods_info::clear_selling_num() {
  selling_num_ = 0u;
  clear_has_selling_num();
}
inline ::google::protobuf::uint32 goods_info::selling_num() const {
  return selling_num_;
}
inline void goods_info::set_selling_num(::google::protobuf::uint32 value) {
  set_has_selling_num();
  selling_num_ = value;
}

// -------------------------------------------------------------------

// goods_item

// optional uint32 item_tid = 1;
inline bool goods_item::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void goods_item::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void goods_item::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void goods_item::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 goods_item::item_tid() const {
  return item_tid_;
}
inline void goods_item::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 item_num = 2;
inline bool goods_item::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void goods_item::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void goods_item::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void goods_item::clear_item_num() {
  item_num_ = 0u;
  clear_has_item_num();
}
inline ::google::protobuf::uint32 goods_item::item_num() const {
  return item_num_;
}
inline void goods_item::set_item_num(::google::protobuf::uint32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional .proto.common.equip_single equip_info = 3;
inline bool goods_item::has_equip_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void goods_item::set_has_equip_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void goods_item::clear_has_equip_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void goods_item::clear_equip_info() {
  if (equip_info_ != NULL) equip_info_->::proto::common::equip_single::Clear();
  clear_has_equip_info();
}
inline const ::proto::common::equip_single& goods_item::equip_info() const {
  return equip_info_ != NULL ? *equip_info_ : *default_instance_->equip_info_;
}
inline ::proto::common::equip_single* goods_item::mutable_equip_info() {
  set_has_equip_info();
  if (equip_info_ == NULL) equip_info_ = new ::proto::common::equip_single;
  return equip_info_;
}
inline ::proto::common::equip_single* goods_item::release_equip_info() {
  clear_has_equip_info();
  ::proto::common::equip_single* temp = equip_info_;
  equip_info_ = NULL;
  return temp;
}
inline void goods_item::set_allocated_equip_info(::proto::common::equip_single* equip_info) {
  delete equip_info_;
  equip_info_ = equip_info;
  if (equip_info) {
    set_has_equip_info();
  } else {
    clear_has_equip_info();
  }
}

// optional uint32 rarity = 4;
inline bool goods_item::has_rarity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void goods_item::set_has_rarity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void goods_item::clear_has_rarity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void goods_item::clear_rarity() {
  rarity_ = 0u;
  clear_has_rarity();
}
inline ::google::protobuf::uint32 goods_item::rarity() const {
  return rarity_;
}
inline void goods_item::set_rarity(::google::protobuf::uint32 value) {
  set_has_rarity();
  rarity_ = value;
}

// -------------------------------------------------------------------

// trade_item_info

// optional uint32 item_tid = 1;
inline bool trade_item_info::has_item_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trade_item_info::set_has_item_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trade_item_info::clear_has_item_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trade_item_info::clear_item_tid() {
  item_tid_ = 0u;
  clear_has_item_tid();
}
inline ::google::protobuf::uint32 trade_item_info::item_tid() const {
  return item_tid_;
}
inline void trade_item_info::set_item_tid(::google::protobuf::uint32 value) {
  set_has_item_tid();
  item_tid_ = value;
}

// optional uint32 scene_id = 2;
inline bool trade_item_info::has_scene_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void trade_item_info::set_has_scene_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void trade_item_info::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void trade_item_info::clear_scene_id() {
  scene_id_ = 0u;
  clear_has_scene_id();
}
inline ::google::protobuf::uint32 trade_item_info::scene_id() const {
  return scene_id_;
}
inline void trade_item_info::set_scene_id(::google::protobuf::uint32 value) {
  set_has_scene_id();
  scene_id_ = value;
}

// optional uint32 trade_id = 3;
inline bool trade_item_info::has_trade_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void trade_item_info::set_has_trade_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void trade_item_info::clear_has_trade_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void trade_item_info::clear_trade_id() {
  trade_id_ = 0u;
  clear_has_trade_id();
}
inline ::google::protobuf::uint32 trade_item_info::trade_id() const {
  return trade_id_;
}
inline void trade_item_info::set_trade_id(::google::protobuf::uint32 value) {
  set_has_trade_id();
  trade_id_ = value;
}

// optional uint32 sour_trade_id = 4;
inline bool trade_item_info::has_sour_trade_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void trade_item_info::set_has_sour_trade_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void trade_item_info::clear_has_sour_trade_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void trade_item_info::clear_sour_trade_id() {
  sour_trade_id_ = 0u;
  clear_has_sour_trade_id();
}
inline ::google::protobuf::uint32 trade_item_info::sour_trade_id() const {
  return sour_trade_id_;
}
inline void trade_item_info::set_sour_trade_id(::google::protobuf::uint32 value) {
  set_has_sour_trade_id();
  sour_trade_id_ = value;
}

// -------------------------------------------------------------------

// arena_fight_data

// optional uint32 update_time = 1;
inline bool arena_fight_data::has_update_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void arena_fight_data::set_has_update_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void arena_fight_data::clear_has_update_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void arena_fight_data::clear_update_time() {
  update_time_ = 0u;
  clear_has_update_time();
}
inline ::google::protobuf::uint32 arena_fight_data::update_time() const {
  return update_time_;
}
inline void arena_fight_data::set_update_time(::google::protobuf::uint32 value) {
  set_has_update_time();
  update_time_ = value;
}

// optional .proto.common.mirror_fight_data fight_data = 2;
inline bool arena_fight_data::has_fight_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void arena_fight_data::set_has_fight_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void arena_fight_data::clear_has_fight_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void arena_fight_data::clear_fight_data() {
  if (fight_data_ != NULL) fight_data_->::proto::common::mirror_fight_data::Clear();
  clear_has_fight_data();
}
inline const ::proto::common::mirror_fight_data& arena_fight_data::fight_data() const {
  return fight_data_ != NULL ? *fight_data_ : *default_instance_->fight_data_;
}
inline ::proto::common::mirror_fight_data* arena_fight_data::mutable_fight_data() {
  set_has_fight_data();
  if (fight_data_ == NULL) fight_data_ = new ::proto::common::mirror_fight_data;
  return fight_data_;
}
inline ::proto::common::mirror_fight_data* arena_fight_data::release_fight_data() {
  clear_has_fight_data();
  ::proto::common::mirror_fight_data* temp = fight_data_;
  fight_data_ = NULL;
  return temp;
}
inline void arena_fight_data::set_allocated_fight_data(::proto::common::mirror_fight_data* fight_data) {
  delete fight_data_;
  fight_data_ = fight_data;
  if (fight_data) {
    set_has_fight_data();
  } else {
    clear_has_fight_data();
  }
}

// optional uint32 fight_value = 3;
inline bool arena_fight_data::has_fight_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void arena_fight_data::set_has_fight_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void arena_fight_data::clear_has_fight_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void arena_fight_data::clear_fight_value() {
  fight_value_ = 0u;
  clear_has_fight_value();
}
inline ::google::protobuf::uint32 arena_fight_data::fight_value() const {
  return fight_value_;
}
inline void arena_fight_data::set_fight_value(::google::protobuf::uint32 value) {
  set_has_fight_value();
  fight_value_ = value;
}

// -------------------------------------------------------------------

// expedition_stage_single

// optional uint32 stage_id = 1;
inline bool expedition_stage_single::has_stage_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void expedition_stage_single::set_has_stage_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void expedition_stage_single::clear_has_stage_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void expedition_stage_single::clear_stage_id() {
  stage_id_ = 0u;
  clear_has_stage_id();
}
inline ::google::protobuf::uint32 expedition_stage_single::stage_id() const {
  return stage_id_;
}
inline void expedition_stage_single::set_stage_id(::google::protobuf::uint32 value) {
  set_has_stage_id();
  stage_id_ = value;
}

// optional uint32 pass_num = 2;
inline bool expedition_stage_single::has_pass_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void expedition_stage_single::set_has_pass_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void expedition_stage_single::clear_has_pass_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void expedition_stage_single::clear_pass_num() {
  pass_num_ = 0u;
  clear_has_pass_num();
}
inline ::google::protobuf::uint32 expedition_stage_single::pass_num() const {
  return pass_num_;
}
inline void expedition_stage_single::set_pass_num(::google::protobuf::uint32 value) {
  set_has_pass_num();
  pass_num_ = value;
}

// repeated .proto.common.mirror_fight_data stage_info = 3;
inline int expedition_stage_single::stage_info_size() const {
  return stage_info_.size();
}
inline void expedition_stage_single::clear_stage_info() {
  stage_info_.Clear();
}
inline const ::proto::common::mirror_fight_data& expedition_stage_single::stage_info(int index) const {
  return stage_info_.Get(index);
}
inline ::proto::common::mirror_fight_data* expedition_stage_single::mutable_stage_info(int index) {
  return stage_info_.Mutable(index);
}
inline ::proto::common::mirror_fight_data* expedition_stage_single::add_stage_info() {
  return stage_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::mirror_fight_data >&
expedition_stage_single::stage_info() const {
  return stage_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::mirror_fight_data >*
expedition_stage_single::mutable_stage_info() {
  return &stage_info_;
}

// optional uint32 award_num = 4;
inline bool expedition_stage_single::has_award_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void expedition_stage_single::set_has_award_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void expedition_stage_single::clear_has_award_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void expedition_stage_single::clear_award_num() {
  award_num_ = 0u;
  clear_has_award_num();
}
inline ::google::protobuf::uint32 expedition_stage_single::award_num() const {
  return award_num_;
}
inline void expedition_stage_single::set_award_num(::google::protobuf::uint32 value) {
  set_has_award_num();
  award_num_ = value;
}

// -------------------------------------------------------------------

// expedition_data

// repeated .proto.common.expedition_stage_single stage_list = 1;
inline int expedition_data::stage_list_size() const {
  return stage_list_.size();
}
inline void expedition_data::clear_stage_list() {
  stage_list_.Clear();
}
inline const ::proto::common::expedition_stage_single& expedition_data::stage_list(int index) const {
  return stage_list_.Get(index);
}
inline ::proto::common::expedition_stage_single* expedition_data::mutable_stage_list(int index) {
  return stage_list_.Mutable(index);
}
inline ::proto::common::expedition_stage_single* expedition_data::add_stage_list() {
  return stage_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::expedition_stage_single >&
expedition_data::stage_list() const {
  return stage_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::expedition_stage_single >*
expedition_data::mutable_stage_list() {
  return &stage_list_;
}

// optional uint32 pass_num = 2;
inline bool expedition_data::has_pass_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void expedition_data::set_has_pass_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void expedition_data::clear_has_pass_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void expedition_data::clear_pass_num() {
  pass_num_ = 0u;
  clear_has_pass_num();
}
inline ::google::protobuf::uint32 expedition_data::pass_num() const {
  return pass_num_;
}
inline void expedition_data::set_pass_num(::google::protobuf::uint32 value) {
  set_has_pass_num();
  pass_num_ = value;
}

// optional uint32 refresh_count = 3;
inline bool expedition_data::has_refresh_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void expedition_data::set_has_refresh_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void expedition_data::clear_has_refresh_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void expedition_data::clear_refresh_count() {
  refresh_count_ = 0u;
  clear_has_refresh_count();
}
inline ::google::protobuf::uint32 expedition_data::refresh_count() const {
  return refresh_count_;
}
inline void expedition_data::set_refresh_count(::google::protobuf::uint32 value) {
  set_has_refresh_count();
  refresh_count_ = value;
}

// optional .proto.common.fight_save_data save_data = 4;
inline bool expedition_data::has_save_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void expedition_data::set_has_save_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void expedition_data::clear_has_save_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void expedition_data::clear_save_data() {
  if (save_data_ != NULL) save_data_->::proto::common::fight_save_data::Clear();
  clear_has_save_data();
}
inline const ::proto::common::fight_save_data& expedition_data::save_data() const {
  return save_data_ != NULL ? *save_data_ : *default_instance_->save_data_;
}
inline ::proto::common::fight_save_data* expedition_data::mutable_save_data() {
  set_has_save_data();
  if (save_data_ == NULL) save_data_ = new ::proto::common::fight_save_data;
  return save_data_;
}
inline ::proto::common::fight_save_data* expedition_data::release_save_data() {
  clear_has_save_data();
  ::proto::common::fight_save_data* temp = save_data_;
  save_data_ = NULL;
  return temp;
}
inline void expedition_data::set_allocated_save_data(::proto::common::fight_save_data* save_data) {
  delete save_data_;
  save_data_ = save_data;
  if (save_data) {
    set_has_save_data();
  } else {
    clear_has_save_data();
  }
}

// optional uint32 call_help_count = 5;
inline bool expedition_data::has_call_help_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void expedition_data::set_has_call_help_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void expedition_data::clear_has_call_help_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void expedition_data::clear_call_help_count() {
  call_help_count_ = 0u;
  clear_has_call_help_count();
}
inline ::google::protobuf::uint32 expedition_data::call_help_count() const {
  return call_help_count_;
}
inline void expedition_data::set_call_help_count(::google::protobuf::uint32 value) {
  set_has_call_help_count();
  call_help_count_ = value;
}

// optional uint32 help_count = 6;
inline bool expedition_data::has_help_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void expedition_data::set_has_help_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void expedition_data::clear_has_help_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void expedition_data::clear_help_count() {
  help_count_ = 0u;
  clear_has_help_count();
}
inline ::google::protobuf::uint32 expedition_data::help_count() const {
  return help_count_;
}
inline void expedition_data::set_help_count(::google::protobuf::uint32 value) {
  set_has_help_count();
  help_count_ = value;
}

// optional uint32 glory = 7;
inline bool expedition_data::has_glory() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void expedition_data::set_has_glory() {
  _has_bits_[0] |= 0x00000040u;
}
inline void expedition_data::clear_has_glory() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void expedition_data::clear_glory() {
  glory_ = 0u;
  clear_has_glory();
}
inline ::google::protobuf::uint32 expedition_data::glory() const {
  return glory_;
}
inline void expedition_data::set_glory(::google::protobuf::uint32 value) {
  set_has_glory();
  glory_ = value;
}

// repeated uint32 buy_count = 8;
inline int expedition_data::buy_count_size() const {
  return buy_count_.size();
}
inline void expedition_data::clear_buy_count() {
  buy_count_.Clear();
}
inline ::google::protobuf::uint32 expedition_data::buy_count(int index) const {
  return buy_count_.Get(index);
}
inline void expedition_data::set_buy_count(int index, ::google::protobuf::uint32 value) {
  buy_count_.Set(index, value);
}
inline void expedition_data::add_buy_count(::google::protobuf::uint32 value) {
  buy_count_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
expedition_data::buy_count() const {
  return buy_count_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
expedition_data::mutable_buy_count() {
  return &buy_count_;
}

// repeated .proto.common.liveness_box box_list = 9;
inline int expedition_data::box_list_size() const {
  return box_list_.size();
}
inline void expedition_data::clear_box_list() {
  box_list_.Clear();
}
inline const ::proto::common::liveness_box& expedition_data::box_list(int index) const {
  return box_list_.Get(index);
}
inline ::proto::common::liveness_box* expedition_data::mutable_box_list(int index) {
  return box_list_.Mutable(index);
}
inline ::proto::common::liveness_box* expedition_data::add_box_list() {
  return box_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
expedition_data::box_list() const {
  return box_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
expedition_data::mutable_box_list() {
  return &box_list_;
}

// optional uint32 liveness = 10;
inline bool expedition_data::has_liveness() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void expedition_data::set_has_liveness() {
  _has_bits_[0] |= 0x00000200u;
}
inline void expedition_data::clear_has_liveness() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void expedition_data::clear_liveness() {
  liveness_ = 0u;
  clear_has_liveness();
}
inline ::google::protobuf::uint32 expedition_data::liveness() const {
  return liveness_;
}
inline void expedition_data::set_liveness(::google::protobuf::uint32 value) {
  set_has_liveness();
  liveness_ = value;
}

// optional uint32 shop_id = 11;
inline bool expedition_data::has_shop_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void expedition_data::set_has_shop_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void expedition_data::clear_has_shop_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void expedition_data::clear_shop_id() {
  shop_id_ = 0u;
  clear_has_shop_id();
}
inline ::google::protobuf::uint32 expedition_data::shop_id() const {
  return shop_id_;
}
inline void expedition_data::set_shop_id(::google::protobuf::uint32 value) {
  set_has_shop_id();
  shop_id_ = value;
}

// optional uint32 is_selled = 12;
inline bool expedition_data::has_is_selled() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void expedition_data::set_has_is_selled() {
  _has_bits_[0] |= 0x00000800u;
}
inline void expedition_data::clear_has_is_selled() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void expedition_data::clear_is_selled() {
  is_selled_ = 0u;
  clear_has_is_selled();
}
inline ::google::protobuf::uint32 expedition_data::is_selled() const {
  return is_selled_;
}
inline void expedition_data::set_is_selled(::google::protobuf::uint32 value) {
  set_has_is_selled();
  is_selled_ = value;
}

// -------------------------------------------------------------------

// fight_save_data

// repeated .proto.common.hero_save_data hero_list = 1;
inline int fight_save_data::hero_list_size() const {
  return hero_list_.size();
}
inline void fight_save_data::clear_hero_list() {
  hero_list_.Clear();
}
inline const ::proto::common::hero_save_data& fight_save_data::hero_list(int index) const {
  return hero_list_.Get(index);
}
inline ::proto::common::hero_save_data* fight_save_data::mutable_hero_list(int index) {
  return hero_list_.Mutable(index);
}
inline ::proto::common::hero_save_data* fight_save_data::add_hero_list() {
  return hero_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_save_data >&
fight_save_data::hero_list() const {
  return hero_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_save_data >*
fight_save_data::mutable_hero_list() {
  return &hero_list_;
}

// -------------------------------------------------------------------

// skill_save_data

// optional uint32 skill_id = 1;
inline bool skill_save_data::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void skill_save_data::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void skill_save_data::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void skill_save_data::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 skill_save_data::skill_id() const {
  return skill_id_;
}
inline void skill_save_data::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 cd = 2;
inline bool skill_save_data::has_cd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void skill_save_data::set_has_cd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void skill_save_data::clear_has_cd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void skill_save_data::clear_cd() {
  cd_ = 0u;
  clear_has_cd();
}
inline ::google::protobuf::uint32 skill_save_data::cd() const {
  return cd_;
}
inline void skill_save_data::set_cd(::google::protobuf::uint32 value) {
  set_has_cd();
  cd_ = value;
}

// -------------------------------------------------------------------

// hero_save_data

// optional uint64 hero_uid = 1;
inline bool hero_save_data::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_save_data::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_save_data::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_save_data::clear_hero_uid() {
  hero_uid_ = GOOGLE_ULONGLONG(0);
  clear_has_hero_uid();
}
inline ::google::protobuf::uint64 hero_save_data::hero_uid() const {
  return hero_uid_;
}
inline void hero_save_data::set_hero_uid(::google::protobuf::uint64 value) {
  set_has_hero_uid();
  hero_uid_ = value;
}

// optional uint32 hp = 2;
inline bool hero_save_data::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_save_data::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_save_data::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_save_data::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 hero_save_data::hp() const {
  return hp_;
}
inline void hero_save_data::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// repeated .proto.common.skill_save_data skill_list = 3;
inline int hero_save_data::skill_list_size() const {
  return skill_list_.size();
}
inline void hero_save_data::clear_skill_list() {
  skill_list_.Clear();
}
inline const ::proto::common::skill_save_data& hero_save_data::skill_list(int index) const {
  return skill_list_.Get(index);
}
inline ::proto::common::skill_save_data* hero_save_data::mutable_skill_list(int index) {
  return skill_list_.Mutable(index);
}
inline ::proto::common::skill_save_data* hero_save_data::add_skill_list() {
  return skill_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::skill_save_data >&
hero_save_data::skill_list() const {
  return skill_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::skill_save_data >*
hero_save_data::mutable_skill_list() {
  return &skill_list_;
}

// -------------------------------------------------------------------

// page_task_single

// optional uint32 id = 1;
inline bool page_task_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void page_task_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void page_task_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void page_task_single::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 page_task_single::id() const {
  return id_;
}
inline void page_task_single::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 status = 2;
inline bool page_task_single::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void page_task_single::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void page_task_single::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void page_task_single::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 page_task_single::status() const {
  return status_;
}
inline void page_task_single::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// page_elite_single

// optional uint32 id = 1;
inline bool page_elite_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void page_elite_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void page_elite_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void page_elite_single::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 page_elite_single::id() const {
  return id_;
}
inline void page_elite_single::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 status = 2;
inline bool page_elite_single::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void page_elite_single::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void page_elite_single::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void page_elite_single::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 page_elite_single::status() const {
  return status_;
}
inline void page_elite_single::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 num = 3;
inline bool page_elite_single::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void page_elite_single::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void page_elite_single::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void page_elite_single::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 page_elite_single::num() const {
  return num_;
}
inline void page_elite_single::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 reset = 4;
inline bool page_elite_single::has_reset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void page_elite_single::set_has_reset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void page_elite_single::clear_has_reset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void page_elite_single::clear_reset() {
  reset_ = 0u;
  clear_has_reset();
}
inline ::google::protobuf::uint32 page_elite_single::reset() const {
  return reset_;
}
inline void page_elite_single::set_reset(::google::protobuf::uint32 value) {
  set_has_reset();
  reset_ = value;
}

// -------------------------------------------------------------------

// page_elite_data

// repeated uint32 can_fight_list = 1;
inline int page_elite_data::can_fight_list_size() const {
  return can_fight_list_.size();
}
inline void page_elite_data::clear_can_fight_list() {
  can_fight_list_.Clear();
}
inline ::google::protobuf::uint32 page_elite_data::can_fight_list(int index) const {
  return can_fight_list_.Get(index);
}
inline void page_elite_data::set_can_fight_list(int index, ::google::protobuf::uint32 value) {
  can_fight_list_.Set(index, value);
}
inline void page_elite_data::add_can_fight_list(::google::protobuf::uint32 value) {
  can_fight_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
page_elite_data::can_fight_list() const {
  return can_fight_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
page_elite_data::mutable_can_fight_list() {
  return &can_fight_list_;
}

// repeated .proto.common.page_elite_single pass_elite_list = 2;
inline int page_elite_data::pass_elite_list_size() const {
  return pass_elite_list_.size();
}
inline void page_elite_data::clear_pass_elite_list() {
  pass_elite_list_.Clear();
}
inline const ::proto::common::page_elite_single& page_elite_data::pass_elite_list(int index) const {
  return pass_elite_list_.Get(index);
}
inline ::proto::common::page_elite_single* page_elite_data::mutable_pass_elite_list(int index) {
  return pass_elite_list_.Mutable(index);
}
inline ::proto::common::page_elite_single* page_elite_data::add_pass_elite_list() {
  return pass_elite_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_elite_single >&
page_elite_data::pass_elite_list() const {
  return pass_elite_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_elite_single >*
page_elite_data::mutable_pass_elite_list() {
  return &pass_elite_list_;
}

// -------------------------------------------------------------------

// page_data

// repeated uint32 pass_page_list = 1;
inline int page_data::pass_page_list_size() const {
  return pass_page_list_.size();
}
inline void page_data::clear_pass_page_list() {
  pass_page_list_.Clear();
}
inline ::google::protobuf::uint32 page_data::pass_page_list(int index) const {
  return pass_page_list_.Get(index);
}
inline void page_data::set_pass_page_list(int index, ::google::protobuf::uint32 value) {
  pass_page_list_.Set(index, value);
}
inline void page_data::add_pass_page_list(::google::protobuf::uint32 value) {
  pass_page_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
page_data::pass_page_list() const {
  return pass_page_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
page_data::mutable_pass_page_list() {
  return &pass_page_list_;
}

// repeated .proto.common.page_task_single task_info = 2;
inline int page_data::task_info_size() const {
  return task_info_.size();
}
inline void page_data::clear_task_info() {
  task_info_.Clear();
}
inline const ::proto::common::page_task_single& page_data::task_info(int index) const {
  return task_info_.Get(index);
}
inline ::proto::common::page_task_single* page_data::mutable_task_info(int index) {
  return task_info_.Mutable(index);
}
inline ::proto::common::page_task_single* page_data::add_task_info() {
  return task_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_task_single >&
page_data::task_info() const {
  return task_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_task_single >*
page_data::mutable_task_info() {
  return &task_info_;
}

// repeated .proto.common.page_quick_fight_data quick_data = 3;
inline int page_data::quick_data_size() const {
  return quick_data_.size();
}
inline void page_data::clear_quick_data() {
  quick_data_.Clear();
}
inline const ::proto::common::page_quick_fight_data& page_data::quick_data(int index) const {
  return quick_data_.Get(index);
}
inline ::proto::common::page_quick_fight_data* page_data::mutable_quick_data(int index) {
  return quick_data_.Mutable(index);
}
inline ::proto::common::page_quick_fight_data* page_data::add_quick_data() {
  return quick_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_quick_fight_data >&
page_data::quick_data() const {
  return quick_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_quick_fight_data >*
page_data::mutable_quick_data() {
  return &quick_data_;
}

// repeated .proto.common.page_reset_quick_fight_data reset_data = 4;
inline int page_data::reset_data_size() const {
  return reset_data_.size();
}
inline void page_data::clear_reset_data() {
  reset_data_.Clear();
}
inline const ::proto::common::page_reset_quick_fight_data& page_data::reset_data(int index) const {
  return reset_data_.Get(index);
}
inline ::proto::common::page_reset_quick_fight_data* page_data::mutable_reset_data(int index) {
  return reset_data_.Mutable(index);
}
inline ::proto::common::page_reset_quick_fight_data* page_data::add_reset_data() {
  return reset_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::page_reset_quick_fight_data >&
page_data::reset_data() const {
  return reset_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::page_reset_quick_fight_data >*
page_data::mutable_reset_data() {
  return &reset_data_;
}

// optional .proto.common.page_elite_data elite_data = 5;
inline bool page_data::has_elite_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void page_data::set_has_elite_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void page_data::clear_has_elite_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void page_data::clear_elite_data() {
  if (elite_data_ != NULL) elite_data_->::proto::common::page_elite_data::Clear();
  clear_has_elite_data();
}
inline const ::proto::common::page_elite_data& page_data::elite_data() const {
  return elite_data_ != NULL ? *elite_data_ : *default_instance_->elite_data_;
}
inline ::proto::common::page_elite_data* page_data::mutable_elite_data() {
  set_has_elite_data();
  if (elite_data_ == NULL) elite_data_ = new ::proto::common::page_elite_data;
  return elite_data_;
}
inline ::proto::common::page_elite_data* page_data::release_elite_data() {
  clear_has_elite_data();
  ::proto::common::page_elite_data* temp = elite_data_;
  elite_data_ = NULL;
  return temp;
}
inline void page_data::set_allocated_elite_data(::proto::common::page_elite_data* elite_data) {
  delete elite_data_;
  elite_data_ = elite_data;
  if (elite_data) {
    set_has_elite_data();
  } else {
    clear_has_elite_data();
  }
}

// -------------------------------------------------------------------

// page_quick_fight_data

// optional uint32 id = 1;
inline bool page_quick_fight_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void page_quick_fight_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void page_quick_fight_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void page_quick_fight_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 page_quick_fight_data::id() const {
  return id_;
}
inline void page_quick_fight_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool page_quick_fight_data::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void page_quick_fight_data::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void page_quick_fight_data::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void page_quick_fight_data::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 page_quick_fight_data::num() const {
  return num_;
}
inline void page_quick_fight_data::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// page_reset_quick_fight_data

// optional uint32 id = 1;
inline bool page_reset_quick_fight_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void page_reset_quick_fight_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void page_reset_quick_fight_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void page_reset_quick_fight_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 page_reset_quick_fight_data::id() const {
  return id_;
}
inline void page_reset_quick_fight_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool page_reset_quick_fight_data::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void page_reset_quick_fight_data::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void page_reset_quick_fight_data::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void page_reset_quick_fight_data::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 page_reset_quick_fight_data::num() const {
  return num_;
}
inline void page_reset_quick_fight_data::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// active_reward_data_single

// optional string uid = 1;
inline bool active_reward_data_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void active_reward_data_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void active_reward_data_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void active_reward_data_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& active_reward_data_single::uid() const {
  return *uid_;
}
inline void active_reward_data_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void active_reward_data_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void active_reward_data_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* active_reward_data_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* active_reward_data_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void active_reward_data_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tid = 2;
inline bool active_reward_data_single::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void active_reward_data_single::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void active_reward_data_single::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void active_reward_data_single::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 active_reward_data_single::tid() const {
  return tid_;
}
inline void active_reward_data_single::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 type = 3;
inline bool active_reward_data_single::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void active_reward_data_single::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void active_reward_data_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void active_reward_data_single::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 active_reward_data_single::type() const {
  return type_;
}
inline void active_reward_data_single::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 event_id = 4;
inline bool active_reward_data_single::has_event_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void active_reward_data_single::set_has_event_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void active_reward_data_single::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void active_reward_data_single::clear_event_id() {
  event_id_ = 0u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 active_reward_data_single::event_id() const {
  return event_id_;
}
inline void active_reward_data_single::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 count = 5;
inline bool active_reward_data_single::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void active_reward_data_single::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void active_reward_data_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void active_reward_data_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 active_reward_data_single::count() const {
  return count_;
}
inline void active_reward_data_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional bool is_finish = 6;
inline bool active_reward_data_single::has_is_finish() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void active_reward_data_single::set_has_is_finish() {
  _has_bits_[0] |= 0x00000020u;
}
inline void active_reward_data_single::clear_has_is_finish() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void active_reward_data_single::clear_is_finish() {
  is_finish_ = false;
  clear_has_is_finish();
}
inline bool active_reward_data_single::is_finish() const {
  return is_finish_;
}
inline void active_reward_data_single::set_is_finish(bool value) {
  set_has_is_finish();
  is_finish_ = value;
}

// optional bool is_grant = 7;
inline bool active_reward_data_single::has_is_grant() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void active_reward_data_single::set_has_is_grant() {
  _has_bits_[0] |= 0x00000040u;
}
inline void active_reward_data_single::clear_has_is_grant() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void active_reward_data_single::clear_is_grant() {
  is_grant_ = false;
  clear_has_is_grant();
}
inline bool active_reward_data_single::is_grant() const {
  return is_grant_;
}
inline void active_reward_data_single::set_is_grant(bool value) {
  set_has_is_grant();
  is_grant_ = value;
}

// -------------------------------------------------------------------

// active_reward_data

// repeated .proto.common.active_reward_data_single active_reward = 1;
inline int active_reward_data::active_reward_size() const {
  return active_reward_.size();
}
inline void active_reward_data::clear_active_reward() {
  active_reward_.Clear();
}
inline const ::proto::common::active_reward_data_single& active_reward_data::active_reward(int index) const {
  return active_reward_.Get(index);
}
inline ::proto::common::active_reward_data_single* active_reward_data::mutable_active_reward(int index) {
  return active_reward_.Mutable(index);
}
inline ::proto::common::active_reward_data_single* active_reward_data::add_active_reward() {
  return active_reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::active_reward_data_single >&
active_reward_data::active_reward() const {
  return active_reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::active_reward_data_single >*
active_reward_data::mutable_active_reward() {
  return &active_reward_;
}

// -------------------------------------------------------------------

// active_reward_task_data

// repeated uint32 task_list = 1;
inline int active_reward_task_data::task_list_size() const {
  return task_list_.size();
}
inline void active_reward_task_data::clear_task_list() {
  task_list_.Clear();
}
inline ::google::protobuf::uint32 active_reward_task_data::task_list(int index) const {
  return task_list_.Get(index);
}
inline void active_reward_task_data::set_task_list(int index, ::google::protobuf::uint32 value) {
  task_list_.Set(index, value);
}
inline void active_reward_task_data::add_task_list(::google::protobuf::uint32 value) {
  task_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
active_reward_task_data::task_list() const {
  return task_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
active_reward_task_data::mutable_task_list() {
  return &task_list_;
}

// -------------------------------------------------------------------

// cheap_day_single

// optional uint32 id = 1;
inline bool cheap_day_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cheap_day_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cheap_day_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cheap_day_single::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 cheap_day_single::id() const {
  return id_;
}
inline void cheap_day_single::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 count = 2;
inline bool cheap_day_single::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cheap_day_single::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cheap_day_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cheap_day_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 cheap_day_single::count() const {
  return count_;
}
inline void cheap_day_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// cheap_day_client_single

// optional uint32 id = 1;
inline bool cheap_day_client_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cheap_day_client_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cheap_day_client_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cheap_day_client_single::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 cheap_day_client_single::id() const {
  return id_;
}
inline void cheap_day_client_single::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 pay = 2;
inline bool cheap_day_client_single::has_pay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cheap_day_client_single::set_has_pay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cheap_day_client_single::clear_has_pay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cheap_day_client_single::clear_pay() {
  pay_ = 0u;
  clear_has_pay();
}
inline ::google::protobuf::uint32 cheap_day_client_single::pay() const {
  return pay_;
}
inline void cheap_day_client_single::set_pay(::google::protobuf::uint32 value) {
  set_has_pay();
  pay_ = value;
}

// optional uint32 count = 3;
inline bool cheap_day_client_single::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cheap_day_client_single::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cheap_day_client_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cheap_day_client_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 cheap_day_client_single::count() const {
  return count_;
}
inline void cheap_day_client_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 limit = 4;
inline bool cheap_day_client_single::has_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cheap_day_client_single::set_has_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cheap_day_client_single::clear_has_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cheap_day_client_single::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 cheap_day_client_single::limit() const {
  return limit_;
}
inline void cheap_day_client_single::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
}

// optional string name = 5;
inline bool cheap_day_client_single::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void cheap_day_client_single::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void cheap_day_client_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void cheap_day_client_single::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& cheap_day_client_single::name() const {
  return *name_;
}
inline void cheap_day_client_single::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cheap_day_client_single::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void cheap_day_client_single::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cheap_day_client_single::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* cheap_day_client_single::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cheap_day_client_single::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 6;
inline bool cheap_day_client_single::has_desc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void cheap_day_client_single::set_has_desc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void cheap_day_client_single::clear_has_desc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void cheap_day_client_single::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& cheap_day_client_single::desc() const {
  return *desc_;
}
inline void cheap_day_client_single::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void cheap_day_client_single::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void cheap_day_client_single::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cheap_day_client_single::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* cheap_day_client_single::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cheap_day_client_single::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string display = 7;
inline bool cheap_day_client_single::has_display() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void cheap_day_client_single::set_has_display() {
  _has_bits_[0] |= 0x00000040u;
}
inline void cheap_day_client_single::clear_has_display() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void cheap_day_client_single::clear_display() {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    display_->clear();
  }
  clear_has_display();
}
inline const ::std::string& cheap_day_client_single::display() const {
  return *display_;
}
inline void cheap_day_client_single::set_display(const ::std::string& value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void cheap_day_client_single::set_display(const char* value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void cheap_day_client_single::set_display(const char* value, size_t size) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cheap_day_client_single::mutable_display() {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  return display_;
}
inline ::std::string* cheap_day_client_single::release_display() {
  clear_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_;
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cheap_day_client_single::set_allocated_display(::std::string* display) {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    delete display_;
  }
  if (display) {
    set_has_display();
    display_ = display;
  } else {
    clear_has_display();
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pic = 8;
inline bool cheap_day_client_single::has_pic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void cheap_day_client_single::set_has_pic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void cheap_day_client_single::clear_has_pic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void cheap_day_client_single::clear_pic() {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    pic_->clear();
  }
  clear_has_pic();
}
inline const ::std::string& cheap_day_client_single::pic() const {
  return *pic_;
}
inline void cheap_day_client_single::set_pic(const ::std::string& value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void cheap_day_client_single::set_pic(const char* value) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(value);
}
inline void cheap_day_client_single::set_pic(const char* value, size_t size) {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  pic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* cheap_day_client_single::mutable_pic() {
  set_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    pic_ = new ::std::string;
  }
  return pic_;
}
inline ::std::string* cheap_day_client_single::release_pic() {
  clear_has_pic();
  if (pic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_;
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void cheap_day_client_single::set_allocated_pic(::std::string* pic) {
  if (pic_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_;
  }
  if (pic) {
    set_has_pic();
    pic_ = pic;
  } else {
    clear_has_pic();
    pic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// recharge_data

// optional uint32 total_cny = 1;
inline bool recharge_data::has_total_cny() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recharge_data::set_has_total_cny() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recharge_data::clear_has_total_cny() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recharge_data::clear_total_cny() {
  total_cny_ = 0u;
  clear_has_total_cny();
}
inline ::google::protobuf::uint32 recharge_data::total_cny() const {
  return total_cny_;
}
inline void recharge_data::set_total_cny(::google::protobuf::uint32 value) {
  set_has_total_cny();
  total_cny_ = value;
}

// optional uint32 recharge_flag = 2;
inline bool recharge_data::has_recharge_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void recharge_data::set_has_recharge_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void recharge_data::clear_has_recharge_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void recharge_data::clear_recharge_flag() {
  recharge_flag_ = 0u;
  clear_has_recharge_flag();
}
inline ::google::protobuf::uint32 recharge_data::recharge_flag() const {
  return recharge_flag_;
}
inline void recharge_data::set_recharge_flag(::google::protobuf::uint32 value) {
  set_has_recharge_flag();
  recharge_flag_ = value;
}

// optional uint32 vip_level = 3;
inline bool recharge_data::has_vip_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void recharge_data::set_has_vip_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void recharge_data::clear_has_vip_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void recharge_data::clear_vip_level() {
  vip_level_ = 0u;
  clear_has_vip_level();
}
inline ::google::protobuf::uint32 recharge_data::vip_level() const {
  return vip_level_;
}
inline void recharge_data::set_vip_level(::google::protobuf::uint32 value) {
  set_has_vip_level();
  vip_level_ = value;
}

// optional uint32 recharge_reward_flag = 4;
inline bool recharge_data::has_recharge_reward_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void recharge_data::set_has_recharge_reward_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void recharge_data::clear_has_recharge_reward_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void recharge_data::clear_recharge_reward_flag() {
  recharge_reward_flag_ = 0u;
  clear_has_recharge_reward_flag();
}
inline ::google::protobuf::uint32 recharge_data::recharge_reward_flag() const {
  return recharge_reward_flag_;
}
inline void recharge_data::set_recharge_reward_flag(::google::protobuf::uint32 value) {
  set_has_recharge_reward_flag();
  recharge_reward_flag_ = value;
}

// repeated .proto.common.cheap_day_single cheap_day = 5;
inline int recharge_data::cheap_day_size() const {
  return cheap_day_.size();
}
inline void recharge_data::clear_cheap_day() {
  cheap_day_.Clear();
}
inline const ::proto::common::cheap_day_single& recharge_data::cheap_day(int index) const {
  return cheap_day_.Get(index);
}
inline ::proto::common::cheap_day_single* recharge_data::mutable_cheap_day(int index) {
  return cheap_day_.Mutable(index);
}
inline ::proto::common::cheap_day_single* recharge_data::add_cheap_day() {
  return cheap_day_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::cheap_day_single >&
recharge_data::cheap_day() const {
  return cheap_day_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::cheap_day_single >*
recharge_data::mutable_cheap_day() {
  return &cheap_day_;
}

// -------------------------------------------------------------------

// random_shop_item

// optional uint32 shop_item = 1;
inline bool random_shop_item::has_shop_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void random_shop_item::set_has_shop_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void random_shop_item::clear_has_shop_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void random_shop_item::clear_shop_item() {
  shop_item_ = 0u;
  clear_has_shop_item();
}
inline ::google::protobuf::uint32 random_shop_item::shop_item() const {
  return shop_item_;
}
inline void random_shop_item::set_shop_item(::google::protobuf::uint32 value) {
  set_has_shop_item();
  shop_item_ = value;
}

// optional .proto.common.random_shop_state state = 2 [default = random_shop_state_none];
inline bool random_shop_item::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void random_shop_item::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void random_shop_item::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void random_shop_item::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::proto::common::random_shop_state random_shop_item::state() const {
  return static_cast< ::proto::common::random_shop_state >(state_);
}
inline void random_shop_item::set_state(::proto::common::random_shop_state value) {
  assert(::proto::common::random_shop_state_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// random_shop_data

// optional uint32 shop_id = 1;
inline bool random_shop_data::has_shop_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void random_shop_data::set_has_shop_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void random_shop_data::clear_has_shop_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void random_shop_data::clear_shop_id() {
  shop_id_ = 0u;
  clear_has_shop_id();
}
inline ::google::protobuf::uint32 random_shop_data::shop_id() const {
  return shop_id_;
}
inline void random_shop_data::set_shop_id(::google::protobuf::uint32 value) {
  set_has_shop_id();
  shop_id_ = value;
}

// optional uint32 free_refresh = 2;
inline bool random_shop_data::has_free_refresh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void random_shop_data::set_has_free_refresh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void random_shop_data::clear_has_free_refresh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void random_shop_data::clear_free_refresh() {
  free_refresh_ = 0u;
  clear_has_free_refresh();
}
inline ::google::protobuf::uint32 random_shop_data::free_refresh() const {
  return free_refresh_;
}
inline void random_shop_data::set_free_refresh(::google::protobuf::uint32 value) {
  set_has_free_refresh();
  free_refresh_ = value;
}

// optional uint32 pay_refresh = 3;
inline bool random_shop_data::has_pay_refresh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void random_shop_data::set_has_pay_refresh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void random_shop_data::clear_has_pay_refresh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void random_shop_data::clear_pay_refresh() {
  pay_refresh_ = 0u;
  clear_has_pay_refresh();
}
inline ::google::protobuf::uint32 random_shop_data::pay_refresh() const {
  return pay_refresh_;
}
inline void random_shop_data::set_pay_refresh(::google::protobuf::uint32 value) {
  set_has_pay_refresh();
  pay_refresh_ = value;
}

// optional uint32 next_refresh_time = 4;
inline bool random_shop_data::has_next_refresh_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void random_shop_data::set_has_next_refresh_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void random_shop_data::clear_has_next_refresh_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void random_shop_data::clear_next_refresh_time() {
  next_refresh_time_ = 0u;
  clear_has_next_refresh_time();
}
inline ::google::protobuf::uint32 random_shop_data::next_refresh_time() const {
  return next_refresh_time_;
}
inline void random_shop_data::set_next_refresh_time(::google::protobuf::uint32 value) {
  set_has_next_refresh_time();
  next_refresh_time_ = value;
}

// repeated .proto.common.random_shop_item items = 5;
inline int random_shop_data::items_size() const {
  return items_.size();
}
inline void random_shop_data::clear_items() {
  items_.Clear();
}
inline const ::proto::common::random_shop_item& random_shop_data::items(int index) const {
  return items_.Get(index);
}
inline ::proto::common::random_shop_item* random_shop_data::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::proto::common::random_shop_item* random_shop_data::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_item >&
random_shop_data::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_item >*
random_shop_data::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// role_random_shop_data

// repeated .proto.common.random_shop_data datas = 1;
inline int role_random_shop_data::datas_size() const {
  return datas_.size();
}
inline void role_random_shop_data::clear_datas() {
  datas_.Clear();
}
inline const ::proto::common::random_shop_data& role_random_shop_data::datas(int index) const {
  return datas_.Get(index);
}
inline ::proto::common::random_shop_data* role_random_shop_data::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::proto::common::random_shop_data* role_random_shop_data::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_data >&
role_random_shop_data::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::random_shop_data >*
role_random_shop_data::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// pve_hero_exp

// optional string hero_uid = 1;
inline bool pve_hero_exp::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pve_hero_exp::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pve_hero_exp::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pve_hero_exp::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& pve_hero_exp::hero_uid() const {
  return *hero_uid_;
}
inline void pve_hero_exp::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void pve_hero_exp::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void pve_hero_exp::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pve_hero_exp::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* pve_hero_exp::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pve_hero_exp::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 exp = 2;
inline bool pve_hero_exp::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pve_hero_exp::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pve_hero_exp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pve_hero_exp::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 pve_hero_exp::exp() const {
  return exp_;
}
inline void pve_hero_exp::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// level_reward_recived_list

// repeated uint32 data = 1;
inline int level_reward_recived_list::data_size() const {
  return data_.size();
}
inline void level_reward_recived_list::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::uint32 level_reward_recived_list::data(int index) const {
  return data_.Get(index);
}
inline void level_reward_recived_list::set_data(int index, ::google::protobuf::uint32 value) {
  data_.Set(index, value);
}
inline void level_reward_recived_list::add_data(::google::protobuf::uint32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
level_reward_recived_list::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
level_reward_recived_list::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// level_reward_mail_recived_list

// repeated uint32 data = 1;
inline int level_reward_mail_recived_list::data_size() const {
  return data_.size();
}
inline void level_reward_mail_recived_list::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::uint32 level_reward_mail_recived_list::data(int index) const {
  return data_.Get(index);
}
inline void level_reward_mail_recived_list::set_data(int index, ::google::protobuf::uint32 value) {
  data_.Set(index, value);
}
inline void level_reward_mail_recived_list::add_data(::google::protobuf::uint32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
level_reward_mail_recived_list::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
level_reward_mail_recived_list::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// offline_role_data

// optional .proto.common.tower_trigger_data tower_trigger = 1;
inline bool offline_role_data::has_tower_trigger() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void offline_role_data::set_has_tower_trigger() {
  _has_bits_[0] |= 0x00000001u;
}
inline void offline_role_data::clear_has_tower_trigger() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void offline_role_data::clear_tower_trigger() {
  if (tower_trigger_ != NULL) tower_trigger_->::proto::common::tower_trigger_data::Clear();
  clear_has_tower_trigger();
}
inline const ::proto::common::tower_trigger_data& offline_role_data::tower_trigger() const {
  return tower_trigger_ != NULL ? *tower_trigger_ : *default_instance_->tower_trigger_;
}
inline ::proto::common::tower_trigger_data* offline_role_data::mutable_tower_trigger() {
  set_has_tower_trigger();
  if (tower_trigger_ == NULL) tower_trigger_ = new ::proto::common::tower_trigger_data;
  return tower_trigger_;
}
inline ::proto::common::tower_trigger_data* offline_role_data::release_tower_trigger() {
  clear_has_tower_trigger();
  ::proto::common::tower_trigger_data* temp = tower_trigger_;
  tower_trigger_ = NULL;
  return temp;
}
inline void offline_role_data::set_allocated_tower_trigger(::proto::common::tower_trigger_data* tower_trigger) {
  delete tower_trigger_;
  tower_trigger_ = tower_trigger;
  if (tower_trigger) {
    set_has_tower_trigger();
  } else {
    clear_has_tower_trigger();
  }
}

// -------------------------------------------------------------------

// sys_notity_single

// optional string uid = 1;
inline bool sys_notity_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_notity_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_notity_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_notity_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& sys_notity_single::uid() const {
  return *uid_;
}
inline void sys_notity_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void sys_notity_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void sys_notity_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_notity_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* sys_notity_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_notity_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 2;
inline bool sys_notity_single::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_notity_single::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_notity_single::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_notity_single::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 sys_notity_single::type() const {
  return type_;
}
inline void sys_notity_single::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 param = 3;
inline bool sys_notity_single::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sys_notity_single::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sys_notity_single::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sys_notity_single::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 sys_notity_single::param() const {
  return param_;
}
inline void sys_notity_single::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// optional uint32 count = 4;
inline bool sys_notity_single::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sys_notity_single::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sys_notity_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sys_notity_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 sys_notity_single::count() const {
  return count_;
}
inline void sys_notity_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// sys_notity_data

// repeated .proto.common.sys_notity_single sys_notity_data_list = 1;
inline int sys_notity_data::sys_notity_data_list_size() const {
  return sys_notity_data_list_.size();
}
inline void sys_notity_data::clear_sys_notity_data_list() {
  sys_notity_data_list_.Clear();
}
inline const ::proto::common::sys_notity_single& sys_notity_data::sys_notity_data_list(int index) const {
  return sys_notity_data_list_.Get(index);
}
inline ::proto::common::sys_notity_single* sys_notity_data::mutable_sys_notity_data_list(int index) {
  return sys_notity_data_list_.Mutable(index);
}
inline ::proto::common::sys_notity_single* sys_notity_data::add_sys_notity_data_list() {
  return sys_notity_data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::sys_notity_single >&
sys_notity_data::sys_notity_data_list() const {
  return sys_notity_data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::sys_notity_single >*
sys_notity_data::mutable_sys_notity_data_list() {
  return &sys_notity_data_list_;
}

// -------------------------------------------------------------------

// public_struct

// optional uint32 type = 1;
inline bool public_struct::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void public_struct::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void public_struct::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void public_struct::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 public_struct::type() const {
  return type_;
}
inline void public_struct::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 param = 2;
inline bool public_struct::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void public_struct::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void public_struct::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void public_struct::clear_param() {
  param_ = 0u;
  clear_has_param();
}
inline ::google::protobuf::uint32 public_struct::param() const {
  return param_;
}
inline void public_struct::set_param(::google::protobuf::uint32 value) {
  set_has_param();
  param_ = value;
}

// -------------------------------------------------------------------

// multi_time_data

// repeated .proto.common.public_struct time_long_list = 1;
inline int multi_time_data::time_long_list_size() const {
  return time_long_list_.size();
}
inline void multi_time_data::clear_time_long_list() {
  time_long_list_.Clear();
}
inline const ::proto::common::public_struct& multi_time_data::time_long_list(int index) const {
  return time_long_list_.Get(index);
}
inline ::proto::common::public_struct* multi_time_data::mutable_time_long_list(int index) {
  return time_long_list_.Mutable(index);
}
inline ::proto::common::public_struct* multi_time_data::add_time_long_list() {
  return time_long_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::public_struct >&
multi_time_data::time_long_list() const {
  return time_long_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::public_struct >*
multi_time_data::mutable_time_long_list() {
  return &time_long_list_;
}

// optional uint32 state = 2;
inline bool multi_time_data::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void multi_time_data::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void multi_time_data::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void multi_time_data::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 multi_time_data::state() const {
  return state_;
}
inline void multi_time_data::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// draw_single

// optional string role_uid = 1;
inline bool draw_single::has_role_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void draw_single::set_has_role_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void draw_single::clear_has_role_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void draw_single::clear_role_uid() {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    role_uid_->clear();
  }
  clear_has_role_uid();
}
inline const ::std::string& draw_single::role_uid() const {
  return *role_uid_;
}
inline void draw_single::set_role_uid(const ::std::string& value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void draw_single::set_role_uid(const char* value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void draw_single::set_role_uid(const char* value, size_t size) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* draw_single::mutable_role_uid() {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  return role_uid_;
}
inline ::std::string* draw_single::release_role_uid() {
  clear_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_uid_;
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void draw_single::set_allocated_role_uid(::std::string* role_uid) {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete role_uid_;
  }
  if (role_uid) {
    set_has_role_uid();
    role_uid_ = role_uid;
  } else {
    clear_has_role_uid();
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 2;
inline bool draw_single::has_role_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void draw_single::set_has_role_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void draw_single::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void draw_single::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& draw_single::role_name() const {
  return *role_name_;
}
inline void draw_single::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void draw_single::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void draw_single::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* draw_single::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* draw_single::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void draw_single::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 money = 3;
inline bool draw_single::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void draw_single::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void draw_single::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void draw_single::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 draw_single::money() const {
  return money_;
}
inline void draw_single::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// draw_data

// repeated .proto.common.draw_single draw_info = 1;
inline int draw_data::draw_info_size() const {
  return draw_info_.size();
}
inline void draw_data::clear_draw_info() {
  draw_info_.Clear();
}
inline const ::proto::common::draw_single& draw_data::draw_info(int index) const {
  return draw_info_.Get(index);
}
inline ::proto::common::draw_single* draw_data::mutable_draw_info(int index) {
  return draw_info_.Mutable(index);
}
inline ::proto::common::draw_single* draw_data::add_draw_info() {
  return draw_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::draw_single >&
draw_data::draw_info() const {
  return draw_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::draw_single >*
draw_data::mutable_draw_info() {
  return &draw_info_;
}

// -------------------------------------------------------------------

// redbag_data

// optional string uid = 1;
inline bool redbag_data::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void redbag_data::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void redbag_data::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void redbag_data::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& redbag_data::uid() const {
  return *uid_;
}
inline void redbag_data::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void redbag_data::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void redbag_data::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* redbag_data::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* redbag_data::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void redbag_data::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sender_uid = 2;
inline bool redbag_data::has_sender_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void redbag_data::set_has_sender_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void redbag_data::clear_has_sender_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void redbag_data::clear_sender_uid() {
  if (sender_uid_ != &::google::protobuf::internal::kEmptyString) {
    sender_uid_->clear();
  }
  clear_has_sender_uid();
}
inline const ::std::string& redbag_data::sender_uid() const {
  return *sender_uid_;
}
inline void redbag_data::set_sender_uid(const ::std::string& value) {
  set_has_sender_uid();
  if (sender_uid_ == &::google::protobuf::internal::kEmptyString) {
    sender_uid_ = new ::std::string;
  }
  sender_uid_->assign(value);
}
inline void redbag_data::set_sender_uid(const char* value) {
  set_has_sender_uid();
  if (sender_uid_ == &::google::protobuf::internal::kEmptyString) {
    sender_uid_ = new ::std::string;
  }
  sender_uid_->assign(value);
}
inline void redbag_data::set_sender_uid(const char* value, size_t size) {
  set_has_sender_uid();
  if (sender_uid_ == &::google::protobuf::internal::kEmptyString) {
    sender_uid_ = new ::std::string;
  }
  sender_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* redbag_data::mutable_sender_uid() {
  set_has_sender_uid();
  if (sender_uid_ == &::google::protobuf::internal::kEmptyString) {
    sender_uid_ = new ::std::string;
  }
  return sender_uid_;
}
inline ::std::string* redbag_data::release_sender_uid() {
  clear_has_sender_uid();
  if (sender_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_uid_;
    sender_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void redbag_data::set_allocated_sender_uid(::std::string* sender_uid) {
  if (sender_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_uid_;
  }
  if (sender_uid) {
    set_has_sender_uid();
    sender_uid_ = sender_uid;
  } else {
    clear_has_sender_uid();
    sender_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sender_name = 3;
inline bool redbag_data::has_sender_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void redbag_data::set_has_sender_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void redbag_data::clear_has_sender_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void redbag_data::clear_sender_name() {
  if (sender_name_ != &::google::protobuf::internal::kEmptyString) {
    sender_name_->clear();
  }
  clear_has_sender_name();
}
inline const ::std::string& redbag_data::sender_name() const {
  return *sender_name_;
}
inline void redbag_data::set_sender_name(const ::std::string& value) {
  set_has_sender_name();
  if (sender_name_ == &::google::protobuf::internal::kEmptyString) {
    sender_name_ = new ::std::string;
  }
  sender_name_->assign(value);
}
inline void redbag_data::set_sender_name(const char* value) {
  set_has_sender_name();
  if (sender_name_ == &::google::protobuf::internal::kEmptyString) {
    sender_name_ = new ::std::string;
  }
  sender_name_->assign(value);
}
inline void redbag_data::set_sender_name(const char* value, size_t size) {
  set_has_sender_name();
  if (sender_name_ == &::google::protobuf::internal::kEmptyString) {
    sender_name_ = new ::std::string;
  }
  sender_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* redbag_data::mutable_sender_name() {
  set_has_sender_name();
  if (sender_name_ == &::google::protobuf::internal::kEmptyString) {
    sender_name_ = new ::std::string;
  }
  return sender_name_;
}
inline ::std::string* redbag_data::release_sender_name() {
  clear_has_sender_name();
  if (sender_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_name_;
    sender_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void redbag_data::set_allocated_sender_name(::std::string* sender_name) {
  if (sender_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_name_;
  }
  if (sender_name) {
    set_has_sender_name();
    sender_name_ = sender_name;
  } else {
    clear_has_sender_name();
    sender_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 count = 4;
inline bool redbag_data::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void redbag_data::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void redbag_data::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void redbag_data::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 redbag_data::count() const {
  return count_;
}
inline void redbag_data::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 money = 5;
inline bool redbag_data::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void redbag_data::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void redbag_data::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void redbag_data::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 redbag_data::money() const {
  return money_;
}
inline void redbag_data::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 rest_count = 6;
inline bool redbag_data::has_rest_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void redbag_data::set_has_rest_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void redbag_data::clear_has_rest_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void redbag_data::clear_rest_count() {
  rest_count_ = 0u;
  clear_has_rest_count();
}
inline ::google::protobuf::uint32 redbag_data::rest_count() const {
  return rest_count_;
}
inline void redbag_data::set_rest_count(::google::protobuf::uint32 value) {
  set_has_rest_count();
  rest_count_ = value;
}

// optional uint32 rest_money = 7;
inline bool redbag_data::has_rest_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void redbag_data::set_has_rest_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void redbag_data::clear_has_rest_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void redbag_data::clear_rest_money() {
  rest_money_ = 0u;
  clear_has_rest_money();
}
inline ::google::protobuf::uint32 redbag_data::rest_money() const {
  return rest_money_;
}
inline void redbag_data::set_rest_money(::google::protobuf::uint32 value) {
  set_has_rest_money();
  rest_money_ = value;
}

// optional uint32 send_time = 8;
inline bool redbag_data::has_send_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void redbag_data::set_has_send_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void redbag_data::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void redbag_data::clear_send_time() {
  send_time_ = 0u;
  clear_has_send_time();
}
inline ::google::protobuf::uint32 redbag_data::send_time() const {
  return send_time_;
}
inline void redbag_data::set_send_time(::google::protobuf::uint32 value) {
  set_has_send_time();
  send_time_ = value;
}

// optional uint32 finish_time = 9;
inline bool redbag_data::has_finish_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void redbag_data::set_has_finish_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void redbag_data::clear_has_finish_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void redbag_data::clear_finish_time() {
  finish_time_ = 0u;
  clear_has_finish_time();
}
inline ::google::protobuf::uint32 redbag_data::finish_time() const {
  return finish_time_;
}
inline void redbag_data::set_finish_time(::google::protobuf::uint32 value) {
  set_has_finish_time();
  finish_time_ = value;
}

// optional .proto.common.draw_data draw_data = 10;
inline bool redbag_data::has_draw_data() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void redbag_data::set_has_draw_data() {
  _has_bits_[0] |= 0x00000200u;
}
inline void redbag_data::clear_has_draw_data() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void redbag_data::clear_draw_data() {
  if (draw_data_ != NULL) draw_data_->::proto::common::draw_data::Clear();
  clear_has_draw_data();
}
inline const ::proto::common::draw_data& redbag_data::draw_data() const {
  return draw_data_ != NULL ? *draw_data_ : *default_instance_->draw_data_;
}
inline ::proto::common::draw_data* redbag_data::mutable_draw_data() {
  set_has_draw_data();
  if (draw_data_ == NULL) draw_data_ = new ::proto::common::draw_data;
  return draw_data_;
}
inline ::proto::common::draw_data* redbag_data::release_draw_data() {
  clear_has_draw_data();
  ::proto::common::draw_data* temp = draw_data_;
  draw_data_ = NULL;
  return temp;
}
inline void redbag_data::set_allocated_draw_data(::proto::common::draw_data* draw_data) {
  delete draw_data_;
  draw_data_ = draw_data;
  if (draw_data) {
    set_has_draw_data();
  } else {
    clear_has_draw_data();
  }
}

// -------------------------------------------------------------------

// other_rank_data

// optional uint32 type = 1;
inline bool other_rank_data::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void other_rank_data::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void other_rank_data::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void other_rank_data::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 other_rank_data::type() const {
  return type_;
}
inline void other_rank_data::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 value = 2;
inline bool other_rank_data::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void other_rank_data::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void other_rank_data::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void other_rank_data::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 other_rank_data::value() const {
  return value_;
}
inline void other_rank_data::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
}

// optional uint32 level = 3;
inline bool other_rank_data::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void other_rank_data::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void other_rank_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void other_rank_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 other_rank_data::level() const {
  return level_;
}
inline void other_rank_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// role_base_data

// optional uint32 role_level = 1;
inline bool role_base_data::has_role_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_base_data::set_has_role_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_base_data::clear_has_role_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_base_data::clear_role_level() {
  role_level_ = 0u;
  clear_has_role_level();
}
inline ::google::protobuf::uint32 role_base_data::role_level() const {
  return role_level_;
}
inline void role_base_data::set_role_level(::google::protobuf::uint32 value) {
  set_has_role_level();
  role_level_ = value;
}

// optional string name = 2;
inline bool role_base_data::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_base_data::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_base_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_base_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& role_base_data::name() const {
  return *name_;
}
inline void role_base_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_base_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void role_base_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_base_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* role_base_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_base_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 3;
inline bool role_base_data::has_family_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_base_data::set_has_family_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_base_data::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_base_data::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& role_base_data::family_name() const {
  return *family_name_;
}
inline void role_base_data::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void role_base_data::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void role_base_data::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_base_data::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* role_base_data::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_base_data::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 head_info = 4;
inline bool role_base_data::has_head_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void role_base_data::set_has_head_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void role_base_data::clear_has_head_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void role_base_data::clear_head_info() {
  head_info_ = 0u;
  clear_has_head_info();
}
inline ::google::protobuf::uint32 role_base_data::head_info() const {
  return head_info_;
}
inline void role_base_data::set_head_info(::google::protobuf::uint32 value) {
  set_has_head_info();
  head_info_ = value;
}

// optional string country_name = 5;
inline bool role_base_data::has_country_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void role_base_data::set_has_country_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void role_base_data::clear_has_country_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void role_base_data::clear_country_name() {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    country_name_->clear();
  }
  clear_has_country_name();
}
inline const ::std::string& role_base_data::country_name() const {
  return *country_name_;
}
inline void role_base_data::set_country_name(const ::std::string& value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void role_base_data::set_country_name(const char* value) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(value);
}
inline void role_base_data::set_country_name(const char* value, size_t size) {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  country_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_base_data::mutable_country_name() {
  set_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    country_name_ = new ::std::string;
  }
  return country_name_;
}
inline ::std::string* role_base_data::release_country_name() {
  clear_has_country_name();
  if (country_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_name_;
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_base_data::set_allocated_country_name(::std::string* country_name) {
  if (country_name_ != &::google::protobuf::internal::kEmptyString) {
    delete country_name_;
  }
  if (country_name) {
    set_has_country_name();
    country_name_ = country_name;
  } else {
    clear_has_country_name();
    country_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fighting = 6;
inline bool role_base_data::has_fighting() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void role_base_data::set_has_fighting() {
  _has_bits_[0] |= 0x00000020u;
}
inline void role_base_data::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void role_base_data::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 role_base_data::fighting() const {
  return fighting_;
}
inline void role_base_data::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional string team_id = 7;
inline bool role_base_data::has_team_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void role_base_data::set_has_team_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void role_base_data::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void role_base_data::clear_team_id() {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    team_id_->clear();
  }
  clear_has_team_id();
}
inline const ::std::string& role_base_data::team_id() const {
  return *team_id_;
}
inline void role_base_data::set_team_id(const ::std::string& value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void role_base_data::set_team_id(const char* value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void role_base_data::set_team_id(const char* value, size_t size) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* role_base_data::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  return team_id_;
}
inline ::std::string* role_base_data::release_team_id() {
  clear_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_id_;
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void role_base_data::set_allocated_team_id(::std::string* team_id) {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    delete team_id_;
  }
  if (team_id) {
    set_has_team_id();
    team_id_ = team_id;
  } else {
    clear_has_team_id();
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 country_flag = 8;
inline bool role_base_data::has_country_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void role_base_data::set_has_country_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void role_base_data::clear_has_country_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void role_base_data::clear_country_flag() {
  country_flag_ = 0u;
  clear_has_country_flag();
}
inline ::google::protobuf::uint32 role_base_data::country_flag() const {
  return country_flag_;
}
inline void role_base_data::set_country_flag(::google::protobuf::uint32 value) {
  set_has_country_flag();
  country_flag_ = value;
}

// optional uint32 charm = 9;
inline bool role_base_data::has_charm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void role_base_data::set_has_charm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void role_base_data::clear_has_charm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void role_base_data::clear_charm() {
  charm_ = 0u;
  clear_has_charm();
}
inline ::google::protobuf::uint32 role_base_data::charm() const {
  return charm_;
}
inline void role_base_data::set_charm(::google::protobuf::uint32 value) {
  set_has_charm();
  charm_ = value;
}

// -------------------------------------------------------------------

// role_simple_data

// optional .proto.common.role_base_data base = 1;
inline bool role_simple_data::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_simple_data::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_simple_data::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_simple_data::clear_base() {
  if (base_ != NULL) base_->::proto::common::role_base_data::Clear();
  clear_has_base();
}
inline const ::proto::common::role_base_data& role_simple_data::base() const {
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::proto::common::role_base_data* role_simple_data::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::proto::common::role_base_data;
  return base_;
}
inline ::proto::common::role_base_data* role_simple_data::release_base() {
  clear_has_base();
  ::proto::common::role_base_data* temp = base_;
  base_ = NULL;
  return temp;
}
inline void role_simple_data::set_allocated_base(::proto::common::role_base_data* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
}

// optional .proto.common.hero_data hero = 2;
inline bool role_simple_data::has_hero() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void role_simple_data::set_has_hero() {
  _has_bits_[0] |= 0x00000002u;
}
inline void role_simple_data::clear_has_hero() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void role_simple_data::clear_hero() {
  if (hero_ != NULL) hero_->::proto::common::hero_data::Clear();
  clear_has_hero();
}
inline const ::proto::common::hero_data& role_simple_data::hero() const {
  return hero_ != NULL ? *hero_ : *default_instance_->hero_;
}
inline ::proto::common::hero_data* role_simple_data::mutable_hero() {
  set_has_hero();
  if (hero_ == NULL) hero_ = new ::proto::common::hero_data;
  return hero_;
}
inline ::proto::common::hero_data* role_simple_data::release_hero() {
  clear_has_hero();
  ::proto::common::hero_data* temp = hero_;
  hero_ = NULL;
  return temp;
}
inline void role_simple_data::set_allocated_hero(::proto::common::hero_data* hero) {
  delete hero_;
  hero_ = hero;
  if (hero) {
    set_has_hero();
  } else {
    clear_has_hero();
  }
}

// optional .proto.common.item_data item = 3;
inline bool role_simple_data::has_item() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void role_simple_data::set_has_item() {
  _has_bits_[0] |= 0x00000004u;
}
inline void role_simple_data::clear_has_item() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void role_simple_data::clear_item() {
  if (item_ != NULL) item_->::proto::common::item_data::Clear();
  clear_has_item();
}
inline const ::proto::common::item_data& role_simple_data::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::proto::common::item_data* role_simple_data::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::proto::common::item_data;
  return item_;
}
inline ::proto::common::item_data* role_simple_data::release_item() {
  clear_has_item();
  ::proto::common::item_data* temp = item_;
  item_ = NULL;
  return temp;
}
inline void role_simple_data::set_allocated_item(::proto::common::item_data* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// role_blob_data

// optional .proto.common.role_simple_data simple = 1;
inline bool role_blob_data::has_simple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void role_blob_data::set_has_simple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void role_blob_data::clear_has_simple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void role_blob_data::clear_simple() {
  if (simple_ != NULL) simple_->::proto::common::role_simple_data::Clear();
  clear_has_simple();
}
inline const ::proto::common::role_simple_data& role_blob_data::simple() const {
  return simple_ != NULL ? *simple_ : *default_instance_->simple_;
}
inline ::proto::common::role_simple_data* role_blob_data::mutable_simple() {
  set_has_simple();
  if (simple_ == NULL) simple_ = new ::proto::common::role_simple_data;
  return simple_;
}
inline ::proto::common::role_simple_data* role_blob_data::release_simple() {
  clear_has_simple();
  ::proto::common::role_simple_data* temp = simple_;
  simple_ = NULL;
  return temp;
}
inline void role_blob_data::set_allocated_simple(::proto::common::role_simple_data* simple) {
  delete simple_;
  simple_ = simple;
  if (simple) {
    set_has_simple();
  } else {
    clear_has_simple();
  }
}

// -------------------------------------------------------------------

// hero_strategy_info

// optional uint32 hero_tid = 1;
inline bool hero_strategy_info::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_strategy_info::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_strategy_info::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_strategy_info::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 hero_strategy_info::hero_tid() const {
  return hero_tid_;
}
inline void hero_strategy_info::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional uint32 hero_use_rate = 2;
inline bool hero_strategy_info::has_hero_use_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_strategy_info::set_has_hero_use_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_strategy_info::clear_has_hero_use_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_strategy_info::clear_hero_use_rate() {
  hero_use_rate_ = 0u;
  clear_has_hero_use_rate();
}
inline ::google::protobuf::uint32 hero_strategy_info::hero_use_rate() const {
  return hero_use_rate_;
}
inline void hero_strategy_info::set_hero_use_rate(::google::protobuf::uint32 value) {
  set_has_hero_use_rate();
  hero_use_rate_ = value;
}

// optional uint32 hero_use_hot = 3;
inline bool hero_strategy_info::has_hero_use_hot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_strategy_info::set_has_hero_use_hot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_strategy_info::clear_has_hero_use_hot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_strategy_info::clear_hero_use_hot() {
  hero_use_hot_ = 0u;
  clear_has_hero_use_hot();
}
inline ::google::protobuf::uint32 hero_strategy_info::hero_use_hot() const {
  return hero_use_hot_;
}
inline void hero_strategy_info::set_hero_use_hot(::google::protobuf::uint32 value) {
  set_has_hero_use_hot();
  hero_use_hot_ = value;
}

// repeated .proto.common.hero_strategy_single role_list = 4;
inline int hero_strategy_info::role_list_size() const {
  return role_list_.size();
}
inline void hero_strategy_info::clear_role_list() {
  role_list_.Clear();
}
inline const ::proto::common::hero_strategy_single& hero_strategy_info::role_list(int index) const {
  return role_list_.Get(index);
}
inline ::proto::common::hero_strategy_single* hero_strategy_info::mutable_role_list(int index) {
  return role_list_.Mutable(index);
}
inline ::proto::common::hero_strategy_single* hero_strategy_info::add_role_list() {
  return role_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::hero_strategy_single >&
hero_strategy_info::role_list() const {
  return role_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::hero_strategy_single >*
hero_strategy_info::mutable_role_list() {
  return &role_list_;
}

// -------------------------------------------------------------------

// hero_strategy_single

// optional string role_name = 1;
inline bool hero_strategy_single::has_role_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_strategy_single::set_has_role_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_strategy_single::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_strategy_single::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& hero_strategy_single::role_name() const {
  return *role_name_;
}
inline void hero_strategy_single::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void hero_strategy_single::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void hero_strategy_single::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_strategy_single::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* hero_strategy_single::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_strategy_single::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 role_rank = 2;
inline bool hero_strategy_single::has_role_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_strategy_single::set_has_role_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_strategy_single::clear_has_role_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_strategy_single::clear_role_rank() {
  role_rank_ = 0u;
  clear_has_role_rank();
}
inline ::google::protobuf::uint32 hero_strategy_single::role_rank() const {
  return role_rank_;
}
inline void hero_strategy_single::set_role_rank(::google::protobuf::uint32 value) {
  set_has_role_rank();
  role_rank_ = value;
}

// optional uint32 role_score = 3;
inline bool hero_strategy_single::has_role_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_strategy_single::set_has_role_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_strategy_single::clear_has_role_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_strategy_single::clear_role_score() {
  role_score_ = 0u;
  clear_has_role_score();
}
inline ::google::protobuf::uint32 hero_strategy_single::role_score() const {
  return role_score_;
}
inline void hero_strategy_single::set_role_score(::google::protobuf::uint32 value) {
  set_has_role_score();
  role_score_ = value;
}

// optional uint32 server_id = 4;
inline bool hero_strategy_single::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero_strategy_single::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero_strategy_single::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero_strategy_single::clear_server_id() {
  server_id_ = 0u;
  clear_has_server_id();
}
inline ::google::protobuf::uint32 hero_strategy_single::server_id() const {
  return server_id_;
}
inline void hero_strategy_single::set_server_id(::google::protobuf::uint32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional string server_name = 5;
inline bool hero_strategy_single::has_server_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void hero_strategy_single::set_has_server_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void hero_strategy_single::clear_has_server_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void hero_strategy_single::clear_server_name() {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    server_name_->clear();
  }
  clear_has_server_name();
}
inline const ::std::string& hero_strategy_single::server_name() const {
  return *server_name_;
}
inline void hero_strategy_single::set_server_name(const ::std::string& value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void hero_strategy_single::set_server_name(const char* value) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(value);
}
inline void hero_strategy_single::set_server_name(const char* value, size_t size) {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  server_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_strategy_single::mutable_server_name() {
  set_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    server_name_ = new ::std::string;
  }
  return server_name_;
}
inline ::std::string* hero_strategy_single::release_server_name() {
  clear_has_server_name();
  if (server_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_name_;
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_strategy_single::set_allocated_server_name(::std::string* server_name) {
  if (server_name_ != &::google::protobuf::internal::kEmptyString) {
    delete server_name_;
  }
  if (server_name) {
    set_has_server_name();
    server_name_ = server_name;
  } else {
    clear_has_server_name();
    server_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.hero_strategy_equip_info equip_info_list = 6;
inline bool hero_strategy_single::has_equip_info_list() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void hero_strategy_single::set_has_equip_info_list() {
  _has_bits_[0] |= 0x00000020u;
}
inline void hero_strategy_single::clear_has_equip_info_list() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void hero_strategy_single::clear_equip_info_list() {
  if (equip_info_list_ != NULL) equip_info_list_->::proto::common::hero_strategy_equip_info::Clear();
  clear_has_equip_info_list();
}
inline const ::proto::common::hero_strategy_equip_info& hero_strategy_single::equip_info_list() const {
  return equip_info_list_ != NULL ? *equip_info_list_ : *default_instance_->equip_info_list_;
}
inline ::proto::common::hero_strategy_equip_info* hero_strategy_single::mutable_equip_info_list() {
  set_has_equip_info_list();
  if (equip_info_list_ == NULL) equip_info_list_ = new ::proto::common::hero_strategy_equip_info;
  return equip_info_list_;
}
inline ::proto::common::hero_strategy_equip_info* hero_strategy_single::release_equip_info_list() {
  clear_has_equip_info_list();
  ::proto::common::hero_strategy_equip_info* temp = equip_info_list_;
  equip_info_list_ = NULL;
  return temp;
}
inline void hero_strategy_single::set_allocated_equip_info_list(::proto::common::hero_strategy_equip_info* equip_info_list) {
  delete equip_info_list_;
  equip_info_list_ = equip_info_list;
  if (equip_info_list) {
    set_has_equip_info_list();
  } else {
    clear_has_equip_info_list();
  }
}

// optional .proto.common.hero_strategy_hero_info hero_info_list = 7;
inline bool hero_strategy_single::has_hero_info_list() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void hero_strategy_single::set_has_hero_info_list() {
  _has_bits_[0] |= 0x00000040u;
}
inline void hero_strategy_single::clear_has_hero_info_list() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void hero_strategy_single::clear_hero_info_list() {
  if (hero_info_list_ != NULL) hero_info_list_->::proto::common::hero_strategy_hero_info::Clear();
  clear_has_hero_info_list();
}
inline const ::proto::common::hero_strategy_hero_info& hero_strategy_single::hero_info_list() const {
  return hero_info_list_ != NULL ? *hero_info_list_ : *default_instance_->hero_info_list_;
}
inline ::proto::common::hero_strategy_hero_info* hero_strategy_single::mutable_hero_info_list() {
  set_has_hero_info_list();
  if (hero_info_list_ == NULL) hero_info_list_ = new ::proto::common::hero_strategy_hero_info;
  return hero_info_list_;
}
inline ::proto::common::hero_strategy_hero_info* hero_strategy_single::release_hero_info_list() {
  clear_has_hero_info_list();
  ::proto::common::hero_strategy_hero_info* temp = hero_info_list_;
  hero_info_list_ = NULL;
  return temp;
}
inline void hero_strategy_single::set_allocated_hero_info_list(::proto::common::hero_strategy_hero_info* hero_info_list) {
  delete hero_info_list_;
  hero_info_list_ = hero_info_list;
  if (hero_info_list) {
    set_has_hero_info_list();
  } else {
    clear_has_hero_info_list();
  }
}

// -------------------------------------------------------------------

// hero_strategy_equip_info

// repeated .proto.common.item_single equip_list = 1;
inline int hero_strategy_equip_info::equip_list_size() const {
  return equip_list_.size();
}
inline void hero_strategy_equip_info::clear_equip_list() {
  equip_list_.Clear();
}
inline const ::proto::common::item_single& hero_strategy_equip_info::equip_list(int index) const {
  return equip_list_.Get(index);
}
inline ::proto::common::item_single* hero_strategy_equip_info::mutable_equip_list(int index) {
  return equip_list_.Mutable(index);
}
inline ::proto::common::item_single* hero_strategy_equip_info::add_equip_list() {
  return equip_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >&
hero_strategy_equip_info::equip_list() const {
  return equip_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_single >*
hero_strategy_equip_info::mutable_equip_list() {
  return &equip_list_;
}

// -------------------------------------------------------------------

// hero_strategy_hero_info

// repeated uint32 hero_tid_list = 1;
inline int hero_strategy_hero_info::hero_tid_list_size() const {
  return hero_tid_list_.size();
}
inline void hero_strategy_hero_info::clear_hero_tid_list() {
  hero_tid_list_.Clear();
}
inline ::google::protobuf::uint32 hero_strategy_hero_info::hero_tid_list(int index) const {
  return hero_tid_list_.Get(index);
}
inline void hero_strategy_hero_info::set_hero_tid_list(int index, ::google::protobuf::uint32 value) {
  hero_tid_list_.Set(index, value);
}
inline void hero_strategy_hero_info::add_hero_tid_list(::google::protobuf::uint32 value) {
  hero_tid_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
hero_strategy_hero_info::hero_tid_list() const {
  return hero_tid_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
hero_strategy_hero_info::mutable_hero_tid_list() {
  return &hero_tid_list_;
}

// -------------------------------------------------------------------

// hero_strategy_comment_info

// optional uint32 hero_tid = 1;
inline bool hero_strategy_comment_info::has_hero_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_strategy_comment_info::set_has_hero_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_strategy_comment_info::clear_has_hero_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_strategy_comment_info::clear_hero_tid() {
  hero_tid_ = 0u;
  clear_has_hero_tid();
}
inline ::google::protobuf::uint32 hero_strategy_comment_info::hero_tid() const {
  return hero_tid_;
}
inline void hero_strategy_comment_info::set_hero_tid(::google::protobuf::uint32 value) {
  set_has_hero_tid();
  hero_tid_ = value;
}

// optional string comment_info = 2;
inline bool hero_strategy_comment_info::has_comment_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_strategy_comment_info::set_has_comment_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_strategy_comment_info::clear_has_comment_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_strategy_comment_info::clear_comment_info() {
  if (comment_info_ != &::google::protobuf::internal::kEmptyString) {
    comment_info_->clear();
  }
  clear_has_comment_info();
}
inline const ::std::string& hero_strategy_comment_info::comment_info() const {
  return *comment_info_;
}
inline void hero_strategy_comment_info::set_comment_info(const ::std::string& value) {
  set_has_comment_info();
  if (comment_info_ == &::google::protobuf::internal::kEmptyString) {
    comment_info_ = new ::std::string;
  }
  comment_info_->assign(value);
}
inline void hero_strategy_comment_info::set_comment_info(const char* value) {
  set_has_comment_info();
  if (comment_info_ == &::google::protobuf::internal::kEmptyString) {
    comment_info_ = new ::std::string;
  }
  comment_info_->assign(value);
}
inline void hero_strategy_comment_info::set_comment_info(const char* value, size_t size) {
  set_has_comment_info();
  if (comment_info_ == &::google::protobuf::internal::kEmptyString) {
    comment_info_ = new ::std::string;
  }
  comment_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_strategy_comment_info::mutable_comment_info() {
  set_has_comment_info();
  if (comment_info_ == &::google::protobuf::internal::kEmptyString) {
    comment_info_ = new ::std::string;
  }
  return comment_info_;
}
inline ::std::string* hero_strategy_comment_info::release_comment_info() {
  clear_has_comment_info();
  if (comment_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_info_;
    comment_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_strategy_comment_info::set_allocated_comment_info(::std::string* comment_info) {
  if (comment_info_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_info_;
  }
  if (comment_info) {
    set_has_comment_info();
    comment_info_ = comment_info;
  } else {
    clear_has_comment_info();
    comment_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_info = 3;
inline bool hero_strategy_comment_info::has_role_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void hero_strategy_comment_info::set_has_role_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void hero_strategy_comment_info::clear_has_role_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void hero_strategy_comment_info::clear_role_info() {
  if (role_info_ != &::google::protobuf::internal::kEmptyString) {
    role_info_->clear();
  }
  clear_has_role_info();
}
inline const ::std::string& hero_strategy_comment_info::role_info() const {
  return *role_info_;
}
inline void hero_strategy_comment_info::set_role_info(const ::std::string& value) {
  set_has_role_info();
  if (role_info_ == &::google::protobuf::internal::kEmptyString) {
    role_info_ = new ::std::string;
  }
  role_info_->assign(value);
}
inline void hero_strategy_comment_info::set_role_info(const char* value) {
  set_has_role_info();
  if (role_info_ == &::google::protobuf::internal::kEmptyString) {
    role_info_ = new ::std::string;
  }
  role_info_->assign(value);
}
inline void hero_strategy_comment_info::set_role_info(const char* value, size_t size) {
  set_has_role_info();
  if (role_info_ == &::google::protobuf::internal::kEmptyString) {
    role_info_ = new ::std::string;
  }
  role_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_strategy_comment_info::mutable_role_info() {
  set_has_role_info();
  if (role_info_ == &::google::protobuf::internal::kEmptyString) {
    role_info_ = new ::std::string;
  }
  return role_info_;
}
inline ::std::string* hero_strategy_comment_info::release_role_info() {
  clear_has_role_info();
  if (role_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_info_;
    role_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_strategy_comment_info::set_allocated_role_info(::std::string* role_info) {
  if (role_info_ != &::google::protobuf::internal::kEmptyString) {
    delete role_info_;
  }
  if (role_info) {
    set_has_role_info();
    role_info_ = role_info;
  } else {
    clear_has_role_info();
    role_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 like_num = 4;
inline bool hero_strategy_comment_info::has_like_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void hero_strategy_comment_info::set_has_like_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void hero_strategy_comment_info::clear_has_like_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void hero_strategy_comment_info::clear_like_num() {
  like_num_ = 0u;
  clear_has_like_num();
}
inline ::google::protobuf::uint32 hero_strategy_comment_info::like_num() const {
  return like_num_;
}
inline void hero_strategy_comment_info::set_like_num(::google::protobuf::uint32 value) {
  set_has_like_num();
  like_num_ = value;
}

// optional uint32 dislike_num = 5;
inline bool hero_strategy_comment_info::has_dislike_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void hero_strategy_comment_info::set_has_dislike_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void hero_strategy_comment_info::clear_has_dislike_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void hero_strategy_comment_info::clear_dislike_num() {
  dislike_num_ = 0u;
  clear_has_dislike_num();
}
inline ::google::protobuf::uint32 hero_strategy_comment_info::dislike_num() const {
  return dislike_num_;
}
inline void hero_strategy_comment_info::set_dislike_num(::google::protobuf::uint32 value) {
  set_has_dislike_num();
  dislike_num_ = value;
}

// optional uint32 time = 6;
inline bool hero_strategy_comment_info::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void hero_strategy_comment_info::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void hero_strategy_comment_info::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void hero_strategy_comment_info::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 hero_strategy_comment_info::time() const {
  return time_;
}
inline void hero_strategy_comment_info::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// offline_arena_single

// optional string role_uid = 1;
inline bool offline_arena_single::has_role_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void offline_arena_single::set_has_role_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void offline_arena_single::clear_has_role_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void offline_arena_single::clear_role_uid() {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    role_uid_->clear();
  }
  clear_has_role_uid();
}
inline const ::std::string& offline_arena_single::role_uid() const {
  return *role_uid_;
}
inline void offline_arena_single::set_role_uid(const ::std::string& value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_single::set_role_uid(const char* value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_single::set_role_uid(const char* value, size_t size) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_single::mutable_role_uid() {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  return role_uid_;
}
inline ::std::string* offline_arena_single::release_role_uid() {
  clear_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_uid_;
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_single::set_allocated_role_uid(::std::string* role_uid) {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete role_uid_;
  }
  if (role_uid) {
    set_has_role_uid();
    role_uid_ = role_uid;
  } else {
    clear_has_role_uid();
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 cur_class = 2;
inline bool offline_arena_single::has_cur_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void offline_arena_single::set_has_cur_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void offline_arena_single::clear_has_cur_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void offline_arena_single::clear_cur_class() {
  cur_class_ = 0u;
  clear_has_cur_class();
}
inline ::google::protobuf::uint32 offline_arena_single::cur_class() const {
  return cur_class_;
}
inline void offline_arena_single::set_cur_class(::google::protobuf::uint32 value) {
  set_has_cur_class();
  cur_class_ = value;
}

// optional uint32 cur_rank = 3;
inline bool offline_arena_single::has_cur_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void offline_arena_single::set_has_cur_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void offline_arena_single::clear_has_cur_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void offline_arena_single::clear_cur_rank() {
  cur_rank_ = 0u;
  clear_has_cur_rank();
}
inline ::google::protobuf::uint32 offline_arena_single::cur_rank() const {
  return cur_rank_;
}
inline void offline_arena_single::set_cur_rank(::google::protobuf::uint32 value) {
  set_has_cur_rank();
  cur_rank_ = value;
}

// optional uint32 old_record_rank = 4;
inline bool offline_arena_single::has_old_record_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void offline_arena_single::set_has_old_record_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void offline_arena_single::clear_has_old_record_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void offline_arena_single::clear_old_record_rank() {
  old_record_rank_ = 0u;
  clear_has_old_record_rank();
}
inline ::google::protobuf::uint32 offline_arena_single::old_record_rank() const {
  return old_record_rank_;
}
inline void offline_arena_single::set_old_record_rank(::google::protobuf::uint32 value) {
  set_has_old_record_rank();
  old_record_rank_ = value;
}

// optional uint32 record_rank = 5;
inline bool offline_arena_single::has_record_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void offline_arena_single::set_has_record_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void offline_arena_single::clear_has_record_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void offline_arena_single::clear_record_rank() {
  record_rank_ = 0u;
  clear_has_record_rank();
}
inline ::google::protobuf::uint32 offline_arena_single::record_rank() const {
  return record_rank_;
}
inline void offline_arena_single::set_record_rank(::google::protobuf::uint32 value) {
  set_has_record_rank();
  record_rank_ = value;
}

// optional uint32 old_class = 6;
inline bool offline_arena_single::has_old_class() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void offline_arena_single::set_has_old_class() {
  _has_bits_[0] |= 0x00000020u;
}
inline void offline_arena_single::clear_has_old_class() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void offline_arena_single::clear_old_class() {
  old_class_ = 0u;
  clear_has_old_class();
}
inline ::google::protobuf::uint32 offline_arena_single::old_class() const {
  return old_class_;
}
inline void offline_arena_single::set_old_class(::google::protobuf::uint32 value) {
  set_has_old_class();
  old_class_ = value;
}

// optional uint32 fight_count = 7;
inline bool offline_arena_single::has_fight_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void offline_arena_single::set_has_fight_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void offline_arena_single::clear_has_fight_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void offline_arena_single::clear_fight_count() {
  fight_count_ = 0u;
  clear_has_fight_count();
}
inline ::google::protobuf::uint32 offline_arena_single::fight_count() const {
  return fight_count_;
}
inline void offline_arena_single::set_fight_count(::google::protobuf::uint32 value) {
  set_has_fight_count();
  fight_count_ = value;
}

// optional uint32 buy_count = 8;
inline bool offline_arena_single::has_buy_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void offline_arena_single::set_has_buy_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void offline_arena_single::clear_has_buy_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void offline_arena_single::clear_buy_count() {
  buy_count_ = 0u;
  clear_has_buy_count();
}
inline ::google::protobuf::uint32 offline_arena_single::buy_count() const {
  return buy_count_;
}
inline void offline_arena_single::set_buy_count(::google::protobuf::uint32 value) {
  set_has_buy_count();
  buy_count_ = value;
}

// optional .proto.common.mirror_fight_data form_data = 9;
inline bool offline_arena_single::has_form_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void offline_arena_single::set_has_form_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void offline_arena_single::clear_has_form_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void offline_arena_single::clear_form_data() {
  if (form_data_ != NULL) form_data_->::proto::common::mirror_fight_data::Clear();
  clear_has_form_data();
}
inline const ::proto::common::mirror_fight_data& offline_arena_single::form_data() const {
  return form_data_ != NULL ? *form_data_ : *default_instance_->form_data_;
}
inline ::proto::common::mirror_fight_data* offline_arena_single::mutable_form_data() {
  set_has_form_data();
  if (form_data_ == NULL) form_data_ = new ::proto::common::mirror_fight_data;
  return form_data_;
}
inline ::proto::common::mirror_fight_data* offline_arena_single::release_form_data() {
  clear_has_form_data();
  ::proto::common::mirror_fight_data* temp = form_data_;
  form_data_ = NULL;
  return temp;
}
inline void offline_arena_single::set_allocated_form_data(::proto::common::mirror_fight_data* form_data) {
  delete form_data_;
  form_data_ = form_data;
  if (form_data) {
    set_has_form_data();
  } else {
    clear_has_form_data();
  }
}

// optional uint32 score = 10;
inline bool offline_arena_single::has_score() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void offline_arena_single::set_has_score() {
  _has_bits_[0] |= 0x00000200u;
}
inline void offline_arena_single::clear_has_score() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void offline_arena_single::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 offline_arena_single::score() const {
  return score_;
}
inline void offline_arena_single::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// repeated .proto.common.liveness_box score_box = 11;
inline int offline_arena_single::score_box_size() const {
  return score_box_.size();
}
inline void offline_arena_single::clear_score_box() {
  score_box_.Clear();
}
inline const ::proto::common::liveness_box& offline_arena_single::score_box(int index) const {
  return score_box_.Get(index);
}
inline ::proto::common::liveness_box* offline_arena_single::mutable_score_box(int index) {
  return score_box_.Mutable(index);
}
inline ::proto::common::liveness_box* offline_arena_single::add_score_box() {
  return score_box_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >&
offline_arena_single::score_box() const {
  return score_box_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::liveness_box >*
offline_arena_single::mutable_score_box() {
  return &score_box_;
}

// -------------------------------------------------------------------

// offline_arena_general

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 1 [default = SCENEOBJECT_USER];
inline bool offline_arena_general::has_object_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void offline_arena_general::set_has_object_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void offline_arena_general::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void offline_arena_general::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE offline_arena_general::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void offline_arena_general::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional string role_uid = 2;
inline bool offline_arena_general::has_role_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void offline_arena_general::set_has_role_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void offline_arena_general::clear_has_role_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void offline_arena_general::clear_role_uid() {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    role_uid_->clear();
  }
  clear_has_role_uid();
}
inline const ::std::string& offline_arena_general::role_uid() const {
  return *role_uid_;
}
inline void offline_arena_general::set_role_uid(const ::std::string& value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_general::set_role_uid(const char* value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_general::set_role_uid(const char* value, size_t size) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_general::mutable_role_uid() {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  return role_uid_;
}
inline ::std::string* offline_arena_general::release_role_uid() {
  clear_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_uid_;
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_general::set_allocated_role_uid(::std::string* role_uid) {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete role_uid_;
  }
  if (role_uid) {
    set_has_role_uid();
    role_uid_ = role_uid;
  } else {
    clear_has_role_uid();
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 3;
inline bool offline_arena_general::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void offline_arena_general::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void offline_arena_general::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void offline_arena_general::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& offline_arena_general::role_name() const {
  return *role_name_;
}
inline void offline_arena_general::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void offline_arena_general::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void offline_arena_general::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_general::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* offline_arena_general::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_general::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string family_name = 4;
inline bool offline_arena_general::has_family_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void offline_arena_general::set_has_family_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void offline_arena_general::clear_has_family_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void offline_arena_general::clear_family_name() {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    family_name_->clear();
  }
  clear_has_family_name();
}
inline const ::std::string& offline_arena_general::family_name() const {
  return *family_name_;
}
inline void offline_arena_general::set_family_name(const ::std::string& value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void offline_arena_general::set_family_name(const char* value) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(value);
}
inline void offline_arena_general::set_family_name(const char* value, size_t size) {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  family_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_general::mutable_family_name() {
  set_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    family_name_ = new ::std::string;
  }
  return family_name_;
}
inline ::std::string* offline_arena_general::release_family_name() {
  clear_has_family_name();
  if (family_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = family_name_;
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_general::set_allocated_family_name(::std::string* family_name) {
  if (family_name_ != &::google::protobuf::internal::kEmptyString) {
    delete family_name_;
  }
  if (family_name) {
    set_has_family_name();
    family_name_ = family_name;
  } else {
    clear_has_family_name();
    family_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fighting = 5;
inline bool offline_arena_general::has_fighting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void offline_arena_general::set_has_fighting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void offline_arena_general::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void offline_arena_general::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 offline_arena_general::fighting() const {
  return fighting_;
}
inline void offline_arena_general::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 cur_rank = 6;
inline bool offline_arena_general::has_cur_rank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void offline_arena_general::set_has_cur_rank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void offline_arena_general::clear_has_cur_rank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void offline_arena_general::clear_cur_rank() {
  cur_rank_ = 0u;
  clear_has_cur_rank();
}
inline ::google::protobuf::uint32 offline_arena_general::cur_rank() const {
  return cur_rank_;
}
inline void offline_arena_general::set_cur_rank(::google::protobuf::uint32 value) {
  set_has_cur_rank();
  cur_rank_ = value;
}

// optional uint32 plugin = 7;
inline bool offline_arena_general::has_plugin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void offline_arena_general::set_has_plugin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void offline_arena_general::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void offline_arena_general::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 offline_arena_general::plugin() const {
  return plugin_;
}
inline void offline_arena_general::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 level = 8;
inline bool offline_arena_general::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void offline_arena_general::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void offline_arena_general::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void offline_arena_general::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 offline_arena_general::level() const {
  return level_;
}
inline void offline_arena_general::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 fight_against_id = 9;
inline bool offline_arena_general::has_fight_against_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void offline_arena_general::set_has_fight_against_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void offline_arena_general::clear_has_fight_against_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void offline_arena_general::clear_fight_against_id() {
  fight_against_id_ = 0u;
  clear_has_fight_against_id();
}
inline ::google::protobuf::uint32 offline_arena_general::fight_against_id() const {
  return fight_against_id_;
}
inline void offline_arena_general::set_fight_against_id(::google::protobuf::uint32 value) {
  set_has_fight_against_id();
  fight_against_id_ = value;
}

// optional uint32 headpic = 10;
inline bool offline_arena_general::has_headpic() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void offline_arena_general::set_has_headpic() {
  _has_bits_[0] |= 0x00000200u;
}
inline void offline_arena_general::clear_has_headpic() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void offline_arena_general::clear_headpic() {
  headpic_ = 0u;
  clear_has_headpic();
}
inline ::google::protobuf::uint32 offline_arena_general::headpic() const {
  return headpic_;
}
inline void offline_arena_general::set_headpic(::google::protobuf::uint32 value) {
  set_has_headpic();
  headpic_ = value;
}

// -------------------------------------------------------------------

// offline_arena_record

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 1 [default = SCENEOBJECT_USER];
inline bool offline_arena_record::has_object_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void offline_arena_record::set_has_object_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void offline_arena_record::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void offline_arena_record::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE offline_arena_record::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void offline_arena_record::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional string role_uid = 2;
inline bool offline_arena_record::has_role_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void offline_arena_record::set_has_role_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void offline_arena_record::clear_has_role_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void offline_arena_record::clear_role_uid() {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    role_uid_->clear();
  }
  clear_has_role_uid();
}
inline const ::std::string& offline_arena_record::role_uid() const {
  return *role_uid_;
}
inline void offline_arena_record::set_role_uid(const ::std::string& value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_record::set_role_uid(const char* value) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(value);
}
inline void offline_arena_record::set_role_uid(const char* value, size_t size) {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  role_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_record::mutable_role_uid() {
  set_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    role_uid_ = new ::std::string;
  }
  return role_uid_;
}
inline ::std::string* offline_arena_record::release_role_uid() {
  clear_has_role_uid();
  if (role_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_uid_;
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_record::set_allocated_role_uid(::std::string* role_uid) {
  if (role_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete role_uid_;
  }
  if (role_uid) {
    set_has_role_uid();
    role_uid_ = role_uid;
  } else {
    clear_has_role_uid();
    role_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 3;
inline bool offline_arena_record::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void offline_arena_record::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void offline_arena_record::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void offline_arena_record::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& offline_arena_record::role_name() const {
  return *role_name_;
}
inline void offline_arena_record::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void offline_arena_record::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void offline_arena_record::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* offline_arena_record::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* offline_arena_record::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void offline_arena_record::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 fighting = 4;
inline bool offline_arena_record::has_fighting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void offline_arena_record::set_has_fighting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void offline_arena_record::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void offline_arena_record::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 offline_arena_record::fighting() const {
  return fighting_;
}
inline void offline_arena_record::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 plugin = 5;
inline bool offline_arena_record::has_plugin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void offline_arena_record::set_has_plugin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void offline_arena_record::clear_has_plugin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void offline_arena_record::clear_plugin() {
  plugin_ = 0u;
  clear_has_plugin();
}
inline ::google::protobuf::uint32 offline_arena_record::plugin() const {
  return plugin_;
}
inline void offline_arena_record::set_plugin(::google::protobuf::uint32 value) {
  set_has_plugin();
  plugin_ = value;
}

// optional uint32 level = 6;
inline bool offline_arena_record::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void offline_arena_record::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void offline_arena_record::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void offline_arena_record::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 offline_arena_record::level() const {
  return level_;
}
inline void offline_arena_record::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 record_time = 7;
inline bool offline_arena_record::has_record_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void offline_arena_record::set_has_record_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void offline_arena_record::clear_has_record_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void offline_arena_record::clear_record_time() {
  record_time_ = 0u;
  clear_has_record_time();
}
inline ::google::protobuf::uint32 offline_arena_record::record_time() const {
  return record_time_;
}
inline void offline_arena_record::set_record_time(::google::protobuf::uint32 value) {
  set_has_record_time();
  record_time_ = value;
}

// optional uint32 old_rank = 8;
inline bool offline_arena_record::has_old_rank() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void offline_arena_record::set_has_old_rank() {
  _has_bits_[0] |= 0x00000080u;
}
inline void offline_arena_record::clear_has_old_rank() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void offline_arena_record::clear_old_rank() {
  old_rank_ = 0u;
  clear_has_old_rank();
}
inline ::google::protobuf::uint32 offline_arena_record::old_rank() const {
  return old_rank_;
}
inline void offline_arena_record::set_old_rank(::google::protobuf::uint32 value) {
  set_has_old_rank();
  old_rank_ = value;
}

// optional uint32 new_rank = 9;
inline bool offline_arena_record::has_new_rank() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void offline_arena_record::set_has_new_rank() {
  _has_bits_[0] |= 0x00000100u;
}
inline void offline_arena_record::clear_has_new_rank() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void offline_arena_record::clear_new_rank() {
  new_rank_ = 0u;
  clear_has_new_rank();
}
inline ::google::protobuf::uint32 offline_arena_record::new_rank() const {
  return new_rank_;
}
inline void offline_arena_record::set_new_rank(::google::protobuf::uint32 value) {
  set_has_new_rank();
  new_rank_ = value;
}

// optional uint32 is_win = 10;
inline bool offline_arena_record::has_is_win() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void offline_arena_record::set_has_is_win() {
  _has_bits_[0] |= 0x00000200u;
}
inline void offline_arena_record::clear_has_is_win() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void offline_arena_record::clear_is_win() {
  is_win_ = 0u;
  clear_has_is_win();
}
inline ::google::protobuf::uint32 offline_arena_record::is_win() const {
  return is_win_;
}
inline void offline_arena_record::set_is_win(::google::protobuf::uint32 value) {
  set_has_is_win();
  is_win_ = value;
}

// optional uint32 side = 11;
inline bool offline_arena_record::has_side() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void offline_arena_record::set_has_side() {
  _has_bits_[0] |= 0x00000400u;
}
inline void offline_arena_record::clear_has_side() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void offline_arena_record::clear_side() {
  side_ = 0u;
  clear_has_side();
}
inline ::google::protobuf::uint32 offline_arena_record::side() const {
  return side_;
}
inline void offline_arena_record::set_side(::google::protobuf::uint32 value) {
  set_has_side();
  side_ = value;
}

// optional uint32 headpic = 12;
inline bool offline_arena_record::has_headpic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void offline_arena_record::set_has_headpic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void offline_arena_record::clear_has_headpic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void offline_arena_record::clear_headpic() {
  headpic_ = 0u;
  clear_has_headpic();
}
inline ::google::protobuf::uint32 offline_arena_record::headpic() const {
  return headpic_;
}
inline void offline_arena_record::set_headpic(::google::protobuf::uint32 value) {
  set_has_headpic();
  headpic_ = value;
}

// -------------------------------------------------------------------

// offline_arena_record_data

// repeated .proto.common.offline_arena_record record_data = 1;
inline int offline_arena_record_data::record_data_size() const {
  return record_data_.size();
}
inline void offline_arena_record_data::clear_record_data() {
  record_data_.Clear();
}
inline const ::proto::common::offline_arena_record& offline_arena_record_data::record_data(int index) const {
  return record_data_.Get(index);
}
inline ::proto::common::offline_arena_record* offline_arena_record_data::mutable_record_data(int index) {
  return record_data_.Mutable(index);
}
inline ::proto::common::offline_arena_record* offline_arena_record_data::add_record_data() {
  return record_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::offline_arena_record >&
offline_arena_record_data::record_data() const {
  return record_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::offline_arena_record >*
offline_arena_record_data::mutable_record_data() {
  return &record_data_;
}

// -------------------------------------------------------------------

// wish_summon_info

// optional uint32 wish_summon_id = 1;
inline bool wish_summon_info::has_wish_summon_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wish_summon_info::set_has_wish_summon_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wish_summon_info::clear_has_wish_summon_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wish_summon_info::clear_wish_summon_id() {
  wish_summon_id_ = 0u;
  clear_has_wish_summon_id();
}
inline ::google::protobuf::uint32 wish_summon_info::wish_summon_id() const {
  return wish_summon_id_;
}
inline void wish_summon_info::set_wish_summon_id(::google::protobuf::uint32 value) {
  set_has_wish_summon_id();
  wish_summon_id_ = value;
}

// optional uint32 open_flag = 2;
inline bool wish_summon_info::has_open_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void wish_summon_info::set_has_open_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void wish_summon_info::clear_has_open_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void wish_summon_info::clear_open_flag() {
  open_flag_ = 0u;
  clear_has_open_flag();
}
inline ::google::protobuf::uint32 wish_summon_info::open_flag() const {
  return open_flag_;
}
inline void wish_summon_info::set_open_flag(::google::protobuf::uint32 value) {
  set_has_open_flag();
  open_flag_ = value;
}

// optional uint32 time_left = 3;
inline bool wish_summon_info::has_time_left() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void wish_summon_info::set_has_time_left() {
  _has_bits_[0] |= 0x00000004u;
}
inline void wish_summon_info::clear_has_time_left() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void wish_summon_info::clear_time_left() {
  time_left_ = 0u;
  clear_has_time_left();
}
inline ::google::protobuf::uint32 wish_summon_info::time_left() const {
  return time_left_;
}
inline void wish_summon_info::set_time_left(::google::protobuf::uint32 value) {
  set_has_time_left();
  time_left_ = value;
}

// optional uint32 buy_count = 4;
inline bool wish_summon_info::has_buy_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void wish_summon_info::set_has_buy_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void wish_summon_info::clear_has_buy_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void wish_summon_info::clear_buy_count() {
  buy_count_ = 0u;
  clear_has_buy_count();
}
inline ::google::protobuf::uint32 wish_summon_info::buy_count() const {
  return buy_count_;
}
inline void wish_summon_info::set_buy_count(::google::protobuf::uint32 value) {
  set_has_buy_count();
  buy_count_ = value;
}

// -------------------------------------------------------------------

// hero_chip_info

// optional string uid = 1;
inline bool hero_chip_info::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void hero_chip_info::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void hero_chip_info::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void hero_chip_info::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& hero_chip_info::uid() const {
  return *uid_;
}
inline void hero_chip_info::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void hero_chip_info::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void hero_chip_info::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* hero_chip_info::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* hero_chip_info::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void hero_chip_info::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num = 2;
inline bool hero_chip_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void hero_chip_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void hero_chip_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void hero_chip_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 hero_chip_info::num() const {
  return num_;
}
inline void hero_chip_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// buy_summon_info

// optional uint32 id = 1;
inline bool buy_summon_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void buy_summon_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void buy_summon_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void buy_summon_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 buy_summon_info::id() const {
  return id_;
}
inline void buy_summon_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool buy_summon_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void buy_summon_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void buy_summon_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void buy_summon_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 buy_summon_info::num() const {
  return num_;
}
inline void buy_summon_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// quick_task_info

// optional uint32 id = 1;
inline bool quick_task_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void quick_task_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void quick_task_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void quick_task_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 quick_task_info::id() const {
  return id_;
}
inline void quick_task_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool quick_task_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void quick_task_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void quick_task_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void quick_task_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 quick_task_info::num() const {
  return num_;
}
inline void quick_task_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 max_num = 3;
inline bool quick_task_info::has_max_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void quick_task_info::set_has_max_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void quick_task_info::clear_has_max_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void quick_task_info::clear_max_num() {
  max_num_ = 0u;
  clear_has_max_num();
}
inline ::google::protobuf::uint32 quick_task_info::max_num() const {
  return max_num_;
}
inline void quick_task_info::set_max_num(::google::protobuf::uint32 value) {
  set_has_max_num();
  max_num_ = value;
}

// -------------------------------------------------------------------

// item_num_info

// optional uint32 id = 1;
inline bool item_num_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void item_num_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void item_num_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void item_num_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 item_num_info::id() const {
  return id_;
}
inline void item_num_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool item_num_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void item_num_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void item_num_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void item_num_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 item_num_info::num() const {
  return num_;
}
inline void item_num_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// item_num_info_list

// repeated .proto.common.item_num_info item_list = 1;
inline int item_num_info_list::item_list_size() const {
  return item_list_.size();
}
inline void item_num_info_list::clear_item_list() {
  item_list_.Clear();
}
inline const ::proto::common::item_num_info& item_num_info_list::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::proto::common::item_num_info* item_num_info_list::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::proto::common::item_num_info* item_num_info_list::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::item_num_info >&
item_num_info_list::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::item_num_info >*
item_num_info_list::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// prize_status_info

// optional uint32 id = 1;
inline bool prize_status_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void prize_status_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void prize_status_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void prize_status_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 prize_status_info::id() const {
  return id_;
}
inline void prize_status_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 status = 2;
inline bool prize_status_info::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void prize_status_info::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void prize_status_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void prize_status_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 prize_status_info::status() const {
  return status_;
}
inline void prize_status_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// life_info

// optional uint32 label = 1;
inline bool life_info::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void life_info::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void life_info::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void life_info::clear_label() {
  label_ = 0u;
  clear_has_label();
}
inline ::google::protobuf::uint32 life_info::label() const {
  return label_;
}
inline void life_info::set_label(::google::protobuf::uint32 value) {
  set_has_label();
  label_ = value;
}

// -------------------------------------------------------------------

// money_tree_data

// optional uint32 level = 1;
inline bool money_tree_data::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void money_tree_data::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void money_tree_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void money_tree_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 money_tree_data::level() const {
  return level_;
}
inline void money_tree_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 count = 2;
inline bool money_tree_data::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void money_tree_data::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void money_tree_data::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void money_tree_data::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 money_tree_data::count() const {
  return count_;
}
inline void money_tree_data::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// bussiness_act_data

// optional .proto.common.money_tree_data money_tree_info = 1;
inline bool bussiness_act_data::has_money_tree_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bussiness_act_data::set_has_money_tree_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bussiness_act_data::clear_has_money_tree_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bussiness_act_data::clear_money_tree_info() {
  if (money_tree_info_ != NULL) money_tree_info_->::proto::common::money_tree_data::Clear();
  clear_has_money_tree_info();
}
inline const ::proto::common::money_tree_data& bussiness_act_data::money_tree_info() const {
  return money_tree_info_ != NULL ? *money_tree_info_ : *default_instance_->money_tree_info_;
}
inline ::proto::common::money_tree_data* bussiness_act_data::mutable_money_tree_info() {
  set_has_money_tree_info();
  if (money_tree_info_ == NULL) money_tree_info_ = new ::proto::common::money_tree_data;
  return money_tree_info_;
}
inline ::proto::common::money_tree_data* bussiness_act_data::release_money_tree_info() {
  clear_has_money_tree_info();
  ::proto::common::money_tree_data* temp = money_tree_info_;
  money_tree_info_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_money_tree_info(::proto::common::money_tree_data* money_tree_info) {
  delete money_tree_info_;
  money_tree_info_ = money_tree_info;
  if (money_tree_info) {
    set_has_money_tree_info();
  } else {
    clear_has_money_tree_info();
  }
}

// optional .proto.common.sevenday_login_save_data sevenday_data = 2;
inline bool bussiness_act_data::has_sevenday_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bussiness_act_data::set_has_sevenday_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bussiness_act_data::clear_has_sevenday_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bussiness_act_data::clear_sevenday_data() {
  if (sevenday_data_ != NULL) sevenday_data_->::proto::common::sevenday_login_save_data::Clear();
  clear_has_sevenday_data();
}
inline const ::proto::common::sevenday_login_save_data& bussiness_act_data::sevenday_data() const {
  return sevenday_data_ != NULL ? *sevenday_data_ : *default_instance_->sevenday_data_;
}
inline ::proto::common::sevenday_login_save_data* bussiness_act_data::mutable_sevenday_data() {
  set_has_sevenday_data();
  if (sevenday_data_ == NULL) sevenday_data_ = new ::proto::common::sevenday_login_save_data;
  return sevenday_data_;
}
inline ::proto::common::sevenday_login_save_data* bussiness_act_data::release_sevenday_data() {
  clear_has_sevenday_data();
  ::proto::common::sevenday_login_save_data* temp = sevenday_data_;
  sevenday_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_sevenday_data(::proto::common::sevenday_login_save_data* sevenday_data) {
  delete sevenday_data_;
  sevenday_data_ = sevenday_data;
  if (sevenday_data) {
    set_has_sevenday_data();
  } else {
    clear_has_sevenday_data();
  }
}

// optional .proto.common.month_card_save_data month_card_data = 3;
inline bool bussiness_act_data::has_month_card_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bussiness_act_data::set_has_month_card_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bussiness_act_data::clear_has_month_card_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bussiness_act_data::clear_month_card_data() {
  if (month_card_data_ != NULL) month_card_data_->::proto::common::month_card_save_data::Clear();
  clear_has_month_card_data();
}
inline const ::proto::common::month_card_save_data& bussiness_act_data::month_card_data() const {
  return month_card_data_ != NULL ? *month_card_data_ : *default_instance_->month_card_data_;
}
inline ::proto::common::month_card_save_data* bussiness_act_data::mutable_month_card_data() {
  set_has_month_card_data();
  if (month_card_data_ == NULL) month_card_data_ = new ::proto::common::month_card_save_data;
  return month_card_data_;
}
inline ::proto::common::month_card_save_data* bussiness_act_data::release_month_card_data() {
  clear_has_month_card_data();
  ::proto::common::month_card_save_data* temp = month_card_data_;
  month_card_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_month_card_data(::proto::common::month_card_save_data* month_card_data) {
  delete month_card_data_;
  month_card_data_ = month_card_data;
  if (month_card_data) {
    set_has_month_card_data();
  } else {
    clear_has_month_card_data();
  }
}

// optional .proto.common.level_fund_save_info level_fund_data = 4;
inline bool bussiness_act_data::has_level_fund_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bussiness_act_data::set_has_level_fund_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void bussiness_act_data::clear_has_level_fund_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void bussiness_act_data::clear_level_fund_data() {
  if (level_fund_data_ != NULL) level_fund_data_->::proto::common::level_fund_save_info::Clear();
  clear_has_level_fund_data();
}
inline const ::proto::common::level_fund_save_info& bussiness_act_data::level_fund_data() const {
  return level_fund_data_ != NULL ? *level_fund_data_ : *default_instance_->level_fund_data_;
}
inline ::proto::common::level_fund_save_info* bussiness_act_data::mutable_level_fund_data() {
  set_has_level_fund_data();
  if (level_fund_data_ == NULL) level_fund_data_ = new ::proto::common::level_fund_save_info;
  return level_fund_data_;
}
inline ::proto::common::level_fund_save_info* bussiness_act_data::release_level_fund_data() {
  clear_has_level_fund_data();
  ::proto::common::level_fund_save_info* temp = level_fund_data_;
  level_fund_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_level_fund_data(::proto::common::level_fund_save_info* level_fund_data) {
  delete level_fund_data_;
  level_fund_data_ = level_fund_data;
  if (level_fund_data) {
    set_has_level_fund_data();
  } else {
    clear_has_level_fund_data();
  }
}

// optional .proto.common.limit_buy_save_data limit_buy_data = 5;
inline bool bussiness_act_data::has_limit_buy_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bussiness_act_data::set_has_limit_buy_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void bussiness_act_data::clear_has_limit_buy_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void bussiness_act_data::clear_limit_buy_data() {
  if (limit_buy_data_ != NULL) limit_buy_data_->::proto::common::limit_buy_save_data::Clear();
  clear_has_limit_buy_data();
}
inline const ::proto::common::limit_buy_save_data& bussiness_act_data::limit_buy_data() const {
  return limit_buy_data_ != NULL ? *limit_buy_data_ : *default_instance_->limit_buy_data_;
}
inline ::proto::common::limit_buy_save_data* bussiness_act_data::mutable_limit_buy_data() {
  set_has_limit_buy_data();
  if (limit_buy_data_ == NULL) limit_buy_data_ = new ::proto::common::limit_buy_save_data;
  return limit_buy_data_;
}
inline ::proto::common::limit_buy_save_data* bussiness_act_data::release_limit_buy_data() {
  clear_has_limit_buy_data();
  ::proto::common::limit_buy_save_data* temp = limit_buy_data_;
  limit_buy_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_limit_buy_data(::proto::common::limit_buy_save_data* limit_buy_data) {
  delete limit_buy_data_;
  limit_buy_data_ = limit_buy_data;
  if (limit_buy_data) {
    set_has_limit_buy_data();
  } else {
    clear_has_limit_buy_data();
  }
}

// optional .proto.common.exchange_item_save_data exchange_data = 6;
inline bool bussiness_act_data::has_exchange_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bussiness_act_data::set_has_exchange_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void bussiness_act_data::clear_has_exchange_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void bussiness_act_data::clear_exchange_data() {
  if (exchange_data_ != NULL) exchange_data_->::proto::common::exchange_item_save_data::Clear();
  clear_has_exchange_data();
}
inline const ::proto::common::exchange_item_save_data& bussiness_act_data::exchange_data() const {
  return exchange_data_ != NULL ? *exchange_data_ : *default_instance_->exchange_data_;
}
inline ::proto::common::exchange_item_save_data* bussiness_act_data::mutable_exchange_data() {
  set_has_exchange_data();
  if (exchange_data_ == NULL) exchange_data_ = new ::proto::common::exchange_item_save_data;
  return exchange_data_;
}
inline ::proto::common::exchange_item_save_data* bussiness_act_data::release_exchange_data() {
  clear_has_exchange_data();
  ::proto::common::exchange_item_save_data* temp = exchange_data_;
  exchange_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_exchange_data(::proto::common::exchange_item_save_data* exchange_data) {
  delete exchange_data_;
  exchange_data_ = exchange_data;
  if (exchange_data) {
    set_has_exchange_data();
  } else {
    clear_has_exchange_data();
  }
}

// optional .proto.common.statistical_save_data statistical_data = 7;
inline bool bussiness_act_data::has_statistical_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void bussiness_act_data::set_has_statistical_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void bussiness_act_data::clear_has_statistical_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void bussiness_act_data::clear_statistical_data() {
  if (statistical_data_ != NULL) statistical_data_->::proto::common::statistical_save_data::Clear();
  clear_has_statistical_data();
}
inline const ::proto::common::statistical_save_data& bussiness_act_data::statistical_data() const {
  return statistical_data_ != NULL ? *statistical_data_ : *default_instance_->statistical_data_;
}
inline ::proto::common::statistical_save_data* bussiness_act_data::mutable_statistical_data() {
  set_has_statistical_data();
  if (statistical_data_ == NULL) statistical_data_ = new ::proto::common::statistical_save_data;
  return statistical_data_;
}
inline ::proto::common::statistical_save_data* bussiness_act_data::release_statistical_data() {
  clear_has_statistical_data();
  ::proto::common::statistical_save_data* temp = statistical_data_;
  statistical_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_statistical_data(::proto::common::statistical_save_data* statistical_data) {
  delete statistical_data_;
  statistical_data_ = statistical_data;
  if (statistical_data) {
    set_has_statistical_data();
  } else {
    clear_has_statistical_data();
  }
}

// optional .proto.common.sd_target_save_data sevenday_target_data = 8;
inline bool bussiness_act_data::has_sevenday_target_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void bussiness_act_data::set_has_sevenday_target_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void bussiness_act_data::clear_has_sevenday_target_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void bussiness_act_data::clear_sevenday_target_data() {
  if (sevenday_target_data_ != NULL) sevenday_target_data_->::proto::common::sd_target_save_data::Clear();
  clear_has_sevenday_target_data();
}
inline const ::proto::common::sd_target_save_data& bussiness_act_data::sevenday_target_data() const {
  return sevenday_target_data_ != NULL ? *sevenday_target_data_ : *default_instance_->sevenday_target_data_;
}
inline ::proto::common::sd_target_save_data* bussiness_act_data::mutable_sevenday_target_data() {
  set_has_sevenday_target_data();
  if (sevenday_target_data_ == NULL) sevenday_target_data_ = new ::proto::common::sd_target_save_data;
  return sevenday_target_data_;
}
inline ::proto::common::sd_target_save_data* bussiness_act_data::release_sevenday_target_data() {
  clear_has_sevenday_target_data();
  ::proto::common::sd_target_save_data* temp = sevenday_target_data_;
  sevenday_target_data_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_sevenday_target_data(::proto::common::sd_target_save_data* sevenday_target_data) {
  delete sevenday_target_data_;
  sevenday_target_data_ = sevenday_target_data;
  if (sevenday_target_data) {
    set_has_sevenday_target_data();
  } else {
    clear_has_sevenday_target_data();
  }
}

// optional .proto.common.recharge_total_data recharge_total = 9;
inline bool bussiness_act_data::has_recharge_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void bussiness_act_data::set_has_recharge_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void bussiness_act_data::clear_has_recharge_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void bussiness_act_data::clear_recharge_total() {
  if (recharge_total_ != NULL) recharge_total_->::proto::common::recharge_total_data::Clear();
  clear_has_recharge_total();
}
inline const ::proto::common::recharge_total_data& bussiness_act_data::recharge_total() const {
  return recharge_total_ != NULL ? *recharge_total_ : *default_instance_->recharge_total_;
}
inline ::proto::common::recharge_total_data* bussiness_act_data::mutable_recharge_total() {
  set_has_recharge_total();
  if (recharge_total_ == NULL) recharge_total_ = new ::proto::common::recharge_total_data;
  return recharge_total_;
}
inline ::proto::common::recharge_total_data* bussiness_act_data::release_recharge_total() {
  clear_has_recharge_total();
  ::proto::common::recharge_total_data* temp = recharge_total_;
  recharge_total_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_recharge_total(::proto::common::recharge_total_data* recharge_total) {
  delete recharge_total_;
  recharge_total_ = recharge_total;
  if (recharge_total) {
    set_has_recharge_total();
  } else {
    clear_has_recharge_total();
  }
}

// optional .proto.common.gold_luckydraw_data gold_luckydraw = 10;
inline bool bussiness_act_data::has_gold_luckydraw() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void bussiness_act_data::set_has_gold_luckydraw() {
  _has_bits_[0] |= 0x00000200u;
}
inline void bussiness_act_data::clear_has_gold_luckydraw() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void bussiness_act_data::clear_gold_luckydraw() {
  if (gold_luckydraw_ != NULL) gold_luckydraw_->::proto::common::gold_luckydraw_data::Clear();
  clear_has_gold_luckydraw();
}
inline const ::proto::common::gold_luckydraw_data& bussiness_act_data::gold_luckydraw() const {
  return gold_luckydraw_ != NULL ? *gold_luckydraw_ : *default_instance_->gold_luckydraw_;
}
inline ::proto::common::gold_luckydraw_data* bussiness_act_data::mutable_gold_luckydraw() {
  set_has_gold_luckydraw();
  if (gold_luckydraw_ == NULL) gold_luckydraw_ = new ::proto::common::gold_luckydraw_data;
  return gold_luckydraw_;
}
inline ::proto::common::gold_luckydraw_data* bussiness_act_data::release_gold_luckydraw() {
  clear_has_gold_luckydraw();
  ::proto::common::gold_luckydraw_data* temp = gold_luckydraw_;
  gold_luckydraw_ = NULL;
  return temp;
}
inline void bussiness_act_data::set_allocated_gold_luckydraw(::proto::common::gold_luckydraw_data* gold_luckydraw) {
  delete gold_luckydraw_;
  gold_luckydraw_ = gold_luckydraw;
  if (gold_luckydraw) {
    set_has_gold_luckydraw();
  } else {
    clear_has_gold_luckydraw();
  }
}

// -------------------------------------------------------------------

// sevenday_login_data_info

// optional uint32 day = 1;
inline bool sevenday_login_data_info::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sevenday_login_data_info::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sevenday_login_data_info::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sevenday_login_data_info::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 sevenday_login_data_info::day() const {
  return day_;
}
inline void sevenday_login_data_info::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 status = 2;
inline bool sevenday_login_data_info::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sevenday_login_data_info::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sevenday_login_data_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sevenday_login_data_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 sevenday_login_data_info::status() const {
  return status_;
}
inline void sevenday_login_data_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 day_show_id = 3;
inline bool sevenday_login_data_info::has_day_show_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sevenday_login_data_info::set_has_day_show_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sevenday_login_data_info::clear_has_day_show_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sevenday_login_data_info::clear_day_show_id() {
  day_show_id_ = 0u;
  clear_has_day_show_id();
}
inline ::google::protobuf::uint32 sevenday_login_data_info::day_show_id() const {
  return day_show_id_;
}
inline void sevenday_login_data_info::set_day_show_id(::google::protobuf::uint32 value) {
  set_has_day_show_id();
  day_show_id_ = value;
}

// optional string show_id_list = 4;
inline bool sevenday_login_data_info::has_show_id_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sevenday_login_data_info::set_has_show_id_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sevenday_login_data_info::clear_has_show_id_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sevenday_login_data_info::clear_show_id_list() {
  if (show_id_list_ != &::google::protobuf::internal::kEmptyString) {
    show_id_list_->clear();
  }
  clear_has_show_id_list();
}
inline const ::std::string& sevenday_login_data_info::show_id_list() const {
  return *show_id_list_;
}
inline void sevenday_login_data_info::set_show_id_list(const ::std::string& value) {
  set_has_show_id_list();
  if (show_id_list_ == &::google::protobuf::internal::kEmptyString) {
    show_id_list_ = new ::std::string;
  }
  show_id_list_->assign(value);
}
inline void sevenday_login_data_info::set_show_id_list(const char* value) {
  set_has_show_id_list();
  if (show_id_list_ == &::google::protobuf::internal::kEmptyString) {
    show_id_list_ = new ::std::string;
  }
  show_id_list_->assign(value);
}
inline void sevenday_login_data_info::set_show_id_list(const char* value, size_t size) {
  set_has_show_id_list();
  if (show_id_list_ == &::google::protobuf::internal::kEmptyString) {
    show_id_list_ = new ::std::string;
  }
  show_id_list_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sevenday_login_data_info::mutable_show_id_list() {
  set_has_show_id_list();
  if (show_id_list_ == &::google::protobuf::internal::kEmptyString) {
    show_id_list_ = new ::std::string;
  }
  return show_id_list_;
}
inline ::std::string* sevenday_login_data_info::release_show_id_list() {
  clear_has_show_id_list();
  if (show_id_list_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = show_id_list_;
    show_id_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sevenday_login_data_info::set_allocated_show_id_list(::std::string* show_id_list) {
  if (show_id_list_ != &::google::protobuf::internal::kEmptyString) {
    delete show_id_list_;
  }
  if (show_id_list) {
    set_has_show_id_list();
    show_id_list_ = show_id_list;
  } else {
    clear_has_show_id_list();
    show_id_list_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// sevenday_login_save_data

// optional uint32 login_flag = 1;
inline bool sevenday_login_save_data::has_login_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sevenday_login_save_data::set_has_login_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sevenday_login_save_data::clear_has_login_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sevenday_login_save_data::clear_login_flag() {
  login_flag_ = 0u;
  clear_has_login_flag();
}
inline ::google::protobuf::uint32 sevenday_login_save_data::login_flag() const {
  return login_flag_;
}
inline void sevenday_login_save_data::set_login_flag(::google::protobuf::uint32 value) {
  set_has_login_flag();
  login_flag_ = value;
}

// optional uint32 day = 2;
inline bool sevenday_login_save_data::has_day() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sevenday_login_save_data::set_has_day() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sevenday_login_save_data::clear_has_day() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sevenday_login_save_data::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 sevenday_login_save_data::day() const {
  return day_;
}
inline void sevenday_login_save_data::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// repeated uint32 days = 3;
inline int sevenday_login_save_data::days_size() const {
  return days_.size();
}
inline void sevenday_login_save_data::clear_days() {
  days_.Clear();
}
inline ::google::protobuf::uint32 sevenday_login_save_data::days(int index) const {
  return days_.Get(index);
}
inline void sevenday_login_save_data::set_days(int index, ::google::protobuf::uint32 value) {
  days_.Set(index, value);
}
inline void sevenday_login_save_data::add_days(::google::protobuf::uint32 value) {
  days_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
sevenday_login_save_data::days() const {
  return days_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
sevenday_login_save_data::mutable_days() {
  return &days_;
}

// -------------------------------------------------------------------

// recharge_total_data

// repeated uint32 recharge_total_id = 1;
inline int recharge_total_data::recharge_total_id_size() const {
  return recharge_total_id_.size();
}
inline void recharge_total_data::clear_recharge_total_id() {
  recharge_total_id_.Clear();
}
inline ::google::protobuf::uint32 recharge_total_data::recharge_total_id(int index) const {
  return recharge_total_id_.Get(index);
}
inline void recharge_total_data::set_recharge_total_id(int index, ::google::protobuf::uint32 value) {
  recharge_total_id_.Set(index, value);
}
inline void recharge_total_data::add_recharge_total_id(::google::protobuf::uint32 value) {
  recharge_total_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
recharge_total_data::recharge_total_id() const {
  return recharge_total_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
recharge_total_data::mutable_recharge_total_id() {
  return &recharge_total_id_;
}

// -------------------------------------------------------------------

// recharge_total_client_data

// repeated .proto.common.recharge_total_client_single info = 1;
inline int recharge_total_client_data::info_size() const {
  return info_.size();
}
inline void recharge_total_client_data::clear_info() {
  info_.Clear();
}
inline const ::proto::common::recharge_total_client_single& recharge_total_client_data::info(int index) const {
  return info_.Get(index);
}
inline ::proto::common::recharge_total_client_single* recharge_total_client_data::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::proto::common::recharge_total_client_single* recharge_total_client_data::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::recharge_total_client_single >&
recharge_total_client_data::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::recharge_total_client_single >*
recharge_total_client_data::mutable_info() {
  return &info_;
}

// optional uint32 recharge_total = 2;
inline bool recharge_total_client_data::has_recharge_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void recharge_total_client_data::set_has_recharge_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void recharge_total_client_data::clear_has_recharge_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void recharge_total_client_data::clear_recharge_total() {
  recharge_total_ = 0u;
  clear_has_recharge_total();
}
inline ::google::protobuf::uint32 recharge_total_client_data::recharge_total() const {
  return recharge_total_;
}
inline void recharge_total_client_data::set_recharge_total(::google::protobuf::uint32 value) {
  set_has_recharge_total();
  recharge_total_ = value;
}

// -------------------------------------------------------------------

// recharge_total_client_single

// optional uint32 recharge_total_id = 1;
inline bool recharge_total_client_single::has_recharge_total_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void recharge_total_client_single::set_has_recharge_total_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void recharge_total_client_single::clear_has_recharge_total_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void recharge_total_client_single::clear_recharge_total_id() {
  recharge_total_id_ = 0u;
  clear_has_recharge_total_id();
}
inline ::google::protobuf::uint32 recharge_total_client_single::recharge_total_id() const {
  return recharge_total_id_;
}
inline void recharge_total_client_single::set_recharge_total_id(::google::protobuf::uint32 value) {
  set_has_recharge_total_id();
  recharge_total_id_ = value;
}

// optional uint32 state = 2;
inline bool recharge_total_client_single::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void recharge_total_client_single::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void recharge_total_client_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void recharge_total_client_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 recharge_total_client_single::state() const {
  return state_;
}
inline void recharge_total_client_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional string display = 3;
inline bool recharge_total_client_single::has_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void recharge_total_client_single::set_has_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void recharge_total_client_single::clear_has_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void recharge_total_client_single::clear_display() {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    display_->clear();
  }
  clear_has_display();
}
inline const ::std::string& recharge_total_client_single::display() const {
  return *display_;
}
inline void recharge_total_client_single::set_display(const ::std::string& value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void recharge_total_client_single::set_display(const char* value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void recharge_total_client_single::set_display(const char* value, size_t size) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* recharge_total_client_single::mutable_display() {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  return display_;
}
inline ::std::string* recharge_total_client_single::release_display() {
  clear_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_;
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void recharge_total_client_single::set_allocated_display(::std::string* display) {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    delete display_;
  }
  if (display) {
    set_has_display();
    display_ = display;
  } else {
    clear_has_display();
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// gold_luckydraw_data

// repeated uint32 gold_luckydraw_id = 1;
inline int gold_luckydraw_data::gold_luckydraw_id_size() const {
  return gold_luckydraw_id_.size();
}
inline void gold_luckydraw_data::clear_gold_luckydraw_id() {
  gold_luckydraw_id_.Clear();
}
inline ::google::protobuf::uint32 gold_luckydraw_data::gold_luckydraw_id(int index) const {
  return gold_luckydraw_id_.Get(index);
}
inline void gold_luckydraw_data::set_gold_luckydraw_id(int index, ::google::protobuf::uint32 value) {
  gold_luckydraw_id_.Set(index, value);
}
inline void gold_luckydraw_data::add_gold_luckydraw_id(::google::protobuf::uint32 value) {
  gold_luckydraw_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
gold_luckydraw_data::gold_luckydraw_id() const {
  return gold_luckydraw_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
gold_luckydraw_data::mutable_gold_luckydraw_id() {
  return &gold_luckydraw_id_;
}

// -------------------------------------------------------------------

// gold_luckydraw_client_single

// optional uint32 gold_luckydraw_id = 1;
inline bool gold_luckydraw_client_single::has_gold_luckydraw_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gold_luckydraw_client_single::set_has_gold_luckydraw_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gold_luckydraw_client_single::clear_has_gold_luckydraw_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gold_luckydraw_client_single::clear_gold_luckydraw_id() {
  gold_luckydraw_id_ = 0u;
  clear_has_gold_luckydraw_id();
}
inline ::google::protobuf::uint32 gold_luckydraw_client_single::gold_luckydraw_id() const {
  return gold_luckydraw_id_;
}
inline void gold_luckydraw_client_single::set_gold_luckydraw_id(::google::protobuf::uint32 value) {
  set_has_gold_luckydraw_id();
  gold_luckydraw_id_ = value;
}

// optional uint32 state = 2;
inline bool gold_luckydraw_client_single::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gold_luckydraw_client_single::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void gold_luckydraw_client_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void gold_luckydraw_client_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 gold_luckydraw_client_single::state() const {
  return state_;
}
inline void gold_luckydraw_client_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional string desc = 3;
inline bool gold_luckydraw_client_single::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gold_luckydraw_client_single::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void gold_luckydraw_client_single::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void gold_luckydraw_client_single::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& gold_luckydraw_client_single::desc() const {
  return *desc_;
}
inline void gold_luckydraw_client_single::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void gold_luckydraw_client_single::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void gold_luckydraw_client_single::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gold_luckydraw_client_single::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* gold_luckydraw_client_single::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gold_luckydraw_client_single::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string display = 4;
inline bool gold_luckydraw_client_single::has_display() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void gold_luckydraw_client_single::set_has_display() {
  _has_bits_[0] |= 0x00000008u;
}
inline void gold_luckydraw_client_single::clear_has_display() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void gold_luckydraw_client_single::clear_display() {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    display_->clear();
  }
  clear_has_display();
}
inline const ::std::string& gold_luckydraw_client_single::display() const {
  return *display_;
}
inline void gold_luckydraw_client_single::set_display(const ::std::string& value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void gold_luckydraw_client_single::set_display(const char* value) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(value);
}
inline void gold_luckydraw_client_single::set_display(const char* value, size_t size) {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  display_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* gold_luckydraw_client_single::mutable_display() {
  set_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    display_ = new ::std::string;
  }
  return display_;
}
inline ::std::string* gold_luckydraw_client_single::release_display() {
  clear_has_display();
  if (display_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_;
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void gold_luckydraw_client_single::set_allocated_display(::std::string* display) {
  if (display_ != &::google::protobuf::internal::kEmptyString) {
    delete display_;
  }
  if (display) {
    set_has_display();
    display_ = display;
  } else {
    clear_has_display();
    display_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 day = 5;
inline bool gold_luckydraw_client_single::has_day() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void gold_luckydraw_client_single::set_has_day() {
  _has_bits_[0] |= 0x00000010u;
}
inline void gold_luckydraw_client_single::clear_has_day() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void gold_luckydraw_client_single::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 gold_luckydraw_client_single::day() const {
  return day_;
}
inline void gold_luckydraw_client_single::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// -------------------------------------------------------------------

// gold_luckydraw_client_data

// repeated .proto.common.gold_luckydraw_client_single gold_luckydraw_data = 1;
inline int gold_luckydraw_client_data::gold_luckydraw_data_size() const {
  return gold_luckydraw_data_.size();
}
inline void gold_luckydraw_client_data::clear_gold_luckydraw_data() {
  gold_luckydraw_data_.Clear();
}
inline const ::proto::common::gold_luckydraw_client_single& gold_luckydraw_client_data::gold_luckydraw_data(int index) const {
  return gold_luckydraw_data_.Get(index);
}
inline ::proto::common::gold_luckydraw_client_single* gold_luckydraw_client_data::mutable_gold_luckydraw_data(int index) {
  return gold_luckydraw_data_.Mutable(index);
}
inline ::proto::common::gold_luckydraw_client_single* gold_luckydraw_client_data::add_gold_luckydraw_data() {
  return gold_luckydraw_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::gold_luckydraw_client_single >&
gold_luckydraw_client_data::gold_luckydraw_data() const {
  return gold_luckydraw_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::gold_luckydraw_client_single >*
gold_luckydraw_client_data::mutable_gold_luckydraw_data() {
  return &gold_luckydraw_data_;
}

// -------------------------------------------------------------------

// cur_task_date

// repeated .proto.common.task_state tasks = 1;
inline int cur_task_date::tasks_size() const {
  return tasks_.size();
}
inline void cur_task_date::clear_tasks() {
  tasks_.Clear();
}
inline const ::proto::common::task_state& cur_task_date::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::proto::common::task_state* cur_task_date::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::proto::common::task_state* cur_task_date::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >&
cur_task_date::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_state >*
cur_task_date::mutable_tasks() {
  return &tasks_;
}

// -------------------------------------------------------------------

// comp_task_date

// repeated uint32 task_list = 1;
inline int comp_task_date::task_list_size() const {
  return task_list_.size();
}
inline void comp_task_date::clear_task_list() {
  task_list_.Clear();
}
inline ::google::protobuf::uint32 comp_task_date::task_list(int index) const {
  return task_list_.Get(index);
}
inline void comp_task_date::set_task_list(int index, ::google::protobuf::uint32 value) {
  task_list_.Set(index, value);
}
inline void comp_task_date::add_task_list(::google::protobuf::uint32 value) {
  task_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
comp_task_date::task_list() const {
  return task_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
comp_task_date::mutable_task_list() {
  return &task_list_;
}

// -------------------------------------------------------------------

// task_event_single

// optional uint32 event_id = 1;
inline bool task_event_single::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void task_event_single::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void task_event_single::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void task_event_single::clear_event_id() {
  event_id_ = 0u;
  clear_has_event_id();
}
inline ::google::protobuf::uint32 task_event_single::event_id() const {
  return event_id_;
}
inline void task_event_single::set_event_id(::google::protobuf::uint32 value) {
  set_has_event_id();
  event_id_ = value;
}

// optional uint32 expired_time = 2;
inline bool task_event_single::has_expired_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void task_event_single::set_has_expired_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void task_event_single::clear_has_expired_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void task_event_single::clear_expired_time() {
  expired_time_ = 0u;
  clear_has_expired_time();
}
inline ::google::protobuf::uint32 task_event_single::expired_time() const {
  return expired_time_;
}
inline void task_event_single::set_expired_time(::google::protobuf::uint32 value) {
  set_has_expired_time();
  expired_time_ = value;
}

// -------------------------------------------------------------------

// task_event

// repeated .proto.common.task_event_single event_data = 1;
inline int task_event::event_data_size() const {
  return event_data_.size();
}
inline void task_event::clear_event_data() {
  event_data_.Clear();
}
inline const ::proto::common::task_event_single& task_event::event_data(int index) const {
  return event_data_.Get(index);
}
inline ::proto::common::task_event_single* task_event::mutable_event_data(int index) {
  return event_data_.Mutable(index);
}
inline ::proto::common::task_event_single* task_event::add_event_data() {
  return event_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::task_event_single >&
task_event::event_data() const {
  return event_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::task_event_single >*
task_event::mutable_event_data() {
  return &event_data_;
}

// -------------------------------------------------------------------

// head_data

// repeated uint32 head_list = 1;
inline int head_data::head_list_size() const {
  return head_list_.size();
}
inline void head_data::clear_head_list() {
  head_list_.Clear();
}
inline ::google::protobuf::uint32 head_data::head_list(int index) const {
  return head_list_.Get(index);
}
inline void head_data::set_head_list(int index, ::google::protobuf::uint32 value) {
  head_list_.Set(index, value);
}
inline void head_data::add_head_list(::google::protobuf::uint32 value) {
  head_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
head_data::head_list() const {
  return head_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
head_data::mutable_head_list() {
  return &head_list_;
}

// repeated uint32 frame_list = 2;
inline int head_data::frame_list_size() const {
  return frame_list_.size();
}
inline void head_data::clear_frame_list() {
  frame_list_.Clear();
}
inline ::google::protobuf::uint32 head_data::frame_list(int index) const {
  return frame_list_.Get(index);
}
inline void head_data::set_frame_list(int index, ::google::protobuf::uint32 value) {
  frame_list_.Set(index, value);
}
inline void head_data::add_frame_list(::google::protobuf::uint32 value) {
  frame_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
head_data::frame_list() const {
  return frame_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
head_data::mutable_frame_list() {
  return &frame_list_;
}

// -------------------------------------------------------------------

// month_card_info

// optional uint32 month_card_id = 1;
inline bool month_card_info::has_month_card_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_card_info::set_has_month_card_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_card_info::clear_has_month_card_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_card_info::clear_month_card_id() {
  month_card_id_ = 0u;
  clear_has_month_card_id();
}
inline ::google::protobuf::uint32 month_card_info::month_card_id() const {
  return month_card_id_;
}
inline void month_card_info::set_month_card_id(::google::protobuf::uint32 value) {
  set_has_month_card_id();
  month_card_id_ = value;
}

// optional uint32 end_time = 2;
inline bool month_card_info::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_card_info::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_card_info::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_card_info::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 month_card_info::end_time() const {
  return end_time_;
}
inline void month_card_info::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional uint32 buy_prize = 3;
inline bool month_card_info::has_buy_prize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void month_card_info::set_has_buy_prize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void month_card_info::clear_has_buy_prize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void month_card_info::clear_buy_prize() {
  buy_prize_ = 0u;
  clear_has_buy_prize();
}
inline ::google::protobuf::uint32 month_card_info::buy_prize() const {
  return buy_prize_;
}
inline void month_card_info::set_buy_prize(::google::protobuf::uint32 value) {
  set_has_buy_prize();
  buy_prize_ = value;
}

// optional uint32 ed_prize = 4;
inline bool month_card_info::has_ed_prize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void month_card_info::set_has_ed_prize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void month_card_info::clear_has_ed_prize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void month_card_info::clear_ed_prize() {
  ed_prize_ = 0u;
  clear_has_ed_prize();
}
inline ::google::protobuf::uint32 month_card_info::ed_prize() const {
  return ed_prize_;
}
inline void month_card_info::set_ed_prize(::google::protobuf::uint32 value) {
  set_has_ed_prize();
  ed_prize_ = value;
}

// optional .proto.common.month_card_show_info show_info = 5;
inline bool month_card_info::has_show_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void month_card_info::set_has_show_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void month_card_info::clear_has_show_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void month_card_info::clear_show_info() {
  if (show_info_ != NULL) show_info_->::proto::common::month_card_show_info::Clear();
  clear_has_show_info();
}
inline const ::proto::common::month_card_show_info& month_card_info::show_info() const {
  return show_info_ != NULL ? *show_info_ : *default_instance_->show_info_;
}
inline ::proto::common::month_card_show_info* month_card_info::mutable_show_info() {
  set_has_show_info();
  if (show_info_ == NULL) show_info_ = new ::proto::common::month_card_show_info;
  return show_info_;
}
inline ::proto::common::month_card_show_info* month_card_info::release_show_info() {
  clear_has_show_info();
  ::proto::common::month_card_show_info* temp = show_info_;
  show_info_ = NULL;
  return temp;
}
inline void month_card_info::set_allocated_show_info(::proto::common::month_card_show_info* show_info) {
  delete show_info_;
  show_info_ = show_info;
  if (show_info) {
    set_has_show_info();
  } else {
    clear_has_show_info();
  }
}

// optional uint32 day_left = 6;
inline bool month_card_info::has_day_left() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void month_card_info::set_has_day_left() {
  _has_bits_[0] |= 0x00000020u;
}
inline void month_card_info::clear_has_day_left() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void month_card_info::clear_day_left() {
  day_left_ = 0u;
  clear_has_day_left();
}
inline ::google::protobuf::uint32 month_card_info::day_left() const {
  return day_left_;
}
inline void month_card_info::set_day_left(::google::protobuf::uint32 value) {
  set_has_day_left();
  day_left_ = value;
}

// -------------------------------------------------------------------

// month_card_show_info

// optional uint32 max_day = 1;
inline bool month_card_show_info::has_max_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void month_card_show_info::set_has_max_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void month_card_show_info::clear_has_max_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void month_card_show_info::clear_max_day() {
  max_day_ = 0u;
  clear_has_max_day();
}
inline ::google::protobuf::uint32 month_card_show_info::max_day() const {
  return max_day_;
}
inline void month_card_show_info::set_max_day(::google::protobuf::uint32 value) {
  set_has_max_day();
  max_day_ = value;
}

// optional string mingshi = 2;
inline bool month_card_show_info::has_mingshi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void month_card_show_info::set_has_mingshi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void month_card_show_info::clear_has_mingshi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void month_card_show_info::clear_mingshi() {
  if (mingshi_ != &::google::protobuf::internal::kEmptyString) {
    mingshi_->clear();
  }
  clear_has_mingshi();
}
inline const ::std::string& month_card_show_info::mingshi() const {
  return *mingshi_;
}
inline void month_card_show_info::set_mingshi(const ::std::string& value) {
  set_has_mingshi();
  if (mingshi_ == &::google::protobuf::internal::kEmptyString) {
    mingshi_ = new ::std::string;
  }
  mingshi_->assign(value);
}
inline void month_card_show_info::set_mingshi(const char* value) {
  set_has_mingshi();
  if (mingshi_ == &::google::protobuf::internal::kEmptyString) {
    mingshi_ = new ::std::string;
  }
  mingshi_->assign(value);
}
inline void month_card_show_info::set_mingshi(const char* value, size_t size) {
  set_has_mingshi();
  if (mingshi_ == &::google::protobuf::internal::kEmptyString) {
    mingshi_ = new ::std::string;
  }
  mingshi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* month_card_show_info::mutable_mingshi() {
  set_has_mingshi();
  if (mingshi_ == &::google::protobuf::internal::kEmptyString) {
    mingshi_ = new ::std::string;
  }
  return mingshi_;
}
inline ::std::string* month_card_show_info::release_mingshi() {
  clear_has_mingshi();
  if (mingshi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mingshi_;
    mingshi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void month_card_show_info::set_allocated_mingshi(::std::string* mingshi) {
  if (mingshi_ != &::google::protobuf::internal::kEmptyString) {
    delete mingshi_;
  }
  if (mingshi) {
    set_has_mingshi();
    mingshi_ = mingshi;
  } else {
    clear_has_mingshi();
    mingshi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ed_yuanbao = 3;
inline bool month_card_show_info::has_ed_yuanbao() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void month_card_show_info::set_has_ed_yuanbao() {
  _has_bits_[0] |= 0x00000004u;
}
inline void month_card_show_info::clear_has_ed_yuanbao() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void month_card_show_info::clear_ed_yuanbao() {
  if (ed_yuanbao_ != &::google::protobuf::internal::kEmptyString) {
    ed_yuanbao_->clear();
  }
  clear_has_ed_yuanbao();
}
inline const ::std::string& month_card_show_info::ed_yuanbao() const {
  return *ed_yuanbao_;
}
inline void month_card_show_info::set_ed_yuanbao(const ::std::string& value) {
  set_has_ed_yuanbao();
  if (ed_yuanbao_ == &::google::protobuf::internal::kEmptyString) {
    ed_yuanbao_ = new ::std::string;
  }
  ed_yuanbao_->assign(value);
}
inline void month_card_show_info::set_ed_yuanbao(const char* value) {
  set_has_ed_yuanbao();
  if (ed_yuanbao_ == &::google::protobuf::internal::kEmptyString) {
    ed_yuanbao_ = new ::std::string;
  }
  ed_yuanbao_->assign(value);
}
inline void month_card_show_info::set_ed_yuanbao(const char* value, size_t size) {
  set_has_ed_yuanbao();
  if (ed_yuanbao_ == &::google::protobuf::internal::kEmptyString) {
    ed_yuanbao_ = new ::std::string;
  }
  ed_yuanbao_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* month_card_show_info::mutable_ed_yuanbao() {
  set_has_ed_yuanbao();
  if (ed_yuanbao_ == &::google::protobuf::internal::kEmptyString) {
    ed_yuanbao_ = new ::std::string;
  }
  return ed_yuanbao_;
}
inline ::std::string* month_card_show_info::release_ed_yuanbao() {
  clear_has_ed_yuanbao();
  if (ed_yuanbao_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ed_yuanbao_;
    ed_yuanbao_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void month_card_show_info::set_allocated_ed_yuanbao(::std::string* ed_yuanbao) {
  if (ed_yuanbao_ != &::google::protobuf::internal::kEmptyString) {
    delete ed_yuanbao_;
  }
  if (ed_yuanbao) {
    set_has_ed_yuanbao();
    ed_yuanbao_ = ed_yuanbao;
  } else {
    clear_has_ed_yuanbao();
    ed_yuanbao_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string show_gift = 4;
inline bool month_card_show_info::has_show_gift() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void month_card_show_info::set_has_show_gift() {
  _has_bits_[0] |= 0x00000008u;
}
inline void month_card_show_info::clear_has_show_gift() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void month_card_show_info::clear_show_gift() {
  if (show_gift_ != &::google::protobuf::internal::kEmptyString) {
    show_gift_->clear();
  }
  clear_has_show_gift();
}
inline const ::std::string& month_card_show_info::show_gift() const {
  return *show_gift_;
}
inline void month_card_show_info::set_show_gift(const ::std::string& value) {
  set_has_show_gift();
  if (show_gift_ == &::google::protobuf::internal::kEmptyString) {
    show_gift_ = new ::std::string;
  }
  show_gift_->assign(value);
}
inline void month_card_show_info::set_show_gift(const char* value) {
  set_has_show_gift();
  if (show_gift_ == &::google::protobuf::internal::kEmptyString) {
    show_gift_ = new ::std::string;
  }
  show_gift_->assign(value);
}
inline void month_card_show_info::set_show_gift(const char* value, size_t size) {
  set_has_show_gift();
  if (show_gift_ == &::google::protobuf::internal::kEmptyString) {
    show_gift_ = new ::std::string;
  }
  show_gift_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* month_card_show_info::mutable_show_gift() {
  set_has_show_gift();
  if (show_gift_ == &::google::protobuf::internal::kEmptyString) {
    show_gift_ = new ::std::string;
  }
  return show_gift_;
}
inline ::std::string* month_card_show_info::release_show_gift() {
  clear_has_show_gift();
  if (show_gift_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = show_gift_;
    show_gift_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void month_card_show_info::set_allocated_show_gift(::std::string* show_gift) {
  if (show_gift_ != &::google::protobuf::internal::kEmptyString) {
    delete show_gift_;
  }
  if (show_gift) {
    set_has_show_gift();
    show_gift_ = show_gift;
  } else {
    clear_has_show_gift();
    show_gift_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 can_buy_day = 5;
inline bool month_card_show_info::has_can_buy_day() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void month_card_show_info::set_has_can_buy_day() {
  _has_bits_[0] |= 0x00000010u;
}
inline void month_card_show_info::clear_has_can_buy_day() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void month_card_show_info::clear_can_buy_day() {
  can_buy_day_ = 0u;
  clear_has_can_buy_day();
}
inline ::google::protobuf::uint32 month_card_show_info::can_buy_day() const {
  return can_buy_day_;
}
inline void month_card_show_info::set_can_buy_day(::google::protobuf::uint32 value) {
  set_has_can_buy_day();
  can_buy_day_ = value;
}

// optional uint32 cz_id = 6;
inline bool month_card_show_info::has_cz_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void month_card_show_info::set_has_cz_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void month_card_show_info::clear_has_cz_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void month_card_show_info::clear_cz_id() {
  cz_id_ = 0u;
  clear_has_cz_id();
}
inline ::google::protobuf::uint32 month_card_show_info::cz_id() const {
  return cz_id_;
}
inline void month_card_show_info::set_cz_id(::google::protobuf::uint32 value) {
  set_has_cz_id();
  cz_id_ = value;
}

// -------------------------------------------------------------------

// month_card_save_data

// repeated .proto.common.month_card_info card_info = 1;
inline int month_card_save_data::card_info_size() const {
  return card_info_.size();
}
inline void month_card_save_data::clear_card_info() {
  card_info_.Clear();
}
inline const ::proto::common::month_card_info& month_card_save_data::card_info(int index) const {
  return card_info_.Get(index);
}
inline ::proto::common::month_card_info* month_card_save_data::mutable_card_info(int index) {
  return card_info_.Mutable(index);
}
inline ::proto::common::month_card_info* month_card_save_data::add_card_info() {
  return card_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::month_card_info >&
month_card_save_data::card_info() const {
  return card_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::month_card_info >*
month_card_save_data::mutable_card_info() {
  return &card_info_;
}

// -------------------------------------------------------------------

// ex_reason

// optional uint32 type = 1;
inline bool ex_reason::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ex_reason::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ex_reason::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ex_reason::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ex_reason::type() const {
  return type_;
}
inline void ex_reason::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 ex_id = 2;
inline bool ex_reason::has_ex_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ex_reason::set_has_ex_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ex_reason::clear_has_ex_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ex_reason::clear_ex_id() {
  ex_id_ = 0u;
  clear_has_ex_id();
}
inline ::google::protobuf::uint32 ex_reason::ex_id() const {
  return ex_id_;
}
inline void ex_reason::set_ex_id(::google::protobuf::uint32 value) {
  set_has_ex_id();
  ex_id_ = value;
}

// -------------------------------------------------------------------

// liandan_single

// optional uint32 state = 1;
inline bool liandan_single::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void liandan_single::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void liandan_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void liandan_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 liandan_single::state() const {
  return state_;
}
inline void liandan_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 free_time = 2;
inline bool liandan_single::has_free_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void liandan_single::set_has_free_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void liandan_single::clear_has_free_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void liandan_single::clear_free_time() {
  free_time_ = 0u;
  clear_has_free_time();
}
inline ::google::protobuf::uint32 liandan_single::free_time() const {
  return free_time_;
}
inline void liandan_single::set_free_time(::google::protobuf::uint32 value) {
  set_has_free_time();
  free_time_ = value;
}

// optional uint32 liandan_tid = 3;
inline bool liandan_single::has_liandan_tid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void liandan_single::set_has_liandan_tid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void liandan_single::clear_has_liandan_tid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void liandan_single::clear_liandan_tid() {
  liandan_tid_ = 0u;
  clear_has_liandan_tid();
}
inline ::google::protobuf::uint32 liandan_single::liandan_tid() const {
  return liandan_tid_;
}
inline void liandan_single::set_liandan_tid(::google::protobuf::uint32 value) {
  set_has_liandan_tid();
  liandan_tid_ = value;
}

// optional uint32 count = 4;
inline bool liandan_single::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void liandan_single::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void liandan_single::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void liandan_single::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 liandan_single::count() const {
  return count_;
}
inline void liandan_single::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// liandan_data

// repeated .proto.common.liandan_single liandan_info = 1;
inline int liandan_data::liandan_info_size() const {
  return liandan_info_.size();
}
inline void liandan_data::clear_liandan_info() {
  liandan_info_.Clear();
}
inline const ::proto::common::liandan_single& liandan_data::liandan_info(int index) const {
  return liandan_info_.Get(index);
}
inline ::proto::common::liandan_single* liandan_data::mutable_liandan_info(int index) {
  return liandan_info_.Mutable(index);
}
inline ::proto::common::liandan_single* liandan_data::add_liandan_info() {
  return liandan_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::liandan_single >&
liandan_data::liandan_info() const {
  return liandan_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::liandan_single >*
liandan_data::mutable_liandan_info() {
  return &liandan_info_;
}

// -------------------------------------------------------------------

// activity_shop_item_info_single

// optional uint32 shop_item_id = 1;
inline bool activity_shop_item_info_single::has_shop_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void activity_shop_item_info_single::set_has_shop_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void activity_shop_item_info_single::clear_has_shop_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void activity_shop_item_info_single::clear_shop_item_id() {
  shop_item_id_ = 0u;
  clear_has_shop_item_id();
}
inline ::google::protobuf::uint32 activity_shop_item_info_single::shop_item_id() const {
  return shop_item_id_;
}
inline void activity_shop_item_info_single::set_shop_item_id(::google::protobuf::uint32 value) {
  set_has_shop_item_id();
  shop_item_id_ = value;
}

// optional uint32 shop_item_price = 2;
inline bool activity_shop_item_info_single::has_shop_item_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void activity_shop_item_info_single::set_has_shop_item_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void activity_shop_item_info_single::clear_has_shop_item_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void activity_shop_item_info_single::clear_shop_item_price() {
  shop_item_price_ = 0u;
  clear_has_shop_item_price();
}
inline ::google::protobuf::uint32 activity_shop_item_info_single::shop_item_price() const {
  return shop_item_price_;
}
inline void activity_shop_item_info_single::set_shop_item_price(::google::protobuf::uint32 value) {
  set_has_shop_item_price();
  shop_item_price_ = value;
}

// optional uint32 shop_item_num = 3;
inline bool activity_shop_item_info_single::has_shop_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void activity_shop_item_info_single::set_has_shop_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void activity_shop_item_info_single::clear_has_shop_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void activity_shop_item_info_single::clear_shop_item_num() {
  shop_item_num_ = 0u;
  clear_has_shop_item_num();
}
inline ::google::protobuf::uint32 activity_shop_item_info_single::shop_item_num() const {
  return shop_item_num_;
}
inline void activity_shop_item_info_single::set_shop_item_num(::google::protobuf::uint32 value) {
  set_has_shop_item_num();
  shop_item_num_ = value;
}

// -------------------------------------------------------------------

// activity_shop_item_info

// repeated .proto.common.activity_shop_item_info_single item_list = 1;
inline int activity_shop_item_info::item_list_size() const {
  return item_list_.size();
}
inline void activity_shop_item_info::clear_item_list() {
  item_list_.Clear();
}
inline const ::proto::common::activity_shop_item_info_single& activity_shop_item_info::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::proto::common::activity_shop_item_info_single* activity_shop_item_info::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::proto::common::activity_shop_item_info_single* activity_shop_item_info::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::activity_shop_item_info_single >&
activity_shop_item_info::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::activity_shop_item_info_single >*
activity_shop_item_info::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// business_active_info

// optional uint32 active_id = 1;
inline bool business_active_info::has_active_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void business_active_info::set_has_active_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void business_active_info::clear_has_active_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void business_active_info::clear_active_id() {
  active_id_ = 0u;
  clear_has_active_id();
}
inline ::google::protobuf::uint32 business_active_info::active_id() const {
  return active_id_;
}
inline void business_active_info::set_active_id(::google::protobuf::uint32 value) {
  set_has_active_id();
  active_id_ = value;
}

// optional uint32 red_num = 2;
inline bool business_active_info::has_red_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void business_active_info::set_has_red_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void business_active_info::clear_has_red_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void business_active_info::clear_red_num() {
  red_num_ = 0u;
  clear_has_red_num();
}
inline ::google::protobuf::uint32 business_active_info::red_num() const {
  return red_num_;
}
inline void business_active_info::set_red_num(::google::protobuf::uint32 value) {
  set_has_red_num();
  red_num_ = value;
}

// optional uint32 start_time = 3;
inline bool business_active_info::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void business_active_info::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void business_active_info::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void business_active_info::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 business_active_info::start_time() const {
  return start_time_;
}
inline void business_active_info::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 end_time = 4;
inline bool business_active_info::has_end_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void business_active_info::set_has_end_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void business_active_info::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void business_active_info::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 business_active_info::end_time() const {
  return end_time_;
}
inline void business_active_info::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// -------------------------------------------------------------------

// level_fund_info

// optional uint32 id = 1;
inline bool level_fund_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void level_fund_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void level_fund_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void level_fund_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 level_fund_info::id() const {
  return id_;
}
inline void level_fund_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 level = 2;
inline bool level_fund_info::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void level_fund_info::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void level_fund_info::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void level_fund_info::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 level_fund_info::level() const {
  return level_;
}
inline void level_fund_info::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 prize_state = 3;
inline bool level_fund_info::has_prize_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void level_fund_info::set_has_prize_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void level_fund_info::clear_has_prize_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void level_fund_info::clear_prize_state() {
  prize_state_ = 0u;
  clear_has_prize_state();
}
inline ::google::protobuf::uint32 level_fund_info::prize_state() const {
  return prize_state_;
}
inline void level_fund_info::set_prize_state(::google::protobuf::uint32 value) {
  set_has_prize_state();
  prize_state_ = value;
}

// optional string des = 4;
inline bool level_fund_info::has_des() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void level_fund_info::set_has_des() {
  _has_bits_[0] |= 0x00000008u;
}
inline void level_fund_info::clear_has_des() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void level_fund_info::clear_des() {
  if (des_ != &::google::protobuf::internal::kEmptyString) {
    des_->clear();
  }
  clear_has_des();
}
inline const ::std::string& level_fund_info::des() const {
  return *des_;
}
inline void level_fund_info::set_des(const ::std::string& value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(value);
}
inline void level_fund_info::set_des(const char* value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(value);
}
inline void level_fund_info::set_des(const char* value, size_t size) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* level_fund_info::mutable_des() {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  return des_;
}
inline ::std::string* level_fund_info::release_des() {
  clear_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = des_;
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void level_fund_info::set_allocated_des(::std::string* des) {
  if (des_ != &::google::protobuf::internal::kEmptyString) {
    delete des_;
  }
  if (des) {
    set_has_des();
    des_ = des;
  } else {
    clear_has_des();
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string show_prize = 5;
inline bool level_fund_info::has_show_prize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void level_fund_info::set_has_show_prize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void level_fund_info::clear_has_show_prize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void level_fund_info::clear_show_prize() {
  if (show_prize_ != &::google::protobuf::internal::kEmptyString) {
    show_prize_->clear();
  }
  clear_has_show_prize();
}
inline const ::std::string& level_fund_info::show_prize() const {
  return *show_prize_;
}
inline void level_fund_info::set_show_prize(const ::std::string& value) {
  set_has_show_prize();
  if (show_prize_ == &::google::protobuf::internal::kEmptyString) {
    show_prize_ = new ::std::string;
  }
  show_prize_->assign(value);
}
inline void level_fund_info::set_show_prize(const char* value) {
  set_has_show_prize();
  if (show_prize_ == &::google::protobuf::internal::kEmptyString) {
    show_prize_ = new ::std::string;
  }
  show_prize_->assign(value);
}
inline void level_fund_info::set_show_prize(const char* value, size_t size) {
  set_has_show_prize();
  if (show_prize_ == &::google::protobuf::internal::kEmptyString) {
    show_prize_ = new ::std::string;
  }
  show_prize_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* level_fund_info::mutable_show_prize() {
  set_has_show_prize();
  if (show_prize_ == &::google::protobuf::internal::kEmptyString) {
    show_prize_ = new ::std::string;
  }
  return show_prize_;
}
inline ::std::string* level_fund_info::release_show_prize() {
  clear_has_show_prize();
  if (show_prize_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = show_prize_;
    show_prize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void level_fund_info::set_allocated_show_prize(::std::string* show_prize) {
  if (show_prize_ != &::google::protobuf::internal::kEmptyString) {
    delete show_prize_;
  }
  if (show_prize) {
    set_has_show_prize();
    show_prize_ = show_prize;
  } else {
    clear_has_show_prize();
    show_prize_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// level_fund_save_info

// optional uint32 buy_flag = 1;
inline bool level_fund_save_info::has_buy_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void level_fund_save_info::set_has_buy_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void level_fund_save_info::clear_has_buy_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void level_fund_save_info::clear_buy_flag() {
  buy_flag_ = 0u;
  clear_has_buy_flag();
}
inline ::google::protobuf::uint32 level_fund_save_info::buy_flag() const {
  return buy_flag_;
}
inline void level_fund_save_info::set_buy_flag(::google::protobuf::uint32 value) {
  set_has_buy_flag();
  buy_flag_ = value;
}

// repeated uint32 id = 2;
inline int level_fund_save_info::id_size() const {
  return id_.size();
}
inline void level_fund_save_info::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::uint32 level_fund_save_info::id(int index) const {
  return id_.Get(index);
}
inline void level_fund_save_info::set_id(int index, ::google::protobuf::uint32 value) {
  id_.Set(index, value);
}
inline void level_fund_save_info::add_id(::google::protobuf::uint32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
level_fund_save_info::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
level_fund_save_info::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// equip_plan_single

// optional string uid = 1;
inline bool equip_plan_single::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void equip_plan_single::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void equip_plan_single::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void equip_plan_single::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& equip_plan_single::uid() const {
  return *uid_;
}
inline void equip_plan_single::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void equip_plan_single::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void equip_plan_single::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* equip_plan_single::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool equip_plan_single::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void equip_plan_single::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void equip_plan_single::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void equip_plan_single::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& equip_plan_single::name() const {
  return *name_;
}
inline void equip_plan_single::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void equip_plan_single::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void equip_plan_single::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* equip_plan_single::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string weapon = 3;
inline bool equip_plan_single::has_weapon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void equip_plan_single::set_has_weapon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void equip_plan_single::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void equip_plan_single::clear_weapon() {
  if (weapon_ != &::google::protobuf::internal::kEmptyString) {
    weapon_->clear();
  }
  clear_has_weapon();
}
inline const ::std::string& equip_plan_single::weapon() const {
  return *weapon_;
}
inline void equip_plan_single::set_weapon(const ::std::string& value) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(value);
}
inline void equip_plan_single::set_weapon(const char* value) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(value);
}
inline void equip_plan_single::set_weapon(const char* value, size_t size) {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  weapon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_weapon() {
  set_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    weapon_ = new ::std::string;
  }
  return weapon_;
}
inline ::std::string* equip_plan_single::release_weapon() {
  clear_has_weapon();
  if (weapon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weapon_;
    weapon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_weapon(::std::string* weapon) {
  if (weapon_ != &::google::protobuf::internal::kEmptyString) {
    delete weapon_;
  }
  if (weapon) {
    set_has_weapon();
    weapon_ = weapon;
  } else {
    clear_has_weapon();
    weapon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string armor = 4;
inline bool equip_plan_single::has_armor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void equip_plan_single::set_has_armor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void equip_plan_single::clear_has_armor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void equip_plan_single::clear_armor() {
  if (armor_ != &::google::protobuf::internal::kEmptyString) {
    armor_->clear();
  }
  clear_has_armor();
}
inline const ::std::string& equip_plan_single::armor() const {
  return *armor_;
}
inline void equip_plan_single::set_armor(const ::std::string& value) {
  set_has_armor();
  if (armor_ == &::google::protobuf::internal::kEmptyString) {
    armor_ = new ::std::string;
  }
  armor_->assign(value);
}
inline void equip_plan_single::set_armor(const char* value) {
  set_has_armor();
  if (armor_ == &::google::protobuf::internal::kEmptyString) {
    armor_ = new ::std::string;
  }
  armor_->assign(value);
}
inline void equip_plan_single::set_armor(const char* value, size_t size) {
  set_has_armor();
  if (armor_ == &::google::protobuf::internal::kEmptyString) {
    armor_ = new ::std::string;
  }
  armor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_armor() {
  set_has_armor();
  if (armor_ == &::google::protobuf::internal::kEmptyString) {
    armor_ = new ::std::string;
  }
  return armor_;
}
inline ::std::string* equip_plan_single::release_armor() {
  clear_has_armor();
  if (armor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = armor_;
    armor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_armor(::std::string* armor) {
  if (armor_ != &::google::protobuf::internal::kEmptyString) {
    delete armor_;
  }
  if (armor) {
    set_has_armor();
    armor_ = armor;
  } else {
    clear_has_armor();
    armor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string talisman = 5;
inline bool equip_plan_single::has_talisman() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void equip_plan_single::set_has_talisman() {
  _has_bits_[0] |= 0x00000010u;
}
inline void equip_plan_single::clear_has_talisman() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void equip_plan_single::clear_talisman() {
  if (talisman_ != &::google::protobuf::internal::kEmptyString) {
    talisman_->clear();
  }
  clear_has_talisman();
}
inline const ::std::string& equip_plan_single::talisman() const {
  return *talisman_;
}
inline void equip_plan_single::set_talisman(const ::std::string& value) {
  set_has_talisman();
  if (talisman_ == &::google::protobuf::internal::kEmptyString) {
    talisman_ = new ::std::string;
  }
  talisman_->assign(value);
}
inline void equip_plan_single::set_talisman(const char* value) {
  set_has_talisman();
  if (talisman_ == &::google::protobuf::internal::kEmptyString) {
    talisman_ = new ::std::string;
  }
  talisman_->assign(value);
}
inline void equip_plan_single::set_talisman(const char* value, size_t size) {
  set_has_talisman();
  if (talisman_ == &::google::protobuf::internal::kEmptyString) {
    talisman_ = new ::std::string;
  }
  talisman_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_talisman() {
  set_has_talisman();
  if (talisman_ == &::google::protobuf::internal::kEmptyString) {
    talisman_ = new ::std::string;
  }
  return talisman_;
}
inline ::std::string* equip_plan_single::release_talisman() {
  clear_has_talisman();
  if (talisman_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = talisman_;
    talisman_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_talisman(::std::string* talisman) {
  if (talisman_ != &::google::protobuf::internal::kEmptyString) {
    delete talisman_;
  }
  if (talisman) {
    set_has_talisman();
    talisman_ = talisman;
  } else {
    clear_has_talisman();
    talisman_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hero_uid = 6;
inline bool equip_plan_single::has_hero_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void equip_plan_single::set_has_hero_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void equip_plan_single::clear_has_hero_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void equip_plan_single::clear_hero_uid() {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    hero_uid_->clear();
  }
  clear_has_hero_uid();
}
inline const ::std::string& equip_plan_single::hero_uid() const {
  return *hero_uid_;
}
inline void equip_plan_single::set_hero_uid(const ::std::string& value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void equip_plan_single::set_hero_uid(const char* value) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(value);
}
inline void equip_plan_single::set_hero_uid(const char* value, size_t size) {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  hero_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* equip_plan_single::mutable_hero_uid() {
  set_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    hero_uid_ = new ::std::string;
  }
  return hero_uid_;
}
inline ::std::string* equip_plan_single::release_hero_uid() {
  clear_has_hero_uid();
  if (hero_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hero_uid_;
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void equip_plan_single::set_allocated_hero_uid(::std::string* hero_uid) {
  if (hero_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete hero_uid_;
  }
  if (hero_uid) {
    set_has_hero_uid();
    hero_uid_ = hero_uid;
  } else {
    clear_has_hero_uid();
    hero_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// patrol_hire_data

// optional uint32 map_id = 1;
inline bool patrol_hire_data::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void patrol_hire_data::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void patrol_hire_data::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void patrol_hire_data::clear_map_id() {
  map_id_ = 0u;
  clear_has_map_id();
}
inline ::google::protobuf::uint32 patrol_hire_data::map_id() const {
  return map_id_;
}
inline void patrol_hire_data::set_map_id(::google::protobuf::uint32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional uint32 begin_time = 2;
inline bool patrol_hire_data::has_begin_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void patrol_hire_data::set_has_begin_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void patrol_hire_data::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void patrol_hire_data::clear_begin_time() {
  begin_time_ = 0u;
  clear_has_begin_time();
}
inline ::google::protobuf::uint32 patrol_hire_data::begin_time() const {
  return begin_time_;
}
inline void patrol_hire_data::set_begin_time(::google::protobuf::uint32 value) {
  set_has_begin_time();
  begin_time_ = value;
}

// optional uint32 fast_patrol_count = 3;
inline bool patrol_hire_data::has_fast_patrol_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void patrol_hire_data::set_has_fast_patrol_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void patrol_hire_data::clear_has_fast_patrol_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void patrol_hire_data::clear_fast_patrol_count() {
  fast_patrol_count_ = 0u;
  clear_has_fast_patrol_count();
}
inline ::google::protobuf::uint32 patrol_hire_data::fast_patrol_count() const {
  return fast_patrol_count_;
}
inline void patrol_hire_data::set_fast_patrol_count(::google::protobuf::uint32 value) {
  set_has_fast_patrol_count();
  fast_patrol_count_ = value;
}

// -------------------------------------------------------------------

// equip_plan_data

// repeated .proto.common.equip_plan_single equip_plan_info = 1;
inline int equip_plan_data::equip_plan_info_size() const {
  return equip_plan_info_.size();
}
inline void equip_plan_data::clear_equip_plan_info() {
  equip_plan_info_.Clear();
}
inline const ::proto::common::equip_plan_single& equip_plan_data::equip_plan_info(int index) const {
  return equip_plan_info_.Get(index);
}
inline ::proto::common::equip_plan_single* equip_plan_data::mutable_equip_plan_info(int index) {
  return equip_plan_info_.Mutable(index);
}
inline ::proto::common::equip_plan_single* equip_plan_data::add_equip_plan_info() {
  return equip_plan_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::equip_plan_single >&
equip_plan_data::equip_plan_info() const {
  return equip_plan_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::equip_plan_single >*
equip_plan_data::mutable_equip_plan_info() {
  return &equip_plan_info_;
}

// -------------------------------------------------------------------

// exchange_item_data

// optional uint32 id = 1;
inline bool exchange_item_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exchange_item_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exchange_item_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exchange_item_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 exchange_item_data::id() const {
  return id_;
}
inline void exchange_item_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 cur_num = 2;
inline bool exchange_item_data::has_cur_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exchange_item_data::set_has_cur_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exchange_item_data::clear_has_cur_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exchange_item_data::clear_cur_num() {
  cur_num_ = 0u;
  clear_has_cur_num();
}
inline ::google::protobuf::uint32 exchange_item_data::cur_num() const {
  return cur_num_;
}
inline void exchange_item_data::set_cur_num(::google::protobuf::uint32 value) {
  set_has_cur_num();
  cur_num_ = value;
}

// optional uint32 max_num = 3;
inline bool exchange_item_data::has_max_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void exchange_item_data::set_has_max_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void exchange_item_data::clear_has_max_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void exchange_item_data::clear_max_num() {
  max_num_ = 0u;
  clear_has_max_num();
}
inline ::google::protobuf::uint32 exchange_item_data::max_num() const {
  return max_num_;
}
inline void exchange_item_data::set_max_num(::google::protobuf::uint32 value) {
  set_has_max_num();
  max_num_ = value;
}

// optional string need_item = 4;
inline bool exchange_item_data::has_need_item() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void exchange_item_data::set_has_need_item() {
  _has_bits_[0] |= 0x00000008u;
}
inline void exchange_item_data::clear_has_need_item() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void exchange_item_data::clear_need_item() {
  if (need_item_ != &::google::protobuf::internal::kEmptyString) {
    need_item_->clear();
  }
  clear_has_need_item();
}
inline const ::std::string& exchange_item_data::need_item() const {
  return *need_item_;
}
inline void exchange_item_data::set_need_item(const ::std::string& value) {
  set_has_need_item();
  if (need_item_ == &::google::protobuf::internal::kEmptyString) {
    need_item_ = new ::std::string;
  }
  need_item_->assign(value);
}
inline void exchange_item_data::set_need_item(const char* value) {
  set_has_need_item();
  if (need_item_ == &::google::protobuf::internal::kEmptyString) {
    need_item_ = new ::std::string;
  }
  need_item_->assign(value);
}
inline void exchange_item_data::set_need_item(const char* value, size_t size) {
  set_has_need_item();
  if (need_item_ == &::google::protobuf::internal::kEmptyString) {
    need_item_ = new ::std::string;
  }
  need_item_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exchange_item_data::mutable_need_item() {
  set_has_need_item();
  if (need_item_ == &::google::protobuf::internal::kEmptyString) {
    need_item_ = new ::std::string;
  }
  return need_item_;
}
inline ::std::string* exchange_item_data::release_need_item() {
  clear_has_need_item();
  if (need_item_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = need_item_;
    need_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exchange_item_data::set_allocated_need_item(::std::string* need_item) {
  if (need_item_ != &::google::protobuf::internal::kEmptyString) {
    delete need_item_;
  }
  if (need_item) {
    set_has_need_item();
    need_item_ = need_item;
  } else {
    clear_has_need_item();
    need_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string make_item = 5;
inline bool exchange_item_data::has_make_item() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void exchange_item_data::set_has_make_item() {
  _has_bits_[0] |= 0x00000010u;
}
inline void exchange_item_data::clear_has_make_item() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void exchange_item_data::clear_make_item() {
  if (make_item_ != &::google::protobuf::internal::kEmptyString) {
    make_item_->clear();
  }
  clear_has_make_item();
}
inline const ::std::string& exchange_item_data::make_item() const {
  return *make_item_;
}
inline void exchange_item_data::set_make_item(const ::std::string& value) {
  set_has_make_item();
  if (make_item_ == &::google::protobuf::internal::kEmptyString) {
    make_item_ = new ::std::string;
  }
  make_item_->assign(value);
}
inline void exchange_item_data::set_make_item(const char* value) {
  set_has_make_item();
  if (make_item_ == &::google::protobuf::internal::kEmptyString) {
    make_item_ = new ::std::string;
  }
  make_item_->assign(value);
}
inline void exchange_item_data::set_make_item(const char* value, size_t size) {
  set_has_make_item();
  if (make_item_ == &::google::protobuf::internal::kEmptyString) {
    make_item_ = new ::std::string;
  }
  make_item_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* exchange_item_data::mutable_make_item() {
  set_has_make_item();
  if (make_item_ == &::google::protobuf::internal::kEmptyString) {
    make_item_ = new ::std::string;
  }
  return make_item_;
}
inline ::std::string* exchange_item_data::release_make_item() {
  clear_has_make_item();
  if (make_item_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = make_item_;
    make_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void exchange_item_data::set_allocated_make_item(::std::string* make_item) {
  if (make_item_ != &::google::protobuf::internal::kEmptyString) {
    delete make_item_;
  }
  if (make_item) {
    set_has_make_item();
    make_item_ = make_item;
  } else {
    clear_has_make_item();
    make_item_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// exchange_item_save_info

// optional uint32 id = 1;
inline bool exchange_item_save_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exchange_item_save_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exchange_item_save_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exchange_item_save_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 exchange_item_save_info::id() const {
  return id_;
}
inline void exchange_item_save_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 cur_num = 2;
inline bool exchange_item_save_info::has_cur_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exchange_item_save_info::set_has_cur_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exchange_item_save_info::clear_has_cur_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exchange_item_save_info::clear_cur_num() {
  cur_num_ = 0u;
  clear_has_cur_num();
}
inline ::google::protobuf::uint32 exchange_item_save_info::cur_num() const {
  return cur_num_;
}
inline void exchange_item_save_info::set_cur_num(::google::protobuf::uint32 value) {
  set_has_cur_num();
  cur_num_ = value;
}

// -------------------------------------------------------------------

// exchange_item_save_data

// optional uint32 start_time = 1;
inline bool exchange_item_save_data::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exchange_item_save_data::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exchange_item_save_data::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exchange_item_save_data::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 exchange_item_save_data::start_time() const {
  return start_time_;
}
inline void exchange_item_save_data::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// repeated .proto.common.exchange_item_save_info info = 2;
inline int exchange_item_save_data::info_size() const {
  return info_.size();
}
inline void exchange_item_save_data::clear_info() {
  info_.Clear();
}
inline const ::proto::common::exchange_item_save_info& exchange_item_save_data::info(int index) const {
  return info_.Get(index);
}
inline ::proto::common::exchange_item_save_info* exchange_item_save_data::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::proto::common::exchange_item_save_info* exchange_item_save_data::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::exchange_item_save_info >&
exchange_item_save_data::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::exchange_item_save_info >*
exchange_item_save_data::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// limit_buy_client_data

// optional uint32 id = 1;
inline bool limit_buy_client_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void limit_buy_client_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void limit_buy_client_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void limit_buy_client_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 limit_buy_client_data::id() const {
  return id_;
}
inline void limit_buy_client_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 show_item_id = 2;
inline bool limit_buy_client_data::has_show_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void limit_buy_client_data::set_has_show_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void limit_buy_client_data::clear_has_show_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void limit_buy_client_data::clear_show_item_id() {
  show_item_id_ = 0u;
  clear_has_show_item_id();
}
inline ::google::protobuf::uint32 limit_buy_client_data::show_item_id() const {
  return show_item_id_;
}
inline void limit_buy_client_data::set_show_item_id(::google::protobuf::uint32 value) {
  set_has_show_item_id();
  show_item_id_ = value;
}

// optional uint32 show_item_num = 3;
inline bool limit_buy_client_data::has_show_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void limit_buy_client_data::set_has_show_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void limit_buy_client_data::clear_has_show_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void limit_buy_client_data::clear_show_item_num() {
  show_item_num_ = 0u;
  clear_has_show_item_num();
}
inline ::google::protobuf::uint32 limit_buy_client_data::show_item_num() const {
  return show_item_num_;
}
inline void limit_buy_client_data::set_show_item_num(::google::protobuf::uint32 value) {
  set_has_show_item_num();
  show_item_num_ = value;
}

// optional string desc = 4;
inline bool limit_buy_client_data::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void limit_buy_client_data::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void limit_buy_client_data::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void limit_buy_client_data::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& limit_buy_client_data::desc() const {
  return *desc_;
}
inline void limit_buy_client_data::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void limit_buy_client_data::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void limit_buy_client_data::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* limit_buy_client_data::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* limit_buy_client_data::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void limit_buy_client_data::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 buy_money_type = 5;
inline bool limit_buy_client_data::has_buy_money_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void limit_buy_client_data::set_has_buy_money_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void limit_buy_client_data::clear_has_buy_money_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void limit_buy_client_data::clear_buy_money_type() {
  buy_money_type_ = 0u;
  clear_has_buy_money_type();
}
inline ::google::protobuf::uint32 limit_buy_client_data::buy_money_type() const {
  return buy_money_type_;
}
inline void limit_buy_client_data::set_buy_money_type(::google::protobuf::uint32 value) {
  set_has_buy_money_type();
  buy_money_type_ = value;
}

// optional uint32 buy_money = 6;
inline bool limit_buy_client_data::has_buy_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void limit_buy_client_data::set_has_buy_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void limit_buy_client_data::clear_has_buy_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void limit_buy_client_data::clear_buy_money() {
  buy_money_ = 0u;
  clear_has_buy_money();
}
inline ::google::protobuf::uint32 limit_buy_client_data::buy_money() const {
  return buy_money_;
}
inline void limit_buy_client_data::set_buy_money(::google::protobuf::uint32 value) {
  set_has_buy_money();
  buy_money_ = value;
}

// optional uint32 buy_num = 7;
inline bool limit_buy_client_data::has_buy_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void limit_buy_client_data::set_has_buy_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void limit_buy_client_data::clear_has_buy_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void limit_buy_client_data::clear_buy_num() {
  buy_num_ = 0u;
  clear_has_buy_num();
}
inline ::google::protobuf::uint32 limit_buy_client_data::buy_num() const {
  return buy_num_;
}
inline void limit_buy_client_data::set_buy_num(::google::protobuf::uint32 value) {
  set_has_buy_num();
  buy_num_ = value;
}

// optional uint32 src_buy_money = 8;
inline bool limit_buy_client_data::has_src_buy_money() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void limit_buy_client_data::set_has_src_buy_money() {
  _has_bits_[0] |= 0x00000080u;
}
inline void limit_buy_client_data::clear_has_src_buy_money() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void limit_buy_client_data::clear_src_buy_money() {
  src_buy_money_ = 0u;
  clear_has_src_buy_money();
}
inline ::google::protobuf::uint32 limit_buy_client_data::src_buy_money() const {
  return src_buy_money_;
}
inline void limit_buy_client_data::set_src_buy_money(::google::protobuf::uint32 value) {
  set_has_src_buy_money();
  src_buy_money_ = value;
}

// optional uint32 is_buy_num = 9;
inline bool limit_buy_client_data::has_is_buy_num() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void limit_buy_client_data::set_has_is_buy_num() {
  _has_bits_[0] |= 0x00000100u;
}
inline void limit_buy_client_data::clear_has_is_buy_num() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void limit_buy_client_data::clear_is_buy_num() {
  is_buy_num_ = 0u;
  clear_has_is_buy_num();
}
inline ::google::protobuf::uint32 limit_buy_client_data::is_buy_num() const {
  return is_buy_num_;
}
inline void limit_buy_client_data::set_is_buy_num(::google::protobuf::uint32 value) {
  set_has_is_buy_num();
  is_buy_num_ = value;
}

// -------------------------------------------------------------------

// limit_buy_save_info

// optional uint32 id = 1;
inline bool limit_buy_save_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void limit_buy_save_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void limit_buy_save_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void limit_buy_save_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 limit_buy_save_info::id() const {
  return id_;
}
inline void limit_buy_save_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool limit_buy_save_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void limit_buy_save_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void limit_buy_save_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void limit_buy_save_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 limit_buy_save_info::num() const {
  return num_;
}
inline void limit_buy_save_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// limit_buy_save_data

// optional uint32 day = 1;
inline bool limit_buy_save_data::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void limit_buy_save_data::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void limit_buy_save_data::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void limit_buy_save_data::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 limit_buy_save_data::day() const {
  return day_;
}
inline void limit_buy_save_data::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 red = 2;
inline bool limit_buy_save_data::has_red() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void limit_buy_save_data::set_has_red() {
  _has_bits_[0] |= 0x00000002u;
}
inline void limit_buy_save_data::clear_has_red() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void limit_buy_save_data::clear_red() {
  red_ = 0u;
  clear_has_red();
}
inline ::google::protobuf::uint32 limit_buy_save_data::red() const {
  return red_;
}
inline void limit_buy_save_data::set_red(::google::protobuf::uint32 value) {
  set_has_red();
  red_ = value;
}

// repeated .proto.common.limit_buy_save_info info = 3;
inline int limit_buy_save_data::info_size() const {
  return info_.size();
}
inline void limit_buy_save_data::clear_info() {
  info_.Clear();
}
inline const ::proto::common::limit_buy_save_info& limit_buy_save_data::info(int index) const {
  return info_.Get(index);
}
inline ::proto::common::limit_buy_save_info* limit_buy_save_data::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::proto::common::limit_buy_save_info* limit_buy_save_data::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::limit_buy_save_info >&
limit_buy_save_data::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::limit_buy_save_info >*
limit_buy_save_data::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// sd_target_info

// optional uint32 index = 1;
inline bool sd_target_info::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sd_target_info::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sd_target_info::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sd_target_info::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 sd_target_info::index() const {
  return index_;
}
inline void sd_target_info::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 num = 2;
inline bool sd_target_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sd_target_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sd_target_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sd_target_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 sd_target_info::num() const {
  return num_;
}
inline void sd_target_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 max_num = 3;
inline bool sd_target_info::has_max_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sd_target_info::set_has_max_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sd_target_info::clear_has_max_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sd_target_info::clear_max_num() {
  max_num_ = 0u;
  clear_has_max_num();
}
inline ::google::protobuf::uint32 sd_target_info::max_num() const {
  return max_num_;
}
inline void sd_target_info::set_max_num(::google::protobuf::uint32 value) {
  set_has_max_num();
  max_num_ = value;
}

// optional uint32 status = 4;
inline bool sd_target_info::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sd_target_info::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sd_target_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sd_target_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 sd_target_info::status() const {
  return status_;
}
inline void sd_target_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 target_id = 5;
inline bool sd_target_info::has_target_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sd_target_info::set_has_target_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sd_target_info::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sd_target_info::clear_target_id() {
  target_id_ = 0u;
  clear_has_target_id();
}
inline ::google::protobuf::uint32 sd_target_info::target_id() const {
  return target_id_;
}
inline void sd_target_info::set_target_id(::google::protobuf::uint32 value) {
  set_has_target_id();
  target_id_ = value;
}

// -------------------------------------------------------------------

// sd_target_save_data

// optional uint32 day = 1;
inline bool sd_target_save_data::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sd_target_save_data::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sd_target_save_data::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sd_target_save_data::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 sd_target_save_data::day() const {
  return day_;
}
inline void sd_target_save_data::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// repeated uint32 info = 2;
inline int sd_target_save_data::info_size() const {
  return info_.size();
}
inline void sd_target_save_data::clear_info() {
  info_.Clear();
}
inline ::google::protobuf::uint32 sd_target_save_data::info(int index) const {
  return info_.Get(index);
}
inline void sd_target_save_data::set_info(int index, ::google::protobuf::uint32 value) {
  info_.Set(index, value);
}
inline void sd_target_save_data::add_info(::google::protobuf::uint32 value) {
  info_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
sd_target_save_data::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
sd_target_save_data::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// sd_target_red_info

// optional uint32 day = 1;
inline bool sd_target_red_info::has_day() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sd_target_red_info::set_has_day() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sd_target_red_info::clear_has_day() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sd_target_red_info::clear_day() {
  day_ = 0u;
  clear_has_day();
}
inline ::google::protobuf::uint32 sd_target_red_info::day() const {
  return day_;
}
inline void sd_target_red_info::set_day(::google::protobuf::uint32 value) {
  set_has_day();
  day_ = value;
}

// optional uint32 red = 2;
inline bool sd_target_red_info::has_red() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sd_target_red_info::set_has_red() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sd_target_red_info::clear_has_red() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sd_target_red_info::clear_red() {
  red_ = 0u;
  clear_has_red();
}
inline ::google::protobuf::uint32 sd_target_red_info::red() const {
  return red_;
}
inline void sd_target_red_info::set_red(::google::protobuf::uint32 value) {
  set_has_red();
  red_ = value;
}

// -------------------------------------------------------------------

// statistical_save_info

// optional uint32 id = 1;
inline bool statistical_save_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statistical_save_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statistical_save_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statistical_save_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 statistical_save_info::id() const {
  return id_;
}
inline void statistical_save_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool statistical_save_info::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void statistical_save_info::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void statistical_save_info::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void statistical_save_info::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 statistical_save_info::num() const {
  return num_;
}
inline void statistical_save_info::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// statistical_save_data

// repeated .proto.common.statistical_save_info info = 1;
inline int statistical_save_data::info_size() const {
  return info_.size();
}
inline void statistical_save_data::clear_info() {
  info_.Clear();
}
inline const ::proto::common::statistical_save_info& statistical_save_data::info(int index) const {
  return info_.Get(index);
}
inline ::proto::common::statistical_save_info* statistical_save_data::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::proto::common::statistical_save_info* statistical_save_data::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::statistical_save_info >&
statistical_save_data::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::statistical_save_info >*
statistical_save_data::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// general_event_info

// optional uint32 id = 1;
inline bool general_event_info::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void general_event_info::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void general_event_info::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void general_event_info::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 general_event_info::id() const {
  return id_;
}
inline void general_event_info::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 process = 2;
inline bool general_event_info::has_process() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void general_event_info::set_has_process() {
  _has_bits_[0] |= 0x00000002u;
}
inline void general_event_info::clear_has_process() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void general_event_info::clear_process() {
  process_ = 0u;
  clear_has_process();
}
inline ::google::protobuf::uint32 general_event_info::process() const {
  return process_;
}
inline void general_event_info::set_process(::google::protobuf::uint32 value) {
  set_has_process();
  process_ = value;
}

// optional uint32 status = 3;
inline bool general_event_info::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void general_event_info::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void general_event_info::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void general_event_info::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 general_event_info::status() const {
  return status_;
}
inline void general_event_info::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 time_left = 4;
inline bool general_event_info::has_time_left() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void general_event_info::set_has_time_left() {
  _has_bits_[0] |= 0x00000008u;
}
inline void general_event_info::clear_has_time_left() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void general_event_info::clear_time_left() {
  time_left_ = 0u;
  clear_has_time_left();
}
inline ::google::protobuf::uint32 general_event_info::time_left() const {
  return time_left_;
}
inline void general_event_info::set_time_left(::google::protobuf::uint32 value) {
  set_has_time_left();
  time_left_ = value;
}

// optional string first_name = 5;
inline bool general_event_info::has_first_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void general_event_info::set_has_first_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void general_event_info::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void general_event_info::clear_first_name() {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    first_name_->clear();
  }
  clear_has_first_name();
}
inline const ::std::string& general_event_info::first_name() const {
  return *first_name_;
}
inline void general_event_info::set_first_name(const ::std::string& value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void general_event_info::set_first_name(const char* value) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(value);
}
inline void general_event_info::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  first_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* general_event_info::mutable_first_name() {
  set_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    first_name_ = new ::std::string;
  }
  return first_name_;
}
inline ::std::string* general_event_info::release_first_name() {
  clear_has_first_name();
  if (first_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = first_name_;
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void general_event_info::set_allocated_first_name(::std::string* first_name) {
  if (first_name_ != &::google::protobuf::internal::kEmptyString) {
    delete first_name_;
  }
  if (first_name) {
    set_has_first_name();
    first_name_ = first_name;
  } else {
    clear_has_first_name();
    first_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 red_num = 6;
inline bool general_event_info::has_red_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void general_event_info::set_has_red_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void general_event_info::clear_has_red_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void general_event_info::clear_red_num() {
  red_num_ = 0u;
  clear_has_red_num();
}
inline ::google::protobuf::uint32 general_event_info::red_num() const {
  return red_num_;
}
inline void general_event_info::set_red_num(::google::protobuf::uint32 value) {
  set_has_red_num();
  red_num_ = value;
}

// -------------------------------------------------------------------

// general_event_detail

// optional uint32 index = 1;
inline bool general_event_detail::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void general_event_detail::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void general_event_detail::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void general_event_detail::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 general_event_detail::index() const {
  return index_;
}
inline void general_event_detail::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 process = 2;
inline bool general_event_detail::has_process() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void general_event_detail::set_has_process() {
  _has_bits_[0] |= 0x00000002u;
}
inline void general_event_detail::clear_has_process() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void general_event_detail::clear_process() {
  process_ = 0u;
  clear_has_process();
}
inline ::google::protobuf::uint32 general_event_detail::process() const {
  return process_;
}
inline void general_event_detail::set_process(::google::protobuf::uint32 value) {
  set_has_process();
  process_ = value;
}

// optional uint32 status = 3;
inline bool general_event_detail::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void general_event_detail::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void general_event_detail::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void general_event_detail::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 general_event_detail::status() const {
  return status_;
}
inline void general_event_detail::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// general_event_count_data

// optional uint32 index = 1;
inline bool general_event_count_data::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void general_event_count_data::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void general_event_count_data::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void general_event_count_data::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 general_event_count_data::index() const {
  return index_;
}
inline void general_event_count_data::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 num = 2;
inline bool general_event_count_data::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void general_event_count_data::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void general_event_count_data::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void general_event_count_data::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 general_event_count_data::num() const {
  return num_;
}
inline void general_event_count_data::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// general_event_data

// optional uint32 id = 1;
inline bool general_event_data::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void general_event_data::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void general_event_data::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void general_event_data::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 general_event_data::id() const {
  return id_;
}
inline void general_event_data::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool general_event_data::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void general_event_data::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void general_event_data::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void general_event_data::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& general_event_data::name() const {
  return *name_;
}
inline void general_event_data::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void general_event_data::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void general_event_data::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* general_event_data::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* general_event_data::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void general_event_data::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 start_time = 3;
inline bool general_event_data::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void general_event_data::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void general_event_data::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void general_event_data::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 general_event_data::start_time() const {
  return start_time_;
}
inline void general_event_data::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 status = 4;
inline bool general_event_data::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void general_event_data::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void general_event_data::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void general_event_data::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 general_event_data::status() const {
  return status_;
}
inline void general_event_data::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional uint32 is_speed_time = 5;
inline bool general_event_data::has_is_speed_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void general_event_data::set_has_is_speed_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void general_event_data::clear_has_is_speed_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void general_event_data::clear_is_speed_time() {
  is_speed_time_ = 0u;
  clear_has_is_speed_time();
}
inline ::google::protobuf::uint32 general_event_data::is_speed_time() const {
  return is_speed_time_;
}
inline void general_event_data::set_is_speed_time(::google::protobuf::uint32 value) {
  set_has_is_speed_time();
  is_speed_time_ = value;
}

// -------------------------------------------------------------------

// general_event_save_data

// repeated uint32 red = 1;
inline int general_event_save_data::red_size() const {
  return red_.size();
}
inline void general_event_save_data::clear_red() {
  red_.Clear();
}
inline ::google::protobuf::uint32 general_event_save_data::red(int index) const {
  return red_.Get(index);
}
inline void general_event_save_data::set_red(int index, ::google::protobuf::uint32 value) {
  red_.Set(index, value);
}
inline void general_event_save_data::add_red(::google::protobuf::uint32 value) {
  red_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
general_event_save_data::red() const {
  return red_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
general_event_save_data::mutable_red() {
  return &red_;
}

// repeated uint32 data = 2;
inline int general_event_save_data::data_size() const {
  return data_.size();
}
inline void general_event_save_data::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::uint32 general_event_save_data::data(int index) const {
  return data_.Get(index);
}
inline void general_event_save_data::set_data(int index, ::google::protobuf::uint32 value) {
  data_.Set(index, value);
}
inline void general_event_save_data::add_data(::google::protobuf::uint32 value) {
  data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
general_event_save_data::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
general_event_save_data::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// general_info_single

// optional uint32 id = 1;
inline bool general_info_single::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void general_info_single::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void general_info_single::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void general_info_single::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 general_info_single::id() const {
  return id_;
}
inline void general_info_single::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 num = 2;
inline bool general_info_single::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void general_info_single::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void general_info_single::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void general_info_single::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 general_info_single::num() const {
  return num_;
}
inline void general_info_single::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// general_info_data

// repeated .proto.common.general_info_single general_info = 1;
inline int general_info_data::general_info_size() const {
  return general_info_.size();
}
inline void general_info_data::clear_general_info() {
  general_info_.Clear();
}
inline const ::proto::common::general_info_single& general_info_data::general_info(int index) const {
  return general_info_.Get(index);
}
inline ::proto::common::general_info_single* general_info_data::mutable_general_info(int index) {
  return general_info_.Mutable(index);
}
inline ::proto::common::general_info_single* general_info_data::add_general_info() {
  return general_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::general_info_single >&
general_info_data::general_info() const {
  return general_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::general_info_single >*
general_info_data::mutable_general_info() {
  return &general_info_;
}

// -------------------------------------------------------------------

// family_skill_single

// optional uint32 skill_id = 1;
inline bool family_skill_single::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void family_skill_single::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void family_skill_single::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void family_skill_single::clear_skill_id() {
  skill_id_ = 0u;
  clear_has_skill_id();
}
inline ::google::protobuf::uint32 family_skill_single::skill_id() const {
  return skill_id_;
}
inline void family_skill_single::set_skill_id(::google::protobuf::uint32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional uint32 skill_level = 2;
inline bool family_skill_single::has_skill_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void family_skill_single::set_has_skill_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void family_skill_single::clear_has_skill_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void family_skill_single::clear_skill_level() {
  skill_level_ = 0u;
  clear_has_skill_level();
}
inline ::google::protobuf::uint32 family_skill_single::skill_level() const {
  return skill_level_;
}
inline void family_skill_single::set_skill_level(::google::protobuf::uint32 value) {
  set_has_skill_level();
  skill_level_ = value;
}

// -------------------------------------------------------------------

// family_skill_data

// repeated .proto.common.family_skill_single skill_data = 1;
inline int family_skill_data::skill_data_size() const {
  return skill_data_.size();
}
inline void family_skill_data::clear_skill_data() {
  skill_data_.Clear();
}
inline const ::proto::common::family_skill_single& family_skill_data::skill_data(int index) const {
  return skill_data_.Get(index);
}
inline ::proto::common::family_skill_single* family_skill_data::mutable_skill_data(int index) {
  return skill_data_.Mutable(index);
}
inline ::proto::common::family_skill_single* family_skill_data::add_skill_data() {
  return skill_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::family_skill_single >&
family_skill_data::skill_data() const {
  return skill_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::family_skill_single >*
family_skill_data::mutable_skill_data() {
  return &skill_data_;
}

// -------------------------------------------------------------------

// general_status_save_data

// repeated .proto.common.general_event_data data_list = 1;
inline int general_status_save_data::data_list_size() const {
  return data_list_.size();
}
inline void general_status_save_data::clear_data_list() {
  data_list_.Clear();
}
inline const ::proto::common::general_event_data& general_status_save_data::data_list(int index) const {
  return data_list_.Get(index);
}
inline ::proto::common::general_event_data* general_status_save_data::mutable_data_list(int index) {
  return data_list_.Mutable(index);
}
inline ::proto::common::general_event_data* general_status_save_data::add_data_list() {
  return data_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::general_event_data >&
general_status_save_data::data_list() const {
  return data_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::general_event_data >*
general_status_save_data::mutable_data_list() {
  return &data_list_;
}

// -------------------------------------------------------------------

// gm_msg_to_account

// optional uint32 user_create_flag = 1;
inline bool gm_msg_to_account::has_user_create_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void gm_msg_to_account::set_has_user_create_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void gm_msg_to_account::clear_has_user_create_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void gm_msg_to_account::clear_user_create_flag() {
  user_create_flag_ = 0u;
  clear_has_user_create_flag();
}
inline ::google::protobuf::uint32 gm_msg_to_account::user_create_flag() const {
  return user_create_flag_;
}
inline void gm_msg_to_account::set_user_create_flag(::google::protobuf::uint32 value) {
  set_has_user_create_flag();
  user_create_flag_ = value;
}

// -------------------------------------------------------------------

// rank_time_single

// optional uint32 rank_id = 1;
inline bool rank_time_single::has_rank_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rank_time_single::set_has_rank_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rank_time_single::clear_has_rank_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rank_time_single::clear_rank_id() {
  rank_id_ = 0u;
  clear_has_rank_id();
}
inline ::google::protobuf::uint32 rank_time_single::rank_id() const {
  return rank_id_;
}
inline void rank_time_single::set_rank_id(::google::protobuf::uint32 value) {
  set_has_rank_id();
  rank_id_ = value;
}

// optional uint32 start_time = 2;
inline bool rank_time_single::has_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rank_time_single::set_has_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rank_time_single::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rank_time_single::clear_start_time() {
  start_time_ = 0u;
  clear_has_start_time();
}
inline ::google::protobuf::uint32 rank_time_single::start_time() const {
  return start_time_;
}
inline void rank_time_single::set_start_time(::google::protobuf::uint32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional uint32 end_time = 3;
inline bool rank_time_single::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rank_time_single::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rank_time_single::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rank_time_single::clear_end_time() {
  end_time_ = 0u;
  clear_has_end_time();
}
inline ::google::protobuf::uint32 rank_time_single::end_time() const {
  return end_time_;
}
inline void rank_time_single::set_end_time(::google::protobuf::uint32 value) {
  set_has_end_time();
  end_time_ = value;
}

// -------------------------------------------------------------------

// office_data

// optional uint32 level = 1;
inline bool office_data::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void office_data::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void office_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void office_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 office_data::level() const {
  return level_;
}
inline void office_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 exp = 2;
inline bool office_data::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void office_data::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void office_data::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void office_data::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 office_data::exp() const {
  return exp_;
}
inline void office_data::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 award = 3;
inline bool office_data::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void office_data::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void office_data::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void office_data::clear_award() {
  award_ = 0u;
  clear_has_award();
}
inline ::google::protobuf::uint32 office_data::award() const {
  return award_;
}
inline void office_data::set_award(::google::protobuf::uint32 value) {
  set_has_award();
  award_ = value;
}

// -------------------------------------------------------------------

// office_task_single

// optional uint32 task_id = 1;
inline bool office_task_single::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void office_task_single::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void office_task_single::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void office_task_single::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 office_task_single::task_id() const {
  return task_id_;
}
inline void office_task_single::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional uint32 state = 2;
inline bool office_task_single::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void office_task_single::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void office_task_single::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void office_task_single::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 office_task_single::state() const {
  return state_;
}
inline void office_task_single::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// office_client_data

// optional uint32 level = 1;
inline bool office_client_data::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void office_client_data::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void office_client_data::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void office_client_data::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 office_client_data::level() const {
  return level_;
}
inline void office_client_data::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 exp = 2;
inline bool office_client_data::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void office_client_data::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void office_client_data::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void office_client_data::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 office_client_data::exp() const {
  return exp_;
}
inline void office_client_data::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 award = 3;
inline bool office_client_data::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void office_client_data::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void office_client_data::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void office_client_data::clear_award() {
  award_ = 0u;
  clear_has_award();
}
inline ::google::protobuf::uint32 office_client_data::award() const {
  return award_;
}
inline void office_client_data::set_award(::google::protobuf::uint32 value) {
  set_has_award();
  award_ = value;
}

// repeated .proto.common.office_task_single tasks = 4;
inline int office_client_data::tasks_size() const {
  return tasks_.size();
}
inline void office_client_data::clear_tasks() {
  tasks_.Clear();
}
inline const ::proto::common::office_task_single& office_client_data::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::proto::common::office_task_single* office_client_data::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::proto::common::office_task_single* office_client_data::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::office_task_single >&
office_client_data::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::office_task_single >*
office_client_data::mutable_tasks() {
  return &tasks_;
}

// -------------------------------------------------------------------

// video_hero_base

// optional uint32 tid = 1;
inline bool video_hero_base::has_tid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void video_hero_base::set_has_tid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void video_hero_base::clear_has_tid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void video_hero_base::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 video_hero_base::tid() const {
  return tid_;
}
inline void video_hero_base::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
}

// optional uint32 resource_id = 2;
inline bool video_hero_base::has_resource_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void video_hero_base::set_has_resource_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void video_hero_base::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void video_hero_base::clear_resource_id() {
  resource_id_ = 0u;
  clear_has_resource_id();
}
inline ::google::protobuf::uint32 video_hero_base::resource_id() const {
  return resource_id_;
}
inline void video_hero_base::set_resource_id(::google::protobuf::uint32 value) {
  set_has_resource_id();
  resource_id_ = value;
}

// optional uint32 lv = 3;
inline bool video_hero_base::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void video_hero_base::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void video_hero_base::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void video_hero_base::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 video_hero_base::lv() const {
  return lv_;
}
inline void video_hero_base::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional uint32 start = 4;
inline bool video_hero_base::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void video_hero_base::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void video_hero_base::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void video_hero_base::clear_start() {
  start_ = 0u;
  clear_has_start();
}
inline ::google::protobuf::uint32 video_hero_base::start() const {
  return start_;
}
inline void video_hero_base::set_start(::google::protobuf::uint32 value) {
  set_has_start();
  start_ = value;
}

// optional uint32 grade = 5;
inline bool video_hero_base::has_grade() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void video_hero_base::set_has_grade() {
  _has_bits_[0] |= 0x00000010u;
}
inline void video_hero_base::clear_has_grade() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void video_hero_base::clear_grade() {
  grade_ = 0u;
  clear_has_grade();
}
inline ::google::protobuf::uint32 video_hero_base::grade() const {
  return grade_;
}
inline void video_hero_base::set_grade(::google::protobuf::uint32 value) {
  set_has_grade();
  grade_ = value;
}

// optional uint32 quality = 6;
inline bool video_hero_base::has_quality() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void video_hero_base::set_has_quality() {
  _has_bits_[0] |= 0x00000020u;
}
inline void video_hero_base::clear_has_quality() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void video_hero_base::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 video_hero_base::quality() const {
  return quality_;
}
inline void video_hero_base::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
}

// optional uint32 terry = 7;
inline bool video_hero_base::has_terry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void video_hero_base::set_has_terry() {
  _has_bits_[0] |= 0x00000040u;
}
inline void video_hero_base::clear_has_terry() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void video_hero_base::clear_terry() {
  terry_ = 0u;
  clear_has_terry();
}
inline ::google::protobuf::uint32 video_hero_base::terry() const {
  return terry_;
}
inline void video_hero_base::set_terry(::google::protobuf::uint32 value) {
  set_has_terry();
  terry_ = value;
}

// -------------------------------------------------------------------

// video_arena_ex

// optional uint32 rank_lv = 1;
inline bool video_arena_ex::has_rank_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void video_arena_ex::set_has_rank_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void video_arena_ex::clear_has_rank_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void video_arena_ex::clear_rank_lv() {
  rank_lv_ = 0u;
  clear_has_rank_lv();
}
inline ::google::protobuf::uint32 video_arena_ex::rank_lv() const {
  return rank_lv_;
}
inline void video_arena_ex::set_rank_lv(::google::protobuf::uint32 value) {
  set_has_rank_lv();
  rank_lv_ = value;
}

// optional uint32 score = 2;
inline bool video_arena_ex::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void video_arena_ex::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void video_arena_ex::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void video_arena_ex::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 video_arena_ex::score() const {
  return score_;
}
inline void video_arena_ex::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// video_obj_base

// optional string uid = 1;
inline bool video_obj_base::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void video_obj_base::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void video_obj_base::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void video_obj_base::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& video_obj_base::uid() const {
  return *uid_;
}
inline void video_obj_base::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void video_obj_base::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void video_obj_base::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* video_obj_base::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* video_obj_base::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void video_obj_base::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.common.EM_SCENEOBJECT_TYPE object_type = 2 [default = SCENEOBJECT_USER];
inline bool video_obj_base::has_object_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void video_obj_base::set_has_object_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void video_obj_base::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void video_obj_base::clear_object_type() {
  object_type_ = 1;
  clear_has_object_type();
}
inline ::proto::common::EM_SCENEOBJECT_TYPE video_obj_base::object_type() const {
  return static_cast< ::proto::common::EM_SCENEOBJECT_TYPE >(object_type_);
}
inline void video_obj_base::set_object_type(::proto::common::EM_SCENEOBJECT_TYPE value) {
  assert(::proto::common::EM_SCENEOBJECT_TYPE_IsValid(value));
  set_has_object_type();
  object_type_ = value;
}

// optional string name = 3;
inline bool video_obj_base::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void video_obj_base::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void video_obj_base::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void video_obj_base::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& video_obj_base::name() const {
  return *name_;
}
inline void video_obj_base::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void video_obj_base::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void video_obj_base::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* video_obj_base::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* video_obj_base::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void video_obj_base::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 head = 4;
inline bool video_obj_base::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void video_obj_base::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void video_obj_base::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void video_obj_base::clear_head() {
  head_ = 0u;
  clear_has_head();
}
inline ::google::protobuf::uint32 video_obj_base::head() const {
  return head_;
}
inline void video_obj_base::set_head(::google::protobuf::uint32 value) {
  set_has_head();
  head_ = value;
}

// optional uint32 fighting = 5;
inline bool video_obj_base::has_fighting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void video_obj_base::set_has_fighting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void video_obj_base::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void video_obj_base::clear_fighting() {
  fighting_ = 0u;
  clear_has_fighting();
}
inline ::google::protobuf::uint32 video_obj_base::fighting() const {
  return fighting_;
}
inline void video_obj_base::set_fighting(::google::protobuf::uint32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional uint32 level = 6;
inline bool video_obj_base::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void video_obj_base::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void video_obj_base::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void video_obj_base::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 video_obj_base::level() const {
  return level_;
}
inline void video_obj_base::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional .proto.common.video_arena_ex cross_arena = 7;
inline bool video_obj_base::has_cross_arena() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void video_obj_base::set_has_cross_arena() {
  _has_bits_[0] |= 0x00000040u;
}
inline void video_obj_base::clear_has_cross_arena() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void video_obj_base::clear_cross_arena() {
  if (cross_arena_ != NULL) cross_arena_->::proto::common::video_arena_ex::Clear();
  clear_has_cross_arena();
}
inline const ::proto::common::video_arena_ex& video_obj_base::cross_arena() const {
  return cross_arena_ != NULL ? *cross_arena_ : *default_instance_->cross_arena_;
}
inline ::proto::common::video_arena_ex* video_obj_base::mutable_cross_arena() {
  set_has_cross_arena();
  if (cross_arena_ == NULL) cross_arena_ = new ::proto::common::video_arena_ex;
  return cross_arena_;
}
inline ::proto::common::video_arena_ex* video_obj_base::release_cross_arena() {
  clear_has_cross_arena();
  ::proto::common::video_arena_ex* temp = cross_arena_;
  cross_arena_ = NULL;
  return temp;
}
inline void video_obj_base::set_allocated_cross_arena(::proto::common::video_arena_ex* cross_arena) {
  delete cross_arena_;
  cross_arena_ = cross_arena;
  if (cross_arena) {
    set_has_cross_arena();
  } else {
    clear_has_cross_arena();
  }
}

// repeated .proto.common.video_hero_base heros = 8;
inline int video_obj_base::heros_size() const {
  return heros_.size();
}
inline void video_obj_base::clear_heros() {
  heros_.Clear();
}
inline const ::proto::common::video_hero_base& video_obj_base::heros(int index) const {
  return heros_.Get(index);
}
inline ::proto::common::video_hero_base* video_obj_base::mutable_heros(int index) {
  return heros_.Mutable(index);
}
inline ::proto::common::video_hero_base* video_obj_base::add_heros() {
  return heros_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::video_hero_base >&
video_obj_base::heros() const {
  return heros_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::video_hero_base >*
video_obj_base::mutable_heros() {
  return &heros_;
}

// -------------------------------------------------------------------

// video_single_base

// optional string video_uid = 1;
inline bool video_single_base::has_video_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void video_single_base::set_has_video_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void video_single_base::clear_has_video_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void video_single_base::clear_video_uid() {
  if (video_uid_ != &::google::protobuf::internal::kEmptyString) {
    video_uid_->clear();
  }
  clear_has_video_uid();
}
inline const ::std::string& video_single_base::video_uid() const {
  return *video_uid_;
}
inline void video_single_base::set_video_uid(const ::std::string& value) {
  set_has_video_uid();
  if (video_uid_ == &::google::protobuf::internal::kEmptyString) {
    video_uid_ = new ::std::string;
  }
  video_uid_->assign(value);
}
inline void video_single_base::set_video_uid(const char* value) {
  set_has_video_uid();
  if (video_uid_ == &::google::protobuf::internal::kEmptyString) {
    video_uid_ = new ::std::string;
  }
  video_uid_->assign(value);
}
inline void video_single_base::set_video_uid(const char* value, size_t size) {
  set_has_video_uid();
  if (video_uid_ == &::google::protobuf::internal::kEmptyString) {
    video_uid_ = new ::std::string;
  }
  video_uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* video_single_base::mutable_video_uid() {
  set_has_video_uid();
  if (video_uid_ == &::google::protobuf::internal::kEmptyString) {
    video_uid_ = new ::std::string;
  }
  return video_uid_;
}
inline ::std::string* video_single_base::release_video_uid() {
  clear_has_video_uid();
  if (video_uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = video_uid_;
    video_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void video_single_base::set_allocated_video_uid(::std::string* video_uid) {
  if (video_uid_ != &::google::protobuf::internal::kEmptyString) {
    delete video_uid_;
  }
  if (video_uid) {
    set_has_video_uid();
    video_uid_ = video_uid;
  } else {
    clear_has_video_uid();
    video_uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 version = 2;
inline bool video_single_base::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void video_single_base::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void video_single_base::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void video_single_base::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 video_single_base::version() const {
  return version_;
}
inline void video_single_base::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// optional uint32 fight_times = 3;
inline bool video_single_base::has_fight_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void video_single_base::set_has_fight_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void video_single_base::clear_has_fight_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void video_single_base::clear_fight_times() {
  fight_times_ = 0u;
  clear_has_fight_times();
}
inline ::google::protobuf::uint32 video_single_base::fight_times() const {
  return fight_times_;
}
inline void video_single_base::set_fight_times(::google::protobuf::uint32 value) {
  set_has_fight_times();
  fight_times_ = value;
}

// optional uint32 win_camp = 4;
inline bool video_single_base::has_win_camp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void video_single_base::set_has_win_camp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void video_single_base::clear_has_win_camp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void video_single_base::clear_win_camp() {
  win_camp_ = 0u;
  clear_has_win_camp();
}
inline ::google::protobuf::uint32 video_single_base::win_camp() const {
  return win_camp_;
}
inline void video_single_base::set_win_camp(::google::protobuf::uint32 value) {
  set_has_win_camp();
  win_camp_ = value;
}

// optional uint32 layer_id = 5;
inline bool video_single_base::has_layer_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void video_single_base::set_has_layer_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void video_single_base::clear_has_layer_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void video_single_base::clear_layer_id() {
  layer_id_ = 0u;
  clear_has_layer_id();
}
inline ::google::protobuf::uint32 video_single_base::layer_id() const {
  return layer_id_;
}
inline void video_single_base::set_layer_id(::google::protobuf::uint32 value) {
  set_has_layer_id();
  layer_id_ = value;
}

// optional uint32 cost_time = 6;
inline bool video_single_base::has_cost_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void video_single_base::set_has_cost_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void video_single_base::clear_has_cost_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void video_single_base::clear_cost_time() {
  cost_time_ = 0u;
  clear_has_cost_time();
}
inline ::google::protobuf::uint32 video_single_base::cost_time() const {
  return cost_time_;
}
inline void video_single_base::set_cost_time(::google::protobuf::uint32 value) {
  set_has_cost_time();
  cost_time_ = value;
}

// repeated .proto.common.video_obj_base objs = 10;
inline int video_single_base::objs_size() const {
  return objs_.size();
}
inline void video_single_base::clear_objs() {
  objs_.Clear();
}
inline const ::proto::common::video_obj_base& video_single_base::objs(int index) const {
  return objs_.Get(index);
}
inline ::proto::common::video_obj_base* video_single_base::mutable_objs(int index) {
  return objs_.Mutable(index);
}
inline ::proto::common::video_obj_base* video_single_base::add_objs() {
  return objs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::common::video_obj_base >&
video_single_base::objs() const {
  return objs_;
}
inline ::google::protobuf::RepeatedPtrField< ::proto::common::video_obj_base >*
video_single_base::mutable_objs() {
  return &objs_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::SERVER_STATE>() {
  return ::proto::common::SERVER_STATE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::MONEY_TYPE>() {
  return ::proto::common::MONEY_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::SYSHINT_TYPE>() {
  return ::proto::common::SYSHINT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::SHOW_POSTION>() {
  return ::proto::common::SHOW_POSTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::EM_PK_MODE>() {
  return ::proto::common::EM_PK_MODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::EM_SCENEOBJECT_TYPE>() {
  return ::proto::common::EM_SCENEOBJECT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::object_revive_type>() {
  return ::proto::common::object_revive_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::ActionType>() {
  return ::proto::common::ActionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::ROLE_MODE>() {
  return ::proto::common::ROLE_MODE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::rt_buff_change_statue>() {
  return ::proto::common::rt_buff_change_statue_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::chat_channel>() {
  return ::proto::common::chat_channel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::chat_type>() {
  return ::proto::common::chat_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::channel_state>() {
  return ::proto::common::channel_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::channel_type>() {
  return ::proto::common::channel_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::item_type>() {
  return ::proto::common::item_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::item_use_type>() {
  return ::proto::common::item_use_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::trade_buy_type>() {
  return ::proto::common::trade_buy_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::trade_event_type>() {
  return ::proto::common::trade_event_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::package_type>() {
  return ::proto::common::package_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::mount_state_type>() {
  return ::proto::common::mount_state_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::change_offline_data_type>() {
  return ::proto::common::change_offline_data_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::collect_cond_type>() {
  return ::proto::common::collect_cond_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::collect_type>() {
  return ::proto::common::collect_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::drop_sys_type>() {
  return ::proto::common::drop_sys_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::role_cross_type>() {
  return ::proto::common::role_cross_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::hero_terry_type>() {
  return ::proto::common::hero_terry_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::hero_rarity_type>() {
  return ::proto::common::hero_rarity_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::hero_state_type>() {
  return ::proto::common::hero_state_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::hero_wakeup_type>() {
  return ::proto::common::hero_wakeup_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::object_state_type>() {
  return ::proto::common::object_state_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::role_mode_state>() {
  return ::proto::common::role_mode_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::EM_MONSTER_TYPE>() {
  return ::proto::common::EM_MONSTER_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::obj_hp_change_type>() {
  return ::proto::common::obj_hp_change_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::function_code_type>() {
  return ::proto::common::function_code_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::skill_type>() {
  return ::proto::common::skill_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::formation_type>() {
  return ::proto::common::formation_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::activity_shop_type>() {
  return ::proto::common::activity_shop_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::EM_CULTIVATE_TYPE>() {
  return ::proto::common::EM_CULTIVATE_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::transmission_type>() {
  return ::proto::common::transmission_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_build_type>() {
  return ::proto::common::family_build_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_member_type>() {
  return ::proto::common::family_member_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_war_state>() {
  return ::proto::common::family_war_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_war_result>() {
  return ::proto::common::family_war_result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_war_hero_type>() {
  return ::proto::common::family_war_hero_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::family_war_platform_type>() {
  return ::proto::common::family_war_platform_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::country_period_type>() {
  return ::proto::common::country_period_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::country_level_type>() {
  return ::proto::common::country_level_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::troop_state_type>() {
  return ::proto::common::troop_state_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::fight_type>() {
  return ::proto::common::fight_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::city_type>() {
  return ::proto::common::city_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_field_boss_state>() {
  return ::proto::common::em_field_boss_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_field_boss_pos>() {
  return ::proto::common::em_field_boss_pos_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_mail_type>() {
  return ::proto::common::em_mail_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_mail_state>() {
  return ::proto::common::em_mail_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_mail_addenda>() {
  return ::proto::common::em_mail_addenda_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_mail_batch>() {
  return ::proto::common::em_mail_batch_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::em_mail_get_type>() {
  return ::proto::common::em_mail_get_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_act_type>() {
  return ::proto::common::combat_act_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_act_step>() {
  return ::proto::common::combat_act_step_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_camp>() {
  return ::proto::common::combat_camp_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_step>() {
  return ::proto::common::combat_step_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_state>() {
  return ::proto::common::combat_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_obj_state>() {
  return ::proto::common::combat_obj_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_fight_result>() {
  return ::proto::common::combat_fight_result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::combat_finish_task_type>() {
  return ::proto::common::combat_finish_task_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::friend_type>() {
  return ::proto::common::friend_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::change_friendliness_reason>() {
  return ::proto::common::change_friendliness_reason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::recommend_source>() {
  return ::proto::common::recommend_source_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::system_notice_type>() {
  return ::proto::common::system_notice_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::shop_type>() {
  return ::proto::common::shop_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::shop_refresh_type>() {
  return ::proto::common::shop_refresh_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::shop_buy_condition>() {
  return ::proto::common::shop_buy_condition_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::challenge_state>() {
  return ::proto::common::challenge_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::troop_event>() {
  return ::proto::common::troop_event_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::king_war_state>() {
  return ::proto::common::king_war_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::king_war_help_state>() {
  return ::proto::common::king_war_help_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::world_cup_round>() {
  return ::proto::common::world_cup_round_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::world_cup_battle_state>() {
  return ::proto::common::world_cup_battle_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::world_cup_bet_result>() {
  return ::proto::common::world_cup_bet_result_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::Achieve_Event_Type>() {
  return ::proto::common::Achieve_Event_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::RED_POINT_TYPE>() {
  return ::proto::common::RED_POINT_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::luckydraw_type>() {
  return ::proto::common::luckydraw_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::dungeon_condition_type>() {
  return ::proto::common::dungeon_condition_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::team_check_type>() {
  return ::proto::common::team_check_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::dungeon_state_type>() {
  return ::proto::common::dungeon_state_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::dungeon_result_type>() {
  return ::proto::common::dungeon_result_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::goods_state>() {
  return ::proto::common::goods_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::random_shop_state>() {
  return ::proto::common::random_shop_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::sys_notify_type>() {
  return ::proto::common::sys_notify_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::role_data_type>() {
  return ::proto::common::role_data_type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::WISH_SUMMON_TYPE>() {
  return ::proto::common::WISH_SUMMON_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::HEAD_FRAME_ADD_TYPE>() {
  return ::proto::common::HEAD_FRAME_ADD_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::PRIZE_STATUS>() {
  return ::proto::common::PRIZE_STATUS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::EX_REASON_TYPE>() {
  return ::proto::common::EX_REASON_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::BUSINESS_ACTIVE_TYPE>() {
  return ::proto::common::BUSINESS_ACTIVE_TYPE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::liandan_state>() {
  return ::proto::common::liandan_state_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::STATISTICAL_OPTION>() {
  return ::proto::common::STATISTICAL_OPTION_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::proto::common::GENERAL_EVENT_STATUS>() {
  return ::proto::common::GENERAL_EVENT_STATUS_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
